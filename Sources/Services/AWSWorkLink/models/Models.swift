// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import Foundation
import Smithy
import SmithyHTTPAPI
import SmithyJSON
import SmithyReadWrite

extension AssociateDomainInput {

    static func urlPathProvider(_ value: AssociateDomainInput) -> Swift.String? {
        return "/associateDomain"
    }
}

extension AssociateDomainInput {

    static func write(value: AssociateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcmCertificateArn"].write(value.acmCertificateArn)
        try writer["DisplayName"].write(value.displayName)
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct AssociateDomainInput {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    /// This member is required.
    public var acmCertificateArn: Swift.String?
    /// The name to display.
    public var displayName: Swift.String?
    /// The fully qualified domain name (FQDN).
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        acmCertificateArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension AssociateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> AssociateDomainOutput {
        return AssociateDomainOutput()
    }
}

public struct AssociateDomainOutput {

    public init() { }
}

enum AssociateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateWebsiteAuthorizationProviderInput {

    static func urlPathProvider(_ value: AssociateWebsiteAuthorizationProviderInput) -> Swift.String? {
        return "/associateWebsiteAuthorizationProvider"
    }
}

extension AssociateWebsiteAuthorizationProviderInput {

    static func write(value: AssociateWebsiteAuthorizationProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationProviderType"].write(value.authorizationProviderType)
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct AssociateWebsiteAuthorizationProviderInput {
    /// The authorization provider type.
    /// This member is required.
    public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderType = authorizationProviderType
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension AssociateWebsiteAuthorizationProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> AssociateWebsiteAuthorizationProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateWebsiteAuthorizationProviderOutput()
        value.authorizationProviderId = try reader["AuthorizationProviderId"].readIfPresent()
        return value
    }
}

public struct AssociateWebsiteAuthorizationProviderOutput {
    /// A unique identifier for the authorization provider.
    public var authorizationProviderId: Swift.String?

    public init(
        authorizationProviderId: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
    }
}

enum AssociateWebsiteAuthorizationProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateWebsiteCertificateAuthorityInput {

    static func urlPathProvider(_ value: AssociateWebsiteCertificateAuthorityInput) -> Swift.String? {
        return "/associateWebsiteCertificateAuthority"
    }
}

extension AssociateWebsiteCertificateAuthorityInput {

    static func write(value: AssociateWebsiteCertificateAuthorityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Certificate"].write(value.certificate)
        try writer["DisplayName"].write(value.displayName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct AssociateWebsiteCertificateAuthorityInput {
    /// The root certificate of the CA.
    /// This member is required.
    public var certificate: Swift.String?
    /// The certificate name to display.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.displayName = displayName
        self.fleetArn = fleetArn
    }
}

extension AssociateWebsiteCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> AssociateWebsiteCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateWebsiteCertificateAuthorityOutput()
        value.websiteCaId = try reader["WebsiteCaId"].readIfPresent()
        return value
    }
}

public struct AssociateWebsiteCertificateAuthorityOutput {
    /// A unique identifier for the CA.
    public var websiteCaId: Swift.String?

    public init(
        websiteCaId: Swift.String? = nil
    )
    {
        self.websiteCaId = websiteCaId
    }
}

enum AssociateWebsiteCertificateAuthorityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension WorkLinkClientTypes {

    public enum AuthorizationProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationProviderType] {
            return [
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        return "/createFleet"
    }
}

extension CreateFleetInput {

    static func write(value: CreateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["FleetName"].write(value.fleetName)
        try writer["OptimizeForEndUserLocation"].write(value.optimizeForEndUserLocation)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateFleetInput {
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// A unique name for the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags to add to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.displayName = displayName
        self.fleetName = fleetName
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

extension CreateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> CreateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetOutput()
        value.fleetArn = try reader["FleetArn"].readIfPresent()
        return value
    }
}

public struct CreateFleetOutput {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

enum CreateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        return "/deleteFleet"
    }
}

extension DeleteFleetInput {

    static func write(value: DeleteFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DeleteFleetInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DeleteFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DeleteFleetOutput {
        return DeleteFleetOutput()
    }
}

public struct DeleteFleetOutput {

    public init() { }
}

enum DeleteFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeAuditStreamConfigurationInput {

    static func urlPathProvider(_ value: DescribeAuditStreamConfigurationInput) -> Swift.String? {
        return "/describeAuditStreamConfiguration"
    }
}

extension DescribeAuditStreamConfigurationInput {

    static func write(value: DescribeAuditStreamConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeAuditStreamConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DescribeAuditStreamConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeAuditStreamConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuditStreamConfigurationOutput()
        value.auditStreamArn = try reader["AuditStreamArn"].readIfPresent()
        return value
    }
}

public struct DescribeAuditStreamConfigurationOutput {
    /// The ARN of the Amazon Kinesis data stream that will receive the audit events.
    public var auditStreamArn: Swift.String?

    public init(
        auditStreamArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
    }
}

enum DescribeAuditStreamConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeCompanyNetworkConfigurationInput {

    static func urlPathProvider(_ value: DescribeCompanyNetworkConfigurationInput) -> Swift.String? {
        return "/describeCompanyNetworkConfiguration"
    }
}

extension DescribeCompanyNetworkConfigurationInput {

    static func write(value: DescribeCompanyNetworkConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeCompanyNetworkConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DescribeCompanyNetworkConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeCompanyNetworkConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCompanyNetworkConfigurationOutput()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

public struct DescribeCompanyNetworkConfigurationOutput {
    /// The security groups associated with access to the provided subnets.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    public var vpcId: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

enum DescribeCompanyNetworkConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeDeviceInput {

    static func urlPathProvider(_ value: DescribeDeviceInput) -> Swift.String? {
        return "/describeDevice"
    }
}

extension DescribeDeviceInput {

    static func write(value: DescribeDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeDeviceInput {
    /// A unique identifier for a registered user's device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.fleetArn = fleetArn
    }
}

extension DescribeDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceOutput()
        value.firstAccessedTime = try reader["FirstAccessedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastAccessedTime = try reader["LastAccessedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.manufacturer = try reader["Manufacturer"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        value.operatingSystemVersion = try reader["OperatingSystemVersion"].readIfPresent()
        value.patchLevel = try reader["PatchLevel"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        return value
    }
}

public struct DescribeDeviceOutput {
    /// The date that the device first signed in to Amazon WorkLink.
    public var firstAccessedTime: Foundation.Date?
    /// The date that the device last accessed Amazon WorkLink.
    public var lastAccessedTime: Foundation.Date?
    /// The manufacturer of the device.
    public var manufacturer: Swift.String?
    /// The model of the device.
    public var model: Swift.String?
    /// The operating system of the device.
    public var operatingSystem: Swift.String?
    /// The operating system version of the device.
    public var operatingSystemVersion: Swift.String?
    /// The operating system patch level of the device.
    public var patchLevel: Swift.String?
    /// The current state of the device.
    public var status: WorkLinkClientTypes.DeviceStatus?
    /// The user name associated with the device.
    public var username: Swift.String?

    public init(
        firstAccessedTime: Foundation.Date? = nil,
        lastAccessedTime: Foundation.Date? = nil,
        manufacturer: Swift.String? = nil,
        model: Swift.String? = nil,
        operatingSystem: Swift.String? = nil,
        operatingSystemVersion: Swift.String? = nil,
        patchLevel: Swift.String? = nil,
        status: WorkLinkClientTypes.DeviceStatus? = nil,
        username: Swift.String? = nil
    )
    {
        self.firstAccessedTime = firstAccessedTime
        self.lastAccessedTime = lastAccessedTime
        self.manufacturer = manufacturer
        self.model = model
        self.operatingSystem = operatingSystem
        self.operatingSystemVersion = operatingSystemVersion
        self.patchLevel = patchLevel
        self.status = status
        self.username = username
    }
}

enum DescribeDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeDevicePolicyConfigurationInput {

    static func urlPathProvider(_ value: DescribeDevicePolicyConfigurationInput) -> Swift.String? {
        return "/describeDevicePolicyConfiguration"
    }
}

extension DescribeDevicePolicyConfigurationInput {

    static func write(value: DescribeDevicePolicyConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeDevicePolicyConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DescribeDevicePolicyConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeDevicePolicyConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDevicePolicyConfigurationOutput()
        value.deviceCaCertificate = try reader["DeviceCaCertificate"].readIfPresent()
        return value
    }
}

public struct DescribeDevicePolicyConfigurationOutput {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?

    public init(
        deviceCaCertificate: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
    }
}

enum DescribeDevicePolicyConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeDomainInput {

    static func urlPathProvider(_ value: DescribeDomainInput) -> Swift.String? {
        return "/describeDomain"
    }
}

extension DescribeDomainInput {

    static func write(value: DescribeDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeDomainInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension DescribeDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainOutput()
        value.acmCertificateArn = try reader["AcmCertificateArn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.domainStatus = try reader["DomainStatus"].readIfPresent()
        return value
    }
}

public struct DescribeDomainOutput {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    public var acmCertificateArn: Swift.String?
    /// The time that the domain was added.
    public var createdTime: Foundation.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The current state for the domain.
    public var domainStatus: WorkLinkClientTypes.DomainStatus?

    public init(
        acmCertificateArn: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainStatus: WorkLinkClientTypes.DomainStatus? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

enum DescribeDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeFleetMetadataInput {

    static func urlPathProvider(_ value: DescribeFleetMetadataInput) -> Swift.String? {
        return "/describeFleetMetadata"
    }
}

extension DescribeFleetMetadataInput {

    static func write(value: DescribeFleetMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeFleetMetadataInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DescribeFleetMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeFleetMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetMetadataOutput()
        value.companyCode = try reader["CompanyCode"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.fleetName = try reader["FleetName"].readIfPresent()
        value.fleetStatus = try reader["FleetStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.optimizeForEndUserLocation = try reader["OptimizeForEndUserLocation"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct DescribeFleetMetadataOutput {
    /// The identifier used by users to sign in to the Amazon WorkLink app.
    public var companyCode: Swift.String?
    /// The time that the fleet was created.
    public var createdTime: Foundation.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The current state of the fleet.
    public var fleetStatus: WorkLinkClientTypes.FleetStatus?
    /// The time that the fleet was last updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        companyCode: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

enum DescribeFleetMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeIdentityProviderConfigurationInput {

    static func urlPathProvider(_ value: DescribeIdentityProviderConfigurationInput) -> Swift.String? {
        return "/describeIdentityProviderConfiguration"
    }
}

extension DescribeIdentityProviderConfigurationInput {

    static func write(value: DescribeIdentityProviderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DescribeIdentityProviderConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

extension DescribeIdentityProviderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeIdentityProviderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIdentityProviderConfigurationOutput()
        value.identityProviderSamlMetadata = try reader["IdentityProviderSamlMetadata"].readIfPresent()
        value.identityProviderType = try reader["IdentityProviderType"].readIfPresent()
        value.serviceProviderSamlMetadata = try reader["ServiceProviderSamlMetadata"].readIfPresent()
        return value
    }
}

public struct DescribeIdentityProviderConfigurationOutput {
    /// The SAML metadata document provided by the user’s identity provider.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    /// The SAML metadata document uploaded to the user’s identity provider.
    public var serviceProviderSamlMetadata: Swift.String?

    public init(
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

enum DescribeIdentityProviderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeWebsiteCertificateAuthorityInput {

    static func urlPathProvider(_ value: DescribeWebsiteCertificateAuthorityInput) -> Swift.String? {
        return "/describeWebsiteCertificateAuthority"
    }
}

extension DescribeWebsiteCertificateAuthorityInput {

    static func write(value: DescribeWebsiteCertificateAuthorityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["WebsiteCaId"].write(value.websiteCaId)
    }
}

public struct DescribeWebsiteCertificateAuthorityInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the certificate authority.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

extension DescribeWebsiteCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeWebsiteCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWebsiteCertificateAuthorityOutput()
        value.certificate = try reader["Certificate"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        return value
    }
}

public struct DescribeWebsiteCertificateAuthorityOutput {
    /// The root certificate of the certificate authority.
    public var certificate: Swift.String?
    /// The time that the certificate authority was added.
    public var createdTime: Foundation.Date?
    /// The certificate name to display.
    public var displayName: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        displayName: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.createdTime = createdTime
        self.displayName = displayName
    }
}

enum DescribeWebsiteCertificateAuthorityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension WorkLinkClientTypes {

    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case signedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .active,
                .signedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .signedOut: return "SIGNED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkLinkClientTypes.DeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkLinkClientTypes.DeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkLinkClientTypes.DeviceSummary()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.deviceStatus = try reader["DeviceStatus"].readIfPresent()
        return value
    }
}

extension WorkLinkClientTypes {
    /// The summary of devices.
    public struct DeviceSummary {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The status of the device.
        public var deviceStatus: WorkLinkClientTypes.DeviceStatus?

        public init(
            deviceId: Swift.String? = nil,
            deviceStatus: WorkLinkClientTypes.DeviceStatus? = nil
        )
        {
            self.deviceId = deviceId
            self.deviceStatus = deviceStatus
        }
    }

}

extension DisassociateDomainInput {

    static func urlPathProvider(_ value: DisassociateDomainInput) -> Swift.String? {
        return "/disassociateDomain"
    }
}

extension DisassociateDomainInput {

    static func write(value: DisassociateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DisassociateDomainInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension DisassociateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DisassociateDomainOutput {
        return DisassociateDomainOutput()
    }
}

public struct DisassociateDomainOutput {

    public init() { }
}

enum DisassociateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateWebsiteAuthorizationProviderInput {

    static func urlPathProvider(_ value: DisassociateWebsiteAuthorizationProviderInput) -> Swift.String? {
        return "/disassociateWebsiteAuthorizationProvider"
    }
}

extension DisassociateWebsiteAuthorizationProviderInput {

    static func write(value: DisassociateWebsiteAuthorizationProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationProviderId"].write(value.authorizationProviderId)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct DisassociateWebsiteAuthorizationProviderInput {
    /// A unique identifier for the authorization provider.
    /// This member is required.
    public var authorizationProviderId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        authorizationProviderId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.fleetArn = fleetArn
    }
}

extension DisassociateWebsiteAuthorizationProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DisassociateWebsiteAuthorizationProviderOutput {
        return DisassociateWebsiteAuthorizationProviderOutput()
    }
}

public struct DisassociateWebsiteAuthorizationProviderOutput {

    public init() { }
}

enum DisassociateWebsiteAuthorizationProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateWebsiteCertificateAuthorityInput {

    static func urlPathProvider(_ value: DisassociateWebsiteCertificateAuthorityInput) -> Swift.String? {
        return "/disassociateWebsiteCertificateAuthority"
    }
}

extension DisassociateWebsiteCertificateAuthorityInput {

    static func write(value: DisassociateWebsiteCertificateAuthorityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["WebsiteCaId"].write(value.websiteCaId)
    }
}

public struct DisassociateWebsiteCertificateAuthorityInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the CA.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

extension DisassociateWebsiteCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DisassociateWebsiteCertificateAuthorityOutput {
        return DisassociateWebsiteCertificateAuthorityOutput()
    }
}

public struct DisassociateWebsiteCertificateAuthorityOutput {

    public init() { }
}

enum DisassociateWebsiteCertificateAuthorityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension WorkLinkClientTypes {

    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case associating
        case disassociated
        case disassociating
        case failedToAssociate
        case failedToDisassociate
        case inactive
        case pendingValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .associating,
                .disassociated,
                .disassociating,
                .failedToAssociate,
                .failedToDisassociate,
                .inactive,
                .pendingValidation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failedToAssociate: return "FAILED_TO_ASSOCIATE"
            case .failedToDisassociate: return "FAILED_TO_DISASSOCIATE"
            case .inactive: return "INACTIVE"
            case .pendingValidation: return "PENDING_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkLinkClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkLinkClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkLinkClientTypes.DomainSummary()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.domainStatus = try reader["DomainStatus"].readIfPresent()
        return value
    }
}

extension WorkLinkClientTypes {
    /// The summary of the domain.
    public struct DomainSummary {
        /// The time that the domain was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The status of the domain.
        /// This member is required.
        public var domainStatus: WorkLinkClientTypes.DomainStatus?

        public init(
            createdTime: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: WorkLinkClientTypes.DomainStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.domainName = domainName
            self.domainStatus = domainStatus
        }
    }

}

extension WorkLinkClientTypes {

    public enum FleetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case failedToCreate
        case failedToDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .failedToCreate,
                .failedToDelete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failedToCreate: return "FAILED_TO_CREATE"
            case .failedToDelete: return "FAILED_TO_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkLinkClientTypes.FleetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkLinkClientTypes.FleetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkLinkClientTypes.FleetSummary()
        value.fleetArn = try reader["FleetArn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.fleetName = try reader["FleetName"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.companyCode = try reader["CompanyCode"].readIfPresent()
        value.fleetStatus = try reader["FleetStatus"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkLinkClientTypes {
    /// The summary of the fleet.
    public struct FleetSummary {
        /// The identifier used by users to sign into the Amazon WorkLink app.
        public var companyCode: Swift.String?
        /// The time when the fleet was created.
        public var createdTime: Foundation.Date?
        /// The name of the fleet to display.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The name of the fleet.
        public var fleetName: Swift.String?
        /// The status of the fleet.
        public var fleetStatus: WorkLinkClientTypes.FleetStatus?
        /// The time when the fleet was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The tags attached to the resource. A tag is a key-value pair.
        public var tags: [Swift.String:Swift.String]?

        public init(
            companyCode: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            fleetArn: Swift.String? = nil,
            fleetName: Swift.String? = nil,
            fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.companyCode = companyCode
            self.createdTime = createdTime
            self.displayName = displayName
            self.fleetArn = fleetArn
            self.fleetName = fleetName
            self.fleetStatus = fleetStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.tags = tags
        }
    }

}

extension WorkLinkClientTypes {

    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The service is temporarily unavailable.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/listDevices"
    }
}

extension ListDevicesInput {

    static func write(value: ListDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListDevicesInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: WorkLinkClientTypes.DeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDevicesOutput {
    /// Information about the devices.
    public var devices: [WorkLinkClientTypes.DeviceSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        devices: [WorkLinkClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/listDomains"
    }
}

extension ListDomainsInput {

    static func write(value: ListDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListDomainsInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: WorkLinkClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDomainsOutput {
    /// Information about the domains.
    public var domains: [WorkLinkClientTypes.DomainSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        domains: [WorkLinkClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListFleetsInput {

    static func urlPathProvider(_ value: ListFleetsInput) -> Swift.String? {
        return "/listFleets"
    }
}

extension ListFleetsInput {

    static func write(value: ListFleetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListFleetsInput {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetsOutput()
        value.fleetSummaryList = try reader["FleetSummaryList"].readListIfPresent(memberReadingClosure: WorkLinkClientTypes.FleetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListFleetsOutput {
    /// The summary list of the fleets.
    public var fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        fleetSummaryList: [WorkLinkClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaryList = fleetSummaryList
        self.nextToken = nextToken
    }
}

enum ListFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWebsiteAuthorizationProvidersInput {

    static func urlPathProvider(_ value: ListWebsiteAuthorizationProvidersInput) -> Swift.String? {
        return "/listWebsiteAuthorizationProviders"
    }
}

extension ListWebsiteAuthorizationProvidersInput {

    static func write(value: ListWebsiteAuthorizationProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListWebsiteAuthorizationProvidersInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListWebsiteAuthorizationProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListWebsiteAuthorizationProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWebsiteAuthorizationProvidersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.websiteAuthorizationProviders = try reader["WebsiteAuthorizationProviders"].readListIfPresent(memberReadingClosure: WorkLinkClientTypes.WebsiteAuthorizationProviderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListWebsiteAuthorizationProvidersOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The website authorization providers.
    public var websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?

    public init(
        nextToken: Swift.String? = nil,
        websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteAuthorizationProviders = websiteAuthorizationProviders
    }
}

enum ListWebsiteAuthorizationProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWebsiteCertificateAuthoritiesInput {

    static func urlPathProvider(_ value: ListWebsiteCertificateAuthoritiesInput) -> Swift.String? {
        return "/listWebsiteCertificateAuthorities"
    }
}

extension ListWebsiteCertificateAuthoritiesInput {

    static func write(value: ListWebsiteCertificateAuthoritiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListWebsiteCertificateAuthoritiesInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListWebsiteCertificateAuthoritiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListWebsiteCertificateAuthoritiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWebsiteCertificateAuthoritiesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.websiteCertificateAuthorities = try reader["WebsiteCertificateAuthorities"].readListIfPresent(memberReadingClosure: WorkLinkClientTypes.WebsiteCaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListWebsiteCertificateAuthoritiesOutput {
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the certificates.
    public var websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteCertificateAuthorities = websiteCertificateAuthorities
    }
}

enum ListWebsiteCertificateAuthoritiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RestoreDomainAccessInput {

    static func urlPathProvider(_ value: RestoreDomainAccessInput) -> Swift.String? {
        return "/restoreDomainAccess"
    }
}

extension RestoreDomainAccessInput {

    static func write(value: RestoreDomainAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct RestoreDomainAccessInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension RestoreDomainAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> RestoreDomainAccessOutput {
        return RestoreDomainAccessOutput()
    }
}

public struct RestoreDomainAccessOutput {

    public init() { }
}

enum RestoreDomainAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RevokeDomainAccessInput {

    static func urlPathProvider(_ value: RevokeDomainAccessInput) -> Swift.String? {
        return "/revokeDomainAccess"
    }
}

extension RevokeDomainAccessInput {

    static func write(value: RevokeDomainAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct RevokeDomainAccessInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension RevokeDomainAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> RevokeDomainAccessOutput {
        return RevokeDomainAccessOutput()
    }
}

public struct RevokeDomainAccessOutput {

    public init() { }
}

enum RevokeDomainAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SignOutUserInput {

    static func urlPathProvider(_ value: SignOutUserInput) -> Swift.String? {
        return "/signOutUser"
    }
}

extension SignOutUserInput {

    static func write(value: SignOutUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["Username"].write(value.username)
    }
}

public struct SignOutUserInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.username = username
    }
}

extension SignOutUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> SignOutUserOutput {
        return SignOutUserOutput()
    }
}

public struct SignOutUserOutput {

    public init() { }
}

enum SignOutUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is a key-value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the limit.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You are not authorized to perform this action.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAuditStreamConfigurationInput {

    static func urlPathProvider(_ value: UpdateAuditStreamConfigurationInput) -> Swift.String? {
        return "/updateAuditStreamConfiguration"
    }
}

extension UpdateAuditStreamConfigurationInput {

    static func write(value: UpdateAuditStreamConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditStreamArn"].write(value.auditStreamArn)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct UpdateAuditStreamConfigurationInput {
    /// The ARN of the Amazon Kinesis data stream that receives the audit events.
    public var auditStreamArn: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        auditStreamArn: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
        self.fleetArn = fleetArn
    }
}

extension UpdateAuditStreamConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateAuditStreamConfigurationOutput {
        return UpdateAuditStreamConfigurationOutput()
    }
}

public struct UpdateAuditStreamConfigurationOutput {

    public init() { }
}

enum UpdateAuditStreamConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateCompanyNetworkConfigurationInput {

    static func urlPathProvider(_ value: UpdateCompanyNetworkConfigurationInput) -> Swift.String? {
        return "/updateCompanyNetworkConfiguration"
    }
}

extension UpdateCompanyNetworkConfigurationInput {

    static func write(value: UpdateCompanyNetworkConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }
}

public struct UpdateCompanyNetworkConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The security groups associated with access to the provided subnets.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension UpdateCompanyNetworkConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateCompanyNetworkConfigurationOutput {
        return UpdateCompanyNetworkConfigurationOutput()
    }
}

public struct UpdateCompanyNetworkConfigurationOutput {

    public init() { }
}

enum UpdateCompanyNetworkConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDevicePolicyConfigurationInput {

    static func urlPathProvider(_ value: UpdateDevicePolicyConfigurationInput) -> Swift.String? {
        return "/updateDevicePolicyConfiguration"
    }
}

extension UpdateDevicePolicyConfigurationInput {

    static func write(value: UpdateDevicePolicyConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceCaCertificate"].write(value.deviceCaCertificate)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct UpdateDevicePolicyConfigurationInput {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        deviceCaCertificate: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
        self.fleetArn = fleetArn
    }
}

extension UpdateDevicePolicyConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateDevicePolicyConfigurationOutput {
        return UpdateDevicePolicyConfigurationOutput()
    }
}

public struct UpdateDevicePolicyConfigurationOutput {

    public init() { }
}

enum UpdateDevicePolicyConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDomainMetadataInput {

    static func urlPathProvider(_ value: UpdateDomainMetadataInput) -> Swift.String? {
        return "/updateDomainMetadata"
    }
}

extension UpdateDomainMetadataInput {

    static func write(value: UpdateDomainMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["DomainName"].write(value.domainName)
        try writer["FleetArn"].write(value.fleetArn)
    }
}

public struct UpdateDomainMetadataInput {
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

extension UpdateDomainMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateDomainMetadataOutput {
        return UpdateDomainMetadataOutput()
    }
}

public struct UpdateDomainMetadataOutput {

    public init() { }
}

enum UpdateDomainMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateFleetMetadataInput {

    static func urlPathProvider(_ value: UpdateFleetMetadataInput) -> Swift.String? {
        return "/UpdateFleetMetadata"
    }
}

extension UpdateFleetMetadataInput {

    static func write(value: UpdateFleetMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["FleetArn"].write(value.fleetArn)
        try writer["OptimizeForEndUserLocation"].write(value.optimizeForEndUserLocation)
    }
}

public struct UpdateFleetMetadataInput {
    /// The fleet name to display. The existing DisplayName is unset if null is passed.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?

    public init(
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil
    )
    {
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
    }
}

extension UpdateFleetMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateFleetMetadataOutput {
        return UpdateFleetMetadataOutput()
    }
}

public struct UpdateFleetMetadataOutput {

    public init() { }
}

enum UpdateFleetMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateIdentityProviderConfigurationInput {

    static func urlPathProvider(_ value: UpdateIdentityProviderConfigurationInput) -> Swift.String? {
        return "/updateIdentityProviderConfiguration"
    }
}

extension UpdateIdentityProviderConfigurationInput {

    static func write(value: UpdateIdentityProviderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FleetArn"].write(value.fleetArn)
        try writer["IdentityProviderSamlMetadata"].write(value.identityProviderSamlMetadata)
        try writer["IdentityProviderType"].write(value.identityProviderType)
    }
}

public struct UpdateIdentityProviderConfigurationInput {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The SAML metadata document provided by the customer’s identity provider. The existing IdentityProviderSamlMetadata is unset if null is passed.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    /// This member is required.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?

    public init(
        fleetArn: Swift.String? = nil,
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil
    )
    {
        self.fleetArn = fleetArn
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
    }
}

extension UpdateIdentityProviderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateIdentityProviderConfigurationOutput {
        return UpdateIdentityProviderConfigurationOutput()
    }
}

public struct UpdateIdentityProviderConfigurationOutput {

    public init() { }
}

enum UpdateIdentityProviderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension WorkLinkClientTypes.WebsiteAuthorizationProviderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkLinkClientTypes.WebsiteAuthorizationProviderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkLinkClientTypes.WebsiteAuthorizationProviderSummary()
        value.authorizationProviderId = try reader["AuthorizationProviderId"].readIfPresent()
        value.authorizationProviderType = try reader["AuthorizationProviderType"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension WorkLinkClientTypes {
    /// The summary of the website authorization provider.
    public struct WebsiteAuthorizationProviderSummary {
        /// A unique identifier for the authorization provider.
        public var authorizationProviderId: Swift.String?
        /// The authorization provider type.
        /// This member is required.
        public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
        /// The time of creation.
        public var createdTime: Foundation.Date?
        /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
        public var domainName: Swift.String?

        public init(
            authorizationProviderId: Swift.String? = nil,
            authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
            createdTime: Foundation.Date? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.authorizationProviderId = authorizationProviderId
            self.authorizationProviderType = authorizationProviderType
            self.createdTime = createdTime
            self.domainName = domainName
        }
    }

}

extension WorkLinkClientTypes.WebsiteCaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkLinkClientTypes.WebsiteCaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkLinkClientTypes.WebsiteCaSummary()
        value.websiteCaId = try reader["WebsiteCaId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        return value
    }
}

extension WorkLinkClientTypes {
    /// The summary of the certificate authority (CA).
    public struct WebsiteCaSummary {
        /// The time when the CA was added.
        public var createdTime: Foundation.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// A unique identifier for the CA.
        public var websiteCaId: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            websiteCaId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.websiteCaId = websiteCaId
        }
    }

}

public enum WorkLinkClientTypes {}
