// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acmCertificateArn = self.acmCertificateArn {
            try encodeContainer.encode(acmCertificateArn, forKey: .acmCertificateArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateDomain"
    }
}

public struct AssociateDomainInput: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    /// This member is required.
    public var acmCertificateArn: Swift.String?
    /// The name to display.
    public var displayName: Swift.String?
    /// The fully qualified domain name (FQDN).
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        acmCertificateArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
    let displayName: Swift.String?
    let acmCertificateArn: Swift.String?
}

extension AssociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

extension AssociateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateWebsiteAuthorizationProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderType = self.authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateWebsiteAuthorizationProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateWebsiteAuthorizationProvider"
    }
}

public struct AssociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// The authorization provider type.
    /// This member is required.
    public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderType = authorizationProviderType
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    let domainName: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWebsiteAuthorizationProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteAuthorizationProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateWebsiteAuthorizationProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationProviderId = output.authorizationProviderId
        } else {
            self.authorizationProviderId = nil
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderOutputResponse: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    public var authorizationProviderId: Swift.String?

    public init (
        authorizationProviderId: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
    }
}

struct AssociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Equatable {
    let authorizationProviderId: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

extension AssociateWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateWebsiteCertificateAuthority"
    }
}

public struct AssociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The root certificate of the CA.
    /// This member is required.
    public var certificate: Swift.String?
    /// The certificate name to display.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.displayName = displayName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let certificate: Swift.String?
    let displayName: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.websiteCaId = output.websiteCaId
        } else {
            self.websiteCaId = nil
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {
    /// A unique identifier for the CA.
    public var websiteCaId: Swift.String?

    public init (
        websiteCaId: Swift.String? = nil
    )
    {
        self.websiteCaId = websiteCaId
    }
}

struct AssociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Equatable {
    let websiteCaId: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension WorkLinkClientTypes {
    public enum AuthorizationProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationProviderType(rawValue: rawValue) ?? AuthorizationProviderType.sdkUnknown(rawValue)
        }
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let optimizeForEndUserLocation = self.optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createFleet"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// A unique name for the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags to add to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.displayName = displayName
        self.fleetName = fleetName
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetArn = output.fleetArn
        } else {
            self.fleetArn = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteFleet"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAuditStreamConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeAuditStreamConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeAuditStreamConfiguration"
    }
}

public struct DescribeAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeAuditStreamConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditStreamConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAuditStreamConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditStreamConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAuditStreamConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.auditStreamArn = output.auditStreamArn
        } else {
            self.auditStreamArn = nil
        }
    }
}

public struct DescribeAuditStreamConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that will receive the audit events.
    public var auditStreamArn: Swift.String?

    public init (
        auditStreamArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
    }
}

struct DescribeAuditStreamConfigurationOutputResponseBody: Swift.Equatable {
    let auditStreamArn: Swift.String?
}

extension DescribeAuditStreamConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

extension DescribeCompanyNetworkConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeCompanyNetworkConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeCompanyNetworkConfiguration"
    }
}

public struct DescribeCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeCompanyNetworkConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCompanyNetworkConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCompanyNetworkConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCompanyNetworkConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCompanyNetworkConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.vpcId = output.vpcId
        } else {
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.vpcId = nil
        }
    }
}

public struct DescribeCompanyNetworkConfigurationOutputResponse: Swift.Equatable {
    /// The security groups associated with access to the provided subnets.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    public var vpcId: Swift.String?

    public init (
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct DescribeCompanyNetworkConfigurationOutputResponseBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
}

extension DescribeCompanyNetworkConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension DescribeDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDevice"
    }
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// A unique identifier for a registered user's device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.fleetArn = fleetArn
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let deviceId: Swift.String?
}

extension DescribeDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DescribeDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firstAccessedTime = output.firstAccessedTime
            self.lastAccessedTime = output.lastAccessedTime
            self.manufacturer = output.manufacturer
            self.model = output.model
            self.operatingSystem = output.operatingSystem
            self.operatingSystemVersion = output.operatingSystemVersion
            self.patchLevel = output.patchLevel
            self.status = output.status
            self.username = output.username
        } else {
            self.firstAccessedTime = nil
            self.lastAccessedTime = nil
            self.manufacturer = nil
            self.model = nil
            self.operatingSystem = nil
            self.operatingSystemVersion = nil
            self.patchLevel = nil
            self.status = nil
            self.username = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Swift.Equatable {
    /// The date that the device first signed in to Amazon WorkLink.
    public var firstAccessedTime: ClientRuntime.Date?
    /// The date that the device last accessed Amazon WorkLink.
    public var lastAccessedTime: ClientRuntime.Date?
    /// The manufacturer of the device.
    public var manufacturer: Swift.String?
    /// The model of the device.
    public var model: Swift.String?
    /// The operating system of the device.
    public var operatingSystem: Swift.String?
    /// The operating system version of the device.
    public var operatingSystemVersion: Swift.String?
    /// The operating system patch level of the device.
    public var patchLevel: Swift.String?
    /// The current state of the device.
    public var status: WorkLinkClientTypes.DeviceStatus?
    /// The user name associated with the device.
    public var username: Swift.String?

    public init (
        firstAccessedTime: ClientRuntime.Date? = nil,
        lastAccessedTime: ClientRuntime.Date? = nil,
        manufacturer: Swift.String? = nil,
        model: Swift.String? = nil,
        operatingSystem: Swift.String? = nil,
        operatingSystemVersion: Swift.String? = nil,
        patchLevel: Swift.String? = nil,
        status: WorkLinkClientTypes.DeviceStatus? = nil,
        username: Swift.String? = nil
    )
    {
        self.firstAccessedTime = firstAccessedTime
        self.lastAccessedTime = lastAccessedTime
        self.manufacturer = manufacturer
        self.model = model
        self.operatingSystem = operatingSystem
        self.operatingSystemVersion = operatingSystemVersion
        self.patchLevel = patchLevel
        self.status = status
        self.username = username
    }
}

struct DescribeDeviceOutputResponseBody: Swift.Equatable {
    let status: WorkLinkClientTypes.DeviceStatus?
    let model: Swift.String?
    let manufacturer: Swift.String?
    let operatingSystem: Swift.String?
    let operatingSystemVersion: Swift.String?
    let patchLevel: Swift.String?
    let firstAccessedTime: ClientRuntime.Date?
    let lastAccessedTime: ClientRuntime.Date?
    let username: Swift.String?
}

extension DescribeDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstAccessedTime = "FirstAccessedTime"
        case lastAccessedTime = "LastAccessedTime"
        case manufacturer = "Manufacturer"
        case model = "Model"
        case operatingSystem = "OperatingSystem"
        case operatingSystemVersion = "OperatingSystemVersion"
        case patchLevel = "PatchLevel"
        case status = "Status"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        let patchLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchLevel)
        patchLevel = patchLevelDecoded
        let firstAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstAccessedTime)
        firstAccessedTime = firstAccessedTimeDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension DescribeDevicePolicyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDevicePolicyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDevicePolicyConfiguration"
    }
}

public struct DescribeDevicePolicyConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeDevicePolicyConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDevicePolicyConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDevicePolicyConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDevicePolicyConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDevicePolicyConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceCaCertificate = output.deviceCaCertificate
        } else {
            self.deviceCaCertificate = nil
        }
    }
}

public struct DescribeDevicePolicyConfigurationOutputResponse: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?

    public init (
        deviceCaCertificate: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
    }
}

struct DescribeDevicePolicyConfigurationOutputResponseBody: Swift.Equatable {
    let deviceCaCertificate: Swift.String?
}

extension DescribeDevicePolicyConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

extension DescribeDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDomain"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension DescribeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acmCertificateArn = output.acmCertificateArn
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.domainName = output.domainName
            self.domainStatus = output.domainStatus
        } else {
            self.acmCertificateArn = nil
            self.createdTime = nil
            self.displayName = nil
            self.domainName = nil
            self.domainStatus = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    public var acmCertificateArn: Swift.String?
    /// The time that the domain was added.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The current state for the domain.
    public var domainStatus: WorkLinkClientTypes.DomainStatus?

    public init (
        acmCertificateArn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainStatus: WorkLinkClientTypes.DomainStatus? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let displayName: Swift.String?
    let createdTime: ClientRuntime.Date?
    let domainStatus: WorkLinkClientTypes.DomainStatus?
    let acmCertificateArn: Swift.String?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

extension DescribeFleetMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeFleetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeFleetMetadata"
    }
}

public struct DescribeFleetMetadataInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeFleetMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeFleetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.companyCode = output.companyCode
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.fleetName = output.fleetName
            self.fleetStatus = output.fleetStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.optimizeForEndUserLocation = output.optimizeForEndUserLocation
            self.tags = output.tags
        } else {
            self.companyCode = nil
            self.createdTime = nil
            self.displayName = nil
            self.fleetName = nil
            self.fleetStatus = nil
            self.lastUpdatedTime = nil
            self.optimizeForEndUserLocation = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetMetadataOutputResponse: Swift.Equatable {
    /// The identifier used by users to sign in to the Amazon WorkLink app.
    public var companyCode: Swift.String?
    /// The time that the fleet was created.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The current state of the fleet.
    public var fleetStatus: WorkLinkClientTypes.FleetStatus?
    /// The time that the fleet was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        companyCode: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct DescribeFleetMetadataOutputResponseBody: Swift.Equatable {
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let fleetName: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
    let companyCode: Swift.String?
    let fleetStatus: WorkLinkClientTypes.FleetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeIdentityProviderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeIdentityProviderConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeIdentityProviderConfiguration"
    }
}

public struct DescribeIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeIdentityProviderConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityProviderConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIdentityProviderConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityProviderConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIdentityProviderConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSamlMetadata = output.identityProviderSamlMetadata
            self.identityProviderType = output.identityProviderType
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.identityProviderSamlMetadata = nil
            self.identityProviderType = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct DescribeIdentityProviderConfigurationOutputResponse: Swift.Equatable {
    /// The SAML metadata document provided by the user’s identity provider.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    /// The SAML metadata document uploaded to the user’s identity provider.
    public var serviceProviderSamlMetadata: Swift.String?

    public init (
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct DescribeIdentityProviderConfigurationOutputResponseBody: Swift.Equatable {
    let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    let serviceProviderSamlMetadata: Swift.String?
    let identityProviderSamlMetadata: Swift.String?
}

extension DescribeIdentityProviderConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
        case serviceProviderSamlMetadata = "ServiceProviderSamlMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

extension DescribeWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

extension DescribeWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWebsiteCertificateAuthority"
    }
}

public struct DescribeWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the certificate authority.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DescribeWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let websiteCaId: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.createdTime = output.createdTime
            self.displayName = output.displayName
        } else {
            self.certificate = nil
            self.createdTime = nil
            self.displayName = nil
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {
    /// The root certificate of the certificate authority.
    public var certificate: Swift.String?
    /// The time that the certificate authority was added.
    public var createdTime: ClientRuntime.Date?
    /// The certificate name to display.
    public var displayName: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.createdTime = createdTime
        self.displayName = displayName
    }
}

struct DescribeWebsiteCertificateAuthorityOutputResponseBody: Swift.Equatable {
    let certificate: Swift.String?
    let createdTime: ClientRuntime.Date?
    let displayName: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WorkLinkClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case signedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .active,
                .signedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .signedOut: return "SIGNED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case deviceStatus = "DeviceStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceStatus = self.deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of devices.
    public struct DeviceSummary: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The status of the device.
        public var deviceStatus: WorkLinkClientTypes.DeviceStatus?

        public init (
            deviceId: Swift.String? = nil,
            deviceStatus: WorkLinkClientTypes.DeviceStatus? = nil
        )
        {
            self.deviceId = deviceId
            self.deviceStatus = deviceStatus
        }
    }

}

extension DisassociateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DisassociateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateDomain"
    }
}

public struct DisassociateDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DisassociateDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension DisassociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWebsiteAuthorizationProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = self.authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DisassociateWebsiteAuthorizationProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateWebsiteAuthorizationProvider"
    }
}

public struct DisassociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    /// This member is required.
    public var authorizationProviderId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        authorizationProviderId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.fleetArn = fleetArn
    }
}

struct DisassociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let authorizationProviderId: Swift.String?
}

extension DisassociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWebsiteAuthorizationProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteAuthorizationProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

extension DisassociateWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateWebsiteCertificateAuthority"
    }
}

public struct DisassociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the CA.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DisassociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let websiteCaId: Swift.String?
}

extension DisassociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateWebsiteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkLinkClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case disassociated
        case disassociating
        case failedToAssociate
        case failedToDisassociate
        case inactive
        case pendingValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .associating,
                .disassociated,
                .disassociating,
                .failedToAssociate,
                .failedToDisassociate,
                .inactive,
                .pendingValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failedToAssociate: return "FAILED_TO_ASSOCIATE"
            case .failedToDisassociate: return "FAILED_TO_DISASSOCIATE"
            case .inactive: return "INACTIVE"
            case .pendingValidation: return "PENDING_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the domain.
    public struct DomainSummary: Swift.Equatable {
        /// The time that the domain was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The status of the domain.
        /// This member is required.
        public var domainStatus: WorkLinkClientTypes.DomainStatus?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: WorkLinkClientTypes.DomainStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.domainName = domainName
            self.domainStatus = domainStatus
        }
    }

}

extension WorkLinkClientTypes {
    public enum FleetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case failedToCreate
        case failedToDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .failedToCreate,
                .failedToDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failedToCreate: return "FAILED_TO_CREATE"
            case .failedToDelete: return "FAILED_TO_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetStatus(rawValue: rawValue) ?? FleetStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.FleetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let companyCode = self.companyCode {
            try encodeContainer.encode(companyCode, forKey: .companyCode)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetStatus = self.fleetStatus {
            try encodeContainer.encode(fleetStatus.rawValue, forKey: .fleetStatus)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkLinkClientTypes {
    /// The summary of the fleet.
    public struct FleetSummary: Swift.Equatable {
        /// The identifier used by users to sign into the Amazon WorkLink app.
        public var companyCode: Swift.String?
        /// The time when the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The name of the fleet to display.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The name of the fleet.
        public var fleetName: Swift.String?
        /// The status of the fleet.
        public var fleetStatus: WorkLinkClientTypes.FleetStatus?
        /// The time when the fleet was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The tags attached to the resource. A tag is a key-value pair.
        public var tags: [Swift.String:Swift.String]?

        public init (
            companyCode: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            fleetArn: Swift.String? = nil,
            fleetName: Swift.String? = nil,
            fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.companyCode = companyCode
            self.createdTime = createdTime
            self.displayName = displayName
            self.fleetArn = fleetArn
            self.fleetName = fleetName
            self.fleetStatus = fleetStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.tags = tags
        }
    }

}

extension WorkLinkClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDevices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Swift.Equatable {
    /// Information about the devices.
    public var devices: [WorkLinkClientTypes.DeviceSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        devices: [WorkLinkClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    let devices: [WorkLinkClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[WorkLinkClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [WorkLinkClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDomains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// Information about the domains.
    public var domains: [WorkLinkClientTypes.DomainSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        domains: [WorkLinkClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domains: [WorkLinkClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[WorkLinkClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkLinkClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listFleets"
    }
}

public struct ListFleetsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFleetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetSummaryList = output.fleetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Swift.Equatable {
    /// The summary list of the fleets.
    public var fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        fleetSummaryList: [WorkLinkClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaryList = fleetSummaryList
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Swift.Equatable {
    let fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetSummaryList = "FleetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummaryListContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.FleetSummary?].self, forKey: .fleetSummaryList)
        var fleetSummaryListDecoded0:[WorkLinkClientTypes.FleetSummary]? = nil
        if let fleetSummaryListContainer = fleetSummaryListContainer {
            fleetSummaryListDecoded0 = [WorkLinkClientTypes.FleetSummary]()
            for structure0 in fleetSummaryListContainer {
                if let structure0 = structure0 {
                    fleetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaryList = fleetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWebsiteAuthorizationProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWebsiteAuthorizationProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWebsiteAuthorizationProviders"
    }
}

public struct ListWebsiteAuthorizationProvidersInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteAuthorizationProvidersInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWebsiteAuthorizationProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebsiteAuthorizationProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteAuthorizationProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWebsiteAuthorizationProvidersOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteAuthorizationProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWebsiteAuthorizationProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteAuthorizationProviders = output.websiteAuthorizationProviders
        } else {
            self.nextToken = nil
            self.websiteAuthorizationProviders = nil
        }
    }
}

public struct ListWebsiteAuthorizationProvidersOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The website authorization providers.
    public var websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?

    public init (
        nextToken: Swift.String? = nil,
        websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteAuthorizationProviders = websiteAuthorizationProviders
    }
}

struct ListWebsiteAuthorizationProvidersOutputResponseBody: Swift.Equatable {
    let websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?
    let nextToken: Swift.String?
}

extension ListWebsiteAuthorizationProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteAuthorizationProviders = "WebsiteAuthorizationProviders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteAuthorizationProvidersContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteAuthorizationProviderSummary?].self, forKey: .websiteAuthorizationProviders)
        var websiteAuthorizationProvidersDecoded0:[WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
        if let websiteAuthorizationProvidersContainer = websiteAuthorizationProvidersContainer {
            websiteAuthorizationProvidersDecoded0 = [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]()
            for structure0 in websiteAuthorizationProvidersContainer {
                if let structure0 = structure0 {
                    websiteAuthorizationProvidersDecoded0?.append(structure0)
                }
            }
        }
        websiteAuthorizationProviders = websiteAuthorizationProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebsiteCertificateAuthoritiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWebsiteCertificateAuthoritiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWebsiteCertificateAuthorities"
    }
}

public struct ListWebsiteCertificateAuthoritiesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteCertificateAuthoritiesInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWebsiteCertificateAuthoritiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteCertificateAuthoritiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWebsiteCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteCertificateAuthorities = output.websiteCertificateAuthorities
        } else {
            self.nextToken = nil
            self.websiteCertificateAuthorities = nil
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the certificates.
    public var websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteCertificateAuthorities = websiteCertificateAuthorities
    }
}

struct ListWebsiteCertificateAuthoritiesOutputResponseBody: Swift.Equatable {
    let websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?
    let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteCertificateAuthorities = "WebsiteCertificateAuthorities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteCaSummary?].self, forKey: .websiteCertificateAuthorities)
        var websiteCertificateAuthoritiesDecoded0:[WorkLinkClientTypes.WebsiteCaSummary]? = nil
        if let websiteCertificateAuthoritiesContainer = websiteCertificateAuthoritiesContainer {
            websiteCertificateAuthoritiesDecoded0 = [WorkLinkClientTypes.WebsiteCaSummary]()
            for structure0 in websiteCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    websiteCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        websiteCertificateAuthorities = websiteCertificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreDomainAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension RestoreDomainAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restoreDomainAccess"
    }
}

public struct RestoreDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RestoreDomainAccessInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension RestoreDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RestoreDomainAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreDomainAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreDomainAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDomainAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestoreDomainAccessOutputResponse: Swift.Equatable {

    public init () { }
}

extension RevokeDomainAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension RevokeDomainAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/revokeDomainAccess"
    }
}

public struct RevokeDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RevokeDomainAccessInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension RevokeDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RevokeDomainAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeDomainAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RevokeDomainAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDomainAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeDomainAccessOutputResponse: Swift.Equatable {

    public init () { }
}

extension SignOutUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension SignOutUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signOutUser"
    }
}

public struct SignOutUserInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.username = username
    }
}

struct SignOutUserInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let username: Swift.String?
}

extension SignOutUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension SignOutUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignOutUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SignOutUserOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignOutUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SignOutUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is a key-value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of requests exceeds the limit.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this action.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAuditStreamConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditStreamArn = self.auditStreamArn {
            try encodeContainer.encode(auditStreamArn, forKey: .auditStreamArn)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateAuditStreamConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateAuditStreamConfiguration"
    }
}

public struct UpdateAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that receives the audit events.
    public var auditStreamArn: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        auditStreamArn: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
        self.fleetArn = fleetArn
    }
}

struct UpdateAuditStreamConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let auditStreamArn: Swift.String?
}

extension UpdateAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

extension UpdateAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuditStreamConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAuditStreamConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuditStreamConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAuditStreamConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCompanyNetworkConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension UpdateCompanyNetworkConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateCompanyNetworkConfiguration"
    }
}

public struct UpdateCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The security groups associated with access to the provided subnets.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        fleetArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateCompanyNetworkConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
}

extension UpdateCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCompanyNetworkConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCompanyNetworkConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCompanyNetworkConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCompanyNetworkConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDevicePolicyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCaCertificate = self.deviceCaCertificate {
            try encodeContainer.encode(deviceCaCertificate, forKey: .deviceCaCertificate)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateDevicePolicyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDevicePolicyConfiguration"
    }
}

public struct UpdateDevicePolicyConfigurationInput: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        deviceCaCertificate: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
        self.fleetArn = fleetArn
    }
}

struct UpdateDevicePolicyConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let deviceCaCertificate: Swift.String?
}

extension UpdateDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

extension UpdateDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePolicyConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDevicePolicyConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePolicyConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDevicePolicyConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDomainMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateDomainMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDomainMetadata"
    }
}

public struct UpdateDomainMetadataInput: Swift.Equatable {
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct UpdateDomainMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
    let displayName: Swift.String?
}

extension UpdateDomainMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateDomainMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDomainMetadataOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFleetMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let optimizeForEndUserLocation = self.optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
    }
}

extension UpdateFleetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateFleetMetadata"
    }
}

public struct UpdateFleetMetadataInput: Swift.Equatable {
    /// The fleet name to display. The existing DisplayName is unset if null is passed.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?

    public init (
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil
    )
    {
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
    }
}

struct UpdateFleetMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
}

extension UpdateFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
    }
}

extension UpdateFleetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFleetMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFleetMetadataOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateIdentityProviderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let identityProviderSamlMetadata = self.identityProviderSamlMetadata {
            try encodeContainer.encode(identityProviderSamlMetadata, forKey: .identityProviderSamlMetadata)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

extension UpdateIdentityProviderConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateIdentityProviderConfiguration"
    }
}

public struct UpdateIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The SAML metadata document provided by the customer’s identity provider. The existing IdentityProviderSamlMetadata is unset if null is passed.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    /// This member is required.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?

    public init (
        fleetArn: Swift.String? = nil,
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil
    )
    {
        self.fleetArn = fleetArn
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    let identityProviderSamlMetadata: Swift.String?
}

extension UpdateIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

extension UpdateIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIdentityProviderConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIdentityProviderConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkLinkClientTypes.WebsiteAuthorizationProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case authorizationProviderType = "AuthorizationProviderType"
        case createdTime = "CreatedTime"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = self.authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let authorizationProviderType = self.authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the website authorization provider.
    public struct WebsiteAuthorizationProviderSummary: Swift.Equatable {
        /// A unique identifier for the authorization provider.
        public var authorizationProviderId: Swift.String?
        /// The authorization provider type.
        /// This member is required.
        public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
        /// The time of creation.
        public var createdTime: ClientRuntime.Date?
        /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
        public var domainName: Swift.String?

        public init (
            authorizationProviderId: Swift.String? = nil,
            authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.authorizationProviderId = authorizationProviderId
            self.authorizationProviderType = authorizationProviderType
            self.createdTime = createdTime
            self.domainName = domainName
        }
    }

}

extension WorkLinkClientTypes.WebsiteCaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the certificate authority (CA).
    public struct WebsiteCaSummary: Swift.Equatable {
        /// The time when the CA was added.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// A unique identifier for the CA.
        public var websiteCaId: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            websiteCaId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.websiteCaId = websiteCaId
        }
    }

}
