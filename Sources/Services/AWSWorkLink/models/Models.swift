// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acmCertificateArn = self.acmCertificateArn {
            try encodeContainer.encode(acmCertificateArn, forKey: .acmCertificateArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateDomain"
    }
}

public struct AssociateDomainInput: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    /// This member is required.
    public var acmCertificateArn: Swift.String?
    /// The name to display.
    public var displayName: Swift.String?
    /// The fully qualified domain name (FQDN).
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        acmCertificateArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
    let displayName: Swift.String?
    let acmCertificateArn: Swift.String?
}

extension AssociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

extension AssociateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDomainOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWebsiteAuthorizationProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderType = self.authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateWebsiteAuthorizationProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateWebsiteAuthorizationProvider"
    }
}

public struct AssociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// The authorization provider type.
    /// This member is required.
    public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderType = authorizationProviderType
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
    let domainName: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension AssociateWebsiteAuthorizationProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateWebsiteAuthorizationProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizationProviderId = output.authorizationProviderId
        } else {
            self.authorizationProviderId = nil
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderOutput: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    public var authorizationProviderId: Swift.String?

    public init(
        authorizationProviderId: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
    }
}

struct AssociateWebsiteAuthorizationProviderOutputBody: Swift.Equatable {
    let authorizationProviderId: Swift.String?
}

extension AssociateWebsiteAuthorizationProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

enum AssociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension AssociateWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateWebsiteCertificateAuthority"
    }
}

public struct AssociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The root certificate of the CA.
    /// This member is required.
    public var certificate: Swift.String?
    /// The certificate name to display.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.displayName = displayName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let certificate: Swift.String?
    let displayName: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension AssociateWebsiteCertificateAuthorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateWebsiteCertificateAuthorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.websiteCaId = output.websiteCaId
        } else {
            self.websiteCaId = nil
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityOutput: Swift.Equatable {
    /// A unique identifier for the CA.
    public var websiteCaId: Swift.String?

    public init(
        websiteCaId: Swift.String? = nil
    )
    {
        self.websiteCaId = websiteCaId
    }
}

struct AssociateWebsiteCertificateAuthorityOutputBody: Swift.Equatable {
    let websiteCaId: Swift.String?
}

extension AssociateWebsiteCertificateAuthorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case websiteCaId = "WebsiteCaId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

enum AssociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkLinkClientTypes {
    public enum AuthorizationProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationProviderType(rawValue: rawValue) ?? AuthorizationProviderType.sdkUnknown(rawValue)
        }
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let optimizeForEndUserLocation = self.optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createFleet"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// A unique name for the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags to add to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.displayName = displayName
        self.fleetName = fleetName
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetArn = output.fleetArn
        } else {
            self.fleetArn = nil
        }
    }
}

public struct CreateFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct CreateFleetOutputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension CreateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

enum CreateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteFleet"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DeleteFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFleetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuditStreamConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeAuditStreamConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeAuditStreamConfiguration"
    }
}

public struct DescribeAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeAuditStreamConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeAuditStreamConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuditStreamConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.auditStreamArn = output.auditStreamArn
        } else {
            self.auditStreamArn = nil
        }
    }
}

public struct DescribeAuditStreamConfigurationOutput: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that will receive the audit events.
    public var auditStreamArn: Swift.String?

    public init(
        auditStreamArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
    }
}

struct DescribeAuditStreamConfigurationOutputBody: Swift.Equatable {
    let auditStreamArn: Swift.String?
}

extension DescribeAuditStreamConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

enum DescribeAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCompanyNetworkConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeCompanyNetworkConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeCompanyNetworkConfiguration"
    }
}

public struct DescribeCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeCompanyNetworkConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeCompanyNetworkConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCompanyNetworkConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.vpcId = output.vpcId
        } else {
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.vpcId = nil
        }
    }
}

public struct DescribeCompanyNetworkConfigurationOutput: Swift.Equatable {
    /// The security groups associated with access to the provided subnets.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    public var vpcId: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct DescribeCompanyNetworkConfigurationOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
}

extension DescribeCompanyNetworkConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

enum DescribeCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDevice"
    }
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// A unique identifier for a registered user's device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.fleetArn = fleetArn
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let deviceId: Swift.String?
}

extension DescribeDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DescribeDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.firstAccessedTime = output.firstAccessedTime
            self.lastAccessedTime = output.lastAccessedTime
            self.manufacturer = output.manufacturer
            self.model = output.model
            self.operatingSystem = output.operatingSystem
            self.operatingSystemVersion = output.operatingSystemVersion
            self.patchLevel = output.patchLevel
            self.status = output.status
            self.username = output.username
        } else {
            self.firstAccessedTime = nil
            self.lastAccessedTime = nil
            self.manufacturer = nil
            self.model = nil
            self.operatingSystem = nil
            self.operatingSystemVersion = nil
            self.patchLevel = nil
            self.status = nil
            self.username = nil
        }
    }
}

public struct DescribeDeviceOutput: Swift.Equatable {
    /// The date that the device first signed in to Amazon WorkLink.
    public var firstAccessedTime: ClientRuntime.Date?
    /// The date that the device last accessed Amazon WorkLink.
    public var lastAccessedTime: ClientRuntime.Date?
    /// The manufacturer of the device.
    public var manufacturer: Swift.String?
    /// The model of the device.
    public var model: Swift.String?
    /// The operating system of the device.
    public var operatingSystem: Swift.String?
    /// The operating system version of the device.
    public var operatingSystemVersion: Swift.String?
    /// The operating system patch level of the device.
    public var patchLevel: Swift.String?
    /// The current state of the device.
    public var status: WorkLinkClientTypes.DeviceStatus?
    /// The user name associated with the device.
    public var username: Swift.String?

    public init(
        firstAccessedTime: ClientRuntime.Date? = nil,
        lastAccessedTime: ClientRuntime.Date? = nil,
        manufacturer: Swift.String? = nil,
        model: Swift.String? = nil,
        operatingSystem: Swift.String? = nil,
        operatingSystemVersion: Swift.String? = nil,
        patchLevel: Swift.String? = nil,
        status: WorkLinkClientTypes.DeviceStatus? = nil,
        username: Swift.String? = nil
    )
    {
        self.firstAccessedTime = firstAccessedTime
        self.lastAccessedTime = lastAccessedTime
        self.manufacturer = manufacturer
        self.model = model
        self.operatingSystem = operatingSystem
        self.operatingSystemVersion = operatingSystemVersion
        self.patchLevel = patchLevel
        self.status = status
        self.username = username
    }
}

struct DescribeDeviceOutputBody: Swift.Equatable {
    let status: WorkLinkClientTypes.DeviceStatus?
    let model: Swift.String?
    let manufacturer: Swift.String?
    let operatingSystem: Swift.String?
    let operatingSystemVersion: Swift.String?
    let patchLevel: Swift.String?
    let firstAccessedTime: ClientRuntime.Date?
    let lastAccessedTime: ClientRuntime.Date?
    let username: Swift.String?
}

extension DescribeDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstAccessedTime = "FirstAccessedTime"
        case lastAccessedTime = "LastAccessedTime"
        case manufacturer = "Manufacturer"
        case model = "Model"
        case operatingSystem = "OperatingSystem"
        case operatingSystemVersion = "OperatingSystemVersion"
        case patchLevel = "PatchLevel"
        case status = "Status"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        let patchLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchLevel)
        patchLevel = patchLevelDecoded
        let firstAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstAccessedTime)
        firstAccessedTime = firstAccessedTimeDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

enum DescribeDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDevicePolicyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDevicePolicyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDevicePolicyConfiguration"
    }
}

public struct DescribeDevicePolicyConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeDevicePolicyConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeDevicePolicyConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDevicePolicyConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceCaCertificate = output.deviceCaCertificate
        } else {
            self.deviceCaCertificate = nil
        }
    }
}

public struct DescribeDevicePolicyConfigurationOutput: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?

    public init(
        deviceCaCertificate: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
    }
}

struct DescribeDevicePolicyConfigurationOutputBody: Swift.Equatable {
    let deviceCaCertificate: Swift.String?
}

extension DescribeDevicePolicyConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

enum DescribeDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDomain"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension DescribeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DescribeDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.acmCertificateArn = output.acmCertificateArn
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.domainName = output.domainName
            self.domainStatus = output.domainStatus
        } else {
            self.acmCertificateArn = nil
            self.createdTime = nil
            self.displayName = nil
            self.domainName = nil
            self.domainStatus = nil
        }
    }
}

public struct DescribeDomainOutput: Swift.Equatable {
    /// The ARN of an issued ACM certificate that is valid for the domain being associated.
    public var acmCertificateArn: Swift.String?
    /// The time that the domain was added.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The current state for the domain.
    public var domainStatus: WorkLinkClientTypes.DomainStatus?

    public init(
        acmCertificateArn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainStatus: WorkLinkClientTypes.DomainStatus? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

struct DescribeDomainOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let displayName: Swift.String?
    let createdTime: ClientRuntime.Date?
    let domainStatus: WorkLinkClientTypes.DomainStatus?
    let acmCertificateArn: Swift.String?
}

extension DescribeDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

enum DescribeDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeFleetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeFleetMetadata"
    }
}

public struct DescribeFleetMetadataInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeFleetMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeFleetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.companyCode = output.companyCode
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.fleetName = output.fleetName
            self.fleetStatus = output.fleetStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.optimizeForEndUserLocation = output.optimizeForEndUserLocation
            self.tags = output.tags
        } else {
            self.companyCode = nil
            self.createdTime = nil
            self.displayName = nil
            self.fleetName = nil
            self.fleetStatus = nil
            self.lastUpdatedTime = nil
            self.optimizeForEndUserLocation = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetMetadataOutput: Swift.Equatable {
    /// The identifier used by users to sign in to the Amazon WorkLink app.
    public var companyCode: Swift.String?
    /// The time that the fleet was created.
    public var createdTime: ClientRuntime.Date?
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The current state of the fleet.
    public var fleetStatus: WorkLinkClientTypes.FleetStatus?
    /// The time that the fleet was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        companyCode: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct DescribeFleetMetadataOutputBody: Swift.Equatable {
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let fleetName: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
    let companyCode: Swift.String?
    let fleetStatus: WorkLinkClientTypes.FleetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeFleetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIdentityProviderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DescribeIdentityProviderConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeIdentityProviderConfiguration"
    }
}

public struct DescribeIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        fleetArn: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeIdentityProviderConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
}

extension DescribeIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeIdentityProviderConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIdentityProviderConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSamlMetadata = output.identityProviderSamlMetadata
            self.identityProviderType = output.identityProviderType
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.identityProviderSamlMetadata = nil
            self.identityProviderType = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct DescribeIdentityProviderConfigurationOutput: Swift.Equatable {
    /// The SAML metadata document provided by the users identity provider.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    /// The SAML metadata document uploaded to the users identity provider.
    public var serviceProviderSamlMetadata: Swift.String?

    public init(
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct DescribeIdentityProviderConfigurationOutputBody: Swift.Equatable {
    let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    let serviceProviderSamlMetadata: Swift.String?
    let identityProviderSamlMetadata: Swift.String?
}

extension DescribeIdentityProviderConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
        case serviceProviderSamlMetadata = "ServiceProviderSamlMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

enum DescribeIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

extension DescribeWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWebsiteCertificateAuthority"
    }
}

public struct DescribeWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the certificate authority.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DescribeWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let websiteCaId: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DescribeWebsiteCertificateAuthorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWebsiteCertificateAuthorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.createdTime = output.createdTime
            self.displayName = output.displayName
        } else {
            self.certificate = nil
            self.createdTime = nil
            self.displayName = nil
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityOutput: Swift.Equatable {
    /// The root certificate of the certificate authority.
    public var certificate: Swift.String?
    /// The time that the certificate authority was added.
    public var createdTime: ClientRuntime.Date?
    /// The certificate name to display.
    public var displayName: Swift.String?

    public init(
        certificate: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.createdTime = createdTime
        self.displayName = displayName
    }
}

struct DescribeWebsiteCertificateAuthorityOutputBody: Swift.Equatable {
    let certificate: Swift.String?
    let createdTime: ClientRuntime.Date?
    let displayName: Swift.String?
}

extension DescribeWebsiteCertificateAuthorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

enum DescribeWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkLinkClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case signedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .active,
                .signedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .signedOut: return "SIGNED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case deviceStatus = "DeviceStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceStatus = self.deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of devices.
    public struct DeviceSummary: Swift.Equatable {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The status of the device.
        public var deviceStatus: WorkLinkClientTypes.DeviceStatus?

        public init(
            deviceId: Swift.String? = nil,
            deviceStatus: WorkLinkClientTypes.DeviceStatus? = nil
        )
        {
            self.deviceId = deviceId
            self.deviceStatus = deviceStatus
        }
    }

}

extension DisassociateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DisassociateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateDomain"
    }
}

public struct DisassociateDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DisassociateDomainInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension DisassociateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDomainOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWebsiteAuthorizationProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = self.authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension DisassociateWebsiteAuthorizationProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateWebsiteAuthorizationProvider"
    }
}

public struct DisassociateWebsiteAuthorizationProviderInput: Swift.Equatable {
    /// A unique identifier for the authorization provider.
    /// This member is required.
    public var authorizationProviderId: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        authorizationProviderId: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.fleetArn = fleetArn
    }
}

struct DisassociateWebsiteAuthorizationProviderInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let authorizationProviderId: Swift.String?
}

extension DisassociateWebsiteAuthorizationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

extension DisassociateWebsiteAuthorizationProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWebsiteAuthorizationProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWebsiteCertificateAuthorityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

extension DisassociateWebsiteCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateWebsiteCertificateAuthority"
    }
}

public struct DisassociateWebsiteCertificateAuthorityInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// A unique identifier for the CA.
    /// This member is required.
    public var websiteCaId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        websiteCaId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DisassociateWebsiteCertificateAuthorityInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let websiteCaId: Swift.String?
}

extension DisassociateWebsiteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DisassociateWebsiteCertificateAuthorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateWebsiteCertificateAuthorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkLinkClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case disassociated
        case disassociating
        case failedToAssociate
        case failedToDisassociate
        case inactive
        case pendingValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .associating,
                .disassociated,
                .disassociating,
                .failedToAssociate,
                .failedToDisassociate,
                .inactive,
                .pendingValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failedToAssociate: return "FAILED_TO_ASSOCIATE"
            case .failedToDisassociate: return "FAILED_TO_DISASSOCIATE"
            case .inactive: return "INACTIVE"
            case .pendingValidation: return "PENDING_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the domain.
    public struct DomainSummary: Swift.Equatable {
        /// The time that the domain was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The status of the domain.
        /// This member is required.
        public var domainStatus: WorkLinkClientTypes.DomainStatus?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: WorkLinkClientTypes.DomainStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.domainName = domainName
            self.domainStatus = domainStatus
        }
    }

}

extension WorkLinkClientTypes {
    public enum FleetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case failedToCreate
        case failedToDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .failedToCreate,
                .failedToDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failedToCreate: return "FAILED_TO_CREATE"
            case .failedToDelete: return "FAILED_TO_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetStatus(rawValue: rawValue) ?? FleetStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkLinkClientTypes.FleetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let companyCode = self.companyCode {
            try encodeContainer.encode(companyCode, forKey: .companyCode)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let fleetName = self.fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetStatus = self.fleetStatus {
            try encodeContainer.encode(fleetStatus.rawValue, forKey: .fleetStatus)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkLinkClientTypes {
    /// The summary of the fleet.
    public struct FleetSummary: Swift.Equatable {
        /// The identifier used by users to sign into the Amazon WorkLink app.
        public var companyCode: Swift.String?
        /// The time when the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The name of the fleet to display.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The name of the fleet.
        public var fleetName: Swift.String?
        /// The status of the fleet.
        public var fleetStatus: WorkLinkClientTypes.FleetStatus?
        /// The time when the fleet was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The tags attached to the resource. A tag is a key-value pair.
        public var tags: [Swift.String:Swift.String]?

        public init(
            companyCode: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            fleetArn: Swift.String? = nil,
            fleetName: Swift.String? = nil,
            fleetStatus: WorkLinkClientTypes.FleetStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.companyCode = companyCode
            self.createdTime = createdTime
            self.displayName = displayName
            self.fleetArn = fleetArn
            self.fleetName = fleetName
            self.fleetStatus = fleetStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.tags = tags
        }
    }

}

extension WorkLinkClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDevices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutput: Swift.Equatable {
    /// Information about the devices.
    public var devices: [WorkLinkClientTypes.DeviceSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        devices: [WorkLinkClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputBody: Swift.Equatable {
    let devices: [WorkLinkClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[WorkLinkClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [WorkLinkClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDomains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// Information about the domains.
    public var domains: [WorkLinkClientTypes.DomainSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        domains: [WorkLinkClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let domains: [WorkLinkClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[WorkLinkClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkLinkClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listFleets"
    }
}

public struct ListFleetsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetSummaryList = output.fleetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutput: Swift.Equatable {
    /// The summary list of the fleets.
    public var fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        fleetSummaryList: [WorkLinkClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaryList = fleetSummaryList
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputBody: Swift.Equatable {
    let fleetSummaryList: [WorkLinkClientTypes.FleetSummary]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetSummaryList = "FleetSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummaryListContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.FleetSummary?].self, forKey: .fleetSummaryList)
        var fleetSummaryListDecoded0:[WorkLinkClientTypes.FleetSummary]? = nil
        if let fleetSummaryListContainer = fleetSummaryListContainer {
            fleetSummaryListDecoded0 = [WorkLinkClientTypes.FleetSummary]()
            for structure0 in fleetSummaryListContainer {
                if let structure0 = structure0 {
                    fleetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaryList = fleetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags attached to the resource. A tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWebsiteAuthorizationProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWebsiteAuthorizationProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWebsiteAuthorizationProviders"
    }
}

public struct ListWebsiteAuthorizationProvidersInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteAuthorizationProvidersInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWebsiteAuthorizationProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebsiteAuthorizationProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWebsiteAuthorizationProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteAuthorizationProviders = output.websiteAuthorizationProviders
        } else {
            self.nextToken = nil
            self.websiteAuthorizationProviders = nil
        }
    }
}

public struct ListWebsiteAuthorizationProvidersOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The website authorization providers.
    public var websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?

    public init(
        nextToken: Swift.String? = nil,
        websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteAuthorizationProviders = websiteAuthorizationProviders
    }
}

struct ListWebsiteAuthorizationProvidersOutputBody: Swift.Equatable {
    let websiteAuthorizationProviders: [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]?
    let nextToken: Swift.String?
}

extension ListWebsiteAuthorizationProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteAuthorizationProviders = "WebsiteAuthorizationProviders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteAuthorizationProvidersContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteAuthorizationProviderSummary?].self, forKey: .websiteAuthorizationProviders)
        var websiteAuthorizationProvidersDecoded0:[WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]? = nil
        if let websiteAuthorizationProvidersContainer = websiteAuthorizationProvidersContainer {
            websiteAuthorizationProvidersDecoded0 = [WorkLinkClientTypes.WebsiteAuthorizationProviderSummary]()
            for structure0 in websiteAuthorizationProvidersContainer {
                if let structure0 = structure0 {
                    websiteAuthorizationProvidersDecoded0?.append(structure0)
                }
            }
        }
        websiteAuthorizationProviders = websiteAuthorizationProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWebsiteAuthorizationProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWebsiteCertificateAuthoritiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWebsiteCertificateAuthoritiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWebsiteCertificateAuthorities"
    }
}

public struct ListWebsiteCertificateAuthoritiesInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteCertificateAuthoritiesInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebsiteCertificateAuthoritiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWebsiteCertificateAuthoritiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.websiteCertificateAuthorities = output.websiteCertificateAuthorities
        } else {
            self.nextToken = nil
            self.websiteCertificateAuthorities = nil
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesOutput: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the certificates.
    public var websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteCertificateAuthorities = websiteCertificateAuthorities
    }
}

struct ListWebsiteCertificateAuthoritiesOutputBody: Swift.Equatable {
    let websiteCertificateAuthorities: [WorkLinkClientTypes.WebsiteCaSummary]?
    let nextToken: Swift.String?
}

extension ListWebsiteCertificateAuthoritiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case websiteCertificateAuthorities = "WebsiteCertificateAuthorities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([WorkLinkClientTypes.WebsiteCaSummary?].self, forKey: .websiteCertificateAuthorities)
        var websiteCertificateAuthoritiesDecoded0:[WorkLinkClientTypes.WebsiteCaSummary]? = nil
        if let websiteCertificateAuthoritiesContainer = websiteCertificateAuthoritiesContainer {
            websiteCertificateAuthoritiesDecoded0 = [WorkLinkClientTypes.WebsiteCaSummary]()
            for structure0 in websiteCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    websiteCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        websiteCertificateAuthorities = websiteCertificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWebsiteCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreDomainAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension RestoreDomainAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restoreDomainAccess"
    }
}

public struct RestoreDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RestoreDomainAccessInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension RestoreDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RestoreDomainAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RestoreDomainAccessOutput: Swift.Equatable {

    public init() { }
}

enum RestoreDomainAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RevokeDomainAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension RevokeDomainAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/revokeDomainAccess"
    }
}

public struct RevokeDomainAccessInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RevokeDomainAccessInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
}

extension RevokeDomainAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RevokeDomainAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokeDomainAccessOutput: Swift.Equatable {

    public init() { }
}

enum RevokeDomainAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignOutUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension SignOutUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signOutUser"
    }
}

public struct SignOutUserInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.username = username
    }
}

struct SignOutUserInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let username: Swift.String?
}

extension SignOutUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension SignOutUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SignOutUserOutput: Swift.Equatable {

    public init() { }
}

enum SignOutUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is a key-value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the limit.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to perform this action.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAuditStreamConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditStreamArn = self.auditStreamArn {
            try encodeContainer.encode(auditStreamArn, forKey: .auditStreamArn)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateAuditStreamConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateAuditStreamConfiguration"
    }
}

public struct UpdateAuditStreamConfigurationInput: Swift.Equatable {
    /// The ARN of the Amazon Kinesis data stream that receives the audit events.
    public var auditStreamArn: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        auditStreamArn: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
        self.fleetArn = fleetArn
    }
}

struct UpdateAuditStreamConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let auditStreamArn: Swift.String?
}

extension UpdateAuditStreamConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

extension UpdateAuditStreamConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAuditStreamConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAuditStreamConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCompanyNetworkConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension UpdateCompanyNetworkConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateCompanyNetworkConfiguration"
    }
}

public struct UpdateCompanyNetworkConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The security groups associated with access to the provided subnets.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets used for X-ENI connections from Amazon WorkLink rendering containers.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The VPC with connectivity to associated websites.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        fleetArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateCompanyNetworkConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
}

extension UpdateCompanyNetworkConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateCompanyNetworkConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCompanyNetworkConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCompanyNetworkConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDevicePolicyConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCaCertificate = self.deviceCaCertificate {
            try encodeContainer.encode(deviceCaCertificate, forKey: .deviceCaCertificate)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateDevicePolicyConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDevicePolicyConfiguration"
    }
}

public struct UpdateDevicePolicyConfigurationInput: Swift.Equatable {
    /// The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.
    public var deviceCaCertificate: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        deviceCaCertificate: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
        self.fleetArn = fleetArn
    }
}

struct UpdateDevicePolicyConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let deviceCaCertificate: Swift.String?
}

extension UpdateDevicePolicyConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

extension UpdateDevicePolicyConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDevicePolicyConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDevicePolicyConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

extension UpdateDomainMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDomainMetadata"
    }
}

public struct UpdateDomainMetadataInput: Swift.Equatable {
    /// The name to display.
    public var displayName: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        fleetArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct UpdateDomainMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let domainName: Swift.String?
    let displayName: Swift.String?
}

extension UpdateDomainMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateDomainMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDomainMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDomainMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFleetMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let optimizeForEndUserLocation = self.optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
    }
}

extension UpdateFleetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateFleetMetadata"
    }
}

public struct UpdateFleetMetadataInput: Swift.Equatable {
    /// The fleet name to display. The existing DisplayName is unset if null is passed.
    public var displayName: Swift.String?
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The option to optimize for better performance by routing traffic through the closest AWS Region to users, which may be outside of your home Region.
    public var optimizeForEndUserLocation: Swift.Bool?

    public init(
        displayName: Swift.String? = nil,
        fleetArn: Swift.String? = nil,
        optimizeForEndUserLocation: Swift.Bool? = nil
    )
    {
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
    }
}

struct UpdateFleetMetadataInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let displayName: Swift.String?
    let optimizeForEndUserLocation: Swift.Bool?
}

extension UpdateFleetMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
    }
}

extension UpdateFleetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFleetMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFleetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdentityProviderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let identityProviderSamlMetadata = self.identityProviderSamlMetadata {
            try encodeContainer.encode(identityProviderSamlMetadata, forKey: .identityProviderSamlMetadata)
        }
        if let identityProviderType = self.identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

extension UpdateIdentityProviderConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateIdentityProviderConfiguration"
    }
}

public struct UpdateIdentityProviderConfigurationInput: Swift.Equatable {
    /// The ARN of the fleet.
    /// This member is required.
    public var fleetArn: Swift.String?
    /// The SAML metadata document provided by the customers identity provider. The existing IdentityProviderSamlMetadata is unset if null is passed.
    public var identityProviderSamlMetadata: Swift.String?
    /// The type of identity provider.
    /// This member is required.
    public var identityProviderType: WorkLinkClientTypes.IdentityProviderType?

    public init(
        fleetArn: Swift.String? = nil,
        identityProviderSamlMetadata: Swift.String? = nil,
        identityProviderType: WorkLinkClientTypes.IdentityProviderType? = nil
    )
    {
        self.fleetArn = fleetArn
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderConfigurationInputBody: Swift.Equatable {
    let fleetArn: Swift.String?
    let identityProviderType: WorkLinkClientTypes.IdentityProviderType?
    let identityProviderSamlMetadata: Swift.String?
}

extension UpdateIdentityProviderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

extension UpdateIdentityProviderConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateIdentityProviderConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateIdentityProviderConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkLinkClientTypes.WebsiteAuthorizationProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case authorizationProviderType = "AuthorizationProviderType"
        case createdTime = "CreatedTime"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = self.authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let authorizationProviderType = self.authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(WorkLinkClientTypes.AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the website authorization provider.
    public struct WebsiteAuthorizationProviderSummary: Swift.Equatable {
        /// A unique identifier for the authorization provider.
        public var authorizationProviderId: Swift.String?
        /// The authorization provider type.
        /// This member is required.
        public var authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType?
        /// The time of creation.
        public var createdTime: ClientRuntime.Date?
        /// The domain name of the authorization provider. This applies only to SAML-based authorization providers.
        public var domainName: Swift.String?

        public init(
            authorizationProviderId: Swift.String? = nil,
            authorizationProviderType: WorkLinkClientTypes.AuthorizationProviderType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.authorizationProviderId = authorizationProviderId
            self.authorizationProviderType = authorizationProviderType
            self.createdTime = createdTime
            self.domainName = domainName
        }
    }

}

extension WorkLinkClientTypes.WebsiteCaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let websiteCaId = self.websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WorkLinkClientTypes {
    /// The summary of the certificate authority (CA).
    public struct WebsiteCaSummary: Swift.Equatable {
        /// The time when the CA was added.
        public var createdTime: ClientRuntime.Date?
        /// The name to display.
        public var displayName: Swift.String?
        /// A unique identifier for the CA.
        public var websiteCaId: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            websiteCaId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.displayName = displayName
            self.websiteCaId = websiteCaId
        }
    }

}
