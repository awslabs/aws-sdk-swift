// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaConnectClientTypes.AddBridgeFlowSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case flowVpcInterfaceAttachment = "flowVpcInterfaceAttachment"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowVpcInterfaceAttachment = self.flowVpcInterfaceAttachment {
            try encodeContainer.encode(flowVpcInterfaceAttachment, forKey: .flowVpcInterfaceAttachment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowVpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .flowVpcInterfaceAttachment)
        flowVpcInterfaceAttachment = flowVpcInterfaceAttachmentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// Add a flow source to an existing bridge.
    public struct AddBridgeFlowSourceRequest: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of the cloud flow to use as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
        }
    }

}

extension MediaConnectClientTypes.AddBridgeNetworkOutputRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "ipAddress"
        case name = "name"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
        case ttl = "ttl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Add a network output to an existing bridge.
    public struct AddBridgeNetworkOutputRequest: Swift.Equatable {
        /// The network output IP Address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name. This name is used to reference the output and must be unique among outputs in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }

}

extension MediaConnectClientTypes.AddBridgeNetworkSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastIp = "multicastIp"
        case name = "name"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastIp = self.multicastIp {
            try encodeContainer.encode(multicastIp, forKey: .multicastIp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastIp)
        multicastIp = multicastIpDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension MediaConnectClientTypes {
    /// Add a network source to an existing bridge.
    public struct AddBridgeNetworkSourceRequest: Swift.Equatable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The name of the network source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension MediaConnectClientTypes.AddBridgeOutputRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkOutput = "networkOutput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkOutput = self.networkOutput {
            try encodeContainer.encode(networkOutput, forKey: .networkOutput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkOutputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddBridgeNetworkOutputRequest.self, forKey: .networkOutput)
        networkOutput = networkOutputDecoded
    }
}

extension MediaConnectClientTypes {
    /// Add an output to a bridge.
    public struct AddBridgeOutputRequest: Swift.Equatable {
        /// Add a network output to an existing bridge.
        public var networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest?

        public init(
            networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest? = nil
        )
        {
            self.networkOutput = networkOutput
        }
    }

}

extension AddBridgeOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for addbridgeoutputrequest0 in outputs {
                try outputsContainer.encode(addbridgeoutputrequest0)
            }
        }
    }
}

extension AddBridgeOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs"
    }
}

/// A request to add outputs to the specified bridge.
public struct AddBridgeOutputsInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The outputs that you want to add to this bridge.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

struct AddBridgeOutputsInputBody: Swift.Equatable {
    let outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?
}

extension AddBridgeOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddBridgeOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddBridgeOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddBridgeOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension AddBridgeOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddBridgeOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.outputs = output.outputs
        } else {
            self.bridgeArn = nil
            self.outputs = nil
        }
    }
}

public struct AddBridgeOutputsOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The outputs that you added to this bridge.
    public var outputs: [MediaConnectClientTypes.BridgeOutput]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.BridgeOutput]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

struct AddBridgeOutputsOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let outputs: [MediaConnectClientTypes.BridgeOutput]?
}

extension AddBridgeOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case outputs = "outputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.BridgeOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.BridgeOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.BridgeOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum AddBridgeOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.AddBridgeSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowSource = "flowSource"
        case networkSource = "networkSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowSource = self.flowSource {
            try encodeContainer.encode(flowSource, forKey: .flowSource)
        }
        if let networkSource = self.networkSource {
            try encodeContainer.encode(networkSource, forKey: .networkSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddBridgeFlowSourceRequest.self, forKey: .flowSource)
        flowSource = flowSourceDecoded
        let networkSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddBridgeNetworkSourceRequest.self, forKey: .networkSource)
        networkSource = networkSourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// Add a source to an existing bridge.
    public struct AddBridgeSourceRequest: Swift.Equatable {
        /// Add a flow source to an existing bridge.
        public var flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest?
        /// Add a network source to an existing bridge.
        public var networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest?

        public init(
            flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest? = nil,
            networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest? = nil
        )
        {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }

}

extension AddBridgeSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for addbridgesourcerequest0 in sources {
                try sourcesContainer.encode(addbridgesourcerequest0)
            }
        }
    }
}

extension AddBridgeSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources"
    }
}

/// A request to add sources to the specified bridge.
public struct AddBridgeSourcesInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

struct AddBridgeSourcesInputBody: Swift.Equatable {
    let sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?
}

extension AddBridgeSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddBridgeSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.AddBridgeSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AddBridgeSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddBridgeSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.sources = output.sources
        } else {
            self.bridgeArn = nil
            self.sources = nil
        }
    }
}

public struct AddBridgeSourcesOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The sources that you added to this bridge.
    public var sources: [MediaConnectClientTypes.BridgeSource]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.BridgeSource]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

struct AddBridgeSourcesOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let sources: [MediaConnectClientTypes.BridgeSource]?
}

extension AddBridgeSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case sources = "sources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.BridgeSource?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.BridgeSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.BridgeSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

enum AddBridgeSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.AddEgressGatewayBridgeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBitrate = "maxBitrate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
    }
}

extension MediaConnectClientTypes {
    public struct AddEgressGatewayBridgeRequest: Swift.Equatable {
        /// The maximum expected bitrate (in bps).
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
        }
    }

}

extension AddFlowMediaStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for addmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(addmediastreamrequest0)
            }
        }
    }
}

extension AddFlowMediaStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams"
    }
}

/// A request to add media streams to the flow.
public struct AddFlowMediaStreamsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The media streams that you want to add to the flow.
    /// This member is required.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsInputBody: Swift.Equatable {
    let mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
}

extension AddFlowMediaStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

extension AddFlowMediaStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddFlowMediaStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStreams = output.mediaStreams
        } else {
            self.flowArn = nil
            self.mediaStreams = nil
        }
    }
}

public struct AddFlowMediaStreamsOutput: Swift.Equatable {
    /// The ARN of the flow that you added media streams to.
    public var flowArn: Swift.String?
    /// The media streams that you added to the flow.
    public var mediaStreams: [MediaConnectClientTypes.MediaStream]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStreams: [MediaConnectClientTypes.MediaStream]?
}

extension AddFlowMediaStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

enum AddFlowMediaStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddFlowOutputs420Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddFlowOutputs420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct AddFlowOutputs420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AddFlowOutputs420Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AddFlowOutputs420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AddFlowOutputs420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddFlowOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for addoutputrequest0 in outputs {
                try outputsContainer.encode(addoutputrequest0)
            }
        }
    }
}

extension AddFlowOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs"
    }
}

/// A request to add outputs to the specified flow.
public struct AddFlowOutputsInput: Swift.Equatable {
    /// The flow that you want to add outputs to.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of outputs that you want to add.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsInputBody: Swift.Equatable {
    let outputs: [MediaConnectClientTypes.AddOutputRequest]?
}

extension AddFlowOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension AddFlowOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddFlowOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.outputs = output.outputs
        } else {
            self.flowArn = nil
            self.outputs = nil
        }
    }
}

public struct AddFlowOutputsOutput: Swift.Equatable {
    /// The ARN of the flow that these outputs were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added outputs.
    public var outputs: [MediaConnectClientTypes.Output]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.Output]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let outputs: [MediaConnectClientTypes.Output]?
}

extension AddFlowOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case outputs = "outputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum AddFlowOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AddFlowOutputs420Exception": return try await AddFlowOutputs420Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddFlowSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for setsourcerequest0 in sources {
                try sourcesContainer.encode(setsourcerequest0)
            }
        }
    }
}

extension AddFlowSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source"
    }
}

/// A request to add sources to the flow.
public struct AddFlowSourcesInput: Swift.Equatable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of sources that you want to add.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesInputBody: Swift.Equatable {
    let sources: [MediaConnectClientTypes.SetSourceRequest]?
}

extension AddFlowSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AddFlowSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddFlowSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.sources = output.sources
        } else {
            self.flowArn = nil
            self.sources = nil
        }
    }
}

public struct AddFlowSourcesOutput: Swift.Equatable {
    /// The ARN of the flow that these sources were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added sources.
    public var sources: [MediaConnectClientTypes.Source]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.Source]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let sources: [MediaConnectClientTypes.Source]?
}

extension AddFlowSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case sources = "sources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

enum AddFlowSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddFlowVpcInterfacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for vpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(vpcinterfacerequest0)
            }
        }
    }
}

extension AddFlowVpcInterfacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces"
    }
}

/// A request to add VPC interfaces to the flow.
public struct AddFlowVpcInterfacesInput: Swift.Equatable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of VPC interfaces that you want to add.
    /// This member is required.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesInputBody: Swift.Equatable {
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?
}

extension AddFlowVpcInterfacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension AddFlowVpcInterfacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddFlowVpcInterfacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.vpcInterfaces = output.vpcInterfaces
        } else {
            self.flowArn = nil
            self.vpcInterfaces = nil
        }
    }
}

public struct AddFlowVpcInterfacesOutput: Swift.Equatable {
    /// The ARN of the flow that these VPC interfaces were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added VPC interfaces.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?
}

extension AddFlowVpcInterfacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

enum AddFlowVpcInterfacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.AddIngressGatewayBridgeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBitrate = "maxBitrate"
        case maxOutputs = "maxOutputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxOutputs = self.maxOutputs {
            try encodeContainer.encode(maxOutputs, forKey: .maxOutputs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxOutputsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxOutputs)
        maxOutputs = maxOutputsDecoded
    }
}

extension MediaConnectClientTypes {
    public struct AddIngressGatewayBridgeRequest: Swift.Equatable {
        /// The maximum expected bitrate (in bps).
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }

}

extension MediaConnectClientTypes.AddMaintenance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenanceDay = "maintenanceDay"
        case maintenanceStartHour = "maintenanceStartHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maintenanceDay = self.maintenanceDay {
            try encodeContainer.encode(maintenanceDay.rawValue, forKey: .maintenanceDay)
        }
        if let maintenanceStartHour = self.maintenanceStartHour {
            try encodeContainer.encode(maintenanceStartHour, forKey: .maintenanceStartHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceDayDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MaintenanceDay.self, forKey: .maintenanceDay)
        maintenanceDay = maintenanceDayDecoded
        let maintenanceStartHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceStartHour)
        maintenanceStartHour = maintenanceStartHourDecoded
    }
}

extension MediaConnectClientTypes {
    /// Create maintenance setting for a flow
    public struct AddMaintenance: Swift.Equatable {
        /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        /// This member is required.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        /// This member is required.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceStartHour = maintenanceStartHour
        }
    }

}

extension MediaConnectClientTypes.AddMediaStreamRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = self.clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaStreamId = self.mediaStreamId {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = self.mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = self.videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that you want to add to the flow.
    public struct AddMediaStreamRequest: Swift.Equatable {
        /// The attributes that you want to assign to the new media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
        /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }

}

extension MediaConnectClientTypes.AddOutputRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case senderControlPort = "senderControlPort"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__string0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let maxLatency = self.maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for mediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(mediastreamoutputconfigurationrequest0)
            }
        }
        if let minLatency = self.minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = self.remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let smoothingLatency = self.smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The output that you want to add to this flow.
    public struct AddOutputRequest: Swift.Equatable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The media streams that are associated with the output, and the parameters for those associations.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the output. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// The protocol to use for the output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull output stream.
        public var remoteId: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            maxLatency: Swift.Int? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            smoothingLatency: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.maxLatency = maxLatency
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.minLatency = minLatency
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.senderControlPort = senderControlPort
            self.smoothingLatency = smoothingLatency
            self.streamId = streamId
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes {
    public enum Algorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case sdkUnknown(Swift.String)

        public static var allCases: [Algorithm] {
            return [
                .aes128,
                .aes192,
                .aes256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "aes128"
            case .aes192: return "aes192"
            case .aes256: return "aes256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Algorithm(rawValue: rawValue) ?? Algorithm.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Bridge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case bridgeMessages = "bridgeMessages"
        case bridgeState = "bridgeState"
        case egressGatewayBridge = "egressGatewayBridge"
        case ingressGatewayBridge = "ingressGatewayBridge"
        case name = "name"
        case outputs = "outputs"
        case placementArn = "placementArn"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let bridgeMessages = bridgeMessages {
            var bridgeMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bridgeMessages)
            for messagedetail0 in bridgeMessages {
                try bridgeMessagesContainer.encode(messagedetail0)
            }
        }
        if let bridgeState = self.bridgeState {
            try encodeContainer.encode(bridgeState.rawValue, forKey: .bridgeState)
        }
        if let egressGatewayBridge = self.egressGatewayBridge {
            try encodeContainer.encode(egressGatewayBridge, forKey: .egressGatewayBridge)
        }
        if let ingressGatewayBridge = self.ingressGatewayBridge {
            try encodeContainer.encode(ingressGatewayBridge, forKey: .ingressGatewayBridge)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for bridgeoutput0 in outputs {
                try outputsContainer.encode(bridgeoutput0)
            }
        }
        if let placementArn = self.placementArn {
            try encodeContainer.encode(placementArn, forKey: .placementArn)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for bridgesource0 in sources {
                try sourcesContainer.encode(bridgesource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let bridgeMessagesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MessageDetail?].self, forKey: .bridgeMessages)
        var bridgeMessagesDecoded0:[MediaConnectClientTypes.MessageDetail]? = nil
        if let bridgeMessagesContainer = bridgeMessagesContainer {
            bridgeMessagesDecoded0 = [MediaConnectClientTypes.MessageDetail]()
            for structure0 in bridgeMessagesContainer {
                if let structure0 = structure0 {
                    bridgeMessagesDecoded0?.append(structure0)
                }
            }
        }
        bridgeMessages = bridgeMessagesDecoded0
        let bridgeStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeState.self, forKey: .bridgeState)
        bridgeState = bridgeStateDecoded
        let egressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EgressGatewayBridge.self, forKey: .egressGatewayBridge)
        egressGatewayBridge = egressGatewayBridgeDecoded
        let ingressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.IngressGatewayBridge.self, forKey: .ingressGatewayBridge)
        ingressGatewayBridge = ingressGatewayBridgeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.BridgeOutput?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.BridgeOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.BridgeOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let placementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementArn)
        placementArn = placementArnDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.BridgeSource?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.BridgeSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.BridgeSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension MediaConnectClientTypes {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public struct Bridge: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        public var bridgeMessages: [MediaConnectClientTypes.MessageDetail]?
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        public var egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge?
        public var ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs on this bridge.
        public var outputs: [MediaConnectClientTypes.BridgeOutput]?
        /// The placement Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var placementArn: Swift.String?
        /// The settings for source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        /// The sources on this bridge.
        public var sources: [MediaConnectClientTypes.BridgeSource]?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge? = nil,
            ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.BridgeOutput]? = nil,
            placementArn: Swift.String? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sources: [MediaConnectClientTypes.BridgeSource]? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgeMessages = bridgeMessages
            self.bridgeState = bridgeState
            self.egressGatewayBridge = egressGatewayBridge
            self.ingressGatewayBridge = ingressGatewayBridge
            self.name = name
            self.outputs = outputs
            self.placementArn = placementArn
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sources = sources
        }
    }

}

extension MediaConnectClientTypes.BridgeFlowOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case flowSourceArn = "flowSourceArn"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowSourceArn = self.flowSourceArn {
            try encodeContainer.encode(flowSourceArn, forKey: .flowSourceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowSourceArn)
        flowSourceArn = flowSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The output of the bridge. A flow output is delivered to the AWS cloud.
    public struct BridgeFlowOutput: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of the cloud flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The Amazon Resource Number (ARN) of the flow source.
        /// This member is required.
        public var flowSourceArn: Swift.String?
        /// The name of the bridge's output.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowSourceArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowSourceArn = flowSourceArn
            self.name = name
        }
    }

}

extension MediaConnectClientTypes.BridgeFlowSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case flowVpcInterfaceAttachment = "flowVpcInterfaceAttachment"
        case name = "name"
        case outputArn = "outputArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowVpcInterfaceAttachment = self.flowVpcInterfaceAttachment {
            try encodeContainer.encode(flowVpcInterfaceAttachment, forKey: .flowVpcInterfaceAttachment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputArn = self.outputArn {
            try encodeContainer.encode(outputArn, forKey: .outputArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowVpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .flowVpcInterfaceAttachment)
        flowVpcInterfaceAttachment = flowVpcInterfaceAttachmentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
    }
}

extension MediaConnectClientTypes {
    /// The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
    public struct BridgeFlowSource: Swift.Equatable {
        /// The ARN of the cloud flow used as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Number (ARN) of the output.
        public var outputArn: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
            self.outputArn = outputArn
        }
    }

}

extension MediaConnectClientTypes.BridgeNetworkOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "ipAddress"
        case name = "name"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
        case ttl = "ttl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension MediaConnectClientTypes {
    /// The output of the bridge. A network output is delivered to your premises.
    public struct BridgeNetworkOutput: Swift.Equatable {
        /// The network output IP Address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }

}

extension MediaConnectClientTypes.BridgeNetworkSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastIp = "multicastIp"
        case name = "name"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastIp = self.multicastIp {
            try encodeContainer.encode(multicastIp, forKey: .multicastIp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastIp)
        multicastIp = multicastIpDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension MediaConnectClientTypes {
    /// The source of the bridge. A network source originates at your premises.
    public struct BridgeNetworkSource: Swift.Equatable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The name of the network source.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension MediaConnectClientTypes.BridgeOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowOutput = "flowOutput"
        case networkOutput = "networkOutput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowOutput = self.flowOutput {
            try encodeContainer.encode(flowOutput, forKey: .flowOutput)
        }
        if let networkOutput = self.networkOutput {
            try encodeContainer.encode(networkOutput, forKey: .networkOutput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowOutputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeFlowOutput.self, forKey: .flowOutput)
        flowOutput = flowOutputDecoded
        let networkOutputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeNetworkOutput.self, forKey: .networkOutput)
        networkOutput = networkOutputDecoded
    }
}

extension MediaConnectClientTypes {
    /// The output of the bridge.
    public struct BridgeOutput: Swift.Equatable {
        /// The output of the bridge. A flow output is delivered to the AWS cloud.
        public var flowOutput: MediaConnectClientTypes.BridgeFlowOutput?
        /// The output of the bridge. A network output is delivered to your premises.
        public var networkOutput: MediaConnectClientTypes.BridgeNetworkOutput?

        public init(
            flowOutput: MediaConnectClientTypes.BridgeFlowOutput? = nil,
            networkOutput: MediaConnectClientTypes.BridgeNetworkOutput? = nil
        )
        {
            self.flowOutput = flowOutput
            self.networkOutput = networkOutput
        }
    }

}

extension MediaConnectClientTypes {
    public enum BridgePlacement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case locked
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgePlacement] {
            return [
                .available,
                .locked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .locked: return "LOCKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BridgePlacement(rawValue: rawValue) ?? BridgePlacement.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.BridgeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowSource = "flowSource"
        case networkSource = "networkSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowSource = self.flowSource {
            try encodeContainer.encode(flowSource, forKey: .flowSource)
        }
        if let networkSource = self.networkSource {
            try encodeContainer.encode(networkSource, forKey: .networkSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeFlowSource.self, forKey: .flowSource)
        flowSource = flowSourceDecoded
        let networkSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeNetworkSource.self, forKey: .networkSource)
        networkSource = networkSourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The bridge's source.
    public struct BridgeSource: Swift.Equatable {
        /// The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        public var flowSource: MediaConnectClientTypes.BridgeFlowSource?
        /// The source of the bridge. A network source originates at your premises.
        public var networkSource: MediaConnectClientTypes.BridgeNetworkSource?

        public init(
            flowSource: MediaConnectClientTypes.BridgeFlowSource? = nil,
            networkSource: MediaConnectClientTypes.BridgeNetworkSource? = nil
        )
        {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }

}

extension MediaConnectClientTypes {
    public enum BridgeState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case deploying
        case standby
        case starting
        case startFailed
        case startPending
        case stopping
        case stopFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgeState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .deploying,
                .standby,
                .starting,
                .startFailed,
                .startPending,
                .stopping,
                .stopFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deploying: return "DEPLOYING"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .startPending: return "START_PENDING"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BridgeState(rawValue: rawValue) ?? BridgeState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum Colorimetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bt2020
        case bt2100
        case bt601
        case bt709
        case st20651
        case st20653
        case xyz
        case sdkUnknown(Swift.String)

        public static var allCases: [Colorimetry] {
            return [
                .bt2020,
                .bt2100,
                .bt601,
                .bt709,
                .st20651,
                .st20653,
                .xyz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bt2020: return "BT2020"
            case .bt2100: return "BT2100"
            case .bt601: return "BT601"
            case .bt709: return "BT709"
            case .st20651: return "ST2065-1"
            case .st20653: return "ST2065-3"
            case .xyz: return "XYZ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Colorimetry(rawValue: rawValue) ?? Colorimetry.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateBridge420Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBridge420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateBridge420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateBridge420Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateBridge420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateBridge420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBridgeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressGatewayBridge = "egressGatewayBridge"
        case ingressGatewayBridge = "ingressGatewayBridge"
        case name = "name"
        case outputs = "outputs"
        case placementArn = "placementArn"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressGatewayBridge = self.egressGatewayBridge {
            try encodeContainer.encode(egressGatewayBridge, forKey: .egressGatewayBridge)
        }
        if let ingressGatewayBridge = self.ingressGatewayBridge {
            try encodeContainer.encode(ingressGatewayBridge, forKey: .ingressGatewayBridge)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for addbridgeoutputrequest0 in outputs {
                try outputsContainer.encode(addbridgeoutputrequest0)
            }
        }
        if let placementArn = self.placementArn {
            try encodeContainer.encode(placementArn, forKey: .placementArn)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for addbridgesourcerequest0 in sources {
                try sourcesContainer.encode(addbridgesourcerequest0)
            }
        }
    }
}

extension CreateBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/bridges"
    }
}

/// Creates a new bridge. The request must include one source.
public struct CreateBridgeInput: Swift.Equatable {
    /// Create a bridge with the egress bridge type. An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public var egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?
    /// Create a bridge with the ingress bridge type. An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public var ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?
    /// The name of the bridge. This name can not be modified after the bridge is created.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this bridge.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?
    /// The bridge placement Amazon Resource Number (ARN).
    /// This member is required.
    public var placementArn: Swift.String?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil,
        placementArn: Swift.String? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    )
    {
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.name = name
        self.outputs = outputs
        self.placementArn = placementArn
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
    }
}

struct CreateBridgeInputBody: Swift.Equatable {
    let egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?
    let ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?
    let name: Swift.String?
    let outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?
    let placementArn: Swift.String?
    let sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    let sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?
}

extension CreateBridgeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressGatewayBridge = "egressGatewayBridge"
        case ingressGatewayBridge = "ingressGatewayBridge"
        case name = "name"
        case outputs = "outputs"
        case placementArn = "placementArn"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddEgressGatewayBridgeRequest.self, forKey: .egressGatewayBridge)
        egressGatewayBridge = egressGatewayBridgeDecoded
        let ingressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddIngressGatewayBridgeRequest.self, forKey: .ingressGatewayBridge)
        ingressGatewayBridge = ingressGatewayBridgeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddBridgeOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddBridgeOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddBridgeOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let placementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementArn)
        placementArn = placementArnDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddBridgeSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.AddBridgeSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension CreateBridgeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBridgeOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridge = output.bridge
        } else {
            self.bridge = nil
        }
    }
}

public struct CreateBridgeOutput: Swift.Equatable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

struct CreateBridgeOutputBody: Swift.Equatable {
    let bridge: MediaConnectClientTypes.Bridge?
}

extension CreateBridgeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridge = "bridge"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Bridge.self, forKey: .bridge)
        bridge = bridgeDecoded
    }
}

enum CreateBridgeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateBridge420Exception": return try await CreateBridge420Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFlow420Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFlow420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateFlow420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateFlow420Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateFlow420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateFlow420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case maintenance = "maintenance"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for grantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(grantentitlementrequest0)
            }
        }
        if let maintenance = self.maintenance {
            try encodeContainer.encode(maintenance, forKey: .maintenance)
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for addmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(addmediastreamrequest0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for addoutputrequest0 in outputs {
                try outputsContainer.encode(addoutputrequest0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for setsourcerequest0 in sources {
                try sourcesContainer.encode(setsourcerequest0)
            }
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for vpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(vpcinterfacerequest0)
            }
        }
    }
}

extension CreateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/flows"
    }
}

/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
public struct CreateFlowInput: Swift.Equatable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
    public var availabilityZone: Swift.String?
    /// The entitlements that you want to grant on a flow.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// Create maintenance setting for a flow
    public var maintenance: MediaConnectClientTypes.AddMaintenance?
    /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this flow.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.SetSourceRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?
    /// The VPC interfaces you want on the flow.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        availabilityZone: Swift.String? = nil,
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        maintenance: MediaConnectClientTypes.AddMaintenance? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil,
        source: MediaConnectClientTypes.SetSourceRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.entitlements = entitlements
        self.maintenance = maintenance
        self.mediaStreams = mediaStreams
        self.name = name
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
        self.vpcInterfaces = vpcInterfaces
    }
}

struct CreateFlowInputBody: Swift.Equatable {
    let availabilityZone: Swift.String?
    let entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    let mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    let name: Swift.String?
    let outputs: [MediaConnectClientTypes.AddOutputRequest]?
    let source: MediaConnectClientTypes.SetSourceRequest?
    let sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    let sources: [MediaConnectClientTypes.SetSourceRequest]?
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?
    let maintenance: MediaConnectClientTypes.AddMaintenance?
}

extension CreateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case maintenance = "maintenance"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SetSourceRequest.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
        let maintenanceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.AddMaintenance.self, forKey: .maintenance)
        maintenance = maintenanceDecoded
    }
}

extension CreateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct CreateFlowOutput: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct CreateFlowOutputBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
}

extension CreateFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

enum CreateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateFlow420Exception": return try await CreateFlow420Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGateway420Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGateway420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateGateway420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateGateway420Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreateGateway420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateGateway420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressCidrBlocks = "egressCidrBlocks"
        case name = "name"
        case networks = "networks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressCidrBlocks = egressCidrBlocks {
            var egressCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .egressCidrBlocks)
            for __string0 in egressCidrBlocks {
                try egressCidrBlocksContainer.encode(__string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networks = networks {
            var networksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networks)
            for gatewaynetwork0 in networks {
                try networksContainer.encode(gatewaynetwork0)
            }
        }
    }
}

extension CreateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/gateways"
    }
}

/// Creates a new gateway. The request must include at least one network (up to 4).
public struct CreateGatewayInput: Swift.Equatable {
    /// The range of IP addresses that are allowed to contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    /// This member is required.
    public var egressCidrBlocks: [Swift.String]?
    /// The name of the gateway. This name can not be modified after the gateway is created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of networks that you want to add.
    /// This member is required.
    public var networks: [MediaConnectClientTypes.GatewayNetwork]?

    public init(
        egressCidrBlocks: [Swift.String]? = nil,
        name: Swift.String? = nil,
        networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
    )
    {
        self.egressCidrBlocks = egressCidrBlocks
        self.name = name
        self.networks = networks
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    let egressCidrBlocks: [Swift.String]?
    let name: Swift.String?
    let networks: [MediaConnectClientTypes.GatewayNetwork]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressCidrBlocks = "egressCidrBlocks"
        case name = "name"
        case networks = "networks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .egressCidrBlocks)
        var egressCidrBlocksDecoded0:[Swift.String]? = nil
        if let egressCidrBlocksContainer = egressCidrBlocksContainer {
            egressCidrBlocksDecoded0 = [Swift.String]()
            for string0 in egressCidrBlocksContainer {
                if let string0 = string0 {
                    egressCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        egressCidrBlocks = egressCidrBlocksDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networksContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GatewayNetwork?].self, forKey: .networks)
        var networksDecoded0:[MediaConnectClientTypes.GatewayNetwork]? = nil
        if let networksContainer = networksContainer {
            networksDecoded0 = [MediaConnectClientTypes.GatewayNetwork]()
            for structure0 in networksContainer {
                if let structure0 = structure0 {
                    networksDecoded0?.append(structure0)
                }
            }
        }
        networks = networksDecoded0
    }
}

extension CreateGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct CreateGatewayOutput: Swift.Equatable {
    /// The settings for a gateway, including its networks.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

struct CreateGatewayOutputBody: Swift.Equatable {
    let gateway: MediaConnectClientTypes.Gateway?
}

extension CreateGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "gateway"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Gateway.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

enum CreateGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreateGateway420Exception": return try await CreateGateway420Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

public struct DeleteBridgeInput: Swift.Equatable {
    /// The ARN of the bridge that you want to delete.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

struct DeleteBridgeInputBody: Swift.Equatable {
}

extension DeleteBridgeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBridgeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBridgeOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
        } else {
            self.bridgeArn = nil
        }
    }
}

public struct DeleteBridgeOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the deleted bridge.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

struct DeleteBridgeOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
}

extension DeleteBridgeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
    }
}

enum DeleteBridgeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

public struct DeleteFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to delete.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DeleteFlowInputBody: Swift.Equatable {
}

extension DeleteFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct DeleteFlowOutput: Swift.Equatable {
    /// The ARN of the flow that was deleted.
    public var flowArn: Swift.String?
    /// The status of the flow when the DeleteFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct DeleteFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension DeleteFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayArn = gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The ARN of the gateway that you want to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
}

extension DeleteGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
        } else {
            self.gatewayArn = nil
        }
    }
}

public struct DeleteGatewayOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway that was deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DeleteGatewayOutputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension DeleteGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "gatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum DeleteGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterGatewayInstanceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeregisterGatewayInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayInstanceArn = gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

public struct DeregisterGatewayInstanceInput: Swift.Equatable {
    /// Force the deregistration of an instance. Force will deregister an instance, even if there are bridges running on it.
    public var force: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway that contains the instance that you want to deregister.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.force = force
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

struct DeregisterGatewayInstanceInputBody: Swift.Equatable {
}

extension DeregisterGatewayInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterGatewayInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeregisterGatewayInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayInstanceArn = output.gatewayInstanceArn
            self.instanceState = output.instanceState
        } else {
            self.gatewayInstanceArn = nil
            self.instanceState = nil
        }
    }
}

public struct DeregisterGatewayInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance.
    public var gatewayInstanceArn: Swift.String?
    /// The status of the instance.
    public var instanceState: MediaConnectClientTypes.InstanceState?

    public init(
        gatewayInstanceArn: Swift.String? = nil,
        instanceState: MediaConnectClientTypes.InstanceState? = nil
    )
    {
        self.gatewayInstanceArn = gatewayInstanceArn
        self.instanceState = instanceState
    }
}

struct DeregisterGatewayInstanceOutputBody: Swift.Equatable {
    let gatewayInstanceArn: Swift.String?
    let instanceState: MediaConnectClientTypes.InstanceState?
}

extension DeregisterGatewayInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayInstanceArn = "gatewayInstanceArn"
        case instanceState = "instanceState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayInstanceArn)
        gatewayInstanceArn = gatewayInstanceArnDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InstanceState.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
    }
}

enum DeregisterGatewayInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

public struct DescribeBridgeInput: Swift.Equatable {
    /// The ARN of the bridge that you want to describe.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

struct DescribeBridgeInputBody: Swift.Equatable {
}

extension DescribeBridgeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBridgeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBridgeOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridge = output.bridge
        } else {
            self.bridge = nil
        }
    }
}

public struct DescribeBridgeOutput: Swift.Equatable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

struct DescribeBridgeOutputBody: Swift.Equatable {
    let bridge: MediaConnectClientTypes.Bridge?
}

extension DescribeBridgeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridge = "bridge"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Bridge.self, forKey: .bridge)
        bridge = bridgeDecoded
    }
}

enum DescribeBridgeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

public struct DescribeFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to describe.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DescribeFlowInputBody: Swift.Equatable {
}

extension DescribeFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
            self.messages = output.messages
        } else {
            self.flow = nil
            self.messages = nil
        }
    }
}

public struct DescribeFlowOutput: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?
    /// Messages that provide the state of the flow.
    public var messages: MediaConnectClientTypes.Messages?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil,
        messages: MediaConnectClientTypes.Messages? = nil
    )
    {
        self.flow = flow
        self.messages = messages
    }
}

struct DescribeFlowOutputBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
    let messages: MediaConnectClientTypes.Messages?
}

extension DescribeFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
        case messages = "messages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
        let messagesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Messages.self, forKey: .messages)
        messages = messagesDecoded
    }
}

enum DescribeFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayArn = gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

public struct DescribeGatewayInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway that you want to describe.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct DescribeGatewayInputBody: Swift.Equatable {
}

extension DescribeGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayInstanceArn = gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

public struct DescribeGatewayInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the gateway instance that you want to describe.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

struct DescribeGatewayInstanceInputBody: Swift.Equatable {
}

extension DescribeGatewayInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGatewayInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayInstance = output.gatewayInstance
        } else {
            self.gatewayInstance = nil
        }
    }
}

public struct DescribeGatewayInstanceOutput: Swift.Equatable {
    /// The settings for an instance in a gateway.
    public var gatewayInstance: MediaConnectClientTypes.GatewayInstance?

    public init(
        gatewayInstance: MediaConnectClientTypes.GatewayInstance? = nil
    )
    {
        self.gatewayInstance = gatewayInstance
    }
}

struct DescribeGatewayInstanceOutputBody: Swift.Equatable {
    let gatewayInstance: MediaConnectClientTypes.GatewayInstance?
}

extension DescribeGatewayInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayInstance = "gatewayInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayInstanceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.GatewayInstance.self, forKey: .gatewayInstance)
        gatewayInstance = gatewayInstanceDecoded
    }
}

enum DescribeGatewayInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct DescribeGatewayOutput: Swift.Equatable {
    /// The settings for a gateway, including its networks.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

struct DescribeGatewayOutputBody: Swift.Equatable {
    let gateway: MediaConnectClientTypes.Gateway?
}

extension DescribeGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "gateway"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Gateway.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

enum DescribeGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let offeringArn = offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

public struct DescribeOfferingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?

    public init(
        offeringArn: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
    }
}

struct DescribeOfferingInputBody: Swift.Equatable {
}

extension DescribeOfferingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOfferingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOfferingOutputBody = try responseDecoder.decode(responseBody: data)
            self.offering = output.offering
        } else {
            self.offering = nil
        }
    }
}

public struct DescribeOfferingOutput: Swift.Equatable {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public var offering: MediaConnectClientTypes.Offering?

    public init(
        offering: MediaConnectClientTypes.Offering? = nil
    )
    {
        self.offering = offering
    }
}

struct DescribeOfferingOutputBody: Swift.Equatable {
    let offering: MediaConnectClientTypes.Offering?
}

extension DescribeOfferingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offering = "offering"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Offering.self, forKey: .offering)
        offering = offeringDecoded
    }
}

enum DescribeOfferingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reservationArn = reservationArn else {
            return nil
        }
        return "/v1/reservations/\(reservationArn.urlPercentEncoding())"
    }
}

public struct DescribeReservationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the reservation.
    /// This member is required.
    public var reservationArn: Swift.String?

    public init(
        reservationArn: Swift.String? = nil
    )
    {
        self.reservationArn = reservationArn
    }
}

struct DescribeReservationInputBody: Swift.Equatable {
}

extension DescribeReservationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReservationOutputBody = try responseDecoder.decode(responseBody: data)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct DescribeReservationOutput: Swift.Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct DescribeReservationOutputBody: Swift.Equatable {
    let reservation: MediaConnectClientTypes.Reservation?
}

extension DescribeReservationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservation = "reservation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

enum DescribeReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes {
    public enum DesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .active,
                .deleted,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DesiredState(rawValue: rawValue) ?? DesiredState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
        case outboundIp = "outboundIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = self.destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = self.interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
        if let outboundIp = self.outboundIp {
            try encodeContainer.encode(outboundIp, forKey: .outboundIp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Interface.self, forKey: .interface)
        interface = interfaceDecoded
        let outboundIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundIp)
        outboundIp = outboundIpDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that are associated with an outbound media stream.
    public struct DestinationConfiguration: Swift.Equatable {
        /// The IP address where contents of the media stream will be sent.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port to use when the content of the media stream is distributed to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that is used for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?
        /// The IP address that the receiver requires in order to establish a connection with the flow. This value is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the CDI or ST 2110 JPEG XS protocol.
        /// This member is required.
        public var outboundIp: Swift.String?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil,
            outboundIp: Swift.String? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
            self.outboundIp = outboundIp
        }
    }

}

extension MediaConnectClientTypes.DestinationConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = self.destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = self.interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that you want to associate with an outbound media stream.
    public struct DestinationConfigurationRequest: Swift.Equatable {
        /// The IP address where you want MediaConnect to send contents of the media stream.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port that you want MediaConnect to use when it distributes the media stream to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that you want to use for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes {
    public enum DurationUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnits] {
            return [
                .months,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .months: return "MONTHS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DurationUnits(rawValue: rawValue) ?? DurationUnits.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.EgressGatewayBridge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "instanceId"
        case maxBitrate = "maxBitrate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
    }
}

extension MediaConnectClientTypes {
    public struct EgressGatewayBridge: Swift.Equatable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the egress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
        }
    }

}

extension MediaConnectClientTypes {
    public enum EncoderProfile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case main
        case sdkUnknown(Swift.String)

        public static var allCases: [EncoderProfile] {
            return [
                .high,
                .main,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .main: return "main"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncoderProfile(rawValue: rawValue) ?? EncoderProfile.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum EncodingName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jxsv
        case pcm
        case raw
        case smpte291
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingName] {
            return [
                .jxsv,
                .pcm,
                .raw,
                .smpte291,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jxsv: return "jxsv"
            case .pcm: return "pcm"
            case .raw: return "raw"
            case .smpte291: return "smpte291"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingName(rawValue: rawValue) ?? EncodingName.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.EncodingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFactor = self.compressionFactor {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = self.encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension MediaConnectClientTypes {
    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParameters: Swift.Equatable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }

}

extension MediaConnectClientTypes.EncodingParametersRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFactor = self.compressionFactor {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = self.encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension MediaConnectClientTypes {
    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParametersRequest: Swift.Equatable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, if at least one source on the flow uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }

}

extension MediaConnectClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = self.algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Information about the encryption of the flow.
    public struct Encryption: Swift.Equatable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }

}

extension MediaConnectClientTypes.Entitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = self.dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementStatus = self.entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __string0 in subscribers {
                try subscribersContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The settings for a flow entitlement.
    public struct Entitlement: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// An indication of whether the entitlement is enabled.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }

}

extension MediaConnectClientTypes {
    public enum EntitlementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementStatus(rawValue: rawValue) ?? EntitlementStatus.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.FailoverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverMode = "failoverMode"
        case recoveryWindow = "recoveryWindow"
        case sourcePriority = "sourcePriority"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverMode = self.failoverMode {
            try encodeContainer.encode(failoverMode.rawValue, forKey: .failoverMode)
        }
        if let recoveryWindow = self.recoveryWindow {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let sourcePriority = self.sourcePriority {
            try encodeContainer.encode(sourcePriority, forKey: .sourcePriority)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverMode.self, forKey: .failoverMode)
        failoverMode = failoverModeDecoded
        let recoveryWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let sourcePriorityDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourcePriority.self, forKey: .sourcePriority)
        sourcePriority = sourcePriorityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for source failover.
    public struct FailoverConfig: Swift.Equatable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Search window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }

}

extension MediaConnectClientTypes {
    public enum FailoverMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failover
        case merge
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverMode] {
            return [
                .failover,
                .merge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .merge: return "MERGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailoverMode(rawValue: rawValue) ?? FailoverMode.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.Flow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case egressIp = "egressIp"
        case entitlements = "entitlements"
        case flowArn = "flowArn"
        case maintenance = "maintenance"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case status = "status"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressIp = self.egressIp {
            try encodeContainer.encode(egressIp, forKey: .egressIp)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlement0 in entitlements {
                try entitlementsContainer.encode(entitlement0)
            }
        }
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let maintenance = self.maintenance {
            try encodeContainer.encode(maintenance, forKey: .maintenance)
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for mediastream0 in mediaStreams {
                try mediaStreamsContainer.encode(mediastream0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for source0 in sources {
                try sourcesContainer.encode(source0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for vpcinterface0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(vpcinterface0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressIp)
        egressIp = egressIpDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
        let maintenanceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Maintenance.self, forKey: .maintenance)
        maintenance = maintenanceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public struct Flow: Swift.Equatable {
        /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var egressIp: Swift.String?
        /// The entitlements in this flow.
        /// This member is required.
        public var entitlements: [MediaConnectClientTypes.Entitlement]?
        /// The Amazon Resource Name (ARN) of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The maintenance setting of a flow
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The media streams that are associated with the flow. After you associate a media stream with a source, you can also associate it with outputs on the flow.
        public var mediaStreams: [MediaConnectClientTypes.MediaStream]?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs in this flow.
        /// This member is required.
        public var outputs: [MediaConnectClientTypes.Output]?
        /// The settings for the source of the flow.
        /// This member is required.
        public var source: MediaConnectClientTypes.Source?
        /// The settings for source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        public var sources: [MediaConnectClientTypes.Source]?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?
        /// The VPC Interfaces for this flow.
        public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            egressIp: Swift.String? = nil,
            entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
            flowArn: Swift.String? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.Output]? = nil,
            source: MediaConnectClientTypes.Source? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sources: [MediaConnectClientTypes.Source]? = nil,
            status: MediaConnectClientTypes.Status? = nil,
            vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.egressIp = egressIp
            self.entitlements = entitlements
            self.flowArn = flowArn
            self.maintenance = maintenance
            self.mediaStreams = mediaStreams
            self.name = name
            self.outputs = outputs
            self.source = source
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sources = sources
            self.status = status
            self.vpcInterfaces = vpcInterfaces
        }
    }

}

extension MediaConnectClientTypes.Fmtp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = self.channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = self.colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = self.exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = self.par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = self.range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = self.scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = self.tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension MediaConnectClientTypes {
    /// FMTP
    public struct Fmtp: Swift.Equatable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the videos appearance
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }

}

extension MediaConnectClientTypes.FmtpRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = self.channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = self.colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = self.exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = self.par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = self.range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = self.scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = self.tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings that you want to use to define the media stream.
    public struct FmtpRequest: Swift.Equatable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the videos appearance.
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Gateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressCidrBlocks = "egressCidrBlocks"
        case gatewayArn = "gatewayArn"
        case gatewayMessages = "gatewayMessages"
        case gatewayState = "gatewayState"
        case name = "name"
        case networks = "networks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressCidrBlocks = egressCidrBlocks {
            var egressCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .egressCidrBlocks)
            for __string0 in egressCidrBlocks {
                try egressCidrBlocksContainer.encode(__string0)
            }
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayMessages = gatewayMessages {
            var gatewayMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayMessages)
            for messagedetail0 in gatewayMessages {
                try gatewayMessagesContainer.encode(messagedetail0)
            }
        }
        if let gatewayState = self.gatewayState {
            try encodeContainer.encode(gatewayState.rawValue, forKey: .gatewayState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networks = networks {
            var networksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networks)
            for gatewaynetwork0 in networks {
                try networksContainer.encode(gatewaynetwork0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .egressCidrBlocks)
        var egressCidrBlocksDecoded0:[Swift.String]? = nil
        if let egressCidrBlocksContainer = egressCidrBlocksContainer {
            egressCidrBlocksDecoded0 = [Swift.String]()
            for string0 in egressCidrBlocksContainer {
                if let string0 = string0 {
                    egressCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        egressCidrBlocks = egressCidrBlocksDecoded0
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayMessagesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MessageDetail?].self, forKey: .gatewayMessages)
        var gatewayMessagesDecoded0:[MediaConnectClientTypes.MessageDetail]? = nil
        if let gatewayMessagesContainer = gatewayMessagesContainer {
            gatewayMessagesDecoded0 = [MediaConnectClientTypes.MessageDetail]()
            for structure0 in gatewayMessagesContainer {
                if let structure0 = structure0 {
                    gatewayMessagesDecoded0?.append(structure0)
                }
            }
        }
        gatewayMessages = gatewayMessagesDecoded0
        let gatewayStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.GatewayState.self, forKey: .gatewayState)
        gatewayState = gatewayStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networksContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GatewayNetwork?].self, forKey: .networks)
        var networksDecoded0:[MediaConnectClientTypes.GatewayNetwork]? = nil
        if let networksContainer = networksContainer {
            networksDecoded0 = [MediaConnectClientTypes.GatewayNetwork]()
            for structure0 in networksContainer {
                if let structure0 = structure0 {
                    networksDecoded0?.append(structure0)
                }
            }
        }
        networks = networksDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The settings for a gateway, including its networks.
    public struct Gateway: Swift.Equatable {
        /// The range of IP addresses that contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var egressCidrBlocks: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        public var gatewayMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The current status of the gateway.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway. This name can not be modified after the gateway is created.
        /// This member is required.
        public var name: Swift.String?
        /// The list of networks in the gateway.
        /// This member is required.
        public var networks: [MediaConnectClientTypes.GatewayNetwork]?

        public init(
            egressCidrBlocks: [Swift.String]? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil,
            networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
        )
        {
            self.egressCidrBlocks = egressCidrBlocks
            self.gatewayArn = gatewayArn
            self.gatewayMessages = gatewayMessages
            self.gatewayState = gatewayState
            self.name = name
            self.networks = networks
        }
    }

}

extension MediaConnectClientTypes.GatewayBridgeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct GatewayBridgeSource: Swift.Equatable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes.GatewayInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgePlacement = "bridgePlacement"
        case connectionStatus = "connectionStatus"
        case gatewayArn = "gatewayArn"
        case gatewayInstanceArn = "gatewayInstanceArn"
        case instanceId = "instanceId"
        case instanceMessages = "instanceMessages"
        case instanceState = "instanceState"
        case runningBridgeCount = "runningBridgeCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgePlacement = self.bridgePlacement {
            try encodeContainer.encode(bridgePlacement.rawValue, forKey: .bridgePlacement)
        }
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayInstanceArn = self.gatewayInstanceArn {
            try encodeContainer.encode(gatewayInstanceArn, forKey: .gatewayInstanceArn)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceMessages = instanceMessages {
            var instanceMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceMessages)
            for messagedetail0 in instanceMessages {
                try instanceMessagesContainer.encode(messagedetail0)
            }
        }
        if let instanceState = self.instanceState {
            try encodeContainer.encode(instanceState.rawValue, forKey: .instanceState)
        }
        if let runningBridgeCount = self.runningBridgeCount {
            try encodeContainer.encode(runningBridgeCount, forKey: .runningBridgeCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgePlacementDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgePlacement.self, forKey: .bridgePlacement)
        bridgePlacement = bridgePlacementDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayInstanceArn)
        gatewayInstanceArn = gatewayInstanceArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceMessagesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MessageDetail?].self, forKey: .instanceMessages)
        var instanceMessagesDecoded0:[MediaConnectClientTypes.MessageDetail]? = nil
        if let instanceMessagesContainer = instanceMessagesContainer {
            instanceMessagesDecoded0 = [MediaConnectClientTypes.MessageDetail]()
            for structure0 in instanceMessagesContainer {
                if let structure0 = structure0 {
                    instanceMessagesDecoded0?.append(structure0)
                }
            }
        }
        instanceMessages = instanceMessagesDecoded0
        let instanceStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InstanceState.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
        let runningBridgeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningBridgeCount)
        runningBridgeCount = runningBridgeCountDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for an instance in a gateway.
    public struct GatewayInstance: Swift.Equatable {
        /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
        /// This member is required.
        public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
        /// The connection state of the instance.
        /// This member is required.
        public var connectionStatus: MediaConnectClientTypes.ConnectionStatus?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The managed instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        public var instanceMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The status of the instance.
        /// This member is required.
        public var instanceState: MediaConnectClientTypes.InstanceState?
        /// The running bridge count.
        /// This member is required.
        public var runningBridgeCount: Swift.Int?

        public init(
            bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
            connectionStatus: MediaConnectClientTypes.ConnectionStatus? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil,
            runningBridgeCount: Swift.Int? = nil
        )
        {
            self.bridgePlacement = bridgePlacement
            self.connectionStatus = connectionStatus
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceMessages = instanceMessages
            self.instanceState = instanceState
            self.runningBridgeCount = runningBridgeCount
        }
    }

}

extension MediaConnectClientTypes.GatewayNetwork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlock = "cidrBlock"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The network settings for a gateway.
    public struct GatewayNetwork: Swift.Equatable {
        /// A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var cidrBlock: Swift.String?
        /// The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            cidrBlock: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.name = name
        }
    }

}

extension MediaConnectClientTypes {
    public enum GatewayState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayState(rawValue: rawValue) ?? GatewayState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.GrantEntitlementRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = self.dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = self.entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __string0 in subscribers {
                try subscribersContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The entitlements that you want to grant on a flow.
    public struct GrantEntitlementRequest: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement. Allowable encryption types: static-key, speke.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you dont specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }

}

extension GrantFlowEntitlements420Exception {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GrantFlowEntitlements420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct GrantFlowEntitlements420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GrantFlowEntitlements420Exception" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GrantFlowEntitlements420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GrantFlowEntitlements420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrantFlowEntitlementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for grantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(grantentitlementrequest0)
            }
        }
    }
}

extension GrantFlowEntitlementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements"
    }
}

/// A request to grant entitlements on a flow.
public struct GrantFlowEntitlementsInput: Swift.Equatable {
    /// The list of entitlements that you want to grant.
    /// This member is required.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// The flow that you want to grant entitlements on.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsInputBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
}

extension GrantFlowEntitlementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
    }
}

extension GrantFlowEntitlementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GrantFlowEntitlementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.flowArn = output.flowArn
        } else {
            self.entitlements = nil
            self.flowArn = nil
        }
    }
}

public struct GrantFlowEntitlementsOutput: Swift.Equatable {
    /// The entitlements that were just granted.
    public var entitlements: [MediaConnectClientTypes.Entitlement]?
    /// The ARN of the flow that these entitlements were granted to.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsOutputBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.Entitlement]?
    let flowArn: Swift.String?
}

extension GrantFlowEntitlementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
        case flowArn = "flowArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

enum GrantFlowEntitlementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GrantFlowEntitlements420Exception": return try await GrantFlowEntitlements420Exception(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.IngressGatewayBridge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "instanceId"
        case maxBitrate = "maxBitrate"
        case maxOutputs = "maxOutputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxOutputs = self.maxOutputs {
            try encodeContainer.encode(maxOutputs, forKey: .maxOutputs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxOutputsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxOutputs)
        maxOutputs = maxOutputsDecoded
    }
}

extension MediaConnectClientTypes {
    public struct IngressGatewayBridge: Swift.Equatable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the ingress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of outputs on the ingress bridge.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }

}

extension MediaConnectClientTypes.InputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIp = "inputIp"
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIp = self.inputIp {
            try encodeContainer.encode(inputIp, forKey: .inputIp)
        }
        if let inputPort = self.inputPort {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = self.interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputIp)
        inputIp = inputIpDecoded
        let inputPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Interface.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that are associated with an incoming media stream.
    public struct InputConfiguration: Swift.Equatable {
        /// The IP address that the flow listens on for incoming content for a media stream.
        /// This member is required.
        public var inputIp: Swift.String?
        /// The port that the flow listens on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface where the media stream comes in from.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?

        public init(
            inputIp: Swift.String? = nil,
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil
        )
        {
            self.inputIp = inputIp
            self.inputPort = inputPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes.InputConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPort = self.inputPort {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = self.interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that you want to associate with an incoming media stream.
    public struct InputConfigurationRequest: Swift.Equatable {
        /// The port that you want the flow to listen on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface that you want to use for the incoming media stream.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.inputPort = inputPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes {
    public enum InstanceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deregistered
        case deregistering
        case deregistrationError
        case registering
        case registrationError
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceState] {
            return [
                .active,
                .deregistered,
                .deregistering,
                .deregistrationError,
                .registering,
                .registrationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .deregistrationError: return "DEREGISTRATION_ERROR"
            case .registering: return "REGISTERING"
            case .registrationError: return "REGISTRATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceState(rawValue: rawValue) ?? InstanceState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.Interface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The VPC interface that is used for the media stream associated with the source or output.
    public struct Interface: Swift.Equatable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension MediaConnectClientTypes.InterfaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The VPC interface that you want to designate where the media stream is coming from or going to.
    public struct InterfaceRequest: Swift.Equatable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes {
    public enum KeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case speke
        case srtPassword
        case staticKey
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .speke,
                .srtPassword,
                .staticKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .speke: return "speke"
            case .srtPassword: return "srt-password"
            case .staticKey: return "static-key"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyType(rawValue: rawValue) ?? KeyType.sdkUnknown(rawValue)
        }
    }
}

extension ListBridgesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let filterArn = filterArn {
                let filterArnQueryItem = ClientRuntime.URLQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
                items.append(filterArnQueryItem)
            }
            return items
        }
    }
}

extension ListBridgesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/bridges"
    }
}

public struct ListBridgesInput: Swift.Equatable {
    /// Filter the list results to display only the bridges associated with the selected Amazon Resource Name (ARN).
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListBridges request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBridgesInputBody: Swift.Equatable {
}

extension ListBridgesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBridgesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBridgesOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridges = output.bridges
            self.nextToken = output.nextToken
        } else {
            self.bridges = nil
            self.nextToken = nil
        }
    }
}

public struct ListBridgesOutput: Swift.Equatable {
    /// A list of bridge summaries.
    public var bridges: [MediaConnectClientTypes.ListedBridge]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        bridges: [MediaConnectClientTypes.ListedBridge]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bridges = bridges
        self.nextToken = nextToken
    }
}

struct ListBridgesOutputBody: Swift.Equatable {
    let bridges: [MediaConnectClientTypes.ListedBridge]?
    let nextToken: Swift.String?
}

extension ListBridgesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridges = "bridges"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedBridge?].self, forKey: .bridges)
        var bridgesDecoded0:[MediaConnectClientTypes.ListedBridge]? = nil
        if let bridgesContainer = bridgesContainer {
            bridgesDecoded0 = [MediaConnectClientTypes.ListedBridge]()
            for structure0 in bridgesContainer {
                if let structure0 = structure0 {
                    bridgesDecoded0?.append(structure0)
                }
            }
        }
        bridges = bridgesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBridgesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEntitlementsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEntitlementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/entitlements"
    }
}

public struct ListEntitlementsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitlementsInputBody: Swift.Equatable {
}

extension ListEntitlementsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEntitlementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitlementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.nextToken = output.nextToken
        } else {
            self.entitlements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitlementsOutput: Swift.Equatable {
    /// A list of entitlements that have been granted to you from other AWS accounts.
    public var entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.ListedEntitlement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

struct ListEntitlementsOutputBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    let nextToken: Swift.String?
}

extension ListEntitlementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedEntitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.ListedEntitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.ListedEntitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEntitlementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/flows"
    }
}

public struct ListFlowsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Swift.Equatable {
}

extension ListFlowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFlowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFlowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutput: Swift.Equatable {
    /// A list of flow summaries.
    public var flows: [MediaConnectClientTypes.ListedFlow]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        flows: [MediaConnectClientTypes.ListedFlow]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputBody: Swift.Equatable {
    let flows: [MediaConnectClientTypes.ListedFlow]?
    let nextToken: Swift.String?
}

extension ListFlowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flows = "flows"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedFlow?].self, forKey: .flows)
        var flowsDecoded0:[MediaConnectClientTypes.ListedFlow]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [MediaConnectClientTypes.ListedFlow]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFlowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGatewayInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let filterArn = filterArn {
                let filterArnQueryItem = ClientRuntime.URLQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
                items.append(filterArnQueryItem)
            }
            return items
        }
    }
}

extension ListGatewayInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/gateway-instances"
    }
}

public struct ListGatewayInstancesInput: Swift.Equatable {
    /// Filter the list results to display only the instances associated with the selected Gateway Amazon Resource Name (ARN).
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListInstances request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewayInstancesInputBody: Swift.Equatable {
}

extension ListGatewayInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewayInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewayInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayInstancesOutput: Swift.Equatable {
    /// A list of instance summaries.
    public var instances: [MediaConnectClientTypes.ListedGatewayInstance]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        instances: [MediaConnectClientTypes.ListedGatewayInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListGatewayInstancesOutputBody: Swift.Equatable {
    let instances: [MediaConnectClientTypes.ListedGatewayInstance]?
    let nextToken: Swift.String?
}

extension ListGatewayInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "instances"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedGatewayInstance?].self, forKey: .instances)
        var instancesDecoded0:[MediaConnectClientTypes.ListedGatewayInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [MediaConnectClientTypes.ListedGatewayInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewayInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/gateways"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListGateways request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
}

extension ListGatewaysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutput: Swift.Equatable {
    /// A list of gateway summaries.
    public var gateways: [MediaConnectClientTypes.ListedGateway]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        gateways: [MediaConnectClientTypes.ListedGateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputBody: Swift.Equatable {
    let gateways: [MediaConnectClientTypes.ListedGateway]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "gateways"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedGateway?].self, forKey: .gateways)
        var gatewaysDecoded0:[MediaConnectClientTypes.ListedGateway]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [MediaConnectClientTypes.ListedGateway]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOfferingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/offerings"
    }
}

public struct ListOfferingsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Swift.Equatable {
}

extension ListOfferingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOfferingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOfferingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

public struct ListOfferingsOutput: Swift.Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of offerings that are available to this account in the current AWS Region.
    public var offerings: [MediaConnectClientTypes.Offering]?

    public init(
        nextToken: Swift.String? = nil,
        offerings: [MediaConnectClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let offerings: [MediaConnectClientTypes.Offering]?
}

extension ListOfferingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case offerings = "offerings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let offeringsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[MediaConnectClientTypes.Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [MediaConnectClientTypes.Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
    }
}

enum ListOfferingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReservationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReservationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/reservations"
    }
}

public struct ListReservationsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReservationsInputBody: Swift.Equatable {
}

extension ListReservationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReservationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReservationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservations = output.reservations
        } else {
            self.nextToken = nil
            self.reservations = nil
        }
    }
}

public struct ListReservationsOutput: Swift.Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListReservations request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of all reservations that have been purchased by this account in the current AWS Region.
    public var reservations: [MediaConnectClientTypes.Reservation]?

    public init(
        nextToken: Swift.String? = nil,
        reservations: [MediaConnectClientTypes.Reservation]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservations = reservations
    }
}

struct ListReservationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservations: [MediaConnectClientTypes.Reservation]?
}

extension ListReservationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case reservations = "reservations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Reservation?].self, forKey: .reservations)
        var reservationsDecoded0:[MediaConnectClientTypes.Reservation]? = nil
        if let reservationsContainer = reservationsContainer {
            reservationsDecoded0 = [MediaConnectClientTypes.Reservation]()
            for structure0 in reservationsContainer {
                if let structure0 = structure0 {
                    reservationsDecoded0?.append(structure0)
                }
            }
        }
        reservations = reservationsDecoded0
    }
}

enum ListReservationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.ListedBridge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case bridgeState = "bridgeState"
        case bridgeType = "bridgeType"
        case name = "name"
        case placementArn = "placementArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let bridgeState = self.bridgeState {
            try encodeContainer.encode(bridgeState.rawValue, forKey: .bridgeState)
        }
        if let bridgeType = self.bridgeType {
            try encodeContainer.encode(bridgeType, forKey: .bridgeType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let placementArn = self.placementArn {
            try encodeContainer.encode(placementArn, forKey: .placementArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let bridgeStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeState.self, forKey: .bridgeState)
        bridgeState = bridgeStateDecoded
        let bridgeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeType)
        bridgeType = bridgeTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let placementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementArn)
        placementArn = placementArnDecoded
    }
}

extension MediaConnectClientTypes {
    /// Displays details of the selected bridge.
    public struct ListedBridge: Swift.Equatable {
        /// The ARN of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        /// The type of the bridge.
        /// This member is required.
        public var bridgeType: Swift.String?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the gateway associated with the bridge.
        /// This member is required.
        public var placementArn: Swift.String?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            bridgeType: Swift.String? = nil,
            name: Swift.String? = nil,
            placementArn: Swift.String? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgeState = bridgeState
            self.bridgeType = bridgeType
            self.name = name
            self.placementArn = placementArn
        }
    }

}

extension MediaConnectClientTypes.ListedEntitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case entitlementArn = "entitlementArn"
        case entitlementName = "entitlementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = self.dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementName = self.entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// An entitlement that has been granted to you from other AWS accounts.
    public struct ListedEntitlement: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// The name of the entitlement.
        /// This member is required.
        public var entitlementName: Swift.String?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementName: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.entitlementArn = entitlementArn
            self.entitlementName = entitlementName
        }
    }

}

extension MediaConnectClientTypes.ListedFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case flowArn = "flowArn"
        case maintenance = "maintenance"
        case name = "name"
        case sourceType = "sourceType"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let maintenance = self.maintenance {
            try encodeContainer.encode(maintenance, forKey: .maintenance)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let maintenanceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Maintenance.self, forKey: .maintenance)
        maintenance = maintenanceDecoded
    }
}

extension MediaConnectClientTypes {
    /// Provides a summary of a flow, including its ARN, Availability Zone, and source type.
    public struct ListedFlow: Swift.Equatable {
        /// The Availability Zone that the flow was created in.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow.
        /// This member is required.
        public var description: Swift.String?
        /// The ARN of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The maintenance setting of a flow
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of source. This value is either owned (originated somewhere other than an AWS Elemental MediaConnect flow owned by another AWS account) or entitled (originated at an AWS Elemental MediaConnect flow owned by another AWS account).
        /// This member is required.
        public var sourceType: MediaConnectClientTypes.SourceType?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            flowArn: Swift.String? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            name: Swift.String? = nil,
            sourceType: MediaConnectClientTypes.SourceType? = nil,
            status: MediaConnectClientTypes.Status? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.flowArn = flowArn
            self.maintenance = maintenance
            self.name = name
            self.sourceType = sourceType
            self.status = status
        }
    }

}

extension MediaConnectClientTypes.ListedGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "gatewayArn"
        case gatewayState = "gatewayState"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayState = self.gatewayState {
            try encodeContainer.encode(gatewayState.rawValue, forKey: .gatewayState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.GatewayState.self, forKey: .gatewayState)
        gatewayState = gatewayStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// Provides a summary of a gateway, including its name, ARN, and status.
    public struct ListedGateway: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// This member is required.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayState = gatewayState
            self.name = name
        }
    }

}

extension MediaConnectClientTypes.ListedGatewayInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "gatewayArn"
        case gatewayInstanceArn = "gatewayInstanceArn"
        case instanceId = "instanceId"
        case instanceState = "instanceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let gatewayInstanceArn = self.gatewayInstanceArn {
            try encodeContainer.encode(gatewayInstanceArn, forKey: .gatewayInstanceArn)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceState = self.instanceState {
            try encodeContainer.encode(instanceState.rawValue, forKey: .instanceState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayInstanceArn)
        gatewayInstanceArn = gatewayInstanceArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InstanceState.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
    }
}

extension MediaConnectClientTypes {
    /// Provides a summary of an instance.
    public struct ListedGatewayInstance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The managed instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of the instance.
        public var instanceState: MediaConnectClientTypes.InstanceState?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceState = instanceState
        }
    }

}

extension MediaConnectClientTypes.Maintenance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenanceDay = "maintenanceDay"
        case maintenanceDeadline = "maintenanceDeadline"
        case maintenanceScheduledDate = "maintenanceScheduledDate"
        case maintenanceStartHour = "maintenanceStartHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maintenanceDay = self.maintenanceDay {
            try encodeContainer.encode(maintenanceDay.rawValue, forKey: .maintenanceDay)
        }
        if let maintenanceDeadline = self.maintenanceDeadline {
            try encodeContainer.encode(maintenanceDeadline, forKey: .maintenanceDeadline)
        }
        if let maintenanceScheduledDate = self.maintenanceScheduledDate {
            try encodeContainer.encode(maintenanceScheduledDate, forKey: .maintenanceScheduledDate)
        }
        if let maintenanceStartHour = self.maintenanceStartHour {
            try encodeContainer.encode(maintenanceStartHour, forKey: .maintenanceStartHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceDayDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MaintenanceDay.self, forKey: .maintenanceDay)
        maintenanceDay = maintenanceDayDecoded
        let maintenanceDeadlineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceDeadline)
        maintenanceDeadline = maintenanceDeadlineDecoded
        let maintenanceScheduledDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceScheduledDate)
        maintenanceScheduledDate = maintenanceScheduledDateDecoded
        let maintenanceStartHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceStartHour)
        maintenanceStartHour = maintenanceStartHourDecoded
    }
}

extension MediaConnectClientTypes {
    /// The maintenance setting of a flow
    public struct Maintenance: Swift.Equatable {
        /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// The Maintenance has to be performed before this deadline in ISO UTC format. Example: 2021-01-30T08:30:00Z.
        public var maintenanceDeadline: Swift.String?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceDeadline: Swift.String? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceDeadline = maintenanceDeadline
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }

}

extension MediaConnectClientTypes {
    public enum MaintenanceDay: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceDay] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "Friday"
            case .monday: return "Monday"
            case .saturday: return "Saturday"
            case .sunday: return "Sunday"
            case .thursday: return "Thursday"
            case .tuesday: return "Tuesday"
            case .wednesday: return "Wednesday"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceDay(rawValue: rawValue) ?? MaintenanceDay.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.MediaStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case fmt = "fmt"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = self.clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fmt = self.fmt {
            try encodeContainer.encode(fmt, forKey: .fmt)
        }
        if let mediaStreamId = self.mediaStreamId {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = self.mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = self.videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fmtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fmt)
        fmt = fmtDecoded
        let mediaStreamIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension MediaConnectClientTypes {
    /// A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
    public struct MediaStream: Swift.Equatable {
        /// Attributes that are related to the media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributes?
        /// The sample rate for the stream. This value is measured in Hz.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        /// This member is required.
        public var fmt: Swift.Int?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributes? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            fmt: Swift.Int? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.fmt = fmt
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }

}

extension MediaConnectClientTypes.MediaStreamAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = self.fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = self.lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Fmtp.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributes: Swift.Equatable {
        /// A set of parameters that define the media stream.
        /// This member is required.
        public var fmtp: MediaConnectClientTypes.Fmtp?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.Fmtp? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }

}

extension MediaConnectClientTypes.MediaStreamAttributesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = self.fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = self.lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FmtpRequest.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributesRequest: Swift.Equatable {
        /// The settings that you want to use to define the media stream.
        public var fmtp: MediaConnectClientTypes.FmtpRequest?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.FmtpRequest? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }

}

extension MediaConnectClientTypes.MediaStreamOutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for destinationconfiguration0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(destinationconfiguration0)
            }
        }
        if let encodingName = self.encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = self.encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.DestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[MediaConnectClientTypes.DestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [MediaConnectClientTypes.DestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingParameters.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that is associated with the output, and the parameters for that association.
    public struct MediaStreamOutputConfiguration: Swift.Equatable {
        /// The transport parameters that are associated with each outbound media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]?
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// Encoding parameters
        public var encodingParameters: MediaConnectClientTypes.EncodingParameters?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParameters? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamOutputConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for destinationconfigurationrequest0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(destinationconfigurationrequest0)
            }
        }
        if let encodingName = self.encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = self.encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.DestinationConfigurationRequest?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[MediaConnectClientTypes.DestinationConfigurationRequest]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [MediaConnectClientTypes.DestinationConfigurationRequest]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingParametersRequest.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that you want to associate with the output, and the parameters for that association.
    public struct MediaStreamOutputConfigurationRequest: Swift.Equatable {
        /// The transport parameters that you want to associate with the media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]?
        /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        public var encodingParameters: MediaConnectClientTypes.EncodingParametersRequest?
        /// The name of the media stream that is associated with the output.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParametersRequest? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = self.encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for inputconfiguration0 in inputConfigurations {
                try inputConfigurationsContainer.encode(inputconfiguration0)
            }
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.InputConfiguration?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[MediaConnectClientTypes.InputConfiguration]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [MediaConnectClientTypes.InputConfiguration]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that is associated with the source, and the parameters for that association.
    public struct MediaStreamSourceConfiguration: Swift.Equatable {
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that are associated with an incoming media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfiguration]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfiguration]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamSourceConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = self.encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for inputconfigurationrequest0 in inputConfigurations {
                try inputConfigurationsContainer.encode(inputconfigurationrequest0)
            }
        }
        if let mediaStreamName = self.mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.InputConfigurationRequest?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[MediaConnectClientTypes.InputConfigurationRequest]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [MediaConnectClientTypes.InputConfigurationRequest]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The definition of a media stream that you want to associate with the source.
    public struct MediaStreamSourceConfigurationRequest: Swift.Equatable {
        /// The format you want to use to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that you want to associate with the media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes {
    public enum MediaStreamType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ancillaryData
        case audio
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .ancillaryData,
                .audio,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ancillaryData: return "ancillary-data"
            case .audio: return "audio"
            case .video: return "video"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStreamType(rawValue: rawValue) ?? MediaStreamType.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.MessageDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension MediaConnectClientTypes {
    public struct MessageDetail: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: Swift.String?
        /// The specific error message that MediaConnect returns to help you understand the reason that the request did not succeed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.resourceName = resourceName
        }
    }

}

extension MediaConnectClientTypes.Messages: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "errors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for __string0 in errors {
                try errorsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .errors)
        var errorsDecoded0:[Swift.String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String]()
            for string0 in errorsContainer {
                if let string0 = string0 {
                    errorsDecoded0?.append(string0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension MediaConnectClientTypes {
    /// Messages that provide the state of the flow.
    public struct Messages: Swift.Equatable {
        /// A list of errors that might have been generated from processes on this flow.
        /// This member is required.
        public var errors: [Swift.String]?

        public init(
            errors: [Swift.String]? = nil
        )
        {
            self.errors = errors
        }
    }

}

extension MediaConnectClientTypes {
    public enum NetworkInterfaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efa
        case ena
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .efa,
                .ena,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .ena: return "ena"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceType(rawValue: rawValue) ?? NetworkInterfaceType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Offering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case resourceSpecification = "resourceSpecification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = self.durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let offeringArn = self.offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = self.offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = self.pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = self.priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let resourceSpecification = self.resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
    }
}

extension MediaConnectClientTypes {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public struct Offering: Swift.Equatable {
        /// The type of currency that is used for billing. The currencyCode used for all reservations is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that your reservation would be active.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.resourceSpecification = resourceSpecification
        }
    }

}

extension MediaConnectClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case bridgePorts = "bridgePorts"
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case listenerAddress = "listenerAddress"
        case mediaLiveInputArn = "mediaLiveInputArn"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case name = "name"
        case outputArn = "outputArn"
        case port = "port"
        case transport = "transport"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let bridgePorts = bridgePorts {
            var bridgePortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bridgePorts)
            for __integer0 in bridgePorts {
                try bridgePortsContainer.encode(__integer0)
            }
        }
        if let dataTransferSubscriberFeePercent = self.dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let listenerAddress = self.listenerAddress {
            try encodeContainer.encode(listenerAddress, forKey: .listenerAddress)
        }
        if let mediaLiveInputArn = self.mediaLiveInputArn {
            try encodeContainer.encode(mediaLiveInputArn, forKey: .mediaLiveInputArn)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for mediastreamoutputconfiguration0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(mediastreamoutputconfiguration0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputArn = self.outputArn {
            try encodeContainer.encode(outputArn, forKey: .outputArn)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let transport = self.transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let listenerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerAddress)
        listenerAddress = listenerAddressDecoded
        let mediaLiveInputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaLiveInputArn)
        mediaLiveInputArn = mediaLiveInputArnDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfiguration?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfiguration]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let transportDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let bridgePortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .bridgePorts)
        var bridgePortsDecoded0:[Swift.Int]? = nil
        if let bridgePortsContainer = bridgePortsContainer {
            bridgePortsDecoded0 = [Swift.Int]()
            for integer0 in bridgePortsContainer {
                if let integer0 = integer0 {
                    bridgePortsDecoded0?.append(integer0)
                }
            }
        }
        bridgePorts = bridgePortsDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The settings for an output.
    public struct Output: Swift.Equatable {
        /// The ARN of the bridge that added this output.
        public var bridgeArn: Swift.String?
        /// The bridge output ports currently in use.
        public var bridgePorts: [Swift.Int]?
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the output.
        public var description: Swift.String?
        /// The address where you want to send the output.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.
        public var entitlementArn: Swift.String?
        /// The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.
        public var listenerAddress: Swift.String?
        /// The input ARN of the AWS Elemental MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.
        public var mediaLiveInputArn: Swift.String?
        /// The configuration for each media stream that is associated with the output.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]?
        /// The name of the output. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the output.
        /// This member is required.
        public var outputArn: Swift.String?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// Attributes related to the transport stream that are used in the output.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgePorts: [Swift.Int]? = nil,
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            listenerAddress: Swift.String? = nil,
            mediaLiveInputArn: Swift.String? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgePorts = bridgePorts
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.listenerAddress = listenerAddress
            self.mediaLiveInputArn = mediaLiveInputArn
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.name = name
            self.outputArn = outputArn
            self.port = port
            self.transport = transport
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes {
    public enum PriceUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hourly
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceUnits] {
            return [
                .hourly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hourly: return "HOURLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceUnits(rawValue: rawValue) ?? PriceUnits.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cdi
        case fujitsuQos
        case rist
        case rtp
        case rtpFec
        case srtCaller
        case srtListener
        case st2110Jpegxs
        case udp
        case zixiPull
        case zixiPush
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .cdi,
                .fujitsuQos,
                .rist,
                .rtp,
                .rtpFec,
                .srtCaller,
                .srtListener,
                .st2110Jpegxs,
                .udp,
                .zixiPull,
                .zixiPush,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cdi: return "cdi"
            case .fujitsuQos: return "fujitsu-qos"
            case .rist: return "rist"
            case .rtp: return "rtp"
            case .rtpFec: return "rtp-fec"
            case .srtCaller: return "srt-caller"
            case .srtListener: return "srt-listener"
            case .st2110Jpegxs: return "st2110-jpegxs"
            case .udp: return "udp"
            case .zixiPull: return "zixi-pull"
            case .zixiPush: return "zixi-push"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension PurchaseOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservationName = self.reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }
}

extension PurchaseOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let offeringArn = offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

/// A request to purchase a offering.
public struct PurchaseOfferingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?
    /// The name that you want to use for the reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
    /// This member is required.
    public var start: Swift.String?

    public init(
        offeringArn: Swift.String? = nil,
        reservationName: Swift.String? = nil,
        start: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
        self.reservationName = reservationName
        self.start = start
    }
}

struct PurchaseOfferingInputBody: Swift.Equatable {
    let reservationName: Swift.String?
    let start: Swift.String?
}

extension PurchaseOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
    }
}

extension PurchaseOfferingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PurchaseOfferingOutputBody = try responseDecoder.decode(responseBody: data)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct PurchaseOfferingOutput: Swift.Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct PurchaseOfferingOutputBody: Swift.Equatable {
    let reservation: MediaConnectClientTypes.Reservation?
}

extension PurchaseOfferingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservation = "reservation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

enum PurchaseOfferingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes {
    public enum Range: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case fullprotect
        case narrow
        case sdkUnknown(Swift.String)

        public static var allCases: [Range] {
            return [
                .full,
                .fullprotect,
                .narrow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .fullprotect: return "FULLPROTECT"
            case .narrow: return "NARROW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Range(rawValue: rawValue) ?? Range.sdkUnknown(rawValue)
        }
    }
}

extension RemoveBridgeOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        guard let outputName = outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

public struct RemoveBridgeOutputInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge output that you want to remove.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

struct RemoveBridgeOutputInputBody: Swift.Equatable {
}

extension RemoveBridgeOutputInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveBridgeOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveBridgeOutputOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.outputName = output.outputName
        } else {
            self.bridgeArn = nil
            self.outputName = nil
        }
    }
}

public struct RemoveBridgeOutputOutput: Swift.Equatable {
    public var bridgeArn: Swift.String?
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

struct RemoveBridgeOutputOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let outputName: Swift.String?
}

extension RemoveBridgeOutputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case outputName = "outputName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let outputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputName)
        outputName = outputNameDecoded
    }
}

enum RemoveBridgeOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveBridgeSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        guard let sourceName = sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

public struct RemoveBridgeSourceInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge source that you want to remove.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

struct RemoveBridgeSourceInputBody: Swift.Equatable {
}

extension RemoveBridgeSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveBridgeSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveBridgeSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.sourceName = output.sourceName
        } else {
            self.bridgeArn = nil
            self.sourceName = nil
        }
    }
}

public struct RemoveBridgeSourceOutput: Swift.Equatable {
    public var bridgeArn: Swift.String?
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

struct RemoveBridgeSourceOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let sourceName: Swift.String?
}

extension RemoveBridgeSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case sourceName = "sourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
    }
}

enum RemoveBridgeSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveFlowMediaStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let mediaStreamName = mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

public struct RemoveFlowMediaStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to remove.
    /// This member is required.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamInputBody: Swift.Equatable {
}

extension RemoveFlowMediaStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowMediaStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveFlowMediaStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStreamName = output.mediaStreamName
        } else {
            self.flowArn = nil
            self.mediaStreamName = nil
        }
    }
}

public struct RemoveFlowMediaStreamOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public var flowArn: Swift.String?
    /// The name of the media stream that was removed.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStreamName: Swift.String?
}

extension RemoveFlowMediaStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStreamName = "mediaStreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

enum RemoveFlowMediaStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveFlowOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let outputArn = outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

public struct RemoveFlowOutputInput: Swift.Equatable {
    /// The flow that you want to remove an output from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the output that you want to remove.
    /// This member is required.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputInputBody: Swift.Equatable {
}

extension RemoveFlowOutputInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveFlowOutputOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.outputArn = output.outputArn
        } else {
            self.flowArn = nil
            self.outputArn = nil
        }
    }
}

public struct RemoveFlowOutputOutput: Swift.Equatable {
    /// The ARN of the flow that is associated with the output you removed.
    public var flowArn: Swift.String?
    /// The ARN of the output that was removed.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let outputArn: Swift.String?
}

extension RemoveFlowOutputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case outputArn = "outputArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
    }
}

enum RemoveFlowOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveFlowSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let sourceArn = sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

public struct RemoveFlowSourceInput: Swift.Equatable {
    /// The flow that you want to remove a source from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the source that you want to remove.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceInputBody: Swift.Equatable {
}

extension RemoveFlowSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveFlowSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.sourceArn = output.sourceArn
        } else {
            self.flowArn = nil
            self.sourceArn = nil
        }
    }
}

public struct RemoveFlowSourceOutput: Swift.Equatable {
    /// The ARN of the flow that is associated with the source you removed.
    public var flowArn: Swift.String?
    /// The ARN of the source that was removed.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let sourceArn: Swift.String?
}

extension RemoveFlowSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case sourceArn = "sourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

enum RemoveFlowSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveFlowVpcInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let vpcInterfaceName = vpcInterfaceName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces/\(vpcInterfaceName.urlPercentEncoding())"
    }
}

public struct RemoveFlowVpcInterfaceInput: Swift.Equatable {
    /// The flow that you want to remove a VPC interface from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the VPC interface that you want to remove.
    /// This member is required.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceInputBody: Swift.Equatable {
}

extension RemoveFlowVpcInterfaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowVpcInterfaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveFlowVpcInterfaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.nonDeletedNetworkInterfaceIds = output.nonDeletedNetworkInterfaceIds
            self.vpcInterfaceName = output.vpcInterfaceName
        } else {
            self.flowArn = nil
            self.nonDeletedNetworkInterfaceIds = nil
            self.vpcInterfaceName = nil
        }
    }
}

public struct RemoveFlowVpcInterfaceOutput: Swift.Equatable {
    /// The ARN of the flow that is associated with the VPC interface you removed.
    public var flowArn: Swift.String?
    /// IDs of network interfaces associated with the removed VPC interface that Media Connect was unable to remove.
    public var nonDeletedNetworkInterfaceIds: [Swift.String]?
    /// The name of the VPC interface that was removed.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        nonDeletedNetworkInterfaceIds: [Swift.String]? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIds
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let nonDeletedNetworkInterfaceIds: [Swift.String]?
    let vpcInterfaceName: Swift.String?
}

extension RemoveFlowVpcInterfaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case nonDeletedNetworkInterfaceIds = "nonDeletedNetworkInterfaceIds"
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nonDeletedNetworkInterfaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonDeletedNetworkInterfaceIds)
        var nonDeletedNetworkInterfaceIdsDecoded0:[Swift.String]? = nil
        if let nonDeletedNetworkInterfaceIdsContainer = nonDeletedNetworkInterfaceIdsContainer {
            nonDeletedNetworkInterfaceIdsDecoded0 = [Swift.String]()
            for string0 in nonDeletedNetworkInterfaceIdsContainer {
                if let string0 = string0 {
                    nonDeletedNetworkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIdsDecoded0
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

enum RemoveFlowVpcInterfaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.Reservation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case end = "end"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case reservationArn = "reservationArn"
        case reservationName = "reservationName"
        case reservationState = "reservationState"
        case resourceSpecification = "resourceSpecification"
        case start = "start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = self.durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringArn = self.offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = self.offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = self.pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = self.priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let reservationArn = self.reservationArn {
            try encodeContainer.encode(reservationArn, forKey: .reservationArn)
        }
        if let reservationName = self.reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let reservationState = self.reservationState {
            try encodeContainer.encode(reservationState.rawValue, forKey: .reservationState)
        }
        if let resourceSpecification = self.resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let reservationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationArn)
        reservationArn = reservationArnDecoded
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let reservationStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ReservationState.self, forKey: .reservationState)
        reservationState = reservationStateDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
    }
}

extension MediaConnectClientTypes {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public struct Reservation: Swift.Equatable {
        /// The type of currency that is used for billing. The currencyCode used for your reservation is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that this reservation is active. MediaConnect defines this value in the offering.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the reservation. MediaConnect defines this value in the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The day and time that this reservation expires. This value is calculated based on the start date and time that you set and the offering's duration.
        /// This member is required.
        public var end: Swift.String?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering. MediaConnect defines this value in the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the reservation when you purchase an offering.
        /// This member is required.
        public var reservationArn: Swift.String?
        /// The name that you assigned to the reservation when you purchased the offering.
        /// This member is required.
        public var reservationName: Swift.String?
        /// The status of your reservation.
        /// This member is required.
        public var reservationState: MediaConnectClientTypes.ReservationState?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering. MediaConnect defines the values that make up the resourceSpecification in the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?
        /// The day and time that the reservation becomes active. You set this value when you purchase the offering.
        /// This member is required.
        public var start: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            end: Swift.String? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            reservationArn: Swift.String? = nil,
            reservationName: Swift.String? = nil,
            reservationState: MediaConnectClientTypes.ReservationState? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil,
            start: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.end = end
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.reservationArn = reservationArn
            self.reservationName = reservationName
            self.reservationState = reservationState
            self.resourceSpecification = resourceSpecification
            self.start = start
        }
    }

}

extension MediaConnectClientTypes {
    public enum ReservationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case expired
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservationState] {
            return [
                .active,
                .canceled,
                .expired,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReservationState(rawValue: rawValue) ?? ReservationState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.ResourceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedBitrate = "reservedBitrate"
        case resourceType = "resourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedBitrate = self.reservedBitrate {
            try encodeContainer.encode(reservedBitrate, forKey: .reservedBitrate)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedBitrate)
        reservedBitrate = reservedBitrateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MediaConnectClientTypes {
    /// A definition of what is being billed for, including the type and amount.
    public struct ResourceSpecification: Swift.Equatable {
        /// The amount of outbound bandwidth that is discounted in the offering.
        public var reservedBitrate: Swift.Int?
        /// The type of resource and the unit that is being billed for.
        /// This member is required.
        public var resourceType: MediaConnectClientTypes.ResourceType?

        public init(
            reservedBitrate: Swift.Int? = nil,
            resourceType: MediaConnectClientTypes.ResourceType? = nil
        )
        {
            self.reservedBitrate = reservedBitrate
            self.resourceType = resourceType
        }
    }

}

extension MediaConnectClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mbpsOutboundBandwidth
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .mbpsOutboundBandwidth,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mbpsOutboundBandwidth: return "Mbps_Outbound_Bandwidth"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RevokeFlowEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let entitlementArn = entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

public struct RevokeFlowEntitlementInput: Swift.Equatable {
    /// The ARN of the entitlement that you want to revoke.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// The flow that you want to revoke an entitlement from.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementInputBody: Swift.Equatable {
}

extension RevokeFlowEntitlementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RevokeFlowEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RevokeFlowEntitlementOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlementArn = output.entitlementArn
            self.flowArn = output.flowArn
        } else {
            self.entitlementArn = nil
            self.flowArn = nil
        }
    }
}

public struct RevokeFlowEntitlementOutput: Swift.Equatable {
    /// The ARN of the entitlement that was revoked.
    public var entitlementArn: Swift.String?
    /// The ARN of the flow that the entitlement was revoked from.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementOutputBody: Swift.Equatable {
    let entitlementArn: Swift.String?
    let flowArn: Swift.String?
}

extension RevokeFlowEntitlementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementArn = "entitlementArn"
        case flowArn = "flowArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

enum RevokeFlowEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes {
    public enum ScanMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interlace
        case progressive
        case progressiveSegmentedFrame
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanMode] {
            return [
                .interlace,
                .progressive,
                .progressiveSegmentedFrame,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interlace: return "interlace"
            case .progressive: return "progressive"
            case .progressiveSegmentedFrame: return "progressive-segmented-frame"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanMode(rawValue: rawValue) ?? ScanMode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.SetGatewayBridgeSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct SetGatewayBridgeSourceRequest: Swift.Equatable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes.SetSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case gatewayBridgeSource = "gatewayBridgeSource"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case `protocol` = "protocol"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case sourceListenerAddress = "sourceListenerAddress"
        case sourceListenerPort = "sourceListenerPort"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = self.decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let gatewayBridgeSource = self.gatewayBridgeSource {
            try encodeContainer.encode(gatewayBridgeSource, forKey: .gatewayBridgeSource)
        }
        if let ingestPort = self.ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = self.maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = self.maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for mediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(mediastreamsourceconfigurationrequest0)
            }
        }
        if let minLatency = self.minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let senderIpAddress = self.senderIpAddress {
            try encodeContainer.encode(senderIpAddress, forKey: .senderIpAddress)
        }
        if let sourceListenerAddress = self.sourceListenerAddress {
            try encodeContainer.encode(sourceListenerAddress, forKey: .sourceListenerAddress)
        }
        if let sourceListenerPort = self.sourceListenerPort {
            try encodeContainer.encode(sourceListenerPort, forKey: .sourceListenerPort)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = self.vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = self.whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let senderIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIpAddress)
        senderIpAddress = senderIpAddressDecoded
        let sourceListenerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceListenerAddress)
        sourceListenerAddress = sourceListenerAddressDecoded
        let sourceListenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sourceListenerPort)
        sourceListenerPort = sourceListenerPortDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
        let gatewayBridgeSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SetGatewayBridgeSourceRequest.self, forKey: .gatewayBridgeSource)
        gatewayBridgeSource = gatewayBridgeSourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for the source of the flow.
    public struct SetSourceRequest: Swift.Equatable {
        /// The type of encryption that is used on the content ingested from this source. Allowable encryption types: static-key.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the source.
        public var name: Swift.String?
        /// The protocol that is used by the source.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface to use for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest? = nil,
            ingestPort: Swift.Int? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestPort = ingestPort
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.minLatency = minLatency
            self.name = name
            self.`protocol` = `protocol`
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.streamId = streamId
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }

}

extension MediaConnectClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case gatewayBridgeSource = "gatewayBridgeSource"
        case ingestIp = "ingestIp"
        case ingestPort = "ingestPort"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case name = "name"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case sourceArn = "sourceArn"
        case transport = "transport"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = self.dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let decryption = self.decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let gatewayBridgeSource = self.gatewayBridgeSource {
            try encodeContainer.encode(gatewayBridgeSource, forKey: .gatewayBridgeSource)
        }
        if let ingestIp = self.ingestIp {
            try encodeContainer.encode(ingestIp, forKey: .ingestIp)
        }
        if let ingestPort = self.ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for mediastreamsourceconfiguration0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(mediastreamsourceconfiguration0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let senderIpAddress = self.senderIpAddress {
            try encodeContainer.encode(senderIpAddress, forKey: .senderIpAddress)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let transport = self.transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceName = self.vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = self.whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestIp)
        ingestIp = ingestIpDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfiguration?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfiguration]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let senderIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIpAddress)
        senderIpAddress = senderIpAddressDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let transportDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
        let gatewayBridgeSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.GatewayBridgeSource.self, forKey: .gatewayBridgeSource)
        gatewayBridgeSource = gatewayBridgeSourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for the source of the flow.
    public struct Source: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The type of encryption that is used on the content ingested from this source.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource?
        /// The IP address that the flow will be listening on for incoming content.
        public var ingestIp: Swift.String?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]?
        /// The name of the source.
        /// This member is required.
        public var name: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The ARN of the source.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// Attributes related to the transport stream that are used in the source.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface that is used for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource? = nil,
            ingestIp: Swift.String? = nil,
            ingestPort: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil,
            name: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestIp = ingestIp
            self.ingestPort = ingestPort
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.name = name
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceArn = sourceArn
            self.transport = transport
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }

}

extension MediaConnectClientTypes.SourcePriority: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primarySource = "primarySource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primarySource = self.primarySource {
            try encodeContainer.encode(primarySource, forKey: .primarySource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primarySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primarySource)
        primarySource = primarySourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
    public struct SourcePriority: Swift.Equatable {
        /// The name of the source you choose as the primary source for this flow.
        public var primarySource: Swift.String?

        public init(
            primarySource: Swift.String? = nil
        )
        {
            self.primarySource = primarySource
        }
    }

}

extension MediaConnectClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .entitled,
                .owned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/start/\(flowArn.urlPercentEncoding())"
    }
}

public struct StartFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to start.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StartFlowInputBody: Swift.Equatable {
}

extension StartFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StartFlowOutput: Swift.Equatable {
    /// The ARN of the flow that you started.
    public var flowArn: Swift.String?
    /// The status of the flow when the StartFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StartFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension StartFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum StartFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case error
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .deleting,
                .error,
                .standby,
                .starting,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/stop/\(flowArn.urlPercentEncoding())"
    }
}

public struct StopFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to stop.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StopFlowInputBody: Swift.Equatable {
}

extension StopFlowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StopFlowOutput: Swift.Equatable {
    /// The ARN of the flow that you stopped.
    public var flowArn: Swift.String?
    /// The status of the flow when the StopFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StopFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension StopFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum StopFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes {
    public enum Tcs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bt2100linhlg
        case bt2100linpq
        case density
        case hlg
        case linear
        case pq
        case sdr
        case st20651
        case st4281
        case sdkUnknown(Swift.String)

        public static var allCases: [Tcs] {
            return [
                .bt2100linhlg,
                .bt2100linpq,
                .density,
                .hlg,
                .linear,
                .pq,
                .sdr,
                .st20651,
                .st4281,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bt2100linhlg: return "BT2100LINHLG"
            case .bt2100linpq: return "BT2100LINPQ"
            case .density: return "DENSITY"
            case .hlg: return "HLG"
            case .linear: return "LINEAR"
            case .pq: return "PQ"
            case .sdr: return "SDR"
            case .st20651: return "ST2065-1"
            case .st4281: return "ST428-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tcs(rawValue: rawValue) ?? Tcs.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Transport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case smoothingLatency = "smoothingLatency"
        case sourceListenerAddress = "sourceListenerAddress"
        case sourceListenerPort = "sourceListenerPort"
        case streamId = "streamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__string0)
            }
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = self.maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = self.maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let minLatency = self.minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = self.remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let senderIpAddress = self.senderIpAddress {
            try encodeContainer.encode(senderIpAddress, forKey: .senderIpAddress)
        }
        if let smoothingLatency = self.smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let sourceListenerAddress = self.sourceListenerAddress {
            try encodeContainer.encode(sourceListenerAddress, forKey: .sourceListenerAddress)
        }
        if let sourceListenerPort = self.sourceListenerPort {
            try encodeContainer.encode(sourceListenerPort, forKey: .sourceListenerPort)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let senderIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIpAddress)
        senderIpAddress = senderIpAddressDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let sourceListenerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceListenerAddress)
        sourceListenerAddress = sourceListenerAddressDecoded
        let sourceListenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sourceListenerPort)
        sourceListenerPort = sourceListenerPortDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes related to the transport stream that are used in a source or output.
    public struct Transport: Swift.Equatable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
        public var minLatency: Swift.Int?
        /// The protocol that is used by the source or output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull stream.
        public var remoteId: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            minLatency: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            smoothingLatency: Swift.Int? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.minLatency = minLatency
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.smoothingLatency = smoothingLatency
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.streamId = streamId
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.UpdateBridgeFlowSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case flowVpcInterfaceAttachment = "flowVpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowVpcInterfaceAttachment = self.flowVpcInterfaceAttachment {
            try encodeContainer.encode(flowVpcInterfaceAttachment, forKey: .flowVpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowVpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .flowVpcInterfaceAttachment)
        flowVpcInterfaceAttachment = flowVpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// Update the flow source of the bridge.
    public struct UpdateBridgeFlowSourceRequest: Swift.Equatable {
        /// The ARN of the cloud flow to use as a source of this bridge.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
        }
    }

}

extension UpdateBridgeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressGatewayBridge = "egressGatewayBridge"
        case ingressGatewayBridge = "ingressGatewayBridge"
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressGatewayBridge = self.egressGatewayBridge {
            try encodeContainer.encode(egressGatewayBridge, forKey: .egressGatewayBridge)
        }
        if let ingressGatewayBridge = self.ingressGatewayBridge {
            try encodeContainer.encode(ingressGatewayBridge, forKey: .ingressGatewayBridge)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
    }
}

extension UpdateBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

/// A request to update the bridge.
public struct UpdateBridgeInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    public var egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?
    public var ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?

    public init(
        bridgeArn: Swift.String? = nil,
        egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

struct UpdateBridgeInputBody: Swift.Equatable {
    let egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?
    let ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?
    let sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?
}

extension UpdateBridgeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressGatewayBridge = "egressGatewayBridge"
        case ingressGatewayBridge = "ingressGatewayBridge"
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest.self, forKey: .egressGatewayBridge)
        egressGatewayBridge = egressGatewayBridgeDecoded
        let ingressGatewayBridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest.self, forKey: .ingressGatewayBridge)
        ingressGatewayBridge = ingressGatewayBridgeDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateFailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
    }
}

extension MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "ipAddress"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
        case ttl = "ttl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Update an existing network output.
    public struct UpdateBridgeNetworkOutputRequest: Swift.Equatable {
        /// The network output IP Address.
        public var ipAddress: Swift.String?
        /// The network output's gateway network name.
        public var networkName: Swift.String?
        /// The network output port.
        public var port: Swift.Int?
        /// The network output protocol.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }

}

extension MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastIp = "multicastIp"
        case networkName = "networkName"
        case port = "port"
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastIp = self.multicastIp {
            try encodeContainer.encode(multicastIp, forKey: .multicastIp)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastIp)
        multicastIp = multicastIpDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension MediaConnectClientTypes {
    /// Update the network source of the bridge.
    public struct UpdateBridgeNetworkSourceRequest: Swift.Equatable {
        /// The network source multicast IP.
        public var multicastIp: Swift.String?
        /// The network source's gateway network name.
        public var networkName: Swift.String?
        /// The network source port.
        public var port: Swift.Int?
        /// The network source protocol.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension UpdateBridgeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBridgeOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridge = output.bridge
        } else {
            self.bridge = nil
        }
    }
}

public struct UpdateBridgeOutput: Swift.Equatable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

struct UpdateBridgeOutputBody: Swift.Equatable {
    let bridge: MediaConnectClientTypes.Bridge?
}

extension UpdateBridgeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridge = "bridge"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Bridge.self, forKey: .bridge)
        bridge = bridgeDecoded
    }
}

enum UpdateBridgeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBridgeOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkOutput = "networkOutput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkOutput = self.networkOutput {
            try encodeContainer.encode(networkOutput, forKey: .networkOutput)
        }
    }
}

extension UpdateBridgeOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        guard let outputName = outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the bridge output.
public struct UpdateBridgeOutputInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// Update an existing network output.
    public var networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?
    /// The name of the bridge output that you want to update.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.networkOutput = networkOutput
        self.outputName = outputName
    }
}

struct UpdateBridgeOutputInputBody: Swift.Equatable {
    let networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?
}

extension UpdateBridgeOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkOutput = "networkOutput"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkOutputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest.self, forKey: .networkOutput)
        networkOutput = networkOutputDecoded
    }
}

extension UpdateBridgeOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBridgeOutputOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.output = output.output
        } else {
            self.bridgeArn = nil
            self.output = nil
        }
    }
}

public struct UpdateBridgeOutputOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The output that you updated.
    public var output: MediaConnectClientTypes.BridgeOutput?

    public init(
        bridgeArn: Swift.String? = nil,
        output: MediaConnectClientTypes.BridgeOutput? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.output = output
    }
}

struct UpdateBridgeOutputOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let output: MediaConnectClientTypes.BridgeOutput?
}

extension UpdateBridgeOutputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case output = "output"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let outputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeOutput.self, forKey: .output)
        output = outputDecoded
    }
}

enum UpdateBridgeOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBridgeSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowSource = "flowSource"
        case networkSource = "networkSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowSource = self.flowSource {
            try encodeContainer.encode(flowSource, forKey: .flowSource)
        }
        if let networkSource = self.networkSource {
            try encodeContainer.encode(networkSource, forKey: .networkSource)
        }
    }
}

extension UpdateBridgeSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        guard let sourceName = sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the bridge source.
public struct UpdateBridgeSourceInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// Update the flow source of the bridge.
    public var flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?
    /// Update the network source of the bridge.
    public var networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?
    /// The name of the source that you want to update.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest? = nil,
        networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.flowSource = flowSource
        self.networkSource = networkSource
        self.sourceName = sourceName
    }
}

struct UpdateBridgeSourceInputBody: Swift.Equatable {
    let flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?
    let networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?
}

extension UpdateBridgeSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowSource = "flowSource"
        case networkSource = "networkSource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateBridgeFlowSourceRequest.self, forKey: .flowSource)
        flowSource = flowSourceDecoded
        let networkSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest.self, forKey: .networkSource)
        networkSource = networkSourceDecoded
    }
}

extension UpdateBridgeSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBridgeSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.source = output.source
        } else {
            self.bridgeArn = nil
            self.source = nil
        }
    }
}

public struct UpdateBridgeSourceOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The bridge's source.
    public var source: MediaConnectClientTypes.BridgeSource?

    public init(
        bridgeArn: Swift.String? = nil,
        source: MediaConnectClientTypes.BridgeSource? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.source = source
    }
}

struct UpdateBridgeSourceOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let source: MediaConnectClientTypes.BridgeSource?
}

extension UpdateBridgeSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case source = "source"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgeSource.self, forKey: .source)
        source = sourceDecoded
    }
}

enum UpdateBridgeSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBridgeStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "desiredState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
    }
}

extension UpdateBridgeStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bridgeArn = bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/state"
    }
}

/// A request to update the bridge state.
public struct UpdateBridgeStateInput: Swift.Equatable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// This member is required.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

struct UpdateBridgeStateInputBody: Swift.Equatable {
    let desiredState: MediaConnectClientTypes.DesiredState?
}

extension UpdateBridgeStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "desiredState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

extension UpdateBridgeStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBridgeStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgeArn = output.bridgeArn
            self.desiredState = output.desiredState
        } else {
            self.bridgeArn = nil
            self.desiredState = nil
        }
    }
}

public struct UpdateBridgeStateOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The state of the bridge. ACTIVE or STANDBY.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

struct UpdateBridgeStateOutputBody: Swift.Equatable {
    let bridgeArn: Swift.String?
    let desiredState: MediaConnectClientTypes.DesiredState?
}

extension UpdateBridgeStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case desiredState = "desiredState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

enum UpdateBridgeStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBitrate = "maxBitrate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
    }
}

extension MediaConnectClientTypes {
    public struct UpdateEgressGatewayBridgeRequest: Swift.Equatable {
        /// Update an existing egress-type bridge.
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
        }
    }

}

extension MediaConnectClientTypes.UpdateEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = self.algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Information about the encryption of the flow.
    public struct UpdateEncryption: Swift.Equatable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }

}

extension MediaConnectClientTypes.UpdateFailoverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverMode = "failoverMode"
        case recoveryWindow = "recoveryWindow"
        case sourcePriority = "sourcePriority"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverMode = self.failoverMode {
            try encodeContainer.encode(failoverMode.rawValue, forKey: .failoverMode)
        }
        if let recoveryWindow = self.recoveryWindow {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let sourcePriority = self.sourcePriority {
            try encodeContainer.encode(sourcePriority, forKey: .sourcePriority)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverMode.self, forKey: .failoverMode)
        failoverMode = failoverModeDecoded
        let recoveryWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let sourcePriorityDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourcePriority.self, forKey: .sourcePriority)
        sourcePriority = sourcePriorityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for source failover.
    public struct UpdateFailoverConfig: Swift.Equatable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Recovery window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }

}

extension UpdateFlowEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = self.entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __string0 in subscribers {
                try subscribersContainer.encode(__string0)
            }
        }
    }
}

extension UpdateFlowEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let entitlementArn = entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

/// The entitlement fields that you want to update.
public struct UpdateFlowEntitlementInput: Swift.Equatable {
    /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
    public var description: Swift.String?
    /// The type of encryption that will be used on the output associated with this entitlement. Allowable encryption types: static-key, speke.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The ARN of the entitlement that you want to update.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscribers flow temporarily. If you dont specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
    public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    /// The flow that is associated with the entitlement that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public var subscribers: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        entitlementArn: Swift.String? = nil,
        entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
        flowArn: Swift.String? = nil,
        subscribers: [Swift.String]? = nil
    )
    {
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.flowArn = flowArn
        self.subscribers = subscribers
    }
}

struct UpdateFlowEntitlementInputBody: Swift.Equatable {
    let description: Swift.String?
    let encryption: MediaConnectClientTypes.UpdateEncryption?
    let entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    let subscribers: [Swift.String]?
}

extension UpdateFlowEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateFlowEntitlementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowEntitlementOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitlement = output.entitlement
            self.flowArn = output.flowArn
        } else {
            self.entitlement = nil
            self.flowArn = nil
        }
    }
}

public struct UpdateFlowEntitlementOutput: Swift.Equatable {
    /// The new configuration of the entitlement that you updated.
    public var entitlement: MediaConnectClientTypes.Entitlement?
    /// The ARN of the flow that this entitlement was granted on.
    public var flowArn: Swift.String?

    public init(
        entitlement: MediaConnectClientTypes.Entitlement? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlement = entitlement
        self.flowArn = flowArn
    }
}

struct UpdateFlowEntitlementOutputBody: Swift.Equatable {
    let entitlement: MediaConnectClientTypes.Entitlement?
    let flowArn: Swift.String?
}

extension UpdateFlowEntitlementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlement = "entitlement"
        case flowArn = "flowArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Entitlement.self, forKey: .entitlement)
        entitlement = entitlementDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

enum UpdateFlowEntitlementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenance = "maintenance"
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maintenance = self.maintenance {
            try encodeContainer.encode(maintenance, forKey: .maintenance)
        }
        if let sourceFailoverConfig = self.sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
    }
}

extension UpdateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

/// A request to update flow.
public struct UpdateFlowInput: Swift.Equatable {
    /// The flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// Update maintenance setting for a flow
    public var maintenance: MediaConnectClientTypes.UpdateMaintenance?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?

    public init(
        flowArn: Swift.String? = nil,
        maintenance: MediaConnectClientTypes.UpdateMaintenance? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil
    )
    {
        self.flowArn = flowArn
        self.maintenance = maintenance
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

struct UpdateFlowInputBody: Swift.Equatable {
    let sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?
    let maintenance: MediaConnectClientTypes.UpdateMaintenance?
}

extension UpdateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenance = "maintenance"
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateFailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let maintenanceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateMaintenance.self, forKey: .maintenance)
        maintenance = maintenanceDecoded
    }
}

extension UpdateFlowMediaStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = self.clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaStreamType = self.mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = self.videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }
}

extension UpdateFlowMediaStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let mediaStreamName = mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the media stream.
public struct UpdateFlowMediaStreamInput: Swift.Equatable {
    /// The attributes that you want to assign to the media stream.
    public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
    public var clockRate: Swift.Int?
    /// Description
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to update.
    /// This member is required.
    public var mediaStreamName: Swift.String?
    /// The type of media stream.
    public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    /// The resolution of the video.
    public var videoFormat: Swift.String?

    public init(
        attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
        clockRate: Swift.Int? = nil,
        description: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil,
        mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
        videoFormat: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

struct UpdateFlowMediaStreamInputBody: Swift.Equatable {
    let attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    let clockRate: Swift.Int?
    let description: Swift.String?
    let mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    let videoFormat: Swift.String?
}

extension UpdateFlowMediaStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension UpdateFlowMediaStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowMediaStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStream = output.mediaStream
        } else {
            self.flowArn = nil
            self.mediaStream = nil
        }
    }
}

public struct UpdateFlowMediaStreamOutput: Swift.Equatable {
    /// The ARN of the flow that is associated with the media stream that you updated.
    public var flowArn: Swift.String?
    /// The media stream that you updated.
    public var mediaStream: MediaConnectClientTypes.MediaStream?

    public init(
        flowArn: Swift.String? = nil,
        mediaStream: MediaConnectClientTypes.MediaStream? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStream = mediaStream
    }
}

struct UpdateFlowMediaStreamOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStream: MediaConnectClientTypes.MediaStream?
}

extension UpdateFlowMediaStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStream = "mediaStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStream.self, forKey: .mediaStream)
        mediaStream = mediaStreamDecoded
    }
}

enum UpdateFlowMediaStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct UpdateFlowOutput: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct UpdateFlowOutputBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
}

extension UpdateFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

enum UpdateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__string0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let maxLatency = self.maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for mediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(mediastreamoutputconfigurationrequest0)
            }
        }
        if let minLatency = self.minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = self.remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let senderIpAddress = self.senderIpAddress {
            try encodeContainer.encode(senderIpAddress, forKey: .senderIpAddress)
        }
        if let smoothingLatency = self.smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }
}

extension UpdateFlowOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let outputArn = outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the output.
public struct UpdateFlowOutputInput: Swift.Equatable {
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var cidrAllowList: [Swift.String]?
    /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
    public var description: Swift.String?
    /// The IP address where you want to send the output.
    public var destination: Swift.String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The flow that is associated with the output that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
    public var maxLatency: Swift.Int?
    /// The media streams that are associated with the output, and the parameters for those associations.
    public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
    public var minLatency: Swift.Int?
    /// The ARN of the output that you want to update.
    /// This member is required.
    public var outputArn: Swift.String?
    /// The port to use when content is distributed to this output.
    public var port: Swift.Int?
    /// The protocol to use for the output.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The remote ID for the Zixi-pull stream.
    public var remoteId: Swift.String?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public var smoothingLatency: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface attachment to use for this output.
    public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

    public init(
        cidrAllowList: [Swift.String]? = nil,
        description: Swift.String? = nil,
        destination: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        flowArn: Swift.String? = nil,
        maxLatency: Swift.Int? = nil,
        mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        outputArn: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        remoteId: Swift.String? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        smoothingLatency: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
    )
    {
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.flowArn = flowArn
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.outputArn = outputArn
        self.port = port
        self.`protocol` = `protocol`
        self.remoteId = remoteId
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

struct UpdateFlowOutputInputBody: Swift.Equatable {
    let cidrAllowList: [Swift.String]?
    let description: Swift.String?
    let destination: Swift.String?
    let encryption: MediaConnectClientTypes.UpdateEncryption?
    let maxLatency: Swift.Int?
    let mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    let minLatency: Swift.Int?
    let port: Swift.Int?
    let `protocol`: MediaConnectClientTypes.ModelProtocol?
    let remoteId: Swift.String?
    let senderControlPort: Swift.Int?
    let senderIpAddress: Swift.String?
    let smoothingLatency: Swift.Int?
    let streamId: Swift.String?
    let vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
}

extension UpdateFlowOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let senderIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIpAddress)
        senderIpAddress = senderIpAddressDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension UpdateFlowOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowOutputOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.output = output.output
        } else {
            self.flowArn = nil
            self.output = nil
        }
    }
}

public struct UpdateFlowOutputOutput: Swift.Equatable {
    /// The ARN of the flow that is associated with the updated output.
    public var flowArn: Swift.String?
    /// The new settings of the output that you updated.
    public var output: MediaConnectClientTypes.Output?

    public init(
        flowArn: Swift.String? = nil,
        output: MediaConnectClientTypes.Output? = nil
    )
    {
        self.flowArn = flowArn
        self.output = output
    }
}

struct UpdateFlowOutputOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let output: MediaConnectClientTypes.Output?
}

extension UpdateFlowOutputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case output = "output"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Output.self, forKey: .output)
        output = outputDecoded
    }
}

enum UpdateFlowOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case gatewayBridgeSource = "gatewayBridgeSource"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case sourceListenerAddress = "sourceListenerAddress"
        case sourceListenerPort = "sourceListenerPort"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = self.decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = self.entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let gatewayBridgeSource = self.gatewayBridgeSource {
            try encodeContainer.encode(gatewayBridgeSource, forKey: .gatewayBridgeSource)
        }
        if let ingestPort = self.ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = self.maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = self.maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for mediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(mediastreamsourceconfigurationrequest0)
            }
        }
        if let minLatency = self.minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let senderControlPort = self.senderControlPort {
            try encodeContainer.encode(senderControlPort, forKey: .senderControlPort)
        }
        if let senderIpAddress = self.senderIpAddress {
            try encodeContainer.encode(senderIpAddress, forKey: .senderIpAddress)
        }
        if let sourceListenerAddress = self.sourceListenerAddress {
            try encodeContainer.encode(sourceListenerAddress, forKey: .sourceListenerAddress)
        }
        if let sourceListenerPort = self.sourceListenerPort {
            try encodeContainer.encode(sourceListenerPort, forKey: .sourceListenerPort)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = self.vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = self.whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }
}

extension UpdateFlowSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let sourceArn = sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

/// A request to update the source of a flow.
public struct UpdateFlowSourceInput: Swift.Equatable {
    /// The type of encryption used on the content ingested from this source. Allowable encryption types: static-key.
    public var decryption: MediaConnectClientTypes.UpdateEncryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public var description: Swift.String?
    /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
    public var entitlementArn: Swift.String?
    /// The flow that is associated with the source that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public var gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?
    /// The port that the flow will be listening on for incoming content.
    public var ingestPort: Swift.Int?
    /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
    public var maxBitrate: Swift.Int?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
    public var maxLatency: Swift.Int?
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public var maxSyncBuffer: Swift.Int?
    /// The media streams that are associated with the source, and the parameters for those associations.
    public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
    public var minLatency: Swift.Int?
    /// The protocol that is used by the source.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The ARN of the source that you want to update.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source IP or domain name for SRT-caller protocol.
    public var sourceListenerAddress: Swift.String?
    /// Source port for SRT-caller protocol.
    public var sourceListenerPort: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface to use for this source.
    public var vpcInterfaceName: Swift.String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var whitelistCidr: Swift.String?

    public init(
        decryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        description: Swift.String? = nil,
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest? = nil,
        ingestPort: Swift.Int? = nil,
        maxBitrate: Swift.Int? = nil,
        maxLatency: Swift.Int? = nil,
        maxSyncBuffer: Swift.Int? = nil,
        mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceListenerAddress: Swift.String? = nil,
        sourceListenerPort: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil,
        whitelistCidr: Swift.String? = nil
    )
    {
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
        self.gatewayBridgeSource = gatewayBridgeSource
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.`protocol` = `protocol`
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.sourceArn = sourceArn
        self.sourceListenerAddress = sourceListenerAddress
        self.sourceListenerPort = sourceListenerPort
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

struct UpdateFlowSourceInputBody: Swift.Equatable {
    let decryption: MediaConnectClientTypes.UpdateEncryption?
    let description: Swift.String?
    let entitlementArn: Swift.String?
    let ingestPort: Swift.Int?
    let maxBitrate: Swift.Int?
    let maxLatency: Swift.Int?
    let maxSyncBuffer: Swift.Int?
    let mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    let minLatency: Swift.Int?
    let `protocol`: MediaConnectClientTypes.ModelProtocol?
    let senderControlPort: Swift.Int?
    let senderIpAddress: Swift.String?
    let sourceListenerAddress: Swift.String?
    let sourceListenerPort: Swift.Int?
    let streamId: Swift.String?
    let vpcInterfaceName: Swift.String?
    let whitelistCidr: Swift.String?
    let gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?
}

extension UpdateFlowSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case gatewayBridgeSource = "gatewayBridgeSource"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case senderControlPort = "senderControlPort"
        case senderIpAddress = "senderIpAddress"
        case sourceListenerAddress = "sourceListenerAddress"
        case sourceListenerPort = "sourceListenerPort"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let senderControlPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .senderControlPort)
        senderControlPort = senderControlPortDecoded
        let senderIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIpAddress)
        senderIpAddress = senderIpAddressDecoded
        let sourceListenerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceListenerAddress)
        sourceListenerAddress = sourceListenerAddressDecoded
        let sourceListenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sourceListenerPort)
        sourceListenerPort = sourceListenerPortDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
        let gatewayBridgeSourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest.self, forKey: .gatewayBridgeSource)
        gatewayBridgeSource = gatewayBridgeSourceDecoded
    }
}

extension UpdateFlowSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.source = output.source
        } else {
            self.flowArn = nil
            self.source = nil
        }
    }
}

public struct UpdateFlowSourceOutput: Swift.Equatable {
    /// The ARN of the flow that you want to update.
    public var flowArn: Swift.String?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.Source?

    public init(
        flowArn: Swift.String? = nil,
        source: MediaConnectClientTypes.Source? = nil
    )
    {
        self.flowArn = flowArn
        self.source = source
    }
}

struct UpdateFlowSourceOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let source: MediaConnectClientTypes.Source?
}

extension UpdateFlowSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case source = "source"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

enum UpdateFlowSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgeArn = "bridgeArn"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgeArn = self.bridgeArn {
            try encodeContainer.encode(bridgeArn, forKey: .bridgeArn)
        }
        if let vpcInterfaceAttachment = self.vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bridgeArn)
        bridgeArn = bridgeArnDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct UpdateGatewayBridgeSourceRequest: Swift.Equatable {
        /// The ARN of the bridge feeding this flow.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension UpdateGatewayInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgePlacement = "bridgePlacement"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bridgePlacement = self.bridgePlacement {
            try encodeContainer.encode(bridgePlacement.rawValue, forKey: .bridgePlacement)
        }
    }
}

extension UpdateGatewayInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayInstanceArn = gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

/// A request to update gateway instance state.
public struct UpdateGatewayInstanceInput: Swift.Equatable {
    /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The Amazon Resource Name (ARN) of the instance that you want to update.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

struct UpdateGatewayInstanceInputBody: Swift.Equatable {
    let bridgePlacement: MediaConnectClientTypes.BridgePlacement?
}

extension UpdateGatewayInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgePlacement = "bridgePlacement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgePlacementDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgePlacement.self, forKey: .bridgePlacement)
        bridgePlacement = bridgePlacementDecoded
    }
}

extension UpdateGatewayInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGatewayInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.bridgePlacement = output.bridgePlacement
            self.gatewayInstanceArn = output.gatewayInstanceArn
        } else {
            self.bridgePlacement = nil
            self.gatewayInstanceArn = nil
        }
    }
}

public struct UpdateGatewayInstanceOutput: Swift.Equatable {
    /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The Amazon Resource Name (ARN) of the instance.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

struct UpdateGatewayInstanceOutputBody: Swift.Equatable {
    let bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    let gatewayInstanceArn: Swift.String?
}

extension UpdateGatewayInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bridgePlacement = "bridgePlacement"
        case gatewayInstanceArn = "gatewayInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bridgePlacementDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.BridgePlacement.self, forKey: .bridgePlacement)
        bridgePlacement = bridgePlacementDecoded
        let gatewayInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayInstanceArn)
        gatewayInstanceArn = gatewayInstanceArnDecoded
    }
}

enum UpdateGatewayInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBitrate = "maxBitrate"
        case maxOutputs = "maxOutputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxOutputs = self.maxOutputs {
            try encodeContainer.encode(maxOutputs, forKey: .maxOutputs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxOutputsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxOutputs)
        maxOutputs = maxOutputsDecoded
    }
}

extension MediaConnectClientTypes {
    public struct UpdateIngressGatewayBridgeRequest: Swift.Equatable {
        /// The maximum expected bitrate (in bps).
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }

}

extension MediaConnectClientTypes.UpdateMaintenance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maintenanceDay = "maintenanceDay"
        case maintenanceScheduledDate = "maintenanceScheduledDate"
        case maintenanceStartHour = "maintenanceStartHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maintenanceDay = self.maintenanceDay {
            try encodeContainer.encode(maintenanceDay.rawValue, forKey: .maintenanceDay)
        }
        if let maintenanceScheduledDate = self.maintenanceScheduledDate {
            try encodeContainer.encode(maintenanceScheduledDate, forKey: .maintenanceScheduledDate)
        }
        if let maintenanceStartHour = self.maintenanceStartHour {
            try encodeContainer.encode(maintenanceStartHour, forKey: .maintenanceStartHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maintenanceDayDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MaintenanceDay.self, forKey: .maintenanceDay)
        maintenanceDay = maintenanceDayDecoded
        let maintenanceScheduledDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceScheduledDate)
        maintenanceScheduledDate = maintenanceScheduledDateDecoded
        let maintenanceStartHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceStartHour)
        maintenanceStartHour = maintenanceStartHourDecoded
    }
}

extension MediaConnectClientTypes {
    /// Update maintenance setting for a flow
    public struct UpdateMaintenance: Swift.Equatable {
        /// A day of a week when the maintenance will happen. use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }

}

extension MediaConnectClientTypes.VpcInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case networkInterfaceIds = "networkInterfaceIds"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceIds = networkInterfaceIds {
            var networkInterfaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceIds)
            for __string0 in networkInterfaceIds {
                try networkInterfaceIdsContainer.encode(__string0)
            }
        }
        if let networkInterfaceType = self.networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__string0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkInterfaceIds)
        var networkInterfaceIdsDecoded0:[Swift.String]? = nil
        if let networkInterfaceIdsContainer = networkInterfaceIdsContainer {
            networkInterfaceIdsDecoded0 = [Swift.String]()
            for string0 in networkInterfaceIdsContainer {
                if let string0 = string0 {
                    networkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        networkInterfaceIds = networkInterfaceIdsDecoded0
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for a VPC Source.
    public struct VpcInterface: Swift.Equatable {
        /// Immutable and has to be a unique against other VpcInterfaces in this Flow.
        /// This member is required.
        public var name: Swift.String?
        /// IDs of the network interfaces created in customer's account by MediaConnect.
        /// This member is required.
        public var networkInterfaceIds: [Swift.String]?
        /// The type of network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            networkInterfaceIds: [Swift.String]? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceIds = networkInterfaceIds
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }

}

extension MediaConnectClientTypes.VpcInterfaceAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaceName = self.vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for attaching a VPC interface to an resource.
    public struct VpcInterfaceAttachment: Swift.Equatable {
        /// The name of the VPC interface to use for this resource.
        public var vpcInterfaceName: Swift.String?

        public init(
            vpcInterfaceName: Swift.String? = nil
        )
        {
            self.vpcInterfaceName = vpcInterfaceName
        }
    }

}

extension MediaConnectClientTypes.VpcInterfaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceType = self.networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__string0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// Desired VPC Interface for a Flow
    public struct VpcInterfaceRequest: Swift.Equatable {
        /// The name of the VPC Interface. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of network interface. If this value is not included in the request, MediaConnect uses ENA as the networkInterfaceType.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }

}
