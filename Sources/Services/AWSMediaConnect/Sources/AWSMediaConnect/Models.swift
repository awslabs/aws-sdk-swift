//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct TagGlobalResourceOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagGlobalResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension MediaConnectClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cdi
        case fujitsuQos
        case ndiSpeedHq
        case rist
        case rtp
        case rtpFec
        case srtCaller
        case srtListener
        case st2110Jpegxs
        case udp
        case zixiPull
        case zixiPush
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .cdi,
                .fujitsuQos,
                .ndiSpeedHq,
                .rist,
                .rtp,
                .rtpFec,
                .srtCaller,
                .srtListener,
                .st2110Jpegxs,
                .udp,
                .zixiPull,
                .zixiPush
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cdi: return "cdi"
            case .fujitsuQos: return "fujitsu-qos"
            case .ndiSpeedHq: return "ndi-speed-hq"
            case .rist: return "rist"
            case .rtp: return "rtp"
            case .rtpFec: return "rtp-fec"
            case .srtCaller: return "srt-caller"
            case .srtListener: return "srt-listener"
            case .st2110Jpegxs: return "st2110-jpegxs"
            case .udp: return "udp"
            case .zixiPull: return "zixi-pull"
            case .zixiPush: return "zixi-push"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a network output to an existing bridge.
    public struct AddBridgeNetworkOutputRequest: Swift.Sendable {
        /// The network output IP Address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name. This name is used to reference the output and must be unique among outputs in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        ) {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

extension MediaConnectClientTypes {

    /// Add outputs to the specified bridge.
    public struct AddBridgeOutputRequest: Swift.Sendable {
        /// The network output of the bridge. A network output is delivered to your premises.
        public var networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest?

        public init(
            networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest? = nil
        ) {
            self.networkOutput = networkOutput
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for attaching a VPC interface to an resource.
    public struct VpcInterfaceAttachment: Swift.Sendable {
        /// The name of the VPC interface to use for this resource.
        public var vpcInterfaceName: Swift.String?

        public init(
            vpcInterfaceName: Swift.String? = nil
        ) {
            self.vpcInterfaceName = vpcInterfaceName
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a flow source to an existing bridge.
    public struct AddBridgeFlowSourceRequest: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the flow to use as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil
        ) {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings related to the multicast source.
    public struct MulticastSourceSettings: Swift.Sendable {
        /// The IP address of the source for source-specific multicast (SSM).
        public var multicastSourceIp: Swift.String?

        public init(
            multicastSourceIp: Swift.String? = nil
        ) {
            self.multicastSourceIp = multicastSourceIp
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a network source to an existing bridge.
    public struct AddBridgeNetworkSourceRequest: Swift.Sendable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The settings related to the multicast source.
        public var multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings?
        /// The name of the network source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        ) {
            self.multicastIp = multicastIp
            self.multicastSourceSettings = multicastSourceSettings
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

extension MediaConnectClientTypes {

    /// Add an output to a bridge.
    public struct AddBridgeSourceRequest: Swift.Sendable {
        /// The source of the flow.
        public var flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest?
        /// The source of the network.
        public var networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest?

        public init(
            flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest? = nil,
            networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest? = nil
        ) {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }
}

extension MediaConnectClientTypes {

    public enum Colorimetry: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bt2020
        case bt2100
        case bt601
        case bt709
        case st20651
        case st20653
        case xyz
        case sdkUnknown(Swift.String)

        public static var allCases: [Colorimetry] {
            return [
                .bt2020,
                .bt2100,
                .bt601,
                .bt709,
                .st20651,
                .st20653,
                .xyz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bt2020: return "BT2020"
            case .bt2100: return "BT2100"
            case .bt601: return "BT601"
            case .bt709: return "BT709"
            case .st20651: return "ST2065-1"
            case .st20653: return "ST2065-3"
            case .xyz: return "XYZ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Range: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case fullprotect
        case narrow
        case sdkUnknown(Swift.String)

        public static var allCases: [Range] {
            return [
                .full,
                .fullprotect,
                .narrow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .fullprotect: return "FULLPROTECT"
            case .narrow: return "NARROW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ScanMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interlace
        case progressive
        case progressiveSegmentedFrame
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanMode] {
            return [
                .interlace,
                .progressive,
                .progressiveSegmentedFrame
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interlace: return "interlace"
            case .progressive: return "progressive"
            case .progressiveSegmentedFrame: return "progressive-segmented-frame"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Tcs: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bt2100linhlg
        case bt2100linpq
        case density
        case hlg
        case linear
        case pq
        case sdr
        case st20651
        case st4281
        case sdkUnknown(Swift.String)

        public static var allCases: [Tcs] {
            return [
                .bt2100linhlg,
                .bt2100linpq,
                .density,
                .hlg,
                .linear,
                .pq,
                .sdr,
                .st20651,
                .st4281
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bt2100linhlg: return "BT2100LINHLG"
            case .bt2100linpq: return "BT2100LINPQ"
            case .density: return "DENSITY"
            case .hlg: return "HLG"
            case .linear: return "LINEAR"
            case .pq: return "PQ"
            case .sdr: return "SDR"
            case .st20651: return "ST2065-1"
            case .st4281: return "ST428-1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings that you want to use to define the media stream.
    public struct FmtpRequest: Swift.Sendable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance.
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        ) {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributesRequest: Swift.Sendable {
        /// The settings that you want to use to define the media stream.
        public var fmtp: MediaConnectClientTypes.FmtpRequest?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.FmtpRequest? = nil,
            lang: Swift.String? = nil
        ) {
            self.fmtp = fmtp
            self.lang = lang
        }
    }
}

extension MediaConnectClientTypes {

    public enum MediaStreamType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ancillaryData
        case audio
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .ancillaryData,
                .audio,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ancillaryData: return "ancillary-data"
            case .audio: return "audio"
            case .video: return "video"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that you want to add to the flow.
    public struct AddMediaStreamRequest: Swift.Sendable {
        /// The attributes that you want to assign to the new media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
        /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The key-value pairs that can be used to tag and organize the media stream.
        public var mediaStreamTags: [Swift.String: Swift.String]?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamTags: [Swift.String: Swift.String]? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        ) {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamTags = mediaStreamTags
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }
}

extension MediaConnectClientTypes {

    public enum Algorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case sdkUnknown(Swift.String)

        public static var allCases: [Algorithm] {
            return [
                .aes128,
                .aes192,
                .aes256
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "aes128"
            case .aes192: return "aes192"
            case .aes256: return "aes256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum KeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case speke
        case srtPassword
        case staticKey
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .speke,
                .srtPassword,
                .staticKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .speke: return "speke"
            case .srtPassword: return "srt-password"
            case .staticKey: return "static-key"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Information about the encryption of the flow.
    public struct Encryption: Swift.Sendable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The Amazon Web Services Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up MediaConnect as a trusted entity).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        ) {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }
}

extension MediaConnectClientTypes {

    /// The VPC interface that you want to designate where the media stream is coming from or going to.
    public struct InterfaceRequest: Swift.Sendable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The definition of a media stream that you want to associate with the output.
    public struct DestinationConfigurationRequest: Swift.Sendable {
        /// The IP address where you want MediaConnect to send contents of the media stream.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port that you want MediaConnect to use when it distributes the media stream to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that you want to use for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        ) {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    public enum EncodingName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jxsv
        case pcm
        case raw
        case smpte291
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingName] {
            return [
                .jxsv,
                .pcm,
                .raw,
                .smpte291
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jxsv: return "jxsv"
            case .pcm: return "pcm"
            case .raw: return "raw"
            case .smpte291: return "smpte291"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum EncoderProfile: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case main
        case sdkUnknown(Swift.String)

        public static var allCases: [EncoderProfile] {
            return [
                .high,
                .main
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .main: return "main"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParametersRequest: Swift.Sendable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, if at least one source on the flow uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        ) {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that you want to associate with the output, and the parameters for that association.
    public struct MediaStreamOutputConfigurationRequest: Swift.Sendable {
        /// The media streams that you want to associate with the output.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]?
        /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        public var encodingParameters: MediaConnectClientTypes.EncodingParametersRequest?
        /// The name of the media stream that is associated with the output.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParametersRequest? = nil,
            mediaStreamName: Swift.String? = nil
        ) {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    public enum OutputStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
    public struct AutomaticEncryptionKeyConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
    public struct SecretsManagerEncryptionKeyConfiguration: Swift.Sendable {
        /// The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the AWS Secrets Manager secret used for transit encryption.
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        ) {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for flow transit encryption keys.
    public enum FlowTransitEncryptionKeyConfiguration: Swift.Sendable {
        /// The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        case secretsmanager(MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration)
        /// Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        case automatic(MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum FlowTransitEncryptionKeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case secretsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowTransitEncryptionKeyType] {
            return [
                .automatic,
                .secretsManager
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .secretsManager: return "SECRETS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
    public struct FlowTransitEncryption: Swift.Sendable {
        /// The configuration details for the encryption key.
        /// This member is required.
        public var encryptionKeyConfiguration: MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration?
        /// The type of encryption key to use for flow transit encryption.
        public var encryptionKeyType: MediaConnectClientTypes.FlowTransitEncryptionKeyType?

        public init(
            encryptionKeyConfiguration: MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration? = nil,
            encryptionKeyType: MediaConnectClientTypes.FlowTransitEncryptionKeyType? = nil
        ) {
            self.encryptionKeyConfiguration = encryptionKeyConfiguration
            self.encryptionKeyType = encryptionKeyType
        }
    }
}

extension MediaConnectClientTypes {

    /// A request to add an output to a flow.
    public struct AddOutputRequest: Swift.Sendable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// A description of the output. This description appears only on the Audit Manager console and will not be seen by the end user.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The media streams that are associated with the output, and the parameters for those associations.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the output. This value must be unique within the current flow.
        public var name: Swift.String?
        /// A suffix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect uses the output name.
        public var ndiProgramName: Swift.String?
        /// A quality setting for the NDI Speed HQ encoder.
        public var ndiSpeedHqQuality: Swift.Int?
        /// An indication of whether the new output should be enabled or disabled as soon as it is created. If you don't specify the outputStatus field in your request, MediaConnect sets it to ENABLED.
        public var outputStatus: MediaConnectClientTypes.OutputStatus?
        /// The key-value pairs that can be used to tag and organize the output.
        public var outputTags: [Swift.String: Swift.String]?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// The protocol to use for the output. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull output stream.
        public var remoteId: Swift.String?
        /// Indicates whether to enable or disable router integration when creating a new flow output.
        public var routerIntegrationState: MediaConnectClientTypes.State?
        /// The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        public var routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            maxLatency: Swift.Int? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            ndiProgramName: Swift.String? = nil,
            ndiSpeedHqQuality: Swift.Int? = nil,
            outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
            outputTags: [Swift.String: Swift.String]? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            routerIntegrationState: MediaConnectClientTypes.State? = nil,
            routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
            senderControlPort: Swift.Int? = nil,
            smoothingLatency: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.cidrAllowList = cidrAllowList
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.maxLatency = maxLatency
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.minLatency = minLatency
            self.name = name
            self.ndiProgramName = ndiProgramName
            self.ndiSpeedHqQuality = ndiSpeedHqQuality
            self.outputStatus = outputStatus
            self.outputTags = outputTags
            self.port = port
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.routerIntegrationState = routerIntegrationState
            self.routerIntegrationTransitEncryption = routerIntegrationTransitEncryption
            self.senderControlPort = senderControlPort
            self.smoothingLatency = smoothingLatency
            self.streamId = streamId
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// Configures settings for the SilentAudio metric.
    public struct SilentAudio: Swift.Sendable {
        /// Indicates whether the SilentAudio metric is enabled or disabled.
        public var state: MediaConnectClientTypes.State?
        /// Specifies the number of consecutive seconds of silence that triggers an event or alert.
        public var thresholdSeconds: Swift.Int?

        public init(
            state: MediaConnectClientTypes.State? = nil,
            thresholdSeconds: Swift.Int? = nil
        ) {
            self.state = state
            self.thresholdSeconds = thresholdSeconds
        }
    }
}

extension MediaConnectClientTypes {

    /// Specifies the configuration for audio stream metrics monitoring.
    public struct AudioMonitoringSetting: Swift.Sendable {
        /// Detects periods of silence.
        public var silentAudio: MediaConnectClientTypes.SilentAudio?

        public init(
            silentAudio: MediaConnectClientTypes.SilentAudio? = nil
        ) {
            self.silentAudio = silentAudio
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge. A flow output is delivered to the Amazon Web Services cloud.
    public struct BridgeFlowOutput: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the cloud flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The Amazon Resource Number (ARN) of the flow source.
        /// This member is required.
        public var flowSourceArn: Swift.String?
        /// The name of the bridge's output.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowSourceArn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.flowArn = flowArn
            self.flowSourceArn = flowSourceArn
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge. A network output is delivered to your premises.
    public struct BridgeNetworkOutput: Swift.Sendable {
        /// The network output IP address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output's port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        ) {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge.
    public struct BridgeOutput: Swift.Sendable {
        /// The output of the associated flow.
        public var flowOutput: MediaConnectClientTypes.BridgeFlowOutput?
        /// The network output for the bridge.
        public var networkOutput: MediaConnectClientTypes.BridgeNetworkOutput?

        public init(
            flowOutput: MediaConnectClientTypes.BridgeFlowOutput? = nil,
            networkOutput: MediaConnectClientTypes.BridgeNetworkOutput? = nil
        ) {
            self.flowOutput = flowOutput
            self.networkOutput = networkOutput
        }
    }
}

extension MediaConnectClientTypes {

    /// The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
    public struct BridgeFlowSource: Swift.Sendable {
        /// The ARN of the cloud flow used as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Number (ARN) of the output.
        public var outputArn: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil
        ) {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
            self.outputArn = outputArn
        }
    }
}

extension MediaConnectClientTypes {

    /// The source of the bridge. A network source originates at your premises.
    public struct BridgeNetworkSource: Swift.Sendable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The settings related to the multicast source.
        public var multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings?
        /// The name of the network source.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        ) {
            self.multicastIp = multicastIp
            self.multicastSourceSettings = multicastSourceSettings
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

extension MediaConnectClientTypes {

    /// The bridge's source.
    public struct BridgeSource: Swift.Sendable {
        /// The source of the associated flow.
        public var flowSource: MediaConnectClientTypes.BridgeFlowSource?
        /// The network source for the bridge.
        public var networkSource: MediaConnectClientTypes.BridgeNetworkSource?

        public init(
            flowSource: MediaConnectClientTypes.BridgeFlowSource? = nil,
            networkSource: MediaConnectClientTypes.BridgeNetworkSource? = nil
        ) {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }
}

extension MediaConnectClientTypes {

    /// The VPC interface that is used for the media stream associated with the source or output.
    public struct Interface: Swift.Sendable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that you want to associate with an outbound media stream.
    public struct DestinationConfiguration: Swift.Sendable {
        /// The IP address where you want MediaConnect to send contents of the media stream.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port that you want MediaConnect to use when it distributes the media stream to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that you want to use for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?
        /// The IP address that the receiver requires in order to establish a connection with the flow. This value is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the CDI or ST 2110 JPEG XS or protocol.
        /// This member is required.
        public var outboundIp: Swift.String?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil,
            outboundIp: Swift.String? = nil
        ) {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
            self.outboundIp = outboundIp
        }
    }
}

extension MediaConnectClientTypes {

    public enum EntitlementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for a flow entitlement.
    public struct Entitlement: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// An indication of whether the entitlement is enabled.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        ) {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }
}

extension MediaConnectClientTypes {

    /// The network settings for a gateway.
    public struct GatewayNetwork: Swift.Sendable {
        /// A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var cidrBlock: Swift.String?
        /// The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            cidrBlock: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.cidrBlock = cidrBlock
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The entitlements that you want to grant on a flow.
    public struct GrantEntitlementRequest: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement. This description appears only on the MediaConnect console and will not be seen by the subscriber or end user.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement. Allowable encryption types: static-key, speke.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you don’t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The key-value pairs that can be used to tag and organize the entitlement.
        public var entitlementTags: [Swift.String: Swift.String]?
        /// The name of the entitlement. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The Amazon Web Services account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            entitlementTags: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        ) {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementStatus = entitlementStatus
            self.entitlementTags = entitlementTags
            self.name = name
            self.subscribers = subscribers
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that are associated with an incoming media stream.
    public struct InputConfiguration: Swift.Sendable {
        /// The IP address that the flow listens on for incoming content for a media stream.
        /// This member is required.
        public var inputIp: Swift.String?
        /// The port that the flow listens on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface where the media stream comes in from.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?

        public init(
            inputIp: Swift.String? = nil,
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil
        ) {
            self.inputIp = inputIp
            self.inputPort = inputPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that you want to associate with an incoming media stream.
    public struct InputConfigurationRequest: Swift.Sendable {
        /// The port that you want the flow to listen on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface that you want to use for the incoming media stream.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        ) {
            self.inputPort = inputPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    public enum BridgeState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case deploying
        case standby
        case starting
        case startFailed
        case startPending
        case stopping
        case stopFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgeState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .deploying,
                .standby,
                .starting,
                .startFailed,
                .startPending,
                .stopping,
                .stopFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deploying: return "DEPLOYING"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .startPending: return "START_PENDING"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Displays details of the selected bridge.
    public struct ListedBridge: Swift.Sendable {
        /// The ARN of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The state of the bridge.
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        /// The type of the bridge.
        /// This member is required.
        public var bridgeType: Swift.String?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the gateway associated with the bridge.
        /// This member is required.
        public var placementArn: Swift.String?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            bridgeType: Swift.String? = nil,
            name: Swift.String? = nil,
            placementArn: Swift.String? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.bridgeState = bridgeState
            self.bridgeType = bridgeType
            self.name = name
            self.placementArn = placementArn
        }
    }
}

extension MediaConnectClientTypes {

    /// An entitlement that has been granted to you from other Amazon Web Services accounts.
    public struct ListedEntitlement: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// The name of the entitlement.
        /// This member is required.
        public var entitlementName: Swift.String?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementName: Swift.String? = nil
        ) {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.entitlementArn = entitlementArn
            self.entitlementName = entitlementName
        }
    }
}

extension MediaConnectClientTypes {

    public enum MaintenanceDay: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceDay] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "Friday"
            case .monday: return "Monday"
            case .saturday: return "Saturday"
            case .sunday: return "Sunday"
            case .thursday: return "Thursday"
            case .tuesday: return "Tuesday"
            case .wednesday: return "Wednesday"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The maintenance setting of a flow.
    public struct Maintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// The Maintenance has to be performed before this deadline in ISO UTC format. Example: 2021-01-30T08:30:00Z.
        public var maintenanceDeadline: Swift.String?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceDeadline: Swift.String? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        ) {
            self.maintenanceDay = maintenanceDay
            self.maintenanceDeadline = maintenanceDeadline
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

extension MediaConnectClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .entitled,
                .owned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case error
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .deleting,
                .error,
                .standby,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A summary of a flow, including its ARN, Availability Zone, and source type.
    public struct ListedFlow: Swift.Sendable {
        /// The Availability Zone that the flow was created in.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow.
        /// This member is required.
        public var description: Swift.String?
        /// The ARN of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The maintenance settings for the flow.
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of source. This value is either owned (originated somewhere other than an MediaConnect flow owned by another Amazon Web Services account) or entitled (originated at a MediaConnect flow owned by another Amazon Web Services account).
        /// This member is required.
        public var sourceType: MediaConnectClientTypes.SourceType?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            flowArn: Swift.String? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            name: Swift.String? = nil,
            sourceType: MediaConnectClientTypes.SourceType? = nil,
            status: MediaConnectClientTypes.Status? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.description = description
            self.flowArn = flowArn
            self.maintenance = maintenance
            self.name = name
            self.sourceType = sourceType
            self.status = status
        }
    }
}

extension MediaConnectClientTypes {

    public enum GatewayState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .error,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A summary of a gateway, including its name, ARN, and status.
    public struct ListedGateway: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The status of the gateway.
        /// This member is required.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil
        ) {
            self.gatewayArn = gatewayArn
            self.gatewayState = gatewayState
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    public enum InstanceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deregistered
        case deregistering
        case deregistrationError
        case registering
        case registrationError
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceState] {
            return [
                .active,
                .deregistered,
                .deregistering,
                .deregistrationError,
                .registering,
                .registrationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .deregistrationError: return "DEREGISTRATION_ERROR"
            case .registering: return "REGISTERING"
            case .registrationError: return "REGISTRATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A summary of an instance.
    public struct ListedGatewayInstance: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The managed instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of the instance.
        public var instanceState: MediaConnectClientTypes.InstanceState?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil
        ) {
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceState = instanceState
        }
    }
}

extension MediaConnectClientTypes {

    /// A set of parameters that define the media stream.
    public struct Fmtp: Swift.Sendable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance.
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        ) {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributes: Swift.Sendable {
        /// The settings that you want to use to define the media stream.
        /// This member is required.
        public var fmtp: MediaConnectClientTypes.Fmtp?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.Fmtp? = nil,
            lang: Swift.String? = nil
        ) {
            self.fmtp = fmtp
            self.lang = lang
        }
    }
}

extension MediaConnectClientTypes {

    /// A media stream represents one component of your content, such as video, audio, or ancillary data. After you add a media stream to your flow, you can associate it with sources and outputs that use the ST 2110 JPEG XS or CDI protocol.
    public struct MediaStream: Swift.Sendable {
        /// Attributes that are related to the media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributes?
        /// The sample rate for the stream. This value is measured in Hz.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        /// This member is required.
        public var fmt: Swift.Int?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributes? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            fmt: Swift.Int? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        ) {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.fmt = fmt
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }
}

extension MediaConnectClientTypes {

    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParameters: Swift.Sendable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        ) {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that is associated with the output, and the parameters for that association.
    public struct MediaStreamOutputConfiguration: Swift.Sendable {
        /// The transport parameters that are associated with each outbound media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]?
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        public var encodingParameters: MediaConnectClientTypes.EncodingParameters?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParameters? = nil,
            mediaStreamName: Swift.String? = nil
        ) {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that is associated with the source, and the parameters for that association.
    public struct MediaStreamSourceConfiguration: Swift.Sendable {
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The media streams that you want to associate with the source.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfiguration]?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfiguration]? = nil,
            mediaStreamName: Swift.String? = nil
        ) {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that you want to associate with the source, and the parameters for that association.
    public struct MediaStreamSourceConfigurationRequest: Swift.Sendable {
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The media streams that you want to associate with the source.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]? = nil,
            mediaStreamName: Swift.String? = nil
        ) {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    /// The details of an error message.
    public struct MessageDetail: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: Swift.String?
        /// The specific error message that MediaConnect returns to help you understand the reason that the request did not succeed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceName: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.resourceName = resourceName
        }
    }
}

extension MediaConnectClientTypes {

    /// Specifies the configuration settings for individual NDI discovery servers. A maximum of 3 servers is allowed.
    public struct NdiDiscoveryServerConfig: Swift.Sendable {
        /// The unique network address of the NDI discovery server.
        /// This member is required.
        public var discoveryServerAddress: Swift.String?
        /// The port for the NDI discovery server. Defaults to 5959 if a custom port isn't specified.
        public var discoveryServerPort: Swift.Int?
        /// The identifier for the Virtual Private Cloud (VPC) network interface used by the flow.
        /// This member is required.
        public var vpcInterfaceAdapter: Swift.String?

        public init(
            discoveryServerAddress: Swift.String? = nil,
            discoveryServerPort: Swift.Int? = nil,
            vpcInterfaceAdapter: Swift.String? = nil
        ) {
            self.discoveryServerAddress = discoveryServerAddress
            self.discoveryServerPort = discoveryServerPort
            self.vpcInterfaceAdapter = vpcInterfaceAdapter
        }
    }
}

extension MediaConnectClientTypes {

    public enum DurationUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnits] {
            return [
                .months
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .months: return "MONTHS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum PriceUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hourly
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceUnits] {
            return [
                .hourly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hourly: return "HOURLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mbpsOutboundBandwidth
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .mbpsOutboundBandwidth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mbpsOutboundBandwidth: return "Mbps_Outbound_Bandwidth"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A definition of what is being billed for, including the type and amount.
    public struct ResourceSpecification: Swift.Sendable {
        /// The amount of outbound bandwidth that is discounted in the offering.
        public var reservedBitrate: Swift.Int?
        /// The type of resource and the unit that is being billed for.
        /// This member is required.
        public var resourceType: MediaConnectClientTypes.ResourceType?

        public init(
            reservedBitrate: Swift.Int? = nil,
            resourceType: MediaConnectClientTypes.ResourceType? = nil
        ) {
            self.reservedBitrate = reservedBitrate
            self.resourceType = resourceType
        }
    }
}

extension MediaConnectClientTypes {

    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public struct Offering: Swift.Sendable {
        /// The type of currency that is used for billing. The currencyCode used for all reservations is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that your reservation would be active.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil
        ) {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.resourceSpecification = resourceSpecification
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes related to the transport stream that are used in a source or output.
    public struct Transport: Swift.Sendable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16
        public var cidrAllowList: [Swift.String]?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// A suffix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect uses the output name.
        public var ndiProgramName: Swift.String?
        /// A quality setting for the NDI Speed HQ encoder.
        public var ndiSpeedHqQuality: Swift.Int?
        /// The protocol that is used by the source or output. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull stream.
        public var remoteId: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            minLatency: Swift.Int? = nil,
            ndiProgramName: Swift.String? = nil,
            ndiSpeedHqQuality: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            smoothingLatency: Swift.Int? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            streamId: Swift.String? = nil
        ) {
            self.cidrAllowList = cidrAllowList
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.minLatency = minLatency
            self.ndiProgramName = ndiProgramName
            self.ndiSpeedHqQuality = ndiSpeedHqQuality
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.smoothingLatency = smoothingLatency
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.streamId = streamId
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for an output.
    public struct Output: Swift.Sendable {
        /// The ARN of the bridge added to this output.
        public var bridgeArn: Swift.String?
        /// The bridge output ports currently in use.
        public var bridgePorts: [Swift.Int]?
        /// The ARN of the router input that's connected to this flow output.
        public var connectedRouterInputArn: Swift.String?
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the output.
        public var description: Swift.String?
        /// The address where you want to send the output.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.
        public var entitlementArn: Swift.String?
        /// The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.
        public var listenerAddress: Swift.String?
        /// The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.
        public var mediaLiveInputArn: Swift.String?
        /// The configuration for each media stream that is associated with the output.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]?
        /// The name of the output. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the output.
        /// This member is required.
        public var outputArn: Swift.String?
        /// An indication of whether the output is transmitting data or not.
        public var outputStatus: MediaConnectClientTypes.OutputStatus?
        /// The IP address of the device that is currently receiving content from this output.
        ///
        /// * For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.
        ///
        /// * For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.
        ///
        /// * Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.
        ///
        /// * The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.
        public var peerIpAddress: Swift.String?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// Indicates if router integration is enabled or disabled on the flow output.
        public var routerIntegrationState: MediaConnectClientTypes.State?
        /// The encryption configuration for the output when router integration is enabled.
        public var routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption?
        /// Attributes related to the transport stream that are used in the output.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgePorts: [Swift.Int]? = nil,
            connectedRouterInputArn: Swift.String? = nil,
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            listenerAddress: Swift.String? = nil,
            mediaLiveInputArn: Swift.String? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil,
            outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
            peerIpAddress: Swift.String? = nil,
            port: Swift.Int? = nil,
            routerIntegrationState: MediaConnectClientTypes.State? = nil,
            routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.bridgePorts = bridgePorts
            self.connectedRouterInputArn = connectedRouterInputArn
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.listenerAddress = listenerAddress
            self.mediaLiveInputArn = mediaLiveInputArn
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.name = name
            self.outputArn = outputArn
            self.outputStatus = outputStatus
            self.peerIpAddress = peerIpAddress
            self.port = port
            self.routerIntegrationState = routerIntegrationState
            self.routerIntegrationTransitEncryption = routerIntegrationTransitEncryption
            self.transport = transport
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    public enum ReservationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case expired
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservationState] {
            return [
                .active,
                .canceled,
                .expired,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public struct Reservation: Swift.Sendable {
        /// The type of currency that is used for billing. The currencyCode used for your reservation is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that this reservation is active. MediaConnect defines this value in the offering.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the reservation. MediaConnect defines this value in the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The day and time that this reservation expires. This value is calculated based on the start date and time that you set and the offering's duration.
        /// This member is required.
        public var end: Swift.String?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering. MediaConnect defines this value in the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the reservation when you purchase an offering.
        /// This member is required.
        public var reservationArn: Swift.String?
        /// The name that you assigned to the reservation when you purchased the offering.
        /// This member is required.
        public var reservationName: Swift.String?
        /// The status of your reservation.
        /// This member is required.
        public var reservationState: MediaConnectClientTypes.ReservationState?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering. MediaConnect defines the values that make up the resourceSpecification in the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?
        /// The day and time that the reservation becomes active. You set this value when you purchase the offering.
        /// This member is required.
        public var start: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            end: Swift.String? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            reservationArn: Swift.String? = nil,
            reservationName: Swift.String? = nil,
            reservationState: MediaConnectClientTypes.ReservationState? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil,
            start: Swift.String? = nil
        ) {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.end = end
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.reservationArn = reservationArn
            self.reservationName = reservationName
            self.reservationState = reservationState
            self.resourceSpecification = resourceSpecification
            self.start = start
        }
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct SetGatewayBridgeSourceRequest: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for the source of the flow.
    public struct SetSourceRequest: Swift.Sendable {
        /// The type of encryption that is used on the content ingested from this source. Allowable encryption types: static-key.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the source.
        public var name: Swift.String?
        /// The protocol that is used by the source. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// Indicates whether to enable or disable router integration when setting a flow source.
        public var routerIntegrationState: MediaConnectClientTypes.State?
        /// The decryption configuration for the flow source when router integration is enabled. Specifies how the source content should be decrypted when router integration is used.
        public var routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The key-value pairs that can be used to tag and organize the source.
        public var sourceTags: [Swift.String: Swift.String]?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface to use for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest? = nil,
            ingestPort: Swift.Int? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            routerIntegrationState: MediaConnectClientTypes.State? = nil,
            routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            sourceTags: [Swift.String: Swift.String]? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        ) {
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestPort = ingestPort
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.minLatency = minLatency
            self.name = name
            self.`protocol` = `protocol`
            self.routerIntegrationState = routerIntegrationState
            self.routerIntegrationTransitDecryption = routerIntegrationTransitDecryption
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.sourceTags = sourceTags
            self.streamId = streamId
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct GatewayBridgeSource: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for the source of the flow.
    public struct Source: Swift.Sendable {
        /// The ARN of the router output that's currently connected to this source.
        public var connectedRouterOutputArn: Swift.String?
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The type of encryption that is used on the content ingested from this source.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to content that comes from another Amazon Web Services account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource?
        /// The IP address that the flow will be listening on for incoming content.
        public var ingestIp: Swift.String?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]?
        /// The name of the source.
        /// This member is required.
        public var name: Swift.String?
        /// The IP address of the device that is currently sending content to this source.
        ///
        /// * For sources that use protocols where you specify the origin (such as SRT Caller), this value matches the configured origin address.
        ///
        /// * For sources that use listener protocols (such as SRT Listener or RTP), this value shows the address of the connected sender.
        ///
        /// * Peer IP addresses aren't available for entitlements and CDI/ST2110 sources.
        ///
        /// * The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.
        public var peerIpAddress: Swift.String?
        /// Indicates if router integration is enabled or disabled on the flow source.
        public var routerIntegrationState: MediaConnectClientTypes.State?
        /// The decryption configuration for the flow source when router integration is enabled.
        public var routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The ARN of the source.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// Attributes related to the transport stream that are used in the source.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface that is used for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            connectedRouterOutputArn: Swift.String? = nil,
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource? = nil,
            ingestIp: Swift.String? = nil,
            ingestPort: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil,
            name: Swift.String? = nil,
            peerIpAddress: Swift.String? = nil,
            routerIntegrationState: MediaConnectClientTypes.State? = nil,
            routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        ) {
            self.connectedRouterOutputArn = connectedRouterOutputArn
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestIp = ingestIp
            self.ingestPort = ingestPort
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.name = name
            self.peerIpAddress = peerIpAddress
            self.routerIntegrationState = routerIntegrationState
            self.routerIntegrationTransitDecryption = routerIntegrationTransitDecryption
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceArn = sourceArn
            self.transport = transport
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }
}

extension MediaConnectClientTypes {

    /// The frame resolution used by the video stream.
    public struct FrameResolution: Swift.Sendable {
        /// The number of pixels in the height of the video frame.
        /// This member is required.
        public var frameHeight: Swift.Int?
        /// The number of pixels in the width of the video frame.
        /// This member is required.
        public var frameWidth: Swift.Int?

        public init(
            frameHeight: Swift.Int? = nil,
            frameWidth: Swift.Int? = nil
        ) {
            self.frameHeight = frameHeight
            self.frameWidth = frameWidth
        }
    }
}

extension MediaConnectClientTypes {

    /// The metadata of an elementary transport stream.
    public struct TransportStream: Swift.Sendable {
        /// The number of channels in the audio stream.
        public var channels: Swift.Int?
        /// The codec used by the stream.
        public var codec: Swift.String?
        /// The frame rate used by the video stream.
        public var frameRate: Swift.String?
        /// The frame resolution used by the video stream.
        public var frameResolution: MediaConnectClientTypes.FrameResolution?
        /// The Packet ID (PID) as it is reported in the Program Map Table.
        /// This member is required.
        public var pid: Swift.Int?
        /// The sample rate used by the audio stream.
        public var sampleRate: Swift.Int?
        /// The sample bit size used by the audio stream.
        public var sampleSize: Swift.Int?
        /// The Stream Type as it is reported in the Program Map Table.
        /// This member is required.
        public var streamType: Swift.String?

        public init(
            channels: Swift.Int? = nil,
            codec: Swift.String? = nil,
            frameRate: Swift.String? = nil,
            frameResolution: MediaConnectClientTypes.FrameResolution? = nil,
            pid: Swift.Int? = nil,
            sampleRate: Swift.Int? = nil,
            sampleSize: Swift.Int? = nil,
            streamType: Swift.String? = nil
        ) {
            self.channels = channels
            self.codec = codec
            self.frameRate = frameRate
            self.frameResolution = frameResolution
            self.pid = pid
            self.sampleRate = sampleRate
            self.sampleSize = sampleSize
            self.streamType = streamType
        }
    }
}

extension MediaConnectClientTypes {

    /// The metadata of a single transport stream program.
    public struct TransportStreamProgram: Swift.Sendable {
        /// The Program Clock Reference (PCR) Packet ID (PID) as it is reported in the Program Association Table.
        /// This member is required.
        public var pcrPid: Swift.Int?
        /// The program name as it is reported in the Program Association Table.
        public var programName: Swift.String?
        /// The program number as it is reported in the Program Association Table.
        /// This member is required.
        public var programNumber: Swift.Int?
        /// The program Packet ID (PID) as it is reported in the Program Association Table.
        /// This member is required.
        public var programPid: Swift.Int?
        /// The list of elementary transport streams in the program. The list includes video, audio, and data streams.
        /// This member is required.
        public var streams: [MediaConnectClientTypes.TransportStream]?

        public init(
            pcrPid: Swift.Int? = nil,
            programName: Swift.String? = nil,
            programNumber: Swift.Int? = nil,
            programPid: Swift.Int? = nil,
            streams: [MediaConnectClientTypes.TransportStream]? = nil
        ) {
            self.pcrPid = pcrPid
            self.programName = programName
            self.programNumber = programNumber
            self.programPid = programPid
            self.streams = streams
        }
    }
}

extension MediaConnectClientTypes {

    /// Configures settings for the BlackFrames metric.
    public struct BlackFrames: Swift.Sendable {
        /// Indicates whether the BlackFrames metric is enabled or disabled..
        public var state: MediaConnectClientTypes.State?
        /// Specifies the number of consecutive seconds of black frames that triggers an event or alert.
        public var thresholdSeconds: Swift.Int?

        public init(
            state: MediaConnectClientTypes.State? = nil,
            thresholdSeconds: Swift.Int? = nil
        ) {
            self.state = state
            self.thresholdSeconds = thresholdSeconds
        }
    }
}

extension MediaConnectClientTypes {

    /// Configures settings for the FrozenFrames metric.
    public struct FrozenFrames: Swift.Sendable {
        /// Indicates whether the FrozenFrames metric is enabled or disabled.
        public var state: MediaConnectClientTypes.State?
        /// Specifies the number of consecutive seconds of a static image that triggers an event or alert.
        public var thresholdSeconds: Swift.Int?

        public init(
            state: MediaConnectClientTypes.State? = nil,
            thresholdSeconds: Swift.Int? = nil
        ) {
            self.state = state
            self.thresholdSeconds = thresholdSeconds
        }
    }
}

extension MediaConnectClientTypes {

    /// Specifies the configuration for video stream metrics monitoring.
    public struct VideoMonitoringSetting: Swift.Sendable {
        /// Detects video frames that are black.
        public var blackFrames: MediaConnectClientTypes.BlackFrames?
        /// Detects video frames that have not changed.
        public var frozenFrames: MediaConnectClientTypes.FrozenFrames?

        public init(
            blackFrames: MediaConnectClientTypes.BlackFrames? = nil,
            frozenFrames: MediaConnectClientTypes.FrozenFrames? = nil
        ) {
            self.blackFrames = blackFrames
            self.frozenFrames = frozenFrames
        }
    }
}

extension MediaConnectClientTypes {

    public enum NetworkInterfaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case efa
        case ena
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .efa,
                .ena
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .ena: return "ena"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for a VPC source.
    public struct VpcInterface: Swift.Sendable {
        /// Immutable and has to be a unique against other VpcInterfaces in this Flow.
        /// This member is required.
        public var name: Swift.String?
        /// IDs of the network interfaces created in customer's account by MediaConnect.
        /// This member is required.
        public var networkInterfaceIds: [Swift.String]?
        /// The type of network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// A role Arn MediaConnect can assume to create ENIs in your account.
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow.
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            networkInterfaceIds: [Swift.String]? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        ) {
            self.name = name
            self.networkInterfaceIds = networkInterfaceIds
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }
}

extension MediaConnectClientTypes {

    /// The details of the VPC interfaces that you want to add to the flow.
    public struct VpcInterfaceRequest: Swift.Sendable {
        /// The name for the VPC interface. This name must be unique within the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of network interface.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// The Amazon Resource Name (ARN) of the role that you created when you set up MediaConnect as a trusted service.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A virtual firewall to control inbound and outbound traffic.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The subnet IDs that you want to use for your VPC interface. A range of IP addresses in your VPC. When you create your VPC, you specify a range of IPv4 addresses for the VPC in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16. This is the primary CIDR block for your VPC. When you create a subnet for your VPC, you specify the CIDR block for the subnet, which is a subset of the VPC CIDR block. The subnets that you use across all VPC interfaces on the flow must be in the same Availability Zone as the flow.
        /// This member is required.
        public var subnetId: Swift.String?
        /// The key-value pairs that can be used to tag and organize the VPC network interface.
        public var vpcInterfaceTags: [Swift.String: Swift.String]?

        public init(
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil,
            vpcInterfaceTags: [Swift.String: Swift.String]? = nil
        ) {
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
            self.vpcInterfaceTags = vpcInterfaceTags
        }
    }
}

/// This exception is thrown if the request contains a semantic error. The precise meaning depends on the API, and is documented in the error message.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service is currently unavailable or busy.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AddBridgeOutputsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The outputs that you want to add to this bridge.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

public struct AddBridgeOutputsOutput: Swift.Sendable {
    /// The ARN of the bridge that you added outputs to.
    public var bridgeArn: Swift.String?
    /// The outputs that you added to this bridge.
    public var outputs: [MediaConnectClientTypes.BridgeOutput]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.BridgeOutput]? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

public struct AddBridgeSourcesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

public struct AddBridgeSourcesOutput: Swift.Sendable {
    /// The ARN of the bridge that you added sources to.
    public var bridgeArn: Swift.String?
    /// The sources that you added to this bridge.
    public var sources: [MediaConnectClientTypes.BridgeSource]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.BridgeSource]? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

extension MediaConnectClientTypes {

    /// Create a bridge with the egress bridge type. An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public struct AddEgressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps) of the egress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        ) {
            self.maxBitrate = maxBitrate
        }
    }
}

public struct AddFlowMediaStreamsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The media streams that you want to add to the flow.
    /// This member is required.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil
    ) {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

public struct AddFlowMediaStreamsOutput: Swift.Sendable {
    /// The ARN of the flow that you added media streams to.
    public var flowArn: Swift.String?
    /// The media streams that you added to the flow.
    public var mediaStreams: [MediaConnectClientTypes.MediaStream]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil
    ) {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

/// Exception raised by Elemental MediaConnect when adding the flow output. See the error message for the operation for more information on the cause of this exception.
public struct AddFlowOutputs420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AddFlowOutputs420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AddFlowOutputsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to add outputs to.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of outputs that you want to add to the flow.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil
    ) {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

public struct AddFlowOutputsOutput: Swift.Sendable {
    /// The ARN of the flow that these outputs were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added outputs.
    public var outputs: [MediaConnectClientTypes.Output]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.Output]? = nil
    ) {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

public struct AddFlowSourcesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of sources that you want to add to the flow.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil
    ) {
        self.flowArn = flowArn
        self.sources = sources
    }
}

public struct AddFlowSourcesOutput: Swift.Sendable {
    /// The ARN of the flow that these sources were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added sources.
    public var sources: [MediaConnectClientTypes.Source]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.Source]? = nil
    ) {
        self.flowArn = flowArn
        self.sources = sources
    }
}

public struct AddFlowVpcInterfacesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of VPC interfaces that you want to add to the flow.
    /// This member is required.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    ) {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

public struct AddFlowVpcInterfacesOutput: Swift.Sendable {
    /// The ARN of the flow that these VPC interfaces were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added VPC interfaces.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
    ) {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

extension MediaConnectClientTypes {

    /// Create a bridge with the ingress bridge type. An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public struct AddIngressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps) of the ingress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs on the ingress bridge.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        ) {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    /// Create a maintenance setting for a flow.
    public struct AddMaintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen.
        /// This member is required.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        /// This member is required.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceStartHour: Swift.String? = nil
        ) {
            self.maintenanceDay = maintenanceDay
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

public struct BatchGetRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Names (ARNs) of the router inputs you want to retrieve information about.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    ) {
        self.arns = arns
    }
}

extension MediaConnectClientTypes {

    /// An error that occurred when retrieving multiple router inputs in the BatchGetRouterInput operation, including the ARN, error code, and error message.
    public struct BatchGetRouterInputError: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router input for which the error occurred.
        /// This member is required.
        public var arn: Swift.String?
        /// The error code associated with the error.
        /// This member is required.
        public var code: Swift.String?
        /// A message describing the error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
    public struct RistRouterInputConfiguration: Swift.Sendable {
        /// The port number used for the RIST protocol in the router input configuration.
        /// This member is required.
        public var port: Swift.Int?
        /// The recovery latency in milliseconds for the RIST protocol in the router input configuration.
        /// This member is required.
        public var recoveryLatencyMilliseconds: Swift.Int?

        public init(
            port: Swift.Int? = nil,
            recoveryLatencyMilliseconds: Swift.Int? = nil
        ) {
            self.port = port
            self.recoveryLatencyMilliseconds = recoveryLatencyMilliseconds
        }
    }
}

extension MediaConnectClientTypes {

    public enum ForwardErrorCorrectionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ForwardErrorCorrectionState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
    public struct RtpRouterInputConfiguration: Swift.Sendable {
        /// The state of forward error correction for the RTP protocol in the router input configuration.
        public var forwardErrorCorrection: MediaConnectClientTypes.ForwardErrorCorrectionState?
        /// The port number used for the RTP protocol in the router input configuration.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            forwardErrorCorrection: MediaConnectClientTypes.ForwardErrorCorrectionState? = nil,
            port: Swift.Int? = nil
        ) {
            self.forwardErrorCorrection = forwardErrorCorrection
            self.port = port
        }
    }
}

extension MediaConnectClientTypes {

    /// Contains the configuration settings for decrypting SRT streams, including the encryption key details and decryption parameters.
    public struct SrtDecryptionConfiguration: Swift.Sendable {
        /// Specifies the encryption key configuration used for decrypting SRT streams, including the key source and associated credentials.
        /// This member is required.
        public var encryptionKey: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration?

        public init(
            encryptionKey: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration? = nil
        ) {
            self.encryptionKey = encryptionKey
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in caller mode, including the source address and port, minimum latency, stream ID, and decryption key configuration.
    public struct SrtCallerRouterInputConfiguration: Swift.Sendable {
        /// Specifies the decryption settings for an SRT caller input, including the encryption key configuration and associated parameters.
        public var decryptionConfiguration: MediaConnectClientTypes.SrtDecryptionConfiguration?
        /// The minimum latency in milliseconds for the SRT protocol in caller mode.
        /// This member is required.
        public var minimumLatencyMilliseconds: Swift.Int?
        /// The source IP address for the SRT protocol in caller mode.
        /// This member is required.
        public var sourceAddress: Swift.String?
        /// The source port number for the SRT protocol in caller mode.
        /// This member is required.
        public var sourcePort: Swift.Int?
        /// The stream ID for the SRT protocol in caller mode.
        public var streamId: Swift.String?

        public init(
            decryptionConfiguration: MediaConnectClientTypes.SrtDecryptionConfiguration? = nil,
            minimumLatencyMilliseconds: Swift.Int? = nil,
            sourceAddress: Swift.String? = nil,
            sourcePort: Swift.Int? = nil,
            streamId: Swift.String? = nil
        ) {
            self.decryptionConfiguration = decryptionConfiguration
            self.minimumLatencyMilliseconds = minimumLatencyMilliseconds
            self.sourceAddress = sourceAddress
            self.sourcePort = sourcePort
            self.streamId = streamId
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and decryption key configuration.
    public struct SrtListenerRouterInputConfiguration: Swift.Sendable {
        /// Specifies the decryption settings for an SRT listener input, including the encryption key configuration and associated parameters.
        public var decryptionConfiguration: MediaConnectClientTypes.SrtDecryptionConfiguration?
        /// The minimum latency in milliseconds for the SRT protocol in listener mode.
        /// This member is required.
        public var minimumLatencyMilliseconds: Swift.Int?
        /// The port number for the SRT protocol in listener mode.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            decryptionConfiguration: MediaConnectClientTypes.SrtDecryptionConfiguration? = nil,
            minimumLatencyMilliseconds: Swift.Int? = nil,
            port: Swift.Int? = nil
        ) {
            self.decryptionConfiguration = decryptionConfiguration
            self.minimumLatencyMilliseconds = minimumLatencyMilliseconds
            self.port = port
        }
    }
}

extension MediaConnectClientTypes {

    /// Protocol configuration settings for failover router inputs.
    public enum FailoverRouterInputProtocolConfiguration: Swift.Sendable {
        /// The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
        case rtp(MediaConnectClientTypes.RtpRouterInputConfiguration)
        /// The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
        case rist(MediaConnectClientTypes.RistRouterInputConfiguration)
        /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and decryption key configuration.
        case srtlistener(MediaConnectClientTypes.SrtListenerRouterInputConfiguration)
        /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in caller mode, including the source address and port, minimum latency, stream ID, and decryption key configuration.
        case srtcaller(MediaConnectClientTypes.SrtCallerRouterInputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum FailoverInputSourcePriorityMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noPriority
        case primarySecondary
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverInputSourcePriorityMode] {
            return [
                .noPriority,
                .primarySecondary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noPriority: return "NO_PRIORITY"
            case .primarySecondary: return "PRIMARY_SECONDARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for a failover router input that allows switching between two input sources.
    public struct FailoverRouterInputConfiguration: Swift.Sendable {
        /// The ARN of the network interface to use for this failover router input.
        /// This member is required.
        public var networkInterfaceArn: Swift.String?
        /// The index (0 or 1) that specifies which source in the protocol configurations list is currently active. Used to control which of the two failover sources is currently selected. This field is ignored when sourcePriorityMode is set to NO_PRIORITY
        public var primarySourceIndex: Swift.Int?
        /// A list of exactly two protocol configurations for the failover input sources. Both must use the same protocol type.
        /// This member is required.
        public var protocolConfigurations: [MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration]?
        /// The mode for determining source priority in failover configurations.
        /// This member is required.
        public var sourcePriorityMode: MediaConnectClientTypes.FailoverInputSourcePriorityMode?

        public init(
            networkInterfaceArn: Swift.String? = nil,
            primarySourceIndex: Swift.Int? = nil,
            protocolConfigurations: [MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration]? = nil,
            sourcePriorityMode: MediaConnectClientTypes.FailoverInputSourcePriorityMode? = nil
        ) {
            self.networkInterfaceArn = networkInterfaceArn
            self.primarySourceIndex = primarySourceIndex
            self.protocolConfigurations = protocolConfigurations
            self.sourcePriorityMode = sourcePriorityMode
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for connecting a router input to a flow output.
    public struct MediaConnectFlowRouterInputConfiguration: Swift.Sendable {
        /// The ARN of the flow to connect to.
        public var flowArn: Swift.String?
        /// The ARN of the flow output to connect to this router input.
        public var flowOutputArn: Swift.String?
        /// The decryption configuration for the flow source when connected to this router input.
        /// This member is required.
        public var sourceTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption?

        public init(
            flowArn: Swift.String? = nil,
            flowOutputArn: Swift.String? = nil,
            sourceTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption? = nil
        ) {
            self.flowArn = flowArn
            self.flowOutputArn = flowOutputArn
            self.sourceTransitDecryption = sourceTransitDecryption
        }
    }
}

extension MediaConnectClientTypes {

    /// Protocol configuration settings for merge router inputs.
    public enum MergeRouterInputProtocolConfiguration: Swift.Sendable {
        /// The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
        case rtp(MediaConnectClientTypes.RtpRouterInputConfiguration)
        /// The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
        case rist(MediaConnectClientTypes.RistRouterInputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for a merge router input that combines two input sources.
    public struct MergeRouterInputConfiguration: Swift.Sendable {
        /// The time window in milliseconds for merging the two input sources.
        /// This member is required.
        public var mergeRecoveryWindowMilliseconds: Swift.Int?
        /// The ARN of the network interface to use for this merge router input.
        /// This member is required.
        public var networkInterfaceArn: Swift.String?
        /// A list of exactly two protocol configurations for the merge input sources. Both must use the same protocol type.
        /// This member is required.
        public var protocolConfigurations: [MediaConnectClientTypes.MergeRouterInputProtocolConfiguration]?

        public init(
            mergeRecoveryWindowMilliseconds: Swift.Int? = nil,
            networkInterfaceArn: Swift.String? = nil,
            protocolConfigurations: [MediaConnectClientTypes.MergeRouterInputProtocolConfiguration]? = nil
        ) {
            self.mergeRecoveryWindowMilliseconds = mergeRecoveryWindowMilliseconds
            self.networkInterfaceArn = networkInterfaceArn
            self.protocolConfigurations = protocolConfigurations
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterInputProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rist
        case rtp
        case srtCaller
        case srtListener
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterInputProtocol] {
            return [
                .rist,
                .rtp,
                .srtCaller,
                .srtListener
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rist: return "RIST"
            case .rtp: return "RTP"
            case .srtCaller: return "SRT_CALLER"
            case .srtListener: return "SRT_LISTENER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The protocol configuration settings for a router input.
    public enum RouterInputProtocolConfiguration: Swift.Sendable {
        /// The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
        case rtp(MediaConnectClientTypes.RtpRouterInputConfiguration)
        /// The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
        case rist(MediaConnectClientTypes.RistRouterInputConfiguration)
        /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and decryption key configuration.
        case srtlistener(MediaConnectClientTypes.SrtListenerRouterInputConfiguration)
        /// The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in caller mode, including the source address and port, minimum latency, stream ID, and decryption key configuration.
        case srtcaller(MediaConnectClientTypes.SrtCallerRouterInputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a standard router input, including the protocol, protocol-specific configuration, network interface, and availability zone.
    public struct StandardRouterInputConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the network interface associated with the standard router input.
        /// This member is required.
        public var networkInterfaceArn: Swift.String?
        /// The protocol used by the standard router input.
        public var `protocol`: MediaConnectClientTypes.RouterInputProtocol?
        /// The configuration settings for the protocol used by the standard router input.
        /// This member is required.
        public var protocolConfiguration: MediaConnectClientTypes.RouterInputProtocolConfiguration?

        public init(
            networkInterfaceArn: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.RouterInputProtocol? = nil,
            protocolConfiguration: MediaConnectClientTypes.RouterInputProtocolConfiguration? = nil
        ) {
            self.networkInterfaceArn = networkInterfaceArn
            self.`protocol` = `protocol`
            self.protocolConfiguration = protocolConfiguration
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router input.
    public enum RouterInputConfiguration: Swift.Sendable {
        /// The configuration settings for a standard router input, including the protocol, protocol-specific configuration, network interface, and availability zone.
        case standard(MediaConnectClientTypes.StandardRouterInputConfiguration)
        /// Configuration settings for a failover router input that allows switching between two input sources.
        case failover(MediaConnectClientTypes.FailoverRouterInputConfiguration)
        /// Configuration settings for a merge router input that combines two input sources.
        case merge(MediaConnectClientTypes.MergeRouterInputConfiguration)
        /// Configuration settings for connecting a router input to a flow output.
        case mediaconnectflow(MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum RouterInputType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case mediaconnectFlow
        case merge
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterInputType] {
            return [
                .failover,
                .mediaconnectFlow,
                .merge,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .mediaconnectFlow: return "MEDIACONNECT_FLOW"
            case .merge: return "MERGE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for default maintenance scheduling.
    public struct DefaultMaintenanceConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension MediaConnectClientTypes {

    public enum Day: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [Day] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration for preferred day and time maintenance settings.
    public struct PreferredDayTimeMaintenanceConfiguration: Swift.Sendable {
        /// The preferred day for maintenance operations.
        /// This member is required.
        public var day: MediaConnectClientTypes.Day?
        /// The preferred time for maintenance operations.
        /// This member is required.
        public var time: Swift.String?

        public init(
            day: MediaConnectClientTypes.Day? = nil,
            time: Swift.String? = nil
        ) {
            self.day = day
            self.time = time
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
    public enum MaintenanceConfiguration: Swift.Sendable {
        /// Preferred day and time maintenance configuration settings.
        case preferreddaytime(MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration)
        /// Default maintenance configuration settings.
        case `default`(MediaConnectClientTypes.DefaultMaintenanceConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// Defines a specific time window for maintenance operations.
    public struct WindowMaintenanceSchedule: Swift.Sendable {
        /// The end time of the maintenance window.
        /// This member is required.
        public var end: Foundation.Date?
        /// The date and time when the maintenance window is scheduled to occur.
        /// This member is required.
        public var scheduledTime: Foundation.Date?
        /// The start time of the maintenance window.
        /// This member is required.
        public var start: Foundation.Date?

        public init(
            end: Foundation.Date? = nil,
            scheduledTime: Foundation.Date? = nil,
            start: Foundation.Date? = nil
        ) {
            self.end = end
            self.scheduledTime = scheduledTime
            self.start = start
        }
    }
}

extension MediaConnectClientTypes {

    /// The details of the maintenance schedule.
    public enum MaintenanceSchedule: Swift.Sendable {
        /// Defines a specific time window for maintenance operations.
        case window(MediaConnectClientTypes.WindowMaintenanceSchedule)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum MaintenanceScheduleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case window
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceScheduleType] {
            return [
                .window
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .window: return "WINDOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum MaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case preferredDayTime
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceType] {
            return [
                .default,
                .preferredDayTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .preferredDayTime: return "PREFERRED_DAY_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A message associated with a router input, including a code and a message.
    public struct RouterInputMessage: Swift.Sendable {
        /// The code associated with the router input message.
        /// This member is required.
        public var code: Swift.String?
        /// The message text associated with the router input message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
        }
    }
}

extension MediaConnectClientTypes {

    public enum RoutingScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingScope] {
            return [
                .global,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterInputState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case migrating
        case recovering
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterInputState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .migrating,
                .recovering,
                .standby,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .migrating: return "MIGRATING"
            case .recovering: return "RECOVERING"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for an indexed stream in a failover router input setup.
    public struct FailoverRouterInputIndexedStreamDetails: Swift.Sendable {
        /// The index number (0 or 1) assigned to this source in the failover configuration.
        /// This member is required.
        public var sourceIndex: Swift.Int?
        /// The IP address of the source for this indexed stream.
        public var sourceIpAddress: Swift.String?

        public init(
            sourceIndex: Swift.Int? = nil,
            sourceIpAddress: Swift.String? = nil
        ) {
            self.sourceIndex = sourceIndex
            self.sourceIpAddress = sourceIpAddress
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a failover router input that can automatically switch between two sources.
    public struct FailoverRouterInputStreamDetails: Swift.Sendable {
        /// Configuration details for the secondary source (index 1) in the failover setup.
        /// This member is required.
        public var sourceIndexOneStreamDetails: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails?
        /// Configuration details for the primary source (index 0) in the failover setup.
        /// This member is required.
        public var sourceIndexZeroStreamDetails: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails?

        public init(
            sourceIndexOneStreamDetails: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails? = nil,
            sourceIndexZeroStreamDetails: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails? = nil
        ) {
            self.sourceIndexOneStreamDetails = sourceIndexOneStreamDetails
            self.sourceIndexZeroStreamDetails = sourceIndexZeroStreamDetails
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a MediaConnect flow when used as a router input source.
    public struct MediaConnectFlowRouterInputStreamDetails: Swift.Sendable {

        public init() { }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for an indexed stream in a merge router input setup.
    public struct MergeRouterInputIndexedStreamDetails: Swift.Sendable {
        /// The index number (0 or 1) assigned to this source in the merge configuration.
        /// This member is required.
        public var sourceIndex: Swift.Int?
        /// The IP address of the source for this indexed stream in the merge setup.
        public var sourceIpAddress: Swift.String?

        public init(
            sourceIndex: Swift.Int? = nil,
            sourceIpAddress: Swift.String? = nil
        ) {
            self.sourceIndex = sourceIndex
            self.sourceIpAddress = sourceIpAddress
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a merge router input that combines two input sources.
    public struct MergeRouterInputStreamDetails: Swift.Sendable {
        /// Configuration details for the second source (index 1) in the merge setup.
        /// This member is required.
        public var sourceIndexOneStreamDetails: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails?
        /// Configuration details for the first source (index 0) in the merge setup.
        /// This member is required.
        public var sourceIndexZeroStreamDetails: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails?

        public init(
            sourceIndexOneStreamDetails: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails? = nil,
            sourceIndexZeroStreamDetails: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails? = nil
        ) {
            self.sourceIndexOneStreamDetails = sourceIndexOneStreamDetails
            self.sourceIndexZeroStreamDetails = sourceIndexZeroStreamDetails
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a standard router input stream type.
    public struct StandardRouterInputStreamDetails: Swift.Sendable {
        /// The source IP address for the standard router input stream.
        public var sourceIpAddress: Swift.String?

        public init(
            sourceIpAddress: Swift.String? = nil
        ) {
            self.sourceIpAddress = sourceIpAddress
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for the router input stream.
    public enum RouterInputStreamDetails: Swift.Sendable {
        /// Configuration details for a standard router input stream type.
        case standard(MediaConnectClientTypes.StandardRouterInputStreamDetails)
        /// Configuration details for a failover router input that can automatically switch between two sources.
        case failover(MediaConnectClientTypes.FailoverRouterInputStreamDetails)
        /// Configuration details for a merge router input that combines two input sources.
        case merge(MediaConnectClientTypes.MergeRouterInputStreamDetails)
        /// Configuration details for a MediaConnect flow when used as a router input source.
        case mediaconnectflow(MediaConnectClientTypes.MediaConnectFlowRouterInputStreamDetails)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum RouterInputTier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case input100
        case input20
        case input50
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterInputTier] {
            return [
                .input100,
                .input20,
                .input50
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .input100: return "INPUT_100"
            case .input20: return "INPUT_20"
            case .input50: return "INPUT_50"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Defines the configuration settings for transit encryption keys.
    public enum RouterInputTransitEncryptionKeyConfiguration: Swift.Sendable {
        /// The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        case secretsmanager(MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration)
        /// Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        case automatic(MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum RouterInputTransitEncryptionKeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case secretsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterInputTransitEncryptionKeyType] {
            return [
                .automatic,
                .secretsManager
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .secretsManager: return "SECRETS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The transit encryption settings for a router input.
    public struct RouterInputTransitEncryption: Swift.Sendable {
        /// Contains the configuration details for the encryption key used in transit encryption, including the key source and associated parameters.
        /// This member is required.
        public var encryptionKeyConfiguration: MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration?
        /// Specifies the type of encryption key to use for transit encryption.
        public var encryptionKeyType: MediaConnectClientTypes.RouterInputTransitEncryptionKeyType?

        public init(
            encryptionKeyConfiguration: MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration? = nil,
            encryptionKeyType: MediaConnectClientTypes.RouterInputTransitEncryptionKeyType? = nil
        ) {
            self.encryptionKeyConfiguration = encryptionKeyConfiguration
            self.encryptionKeyType = encryptionKeyType
        }
    }
}

extension MediaConnectClientTypes {

    /// A router input in AWS Elemental MediaConnect. A router input is a source of media content that can be routed to one or more router outputs.
    public struct RouterInput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router input.
        /// This member is required.
        public var arn: Swift.String?
        /// The Availability Zone of the router input.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// The configuration settings for a router input.
        /// This member is required.
        public var configuration: MediaConnectClientTypes.RouterInputConfiguration?
        /// The timestamp when the router input was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router input.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the router input.
        /// This member is required.
        public var inputType: MediaConnectClientTypes.RouterInputType?
        /// The IP address of the router input.
        public var ipAddress: Swift.String?
        /// The maintenance configuration settings applied to this router input.
        /// This member is required.
        public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
        /// The current maintenance schedule details for this router input.
        public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
        /// The type of maintenance schedule currently in effect for this router input.
        public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
        /// The type of maintenance configuration applied to this router input.
        /// This member is required.
        public var maintenanceType: MediaConnectClientTypes.MaintenanceType?
        /// The maximum bitrate for the router input.
        /// This member is required.
        public var maximumBitrate: Swift.Int?
        /// The maximum number of outputs that can be simultaneously routed to this input.
        public var maximumRoutedOutputs: Swift.Int?
        /// The messages associated with the router input.
        /// This member is required.
        public var messages: [MediaConnectClientTypes.RouterInputMessage]?
        /// The name of the router input.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS Region where the router input is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The number of router outputs associated with the router input.
        /// This member is required.
        public var routedOutputs: Swift.Int?
        /// Indicates whether the router input is configured for Regional or global routing.
        /// This member is required.
        public var routingScope: MediaConnectClientTypes.RoutingScope?
        /// The current state of the router input.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterInputState?
        /// Configuration details for the router input stream.
        /// This member is required.
        public var streamDetails: MediaConnectClientTypes.RouterInputStreamDetails?
        /// Key-value pairs that can be used to tag and organize this router input.
        /// This member is required.
        public var tags: [Swift.String: Swift.String]?
        /// The tier level of the router input.
        /// This member is required.
        public var tier: MediaConnectClientTypes.RouterInputTier?
        /// The transit encryption settings for a router input.
        /// This member is required.
        public var transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption?
        /// The timestamp when the router input was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            configuration: MediaConnectClientTypes.RouterInputConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            inputType: MediaConnectClientTypes.RouterInputType? = nil,
            ipAddress: Swift.String? = nil,
            maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
            maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
            maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
            maintenanceType: MediaConnectClientTypes.MaintenanceType? = nil,
            maximumBitrate: Swift.Int? = nil,
            maximumRoutedOutputs: Swift.Int? = nil,
            messages: [MediaConnectClientTypes.RouterInputMessage]? = nil,
            name: Swift.String? = nil,
            regionName: Swift.String? = nil,
            routedOutputs: Swift.Int? = nil,
            routingScope: MediaConnectClientTypes.RoutingScope? = nil,
            state: MediaConnectClientTypes.RouterInputState? = nil,
            streamDetails: MediaConnectClientTypes.RouterInputStreamDetails? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            tier: MediaConnectClientTypes.RouterInputTier? = nil,
            transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.configuration = configuration
            self.createdAt = createdAt
            self.id = id
            self.inputType = inputType
            self.ipAddress = ipAddress
            self.maintenanceConfiguration = maintenanceConfiguration
            self.maintenanceSchedule = maintenanceSchedule
            self.maintenanceScheduleType = maintenanceScheduleType
            self.maintenanceType = maintenanceType
            self.maximumBitrate = maximumBitrate
            self.maximumRoutedOutputs = maximumRoutedOutputs
            self.messages = messages
            self.name = name
            self.regionName = regionName
            self.routedOutputs = routedOutputs
            self.routingScope = routingScope
            self.state = state
            self.streamDetails = streamDetails
            self.tags = tags
            self.tier = tier
            self.transitEncryption = transitEncryption
            self.updatedAt = updatedAt
        }
    }
}

public struct BatchGetRouterInputOutput: Swift.Sendable {
    /// An array of errors that occurred when retrieving the requested router inputs.
    /// This member is required.
    public var errors: [MediaConnectClientTypes.BatchGetRouterInputError]?
    /// An array of router inputs that were successfully retrieved.
    /// This member is required.
    public var routerInputs: [MediaConnectClientTypes.RouterInput]?

    public init(
        errors: [MediaConnectClientTypes.BatchGetRouterInputError]? = nil,
        routerInputs: [MediaConnectClientTypes.RouterInput]? = nil
    ) {
        self.errors = errors
        self.routerInputs = routerInputs
    }
}

public struct BatchGetRouterNetworkInterfaceInput: Swift.Sendable {
    /// The Amazon Resource Names (ARNs) of the router network interfaces you want to retrieve information about.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    ) {
        self.arns = arns
    }
}

extension MediaConnectClientTypes {

    /// An error that occurred when retrieving multiple router network interfaces in the BatchGetRouterNetworkInterface operation, including the ARN, error code, and error message.
    public struct BatchGetRouterNetworkInterfaceError: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router network interface for which the error occurred.
        /// This member is required.
        public var arn: Swift.String?
        /// The error code associated with the error.
        /// This member is required.
        public var code: Swift.String?
        /// A message describing the error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }
}

extension MediaConnectClientTypes {

    /// A rule that allows a specific CIDR block to access the public router network interface.
    public struct PublicRouterNetworkInterfaceRule: Swift.Sendable {
        /// The CIDR block that is allowed to access the public router network interface.
        /// This member is required.
        public var cidr: Swift.String?

        public init(
            cidr: Swift.String? = nil
        ) {
            self.cidr = cidr
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a public router network interface, including the list of allowed CIDR blocks.
    public struct PublicRouterNetworkInterfaceConfiguration: Swift.Sendable {
        /// The list of allowed CIDR blocks for the public router network interface.
        /// This member is required.
        public var allowRules: [MediaConnectClientTypes.PublicRouterNetworkInterfaceRule]?

        public init(
            allowRules: [MediaConnectClientTypes.PublicRouterNetworkInterfaceRule]? = nil
        ) {
            self.allowRules = allowRules
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router network interface within a VPC, including the security group IDs and subnet ID.
    public struct VpcRouterNetworkInterfaceConfiguration: Swift.Sendable {
        /// The IDs of the security groups to associate with the router network interface within the VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// The ID of the subnet within the VPC to associate the router network interface with.
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        ) {
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router network interface.
    public enum RouterNetworkInterfaceConfiguration: Swift.Sendable {
        /// The configuration settings for a public router network interface, including the list of allowed CIDR blocks.
        case `public`(MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration)
        /// The configuration settings for a router network interface within a VPC, including the security group IDs and subnet ID.
        case vpc(MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum RouterNetworkInterfaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `public`
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterNetworkInterfaceType] {
            return [
                .public,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterNetworkInterfaceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case recovering
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterNetworkInterfaceState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .recovering,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .recovering: return "RECOVERING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A router network interface in AWS Elemental MediaConnect. A router network interface is a network interface that can be associated with one or more router inputs and outputs.
    public struct RouterNetworkInterface: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router network interface.
        /// This member is required.
        public var arn: Swift.String?
        /// The number of router inputs associated with the network interface.
        /// This member is required.
        public var associatedInputCount: Swift.Int?
        /// The number of router outputs associated with the network interface.
        /// This member is required.
        public var associatedOutputCount: Swift.Int?
        /// The configuration settings for a router network interface.
        /// This member is required.
        public var configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration?
        /// The timestamp when the router network interface was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router network interface.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the router network interface.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the router network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.RouterNetworkInterfaceType?
        /// The AWS Region where the router network interface is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The current state of the router network interface.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterNetworkInterfaceState?
        /// Key-value pairs that can be used to tag and organize this router network interface.
        /// This member is required.
        public var tags: [Swift.String: Swift.String]?
        /// The timestamp when the router network interface was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedInputCount: Swift.Int? = nil,
            associatedOutputCount: Swift.Int? = nil,
            configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.RouterNetworkInterfaceType? = nil,
            regionName: Swift.String? = nil,
            state: MediaConnectClientTypes.RouterNetworkInterfaceState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedInputCount = associatedInputCount
            self.associatedOutputCount = associatedOutputCount
            self.configuration = configuration
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.regionName = regionName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }
}

public struct BatchGetRouterNetworkInterfaceOutput: Swift.Sendable {
    /// An array of errors that occurred when retrieving the requested router network interfaces.
    /// This member is required.
    public var errors: [MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError]?
    /// An array of router network interfaces that were successfully retrieved.
    /// This member is required.
    public var routerNetworkInterfaces: [MediaConnectClientTypes.RouterNetworkInterface]?

    public init(
        errors: [MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError]? = nil,
        routerNetworkInterfaces: [MediaConnectClientTypes.RouterNetworkInterface]? = nil
    ) {
        self.errors = errors
        self.routerNetworkInterfaces = routerNetworkInterfaces
    }
}

public struct BatchGetRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Names (ARNs) of the router outputs you want to retrieve information about.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    ) {
        self.arns = arns
    }
}

extension MediaConnectClientTypes {

    /// An error that occurred when retrieving multiple router outputs in the BatchGetRouterOutput operation, including the ARN, error code, and error message.
    public struct BatchGetRouterOutputError: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router output for which the error occurred.
        /// This member is required.
        public var arn: Swift.String?
        /// The error code associated with the error.
        /// This member is required.
        public var code: Swift.String?
        /// A message describing the error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for connecting a router output to a MediaConnect flow source.
    public struct MediaConnectFlowRouterOutputConfiguration: Swift.Sendable {
        /// The encryption configuration for the flow destination when connected to this router output.
        /// This member is required.
        public var destinationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption?
        /// The ARN of the flow to connect to this router output.
        public var flowArn: Swift.String?
        /// The ARN of the flow source to connect to this router output.
        public var flowSourceArn: Swift.String?

        public init(
            destinationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
            flowArn: Swift.String? = nil,
            flowSourceArn: Swift.String? = nil
        ) {
            self.destinationTransitEncryption = destinationTransitEncryption
            self.flowArn = flowArn
            self.flowSourceArn = flowSourceArn
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for the MediaLive transit encryption key.
    public enum MediaLiveTransitEncryptionKeyConfiguration: Swift.Sendable {
        /// The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        case secretsmanager(MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration)
        /// Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        case automatic(MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum MediaLiveTransitEncryptionKeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case secretsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaLiveTransitEncryptionKeyType] {
            return [
                .automatic,
                .secretsManager
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .secretsManager: return "SECRETS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The encryption configuration that defines how content is encrypted during transit between MediaConnect Router and MediaLive. This configuration determines whether encryption keys are automatically managed by the service or manually managed through AWS Secrets Manager.
    public struct MediaLiveTransitEncryption: Swift.Sendable {
        /// The configuration details for the MediaLive encryption key.
        /// This member is required.
        public var encryptionKeyConfiguration: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration?
        /// The type of encryption key to use for MediaLive transit encryption.
        public var encryptionKeyType: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyType?

        public init(
            encryptionKeyConfiguration: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration? = nil,
            encryptionKeyType: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyType? = nil
        ) {
            self.encryptionKeyConfiguration = encryptionKeyConfiguration
            self.encryptionKeyType = encryptionKeyType
        }
    }
}

extension MediaConnectClientTypes {

    public enum MediaLiveInputPipelineId: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pipeline0
        case pipeline1
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaLiveInputPipelineId] {
            return [
                .pipeline0,
                .pipeline1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pipeline0: return "PIPELINE_0"
            case .pipeline1: return "PIPELINE_1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration settings for connecting a router output to a MediaLive input.
    public struct MediaLiveInputRouterOutputConfiguration: Swift.Sendable {
        /// The encryption configuration for the MediaLive input when connected to this router output.
        /// This member is required.
        public var destinationTransitEncryption: MediaConnectClientTypes.MediaLiveTransitEncryption?
        /// The ARN of the MediaLive input to connect to this router output.
        public var mediaLiveInputArn: Swift.String?
        /// The index of the MediaLive pipeline to connect to this router output.
        public var mediaLivePipelineId: MediaConnectClientTypes.MediaLiveInputPipelineId?

        public init(
            destinationTransitEncryption: MediaConnectClientTypes.MediaLiveTransitEncryption? = nil,
            mediaLiveInputArn: Swift.String? = nil,
            mediaLivePipelineId: MediaConnectClientTypes.MediaLiveInputPipelineId? = nil
        ) {
            self.destinationTransitEncryption = destinationTransitEncryption
            self.mediaLiveInputArn = mediaLiveInputArn
            self.mediaLivePipelineId = mediaLivePipelineId
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterOutputProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rist
        case rtp
        case srtCaller
        case srtListener
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterOutputProtocol] {
            return [
                .rist,
                .rtp,
                .srtCaller,
                .srtListener
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rist: return "RIST"
            case .rtp: return "RTP"
            case .srtCaller: return "SRT_CALLER"
            case .srtListener: return "SRT_LISTENER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router output using the RIST (Reliable Internet Stream Transport) protocol, including the destination address and port.
    public struct RistRouterOutputConfiguration: Swift.Sendable {
        /// The destination IP address for the RIST protocol in the router output configuration.
        /// This member is required.
        public var destinationAddress: Swift.String?
        /// The destination port number for the RIST protocol in the router output configuration.
        /// This member is required.
        public var destinationPort: Swift.Int?

        public init(
            destinationAddress: Swift.String? = nil,
            destinationPort: Swift.Int? = nil
        ) {
            self.destinationAddress = destinationAddress
            self.destinationPort = destinationPort
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router output using the RTP (Real-Time Transport Protocol) protocol, including the destination address and port, and forward error correction state.
    public struct RtpRouterOutputConfiguration: Swift.Sendable {
        /// The destination IP address for the RTP protocol in the router output configuration.
        /// This member is required.
        public var destinationAddress: Swift.String?
        /// The destination port number for the RTP protocol in the router output configuration.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The state of forward error correction for the RTP protocol in the router output configuration.
        public var forwardErrorCorrection: MediaConnectClientTypes.ForwardErrorCorrectionState?

        public init(
            destinationAddress: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            forwardErrorCorrection: MediaConnectClientTypes.ForwardErrorCorrectionState? = nil
        ) {
            self.destinationAddress = destinationAddress
            self.destinationPort = destinationPort
            self.forwardErrorCorrection = forwardErrorCorrection
        }
    }
}

extension MediaConnectClientTypes {

    /// Contains the configuration settings for encrypting SRT streams, including the encryption key details and encryption parameters.
    public struct SrtEncryptionConfiguration: Swift.Sendable {
        /// Specifies the encryption key configuration used for encrypting SRT streams, including the key source and associated credentials.
        /// This member is required.
        public var encryptionKey: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration?

        public init(
            encryptionKey: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration? = nil
        ) {
            self.encryptionKey = encryptionKey
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in caller mode, including the destination address and port, minimum latency, stream ID, and encryption key configuration.
    public struct SrtCallerRouterOutputConfiguration: Swift.Sendable {
        /// The destination IP address for the SRT protocol in caller mode.
        /// This member is required.
        public var destinationAddress: Swift.String?
        /// The destination port number for the SRT protocol in caller mode.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// Defines the encryption settings for an SRT caller output, including the encryption key configuration and associated parameters.
        public var encryptionConfiguration: MediaConnectClientTypes.SrtEncryptionConfiguration?
        /// The minimum latency in milliseconds for the SRT protocol in caller mode.
        /// This member is required.
        public var minimumLatencyMilliseconds: Swift.Int?
        /// The stream ID for the SRT protocol in caller mode.
        public var streamId: Swift.String?

        public init(
            destinationAddress: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            encryptionConfiguration: MediaConnectClientTypes.SrtEncryptionConfiguration? = nil,
            minimumLatencyMilliseconds: Swift.Int? = nil,
            streamId: Swift.String? = nil
        ) {
            self.destinationAddress = destinationAddress
            self.destinationPort = destinationPort
            self.encryptionConfiguration = encryptionConfiguration
            self.minimumLatencyMilliseconds = minimumLatencyMilliseconds
            self.streamId = streamId
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and encryption key configuration.
    public struct SrtListenerRouterOutputConfiguration: Swift.Sendable {
        /// Defines the encryption settings for an SRT listener output, including the encryption key configuration and associated parameters.
        public var encryptionConfiguration: MediaConnectClientTypes.SrtEncryptionConfiguration?
        /// The minimum latency in milliseconds for the SRT protocol in listener mode.
        /// This member is required.
        public var minimumLatencyMilliseconds: Swift.Int?
        /// The port number for the SRT protocol in listener mode.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            encryptionConfiguration: MediaConnectClientTypes.SrtEncryptionConfiguration? = nil,
            minimumLatencyMilliseconds: Swift.Int? = nil,
            port: Swift.Int? = nil
        ) {
            self.encryptionConfiguration = encryptionConfiguration
            self.minimumLatencyMilliseconds = minimumLatencyMilliseconds
            self.port = port
        }
    }
}

extension MediaConnectClientTypes {

    /// The protocol configuration settings for a router output.
    public enum RouterOutputProtocolConfiguration: Swift.Sendable {
        /// The configuration settings for a router output using the RTP (Real-Time Transport Protocol) protocol, including the destination address and port, and forward error correction state.
        case rtp(MediaConnectClientTypes.RtpRouterOutputConfiguration)
        /// The configuration settings for a router output using the RIST (Reliable Internet Stream Transport) protocol, including the destination address and port.
        case rist(MediaConnectClientTypes.RistRouterOutputConfiguration)
        /// The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and encryption key configuration.
        case srtlistener(MediaConnectClientTypes.SrtListenerRouterOutputConfiguration)
        /// The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in caller mode, including the destination address and port, minimum latency, stream ID, and encryption key configuration.
        case srtcaller(MediaConnectClientTypes.SrtCallerRouterOutputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a standard router output, including the protocol, protocol-specific configuration, network interface, and availability zone.
    public struct StandardRouterOutputConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the network interface associated with the standard router output.
        /// This member is required.
        public var networkInterfaceArn: Swift.String?
        /// The protocol used by the standard router output.
        public var `protocol`: MediaConnectClientTypes.RouterOutputProtocol?
        /// The configuration settings for the protocol used by the standard router output.
        /// This member is required.
        public var protocolConfiguration: MediaConnectClientTypes.RouterOutputProtocolConfiguration?

        public init(
            networkInterfaceArn: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.RouterOutputProtocol? = nil,
            protocolConfiguration: MediaConnectClientTypes.RouterOutputProtocolConfiguration? = nil
        ) {
            self.networkInterfaceArn = networkInterfaceArn
            self.`protocol` = `protocol`
            self.protocolConfiguration = protocolConfiguration
        }
    }
}

extension MediaConnectClientTypes {

    /// The configuration settings for a router output.
    public enum RouterOutputConfiguration: Swift.Sendable {
        /// The configuration settings for a standard router output, including the protocol, protocol-specific configuration, network interface, and availability zone.
        case standard(MediaConnectClientTypes.StandardRouterOutputConfiguration)
        /// Configuration settings for connecting a router output to a MediaConnect flow source.
        case mediaconnectflow(MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration)
        /// Configuration settings for connecting a router output to a MediaLive input.
        case medialiveinput(MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// A message associated with a router output.
    public struct RouterOutputMessage: Swift.Sendable {
        /// The code associated with the router output message.
        /// This member is required.
        public var code: Swift.String?
        /// The message text associated with the router output message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterOutputType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mediaconnectFlow
        case medialiveInput
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterOutputType] {
            return [
                .mediaconnectFlow,
                .medialiveInput,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mediaconnectFlow: return "MEDIACONNECT_FLOW"
            case .medialiveInput: return "MEDIALIVE_INPUT"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterOutputRoutedState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case routed
        case routing
        case unrouted
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterOutputRoutedState] {
            return [
                .routed,
                .routing,
                .unrouted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .routed: return "ROUTED"
            case .routing: return "ROUTING"
            case .unrouted: return "UNROUTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum RouterOutputState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case migrating
        case recovering
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterOutputState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .migrating,
                .recovering,
                .standby,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .migrating: return "MIGRATING"
            case .recovering: return "RECOVERING"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a MediaConnect flow when used as a router output destination.
    public struct MediaConnectFlowRouterOutputStreamDetails: Swift.Sendable {

        public init() { }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a MediaLive input when used as a router output destination.
    public struct MediaLiveInputRouterOutputStreamDetails: Swift.Sendable {

        public init() { }
    }
}

extension MediaConnectClientTypes {

    /// Configuration details for a standard router output stream type. Contains information about the destination IP address and connection state for basic output routing.
    public struct StandardRouterOutputStreamDetails: Swift.Sendable {
        /// The IP address where the output stream will be sent. This is the destination address that will receive the routed media content.
        public var destinationIpAddress: Swift.String?

        public init(
            destinationIpAddress: Swift.String? = nil
        ) {
            self.destinationIpAddress = destinationIpAddress
        }
    }
}

extension MediaConnectClientTypes {

    /// Information about the router output's stream, including connection state and destination details. The specific details provided vary based on the router output type.
    public enum RouterOutputStreamDetails: Swift.Sendable {
        /// Configuration details for a standard router output stream type. Contains information about the destination IP address and connection state for basic output routing.
        case standard(MediaConnectClientTypes.StandardRouterOutputStreamDetails)
        /// Configuration details for a MediaConnect flow when used as a router output destination.
        case mediaconnectflow(MediaConnectClientTypes.MediaConnectFlowRouterOutputStreamDetails)
        /// Configuration details for a MediaLive input when used as a router output destination.
        case medialiveinput(MediaConnectClientTypes.MediaLiveInputRouterOutputStreamDetails)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    public enum RouterOutputTier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case output100
        case output20
        case output50
        case sdkUnknown(Swift.String)

        public static var allCases: [RouterOutputTier] {
            return [
                .output100,
                .output20,
                .output50
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .output100: return "OUTPUT_100"
            case .output20: return "OUTPUT_20"
            case .output50: return "OUTPUT_50"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A router output in AWS Elemental MediaConnect. A router output is a destination for media content that can receive input from one or more router inputs.
    public struct RouterOutput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router output.
        /// This member is required.
        public var arn: Swift.String?
        /// The Availability Zone of the router output.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// The configuration settings for a router output.
        /// This member is required.
        public var configuration: MediaConnectClientTypes.RouterOutputConfiguration?
        /// The timestamp when the router output was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router output.
        /// This member is required.
        public var id: Swift.String?
        /// The IP address of the router output.
        public var ipAddress: Swift.String?
        /// The maintenance configuration settings applied to this router output.
        /// This member is required.
        public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
        /// The current maintenance schedule details for this router output.
        public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
        /// The type of maintenance schedule currently in effect for this router output.
        public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
        /// The type of maintenance configuration applied to this router output.
        /// This member is required.
        public var maintenanceType: MediaConnectClientTypes.MaintenanceType?
        /// The maximum bitrate for the router output.
        /// This member is required.
        public var maximumBitrate: Swift.Int?
        /// The messages associated with the router output.
        /// This member is required.
        public var messages: [MediaConnectClientTypes.RouterOutputMessage]?
        /// The name of the router output.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the router output.
        /// This member is required.
        public var outputType: MediaConnectClientTypes.RouterOutputType?
        /// The AWS Region where the router output is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the router input associated with the output.
        public var routedInputArn: Swift.String?
        /// The current state of the association between the router output and its input.
        /// This member is required.
        public var routedState: MediaConnectClientTypes.RouterOutputRoutedState?
        /// Indicates whether the router output is configured for Regional or global routing.
        /// This member is required.
        public var routingScope: MediaConnectClientTypes.RoutingScope?
        /// The overall state of the router output.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterOutputState?
        /// Information about the router output's stream, including connection state and destination details. The specific details provided vary based on the router output type.
        /// This member is required.
        public var streamDetails: MediaConnectClientTypes.RouterOutputStreamDetails?
        /// Key-value pairs that can be used to tag and organize this router output.
        /// This member is required.
        public var tags: [Swift.String: Swift.String]?
        /// The tier level of the router output.
        /// This member is required.
        public var tier: MediaConnectClientTypes.RouterOutputTier?
        /// The timestamp when the router output was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            configuration: MediaConnectClientTypes.RouterOutputConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
            maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
            maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
            maintenanceType: MediaConnectClientTypes.MaintenanceType? = nil,
            maximumBitrate: Swift.Int? = nil,
            messages: [MediaConnectClientTypes.RouterOutputMessage]? = nil,
            name: Swift.String? = nil,
            outputType: MediaConnectClientTypes.RouterOutputType? = nil,
            regionName: Swift.String? = nil,
            routedInputArn: Swift.String? = nil,
            routedState: MediaConnectClientTypes.RouterOutputRoutedState? = nil,
            routingScope: MediaConnectClientTypes.RoutingScope? = nil,
            state: MediaConnectClientTypes.RouterOutputState? = nil,
            streamDetails: MediaConnectClientTypes.RouterOutputStreamDetails? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            tier: MediaConnectClientTypes.RouterOutputTier? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.configuration = configuration
            self.createdAt = createdAt
            self.id = id
            self.ipAddress = ipAddress
            self.maintenanceConfiguration = maintenanceConfiguration
            self.maintenanceSchedule = maintenanceSchedule
            self.maintenanceScheduleType = maintenanceScheduleType
            self.maintenanceType = maintenanceType
            self.maximumBitrate = maximumBitrate
            self.messages = messages
            self.name = name
            self.outputType = outputType
            self.regionName = regionName
            self.routedInputArn = routedInputArn
            self.routedState = routedState
            self.routingScope = routingScope
            self.state = state
            self.streamDetails = streamDetails
            self.tags = tags
            self.tier = tier
            self.updatedAt = updatedAt
        }
    }
}

public struct BatchGetRouterOutputOutput: Swift.Sendable {
    /// An array of errors that occurred when retrieving the requested router outputs.
    /// This member is required.
    public var errors: [MediaConnectClientTypes.BatchGetRouterOutputError]?
    /// An array of router outputs that were successfully retrieved.
    /// This member is required.
    public var routerOutputs: [MediaConnectClientTypes.RouterOutput]?

    public init(
        errors: [MediaConnectClientTypes.BatchGetRouterOutputError]? = nil,
        routerOutputs: [MediaConnectClientTypes.RouterOutput]? = nil
    ) {
        self.errors = errors
        self.routerOutputs = routerOutputs
    }
}

extension MediaConnectClientTypes {

    /// Create a bridge with the egress bridge type. An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public struct EgressGatewayBridge: Swift.Sendable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the egress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil
        ) {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
        }
    }
}

extension MediaConnectClientTypes {

    /// Create a bridge with the ingress bridge type. An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public struct IngressGatewayBridge: Swift.Sendable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the ingress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of outputs on the ingress bridge.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        ) {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    public enum FailoverMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case merge
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverMode] {
            return [
                .failover,
                .merge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .merge: return "MERGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
    public struct SourcePriority: Swift.Sendable {
        /// The name of the source you choose as the primary source for this flow.
        public var primarySource: Swift.String?

        public init(
            primarySource: Swift.String? = nil
        ) {
            self.primarySource = primarySource
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source failover.
    public struct FailoverConfig: Swift.Sendable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Search window time to look for dash-7 packets.
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        /// The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        ) {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }
}

extension MediaConnectClientTypes {

    /// A Bridge is the connection between your data center's Instances and the Amazon Web Services cloud. A bridge can be used to send video from the Amazon Web Services cloud to your data center or from your data center to the Amazon Web Services cloud.
    public struct Bridge: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// Messages with details about the bridge.
        public var bridgeMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The state of the bridge.
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        /// An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
        public var egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge?
        /// An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
        public var ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs on this bridge.
        public var outputs: [MediaConnectClientTypes.BridgeOutput]?
        /// The placement Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var placementArn: Swift.String?
        /// The settings for source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        /// The sources on this bridge.
        public var sources: [MediaConnectClientTypes.BridgeSource]?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge? = nil,
            ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.BridgeOutput]? = nil,
            placementArn: Swift.String? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sources: [MediaConnectClientTypes.BridgeSource]? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.bridgeMessages = bridgeMessages
            self.bridgeState = bridgeState
            self.egressGatewayBridge = egressGatewayBridge
            self.ingressGatewayBridge = ingressGatewayBridge
            self.name = name
            self.outputs = outputs
            self.placementArn = placementArn
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sources = sources
        }
    }
}

extension MediaConnectClientTypes {

    public enum BridgePlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case locked
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgePlacement] {
            return [
                .available,
                .locked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .locked: return "LOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception raised by Elemental MediaConnect when creating the bridge. See the error message for the operation for more information on the cause of this exception.
public struct CreateBridge420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateBridge420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateBridgeInput: Swift.Sendable {
    /// An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public var egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?
    /// An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public var ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?
    /// The name of the bridge. This name can not be modified after the bridge is created.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this bridge.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?
    /// The bridge placement Amazon Resource Number (ARN).
    /// This member is required.
    public var placementArn: Swift.String?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil,
        placementArn: Swift.String? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    ) {
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.name = name
        self.outputs = outputs
        self.placementArn = placementArn
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
    }
}

public struct CreateBridgeOutput: Swift.Sendable {
    /// The name of the bridge that was created.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    ) {
        self.bridge = bridge
    }
}

public struct DeleteBridgeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to delete.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
    }
}

public struct DeleteBridgeOutput: Swift.Sendable {
    /// The ARN of the deleted bridge.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
    }
}

public struct DescribeBridgeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to describe.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
    }
}

public struct DescribeBridgeOutput: Swift.Sendable {
    /// The bridge that you requested a description of.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    ) {
        self.bridge = bridge
    }
}

public struct ListBridgesInput: Swift.Sendable {
    /// Filter the list results to display only the bridges associated with the selected ARN.
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListBridges request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBridgesOutput: Swift.Sendable {
    /// A list of bridge summaries.
    public var bridges: [MediaConnectClientTypes.ListedBridge]?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        bridges: [MediaConnectClientTypes.ListedBridge]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.bridges = bridges
        self.nextToken = nextToken
    }
}

public struct RemoveBridgeOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge output that you want to remove.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

public struct RemoveBridgeOutputOutput: Swift.Sendable {
    /// The ARN of the bridge from which the output was removed.
    public var bridgeArn: Swift.String?
    /// The name of the bridge output that was removed.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

public struct RemoveBridgeSourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge source that you want to remove.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

public struct RemoveBridgeSourceOutput: Swift.Sendable {
    /// The ARN of the bridge from which the source was removed.
    public var bridgeArn: Swift.String?
    /// The name of the bridge source that was removed.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

extension MediaConnectClientTypes {

    /// Update an existing egress-type bridge.
    public struct UpdateEgressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps).
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        ) {
            self.maxBitrate = maxBitrate
        }
    }
}

extension MediaConnectClientTypes {

    /// Update an existing ingress-type bridge.
    public struct UpdateIngressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps).
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        ) {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source failover.
    public struct UpdateFailoverConfig: Swift.Sendable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Recovery window time to look for dash-7 packets.
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        /// The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        ) {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }
}

public struct UpdateBridgeInput: Swift.Sendable {
    /// TheAmazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// A cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public var egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?
    /// A ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public var ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?

    public init(
        bridgeArn: Swift.String? = nil,
        egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

public struct UpdateBridgeOutput: Swift.Sendable {
    /// The bridge that was updated.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    ) {
        self.bridge = bridge
    }
}

extension MediaConnectClientTypes {

    /// Update an existing network output.
    public struct UpdateBridgeNetworkOutputRequest: Swift.Sendable {
        /// The network output IP Address.
        public var ipAddress: Swift.String?
        /// The network output's gateway network name.
        public var networkName: Swift.String?
        /// The network output port.
        public var port: Swift.Int?
        /// The network output protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        ) {
            self.ipAddress = ipAddress
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

public struct UpdateBridgeOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The network of the bridge output.
    public var networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?
    /// Tname of the output that you want to update.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest? = nil,
        outputName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.networkOutput = networkOutput
        self.outputName = outputName
    }
}

public struct UpdateBridgeOutputOutput: Swift.Sendable {
    /// The ARN of the bridge that was updated.
    public var bridgeArn: Swift.String?
    /// The bridge output that was updated.
    public var output: MediaConnectClientTypes.BridgeOutput?

    public init(
        bridgeArn: Swift.String? = nil,
        output: MediaConnectClientTypes.BridgeOutput? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.output = output
    }
}

extension MediaConnectClientTypes {

    /// Update the flow source of the bridge.
    public struct UpdateBridgeFlowSourceRequest: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the MediaConnect resource from which to delete tags.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// Update the network source of the bridge.
    public struct UpdateBridgeNetworkSourceRequest: Swift.Sendable {
        /// The network source multicast IP.
        public var multicastIp: Swift.String?
        /// The settings related to the multicast source.
        public var multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings?
        /// The network source's gateway network name.
        public var networkName: Swift.String?
        /// The network source port.
        public var port: Swift.Int?
        /// The network source protocol. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            multicastSourceSettings: MediaConnectClientTypes.MulticastSourceSettings? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        ) {
            self.multicastIp = multicastIp
            self.multicastSourceSettings = multicastSourceSettings
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

public struct UpdateBridgeSourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the flow that you want to update.
    public var flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?
    /// The network for the bridge source.
    public var networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?
    /// The name of the source that you want to update.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest? = nil,
        networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest? = nil,
        sourceName: Swift.String? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.flowSource = flowSource
        self.networkSource = networkSource
        self.sourceName = sourceName
    }
}

public struct UpdateBridgeSourceOutput: Swift.Sendable {
    /// The ARN of the updated bridge source.
    public var bridgeArn: Swift.String?
    /// The updated bridge source.
    public var source: MediaConnectClientTypes.BridgeSource?

    public init(
        bridgeArn: Swift.String? = nil,
        source: MediaConnectClientTypes.BridgeSource? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.source = source
    }
}

extension MediaConnectClientTypes {

    public enum DesiredState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .active,
                .deleted,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateBridgeStateInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the bridge that you want to update the state of.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The desired state for the bridge.
    /// This member is required.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

public struct UpdateBridgeStateOutput: Swift.Sendable {
    /// The ARN of the updated bridge.
    public var bridgeArn: Swift.String?
    /// The new state of the bridge.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    ) {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

extension MediaConnectClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ContentQualityAnalysisState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentQualityAnalysisState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception raised by Elemental MediaConnect when creating the flow. See the error message for the operation for more information on the cause of this exception.
public struct CreateFlow420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateFlow420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension MediaConnectClientTypes {

    public enum FlowSize: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowSize] {
            return [
                .large,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum NdiState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NdiState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
    public struct NdiConfig: Swift.Sendable {
        /// A prefix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect generates a unique 12-character ID as the prefix.
        public var machineName: Swift.String?
        /// A list of up to three NDI discovery server configurations. While not required by the API, this configuration is necessary for NDI functionality to work properly.
        public var ndiDiscoveryServers: [MediaConnectClientTypes.NdiDiscoveryServerConfig]?
        /// A setting that controls whether NDI outputs can be used in the flow. Must be ENABLED to add NDI outputs. Default is DISABLED.
        public var ndiState: MediaConnectClientTypes.NdiState?

        public init(
            machineName: Swift.String? = nil,
            ndiDiscoveryServers: [MediaConnectClientTypes.NdiDiscoveryServerConfig]? = nil,
            ndiState: MediaConnectClientTypes.NdiState? = nil
        ) {
            self.machineName = machineName
            self.ndiDiscoveryServers = ndiDiscoveryServers
            self.ndiState = ndiState
        }
    }
}

extension MediaConnectClientTypes {

    public enum ThumbnailState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source monitoring.
    public struct MonitoringConfig: Swift.Sendable {
        /// Contains the settings for audio stream metrics monitoring.
        public var audioMonitoringSettings: [MediaConnectClientTypes.AudioMonitoringSetting]?
        /// Indicates whether content quality analysis is enabled or disabled.
        public var contentQualityAnalysisState: MediaConnectClientTypes.ContentQualityAnalysisState?
        /// Indicates whether thumbnails are enabled or disabled.
        public var thumbnailState: MediaConnectClientTypes.ThumbnailState?
        /// Contains the settings for video stream metrics monitoring.
        public var videoMonitoringSettings: [MediaConnectClientTypes.VideoMonitoringSetting]?

        public init(
            audioMonitoringSettings: [MediaConnectClientTypes.AudioMonitoringSetting]? = nil,
            contentQualityAnalysisState: MediaConnectClientTypes.ContentQualityAnalysisState? = nil,
            thumbnailState: MediaConnectClientTypes.ThumbnailState? = nil,
            videoMonitoringSettings: [MediaConnectClientTypes.VideoMonitoringSetting]? = nil
        ) {
            self.audioMonitoringSettings = audioMonitoringSettings
            self.contentQualityAnalysisState = contentQualityAnalysisState
            self.thumbnailState = thumbnailState
            self.videoMonitoringSettings = videoMonitoringSettings
        }
    }
}

public struct CreateFlowInput: Swift.Sendable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current Amazon Web Services Region.
    public var availabilityZone: Swift.String?
    /// The entitlements that you want to grant on a flow.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// Determines the processing capacity and feature set of the flow. Set this optional parameter to LARGE if you want to enable NDI outputs on the flow.
    public var flowSize: MediaConnectClientTypes.FlowSize?
    /// The key-value pairs that can be used to tag and organize the flow.
    public var flowTags: [Swift.String: Swift.String]?
    /// The maintenance settings you want to use for the flow.
    public var maintenance: MediaConnectClientTypes.AddMaintenance?
    /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
    public var ndiConfig: MediaConnectClientTypes.NdiConfig?
    /// The outputs that you want to add to this flow.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?
    /// The settings for the source that you want to use for the new flow.
    public var source: MediaConnectClientTypes.SetSourceRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    /// The settings for source monitoring.
    public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?
    /// The sources that are assigned to the flow.
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?
    /// The VPC interfaces you want on the flow.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        availabilityZone: Swift.String? = nil,
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        flowSize: MediaConnectClientTypes.FlowSize? = nil,
        flowTags: [Swift.String: Swift.String]? = nil,
        maintenance: MediaConnectClientTypes.AddMaintenance? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil,
        name: Swift.String? = nil,
        ndiConfig: MediaConnectClientTypes.NdiConfig? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil,
        source: MediaConnectClientTypes.SetSourceRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.entitlements = entitlements
        self.flowSize = flowSize
        self.flowTags = flowTags
        self.maintenance = maintenance
        self.mediaStreams = mediaStreams
        self.name = name
        self.ndiConfig = ndiConfig
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sourceMonitoringConfig = sourceMonitoringConfig
        self.sources = sources
        self.vpcInterfaces = vpcInterfaces
    }
}

extension MediaConnectClientTypes {

    /// The settings for a flow, including its source, outputs, and entitlements.
    public struct Flow: Swift.Sendable {
        /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current Amazon Web Services Region.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow. This value is not used or seen outside of the current MediaConnect account.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var egressIp: Swift.String?
        /// The entitlements in this flow.
        /// This member is required.
        public var entitlements: [MediaConnectClientTypes.Entitlement]?
        /// The Amazon Resource Name (ARN) of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// Determines the processing capacity and feature set of the flow. Set this optional parameter to LARGE if you want to enable NDI outputs on the flow.
        public var flowSize: MediaConnectClientTypes.FlowSize?
        /// The maintenance settings for the flow.
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The media streams that are associated with the flow. After you associate a media stream with a source, you can also associate it with outputs on the flow.
        public var mediaStreams: [MediaConnectClientTypes.MediaStream]?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
        public var ndiConfig: MediaConnectClientTypes.NdiConfig?
        /// The outputs in this flow.
        /// This member is required.
        public var outputs: [MediaConnectClientTypes.Output]?
        /// The source for the flow.
        /// This member is required.
        public var source: MediaConnectClientTypes.Source?
        /// The settings for the source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        /// The settings for source monitoring.
        public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?
        /// The settings for the sources that are assigned to the flow.
        public var sources: [MediaConnectClientTypes.Source]?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?
        /// The VPC Interfaces for this flow.
        public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            egressIp: Swift.String? = nil,
            entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
            flowArn: Swift.String? = nil,
            flowSize: MediaConnectClientTypes.FlowSize? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil,
            name: Swift.String? = nil,
            ndiConfig: MediaConnectClientTypes.NdiConfig? = nil,
            outputs: [MediaConnectClientTypes.Output]? = nil,
            source: MediaConnectClientTypes.Source? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil,
            sources: [MediaConnectClientTypes.Source]? = nil,
            status: MediaConnectClientTypes.Status? = nil,
            vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.description = description
            self.egressIp = egressIp
            self.entitlements = entitlements
            self.flowArn = flowArn
            self.flowSize = flowSize
            self.maintenance = maintenance
            self.mediaStreams = mediaStreams
            self.name = name
            self.ndiConfig = ndiConfig
            self.outputs = outputs
            self.source = source
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sourceMonitoringConfig = sourceMonitoringConfig
            self.sources = sources
            self.status = status
            self.vpcInterfaces = vpcInterfaces
        }
    }
}

public struct CreateFlowOutput: Swift.Sendable {
    /// The flow that you created.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    ) {
        self.flow = flow
    }
}

/// Exception raised by Elemental MediaConnect when creating the gateway. See the error message for the operation for more information on the cause of this exception.
public struct CreateGateway420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateGateway420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateGatewayInput: Swift.Sendable {
    /// The range of IP addresses that are allowed to contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    /// This member is required.
    public var egressCidrBlocks: [Swift.String]?
    /// The name of the gateway. This name can not be modified after the gateway is created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of networks that you want to add to the gateway.
    /// This member is required.
    public var networks: [MediaConnectClientTypes.GatewayNetwork]?

    public init(
        egressCidrBlocks: [Swift.String]? = nil,
        name: Swift.String? = nil,
        networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
    ) {
        self.egressCidrBlocks = egressCidrBlocks
        self.name = name
        self.networks = networks
    }
}

extension MediaConnectClientTypes {

    /// The settings for a gateway, including its networks.
    public struct Gateway: Swift.Sendable {
        /// The range of IP addresses that contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var egressCidrBlocks: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// Messages with information about the gateway.
        public var gatewayMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The current status of the gateway.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway. This name can not be modified after the gateway is created.
        /// This member is required.
        public var name: Swift.String?
        /// The list of networks in the gateway.
        /// This member is required.
        public var networks: [MediaConnectClientTypes.GatewayNetwork]?

        public init(
            egressCidrBlocks: [Swift.String]? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil,
            networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
        ) {
            self.egressCidrBlocks = egressCidrBlocks
            self.gatewayArn = gatewayArn
            self.gatewayMessages = gatewayMessages
            self.gatewayState = gatewayState
            self.name = name
            self.networks = networks
        }
    }
}

public struct CreateGatewayOutput: Swift.Sendable {
    /// The gateway that you created.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    ) {
        self.gateway = gateway
    }
}

/// The request to create a new router input would exceed the service quotas for the account.
public struct RouterInputServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RouterInputServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateRouterInputInput: Swift.Sendable {
    /// The Availability Zone where you want to create the router input. This must be a valid Availability Zone for the region specified by regionName, or the current region if no regionName is provided.
    public var availabilityZone: Swift.String?
    /// A unique identifier for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration settings for the router input, which can include the protocol, network interface, and other details.
    /// This member is required.
    public var configuration: MediaConnectClientTypes.RouterInputConfiguration?
    /// The maintenance configuration settings for the router input, including preferred maintenance windows and schedules.
    public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
    /// The maximum bitrate for the router input.
    /// This member is required.
    public var maximumBitrate: Swift.Int?
    /// The name of the router input.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Region for the router input. Defaults to the current region if not specified.
    public var regionName: Swift.String?
    /// Specifies whether the router input can be assigned to outputs in different Regions. REGIONAL (default) - connects only to outputs in same Region. GLOBAL - connects to outputs in any Region.
    /// This member is required.
    public var routingScope: MediaConnectClientTypes.RoutingScope?
    /// Key-value pairs that can be used to tag and organize this router input.
    public var tags: [Swift.String: Swift.String]?
    /// The tier level for the router input.
    /// This member is required.
    public var tier: MediaConnectClientTypes.RouterInputTier?
    /// The transit encryption settings for the router input.
    public var transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption?

    public init(
        availabilityZone: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterInputConfiguration? = nil,
        maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
        maximumBitrate: Swift.Int? = nil,
        name: Swift.String? = nil,
        regionName: Swift.String? = nil,
        routingScope: MediaConnectClientTypes.RoutingScope? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: MediaConnectClientTypes.RouterInputTier? = nil,
        transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.configuration = configuration
        self.maintenanceConfiguration = maintenanceConfiguration
        self.maximumBitrate = maximumBitrate
        self.name = name
        self.regionName = regionName
        self.routingScope = routingScope
        self.tags = tags
        self.tier = tier
        self.transitEncryption = transitEncryption
    }
}

public struct CreateRouterInputOutput: Swift.Sendable {
    /// The newly-created router input.
    /// This member is required.
    public var routerInput: MediaConnectClientTypes.RouterInput?

    public init(
        routerInput: MediaConnectClientTypes.RouterInput? = nil
    ) {
        self.routerInput = routerInput
    }
}

/// The request to create a new router network interface would exceed the service quotas (limits) set for the account.
public struct RouterNetworkInterfaceServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RouterNetworkInterfaceServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateRouterNetworkInterfaceInput: Swift.Sendable {
    /// A unique identifier for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration settings for the router network interface.
    /// This member is required.
    public var configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration?
    /// The name of the router network interface.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Region for the router network interface. Defaults to the current region if not specified.
    public var regionName: Swift.String?
    /// Key-value pairs that can be used to tag and organize this router network interface.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration? = nil,
        name: Swift.String? = nil,
        regionName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.configuration = configuration
        self.name = name
        self.regionName = regionName
        self.tags = tags
    }
}

public struct CreateRouterNetworkInterfaceOutput: Swift.Sendable {
    /// The newly-created router network interface.
    /// This member is required.
    public var routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface?

    public init(
        routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface? = nil
    ) {
        self.routerNetworkInterface = routerNetworkInterface
    }
}

/// The request to create a new router output would exceed the service quotas (limits) set for the account.
public struct RouterOutputServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RouterOutputServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateRouterOutputInput: Swift.Sendable {
    /// The Availability Zone where you want to create the router output. This must be a valid Availability Zone for the region specified by regionName, or the current region if no regionName is provided.
    public var availabilityZone: Swift.String?
    /// A unique identifier for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration settings for the router output.
    /// This member is required.
    public var configuration: MediaConnectClientTypes.RouterOutputConfiguration?
    /// The maintenance configuration settings for the router output, including preferred maintenance windows and schedules.
    public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
    /// The maximum bitrate for the router output.
    /// This member is required.
    public var maximumBitrate: Swift.Int?
    /// The name of the router output.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Region for the router output. Defaults to the current region if not specified.
    public var regionName: Swift.String?
    /// Specifies whether the router output can take inputs that are in different Regions. REGIONAL (default) - can only take inputs from same Region. GLOBAL - can take inputs from any Region.
    /// This member is required.
    public var routingScope: MediaConnectClientTypes.RoutingScope?
    /// Key-value pairs that can be used to tag this router output.
    public var tags: [Swift.String: Swift.String]?
    /// The tier level for the router output.
    /// This member is required.
    public var tier: MediaConnectClientTypes.RouterOutputTier?

    public init(
        availabilityZone: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterOutputConfiguration? = nil,
        maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
        maximumBitrate: Swift.Int? = nil,
        name: Swift.String? = nil,
        regionName: Swift.String? = nil,
        routingScope: MediaConnectClientTypes.RoutingScope? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: MediaConnectClientTypes.RouterOutputTier? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.configuration = configuration
        self.maintenanceConfiguration = maintenanceConfiguration
        self.maximumBitrate = maximumBitrate
        self.name = name
        self.regionName = regionName
        self.routingScope = routingScope
        self.tags = tags
        self.tier = tier
    }
}

public struct CreateRouterOutputOutput: Swift.Sendable {
    /// The newly-created router output.
    /// This member is required.
    public var routerOutput: MediaConnectClientTypes.RouterOutput?

    public init(
        routerOutput: MediaConnectClientTypes.RouterOutput? = nil
    ) {
        self.routerOutput = routerOutput
    }
}

public struct DeleteFlowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to delete.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

public struct DeleteFlowOutput: Swift.Sendable {
    /// The ARN of the flow that was deleted.
    public var flowArn: Swift.String?
    /// The status of the flow when the DeleteFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    ) {
        self.flowArn = flowArn
        self.status = status
    }
}

public struct DeleteGatewayInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway that you want to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    ) {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteGatewayOutput: Swift.Sendable {
    /// The ARN of the gateway that was deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    ) {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteRouterInputOutput: Swift.Sendable {
    /// The ARN of the deleted router input.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted router input.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the deleted router input, indicating where it is in the deletion process.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterInputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterInputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct DeleteRouterNetworkInterfaceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router network interface that you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteRouterNetworkInterfaceOutput: Swift.Sendable {
    /// The ARN of the deleted router network interface.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted router network interface.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the deleted router network interface, indicating where it is in the deletion process.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterNetworkInterfaceState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterNetworkInterfaceState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct DeleteRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteRouterOutputOutput: Swift.Sendable {
    /// The ARN of the deleted router output.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted router output.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the deleted router output, indicating where it is in the deletion process.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterOutputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterOutputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct DeregisterGatewayInstanceInput: Swift.Sendable {
    /// Force the deregistration of an instance. Force will deregister an instance, even if there are bridges running on it.
    public var force: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway that contains the instance that you want to deregister.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        gatewayInstanceArn: Swift.String? = nil
    ) {
        self.force = force
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

public struct DeregisterGatewayInstanceOutput: Swift.Sendable {
    /// The ARN of the instance.
    public var gatewayInstanceArn: Swift.String?
    /// The status of the instance.
    public var instanceState: MediaConnectClientTypes.InstanceState?

    public init(
        gatewayInstanceArn: Swift.String? = nil,
        instanceState: MediaConnectClientTypes.InstanceState? = nil
    ) {
        self.gatewayInstanceArn = gatewayInstanceArn
        self.instanceState = instanceState
    }
}

public struct DescribeFlowInput: Swift.Sendable {
    /// The ARN of the flow that you want to describe.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// Messages that provide the state of the flow.
    public struct Messages: Swift.Sendable {
        /// A list of errors that might have been generated from processes on this flow.
        /// This member is required.
        public var errors: [Swift.String]?

        public init(
            errors: [Swift.String]? = nil
        ) {
            self.errors = errors
        }
    }
}

public struct DescribeFlowOutput: Swift.Sendable {
    /// The flow that you requested a description of.
    public var flow: MediaConnectClientTypes.Flow?
    /// Any errors that apply currently to the flow. If there are no errors, MediaConnect will not include this field in the response.
    public var messages: MediaConnectClientTypes.Messages?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil,
        messages: MediaConnectClientTypes.Messages? = nil
    ) {
        self.flow = flow
        self.messages = messages
    }
}

public struct DescribeFlowSourceMetadataInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// The metadata of the transport stream in the current flow's source.
    public struct TransportMediaInfo: Swift.Sendable {
        /// The list of transport stream programs in the current flow's source.
        /// This member is required.
        public var programs: [MediaConnectClientTypes.TransportStreamProgram]?

        public init(
            programs: [MediaConnectClientTypes.TransportStreamProgram]? = nil
        ) {
            self.programs = programs
        }
    }
}

public struct DescribeFlowSourceMetadataOutput: Swift.Sendable {
    /// The ARN of the flow that DescribeFlowSourceMetadata was performed on.
    public var flowArn: Swift.String?
    /// Provides a status code and message regarding issues found with the flow source metadata.
    public var messages: [MediaConnectClientTypes.MessageDetail]?
    /// The timestamp of the most recent change in metadata for this flow’s source.
    public var timestamp: Foundation.Date?
    /// Information about the flow's transport media.
    public var transportMediaInfo: MediaConnectClientTypes.TransportMediaInfo?

    public init(
        flowArn: Swift.String? = nil,
        messages: [MediaConnectClientTypes.MessageDetail]? = nil,
        timestamp: Foundation.Date? = nil,
        transportMediaInfo: MediaConnectClientTypes.TransportMediaInfo? = nil
    ) {
        self.flowArn = flowArn
        self.messages = messages
        self.timestamp = timestamp
        self.transportMediaInfo = transportMediaInfo
    }
}

public struct DescribeFlowSourceThumbnailInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// The details of the thumbnail, including thumbnail base64 string, timecode and the time when thumbnail was generated.
    public struct ThumbnailDetails: Swift.Sendable {
        /// The ARN of the flow that DescribeFlowSourceThumbnail was performed on.
        /// This member is required.
        public var flowArn: Swift.String?
        /// Thumbnail Base64 string.
        public var thumbnail: Swift.String?
        /// Status code and messages about the flow source thumbnail.
        /// This member is required.
        public var thumbnailMessages: [MediaConnectClientTypes.MessageDetail]?
        /// Timecode of thumbnail.
        public var timecode: Swift.String?
        /// The timestamp of when thumbnail was generated.
        public var timestamp: Foundation.Date?

        public init(
            flowArn: Swift.String? = nil,
            thumbnail: Swift.String? = nil,
            thumbnailMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            timecode: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.flowArn = flowArn
            self.thumbnail = thumbnail
            self.thumbnailMessages = thumbnailMessages
            self.timecode = timecode
            self.timestamp = timestamp
        }
    }
}

public struct DescribeFlowSourceThumbnailOutput: Swift.Sendable {
    /// The details of the thumbnail, including thumbnail base64 string, timecode and the time when thumbnail was generated.
    public var thumbnailDetails: MediaConnectClientTypes.ThumbnailDetails?

    public init(
        thumbnailDetails: MediaConnectClientTypes.ThumbnailDetails? = nil
    ) {
        self.thumbnailDetails = thumbnailDetails
    }
}

public struct DescribeGatewayInput: Swift.Sendable {
    /// The ARN of the gateway that you want to describe.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    ) {
        self.gatewayArn = gatewayArn
    }
}

public struct DescribeGatewayOutput: Swift.Sendable {
    /// The gateway that you wanted to describe.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    ) {
        self.gateway = gateway
    }
}

public struct DescribeGatewayInstanceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway instance that you want to describe.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        gatewayInstanceArn: Swift.String? = nil
    ) {
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

extension MediaConnectClientTypes {

    /// The settings for an instance in a gateway.
    public struct GatewayInstance: Swift.Sendable {
        /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be deployed to this instance.
        /// This member is required.
        public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
        /// The connection state of the instance.
        /// This member is required.
        public var connectionStatus: MediaConnectClientTypes.ConnectionStatus?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The ARN of the gateway.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        /// Messages with information about the gateway.
        public var instanceMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The status of the instance.
        /// This member is required.
        public var instanceState: MediaConnectClientTypes.InstanceState?
        /// The running bridge count.
        /// This member is required.
        public var runningBridgeCount: Swift.Int?

        public init(
            bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
            connectionStatus: MediaConnectClientTypes.ConnectionStatus? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil,
            runningBridgeCount: Swift.Int? = nil
        ) {
            self.bridgePlacement = bridgePlacement
            self.connectionStatus = connectionStatus
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceMessages = instanceMessages
            self.instanceState = instanceState
            self.runningBridgeCount = runningBridgeCount
        }
    }
}

public struct DescribeGatewayInstanceOutput: Swift.Sendable {
    /// The gateway instance that you requested a description of.
    public var gatewayInstance: MediaConnectClientTypes.GatewayInstance?

    public init(
        gatewayInstance: MediaConnectClientTypes.GatewayInstance? = nil
    ) {
        self.gatewayInstance = gatewayInstance
    }
}

public struct DescribeOfferingInput: Swift.Sendable {
    /// The ARN of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?

    public init(
        offeringArn: Swift.String? = nil
    ) {
        self.offeringArn = offeringArn
    }
}

public struct DescribeOfferingOutput: Swift.Sendable {
    /// The offering that you requested a description of.
    public var offering: MediaConnectClientTypes.Offering?

    public init(
        offering: MediaConnectClientTypes.Offering? = nil
    ) {
        self.offering = offering
    }
}

public struct DescribeReservationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var reservationArn: Swift.String?

    public init(
        reservationArn: Swift.String? = nil
    ) {
        self.reservationArn = reservationArn
    }
}

public struct DescribeReservationOutput: Swift.Sendable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    ) {
        self.reservation = reservation
    }
}

/// Exception raised by Elemental MediaConnect when granting the entitlement. See the error message for the operation for more information on the cause of this exception.
public struct GrantFlowEntitlements420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GrantFlowEntitlements420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GrantFlowEntitlementsInput: Swift.Sendable {
    /// The list of entitlements that you want to grant.
    /// This member is required.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// The Amazon Resource Name (ARN) of the flow that you want to grant entitlements on.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        flowArn: Swift.String? = nil
    ) {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

public struct GrantFlowEntitlementsOutput: Swift.Sendable {
    /// The entitlements that were just granted.
    public var entitlements: [MediaConnectClientTypes.Entitlement]?
    /// The ARN of the flow that these entitlements were granted to.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
        flowArn: Swift.String? = nil
    ) {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

public struct ListFlowsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFlowsOutput: Swift.Sendable {
    /// A list of flow summaries.
    public var flows: [MediaConnectClientTypes.ListedFlow]?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        flows: [MediaConnectClientTypes.ListedFlow]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.flows = flows
        self.nextToken = nextToken
    }
}

public struct RemoveFlowMediaStreamInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to remove.
    /// This member is required.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

public struct RemoveFlowMediaStreamOutput: Swift.Sendable {
    /// The ARN of the flow that was updated.
    public var flowArn: Swift.String?
    /// The name of the media stream that was removed.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

public struct RemoveFlowOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to remove an output from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the output that you want to remove.
    /// This member is required.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

public struct RemoveFlowOutputOutput: Swift.Sendable {
    /// The ARN of the flow that the output was removed from.
    public var flowArn: Swift.String?
    /// The ARN of the output that was removed.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

public struct RemoveFlowSourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to remove a source from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the source that you want to remove.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

public struct RemoveFlowSourceOutput: Swift.Sendable {
    /// The ARN of the flow that the source was removed from.
    public var flowArn: Swift.String?
    /// The ARN of the source that was removed.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

public struct RemoveFlowVpcInterfaceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to remove a VPC interface from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the VPC interface that you want to remove.
    /// This member is required.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.vpcInterfaceName = vpcInterfaceName
    }
}

public struct RemoveFlowVpcInterfaceOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the VPC interface you removed.
    public var flowArn: Swift.String?
    /// IDs of network interfaces associated with the removed VPC interface that MediaConnect was unable to remove.
    public var nonDeletedNetworkInterfaceIds: [Swift.String]?
    /// The name of the VPC interface that was removed.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        nonDeletedNetworkInterfaceIds: [Swift.String]? = nil,
        vpcInterfaceName: Swift.String? = nil
    ) {
        self.flowArn = flowArn
        self.nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIds
        self.vpcInterfaceName = vpcInterfaceName
    }
}

public struct RevokeFlowEntitlementInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the entitlement that you want to revoke.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// The flow that you want to revoke an entitlement from.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    ) {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

public struct RevokeFlowEntitlementOutput: Swift.Sendable {
    /// The ARN of the entitlement that was revoked.
    public var entitlementArn: Swift.String?
    /// The ARN of the flow that the entitlement was revoked from.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    ) {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

public struct StartFlowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to start.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

public struct StartFlowOutput: Swift.Sendable {
    /// The ARN of the flow that you started.
    public var flowArn: Swift.String?
    /// The status of the flow when the StartFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    ) {
        self.flowArn = flowArn
        self.status = status
    }
}

public struct StopFlowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to stop.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    ) {
        self.flowArn = flowArn
    }
}

public struct StopFlowOutput: Swift.Sendable {
    /// The ARN of the flow that you stopped.
    public var flowArn: Swift.String?
    /// The status of the flow when the StopFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    ) {
        self.flowArn = flowArn
        self.status = status
    }
}

extension MediaConnectClientTypes {

    /// Update maintenance setting for a flow.
    public struct UpdateMaintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        ) {
            self.maintenanceDay = maintenanceDay
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

public struct UpdateFlowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// Determines the processing capacity and feature set of the flow.
    public var flowSize: MediaConnectClientTypes.FlowSize?
    /// The maintenance setting of the flow.
    public var maintenance: MediaConnectClientTypes.UpdateMaintenance?
    /// Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
    public var ndiConfig: MediaConnectClientTypes.NdiConfig?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?
    /// The settings for source monitoring.
    public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?

    public init(
        flowArn: Swift.String? = nil,
        flowSize: MediaConnectClientTypes.FlowSize? = nil,
        maintenance: MediaConnectClientTypes.UpdateMaintenance? = nil,
        ndiConfig: MediaConnectClientTypes.NdiConfig? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil,
        sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil
    ) {
        self.flowArn = flowArn
        self.flowSize = flowSize
        self.maintenance = maintenance
        self.ndiConfig = ndiConfig
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sourceMonitoringConfig = sourceMonitoringConfig
    }
}

public struct UpdateFlowOutput: Swift.Sendable {
    /// The updated flow.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    ) {
        self.flow = flow
    }
}

extension MediaConnectClientTypes {

    /// Information about the encryption of the flow.
    public struct UpdateEncryption: Swift.Sendable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The Amazon Web Services Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up MediaConnect as a trusted entity).
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        ) {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }
}

public struct UpdateFlowEntitlementInput: Swift.Sendable {
    /// A description of the entitlement. This description appears only on the MediaConnect console and will not be seen by the subscriber or end user.
    public var description: Swift.String?
    /// The type of encryption that will be used on the output associated with this entitlement. Allowable encryption types: static-key, speke.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The Amazon Resource Name (ARN) of the entitlement that you want to update.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscriber’s flow temporarily. If you don’t specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
    public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    /// The ARN of the flow that is associated with the entitlement that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The Amazon Web Services account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public var subscribers: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        entitlementArn: Swift.String? = nil,
        entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
        flowArn: Swift.String? = nil,
        subscribers: [Swift.String]? = nil
    ) {
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.flowArn = flowArn
        self.subscribers = subscribers
    }
}

public struct UpdateFlowEntitlementOutput: Swift.Sendable {
    /// The new configuration of the entitlement that you updated.
    public var entitlement: MediaConnectClientTypes.Entitlement?
    /// The ARN of the flow that this entitlement was granted on.
    public var flowArn: Swift.String?

    public init(
        entitlement: MediaConnectClientTypes.Entitlement? = nil,
        flowArn: Swift.String? = nil
    ) {
        self.entitlement = entitlement
        self.flowArn = flowArn
    }
}

public struct UpdateFlowMediaStreamInput: Swift.Sendable {
    /// The attributes that you want to assign to the media stream.
    public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    /// The sample rate for the stream. This value in measured in kHz.
    public var clockRate: Swift.Int?
    /// A description that can help you quickly identify what your media stream is used for.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow that is associated with the media stream that you updated.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The media stream that you updated.
    /// This member is required.
    public var mediaStreamName: Swift.String?
    /// The type of media stream.
    public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    /// The resolution of the video.
    public var videoFormat: Swift.String?

    public init(
        attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
        clockRate: Swift.Int? = nil,
        description: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil,
        mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
        videoFormat: Swift.String? = nil
    ) {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

public struct UpdateFlowMediaStreamOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the media stream that you updated.
    public var flowArn: Swift.String?
    /// The media stream that you updated.
    public var mediaStream: MediaConnectClientTypes.MediaStream?

    public init(
        flowArn: Swift.String? = nil,
        mediaStream: MediaConnectClientTypes.MediaStream? = nil
    ) {
        self.flowArn = flowArn
        self.mediaStream = mediaStream
    }
}

public struct UpdateFlowOutputInput: Swift.Sendable {
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var cidrAllowList: [Swift.String]?
    /// A description of the output. This description appears only on the MediaConnect console and will not be seen by the end user.
    public var description: Swift.String?
    /// The IP address where you want to send the output.
    public var destination: Swift.String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The Amazon Resource Name (ARN) of the flow that is associated with the output that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public var maxLatency: Swift.Int?
    /// The media streams that are associated with the output, and the parameters for those associations.
    public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// A suffix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect uses the output name.
    public var ndiProgramName: Swift.String?
    /// A quality setting for the NDI Speed HQ encoder.
    public var ndiSpeedHqQuality: Swift.Int?
    /// The ARN of the output that you want to update.
    /// This member is required.
    public var outputArn: Swift.String?
    /// An indication of whether the output should transmit data or not. If you don't specify the outputStatus field in your request, MediaConnect leaves the value unchanged.
    public var outputStatus: MediaConnectClientTypes.OutputStatus?
    /// The port to use when content is distributed to this output.
    public var port: Swift.Int?
    /// The protocol to use for the output. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The remote ID for the Zixi-pull stream.
    public var remoteId: Swift.String?
    /// Indicates whether to enable or disable router integration for this flow output.
    public var routerIntegrationState: MediaConnectClientTypes.State?
    /// The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
    public var routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public var smoothingLatency: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface attachment to use for this output.
    public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

    public init(
        cidrAllowList: [Swift.String]? = nil,
        description: Swift.String? = nil,
        destination: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        flowArn: Swift.String? = nil,
        maxLatency: Swift.Int? = nil,
        mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        ndiProgramName: Swift.String? = nil,
        ndiSpeedHqQuality: Swift.Int? = nil,
        outputArn: Swift.String? = nil,
        outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
        port: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        remoteId: Swift.String? = nil,
        routerIntegrationState: MediaConnectClientTypes.State? = nil,
        routerIntegrationTransitEncryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        smoothingLatency: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
    ) {
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.flowArn = flowArn
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.ndiProgramName = ndiProgramName
        self.ndiSpeedHqQuality = ndiSpeedHqQuality
        self.outputArn = outputArn
        self.outputStatus = outputStatus
        self.port = port
        self.`protocol` = `protocol`
        self.remoteId = remoteId
        self.routerIntegrationState = routerIntegrationState
        self.routerIntegrationTransitEncryption = routerIntegrationTransitEncryption
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

public struct UpdateFlowOutputOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the updated output.
    public var flowArn: Swift.String?
    /// The new settings of the output that you updated.
    public var output: MediaConnectClientTypes.Output?

    public init(
        flowArn: Swift.String? = nil,
        output: MediaConnectClientTypes.Output? = nil
    ) {
        self.flowArn = flowArn
        self.output = output
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct UpdateGatewayBridgeSourceRequest: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        ) {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

public struct UpdateFlowSourceInput: Swift.Sendable {
    /// The type of encryption that is used on the content ingested from the source.
    public var decryption: MediaConnectClientTypes.UpdateEncryption?
    /// A description of the source. This description is not visible outside of the current Amazon Web Services account.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the entitlement that allows you to subscribe to the flow. The entitlement is set by the content originator, and the ARN is generated as part of the originator's flow.
    public var entitlementArn: Swift.String?
    /// The ARN of the flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public var gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?
    /// The port that the flow listens on for incoming content. If the protocol of the source is Zixi, the port must be set to 2088.
    public var ingestPort: Swift.Int?
    /// The maximum bitrate for RIST, RTP, and RTP-FEC streams.
    public var maxBitrate: Swift.Int?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public var maxLatency: Swift.Int?
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public var maxSyncBuffer: Swift.Int?
    /// The media stream that is associated with the source, and the parameters for that association.
    public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// The protocol that the source uses to deliver the content to MediaConnect. Elemental MediaConnect no longer supports the Fujitsu QoS protocol. This reference is maintained for legacy purposes only.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// Indicates whether to enable or disable router integration for this flow source.
    public var routerIntegrationState: MediaConnectClientTypes.State?
    /// The encryption configuration for the flow source when router integration is enabled.
    public var routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The ARN of the source that you want to update.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The source IP or domain name for SRT-caller protocol.
    public var sourceListenerAddress: Swift.String?
    /// Source port for SRT-caller protocol.
    public var sourceListenerPort: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface that you want to send your output to.
    public var vpcInterfaceName: Swift.String?
    /// The range of IP addresses that are allowed to contribute content to your source. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var whitelistCidr: Swift.String?

    public init(
        decryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        description: Swift.String? = nil,
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest? = nil,
        ingestPort: Swift.Int? = nil,
        maxBitrate: Swift.Int? = nil,
        maxLatency: Swift.Int? = nil,
        maxSyncBuffer: Swift.Int? = nil,
        mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        routerIntegrationState: MediaConnectClientTypes.State? = nil,
        routerIntegrationTransitDecryption: MediaConnectClientTypes.FlowTransitEncryption? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceListenerAddress: Swift.String? = nil,
        sourceListenerPort: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil,
        whitelistCidr: Swift.String? = nil
    ) {
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
        self.gatewayBridgeSource = gatewayBridgeSource
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.`protocol` = `protocol`
        self.routerIntegrationState = routerIntegrationState
        self.routerIntegrationTransitDecryption = routerIntegrationTransitDecryption
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.sourceArn = sourceArn
        self.sourceListenerAddress = sourceListenerAddress
        self.sourceListenerPort = sourceListenerPort
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

public struct UpdateFlowSourceOutput: Swift.Sendable {
    /// The ARN of the flow that you was updated.
    public var flowArn: Swift.String?
    /// The details of the sources that are assigned to the flow.
    public var source: MediaConnectClientTypes.Source?

    public init(
        flowArn: Swift.String? = nil,
        source: MediaConnectClientTypes.Source? = nil
    ) {
        self.flowArn = flowArn
        self.source = source
    }
}

public struct ListGatewayInstancesInput: Swift.Sendable {
    /// Filter the list results to display only the instances associated with the selected Gateway ARN.
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListInstances request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGatewayInstancesOutput: Swift.Sendable {
    /// A list of instance summaries.
    public var instances: [MediaConnectClientTypes.ListedGatewayInstance]?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        instances: [MediaConnectClientTypes.ListedGatewayInstance]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instances = instances
        self.nextToken = nextToken
    }
}

public struct UpdateGatewayInstanceInput: Swift.Sendable {
    /// The state of the instance. ACTIVE or INACTIVE.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The Amazon Resource Name (ARN) of the gateway instance that you want to update.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    ) {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

public struct UpdateGatewayInstanceOutput: Swift.Sendable {
    /// The state of the instance. ACTIVE or INACTIVE.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The ARN of the instance that was updated.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    ) {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

public struct ListGatewaysInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListGateways request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGatewaysOutput: Swift.Sendable {
    /// A list of gateway summaries.
    public var gateways: [MediaConnectClientTypes.ListedGateway]?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        gateways: [MediaConnectClientTypes.ListedGateway]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

public struct GetRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input to retrieve information about.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct GetRouterInputOutput: Swift.Sendable {
    /// The details of the requested router input, including its configuration, state, and other attributes.
    /// This member is required.
    public var routerInput: MediaConnectClientTypes.RouterInput?

    public init(
        routerInput: MediaConnectClientTypes.RouterInput? = nil
    ) {
        self.routerInput = routerInput
    }
}

public struct GetRouterInputSourceMetadataInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input to retrieve metadata for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension MediaConnectClientTypes {

    /// Metadata information associated with the router input, including stream details and connection state.
    public enum RouterInputMetadata: Swift.Sendable {
        /// The metadata of the transport stream in the current flow's source.
        case transportstreammediainfo(MediaConnectClientTypes.TransportMediaInfo)
        case sdkUnknown(Swift.String)
    }
}

extension MediaConnectClientTypes {

    /// Detailed metadata information about a router input source.
    public struct RouterInputSourceMetadataDetails: Swift.Sendable {
        /// Metadata information specific to the router input configuration and state.
        public var routerInputMetadata: MediaConnectClientTypes.RouterInputMetadata?
        /// Collection of metadata messages associated with the router input source.
        /// This member is required.
        public var sourceMetadataMessages: [MediaConnectClientTypes.RouterInputMessage]?
        /// The timestamp when the metadata was last updated.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            routerInputMetadata: MediaConnectClientTypes.RouterInputMetadata? = nil,
            sourceMetadataMessages: [MediaConnectClientTypes.RouterInputMessage]? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.routerInputMetadata = routerInputMetadata
            self.sourceMetadataMessages = sourceMetadataMessages
            self.timestamp = timestamp
        }
    }
}

public struct GetRouterInputSourceMetadataOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router input.
    /// This member is required.
    public var name: Swift.String?
    /// Detailed metadata information about the router input source, including connection state, timestamps, and stream configuration.
    /// This member is required.
    public var sourceMetadataDetails: MediaConnectClientTypes.RouterInputSourceMetadataDetails?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceMetadataDetails: MediaConnectClientTypes.RouterInputSourceMetadataDetails? = nil
    ) {
        self.arn = arn
        self.name = name
        self.sourceMetadataDetails = sourceMetadataDetails
    }
}

public struct GetRouterInputThumbnailInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to see a thumbnail of.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension MediaConnectClientTypes {

    /// The details of a thumbnail associated with a router input, including the thumbnail messages, the thumbnail image, the timecode, and the timestamp.
    public struct RouterInputThumbnailDetails: Swift.Sendable {
        /// The thumbnail image, encoded as a Base64-encoded binary data object.
        public var thumbnail: Foundation.Data?
        /// The messages associated with the router input thumbnail.
        /// This member is required.
        public var thumbnailMessages: [MediaConnectClientTypes.RouterInputMessage]?
        /// The timecode associated with the thumbnail.
        public var timecode: Swift.String?
        /// The timestamp associated with the thumbnail.
        public var timestamp: Foundation.Date?

        public init(
            thumbnail: Foundation.Data? = nil,
            thumbnailMessages: [MediaConnectClientTypes.RouterInputMessage]? = nil,
            timecode: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.thumbnail = thumbnail
            self.thumbnailMessages = thumbnailMessages
            self.timecode = timecode
            self.timestamp = timestamp
        }
    }
}

public struct GetRouterInputThumbnailOutput: Swift.Sendable {
    /// The ARN of the router input.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router input.
    /// This member is required.
    public var name: Swift.String?
    /// The details of the thumbnail associated with the router input, including the thumbnail image, timecode, timestamp, and any associated error messages.
    /// This member is required.
    public var thumbnailDetails: MediaConnectClientTypes.RouterInputThumbnailDetails?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        thumbnailDetails: MediaConnectClientTypes.RouterInputThumbnailDetails? = nil
    ) {
        self.arn = arn
        self.name = name
        self.thumbnailDetails = thumbnailDetails
    }
}

public struct GetRouterNetworkInterfaceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router network interface that you want to retrieve information about.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct GetRouterNetworkInterfaceOutput: Swift.Sendable {
    /// The details of the requested router network interface, including its configuration and other attributes.
    /// This member is required.
    public var routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface?

    public init(
        routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface? = nil
    ) {
        self.routerNetworkInterface = routerNetworkInterface
    }
}

public struct GetRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to retrieve information about.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct GetRouterOutputOutput: Swift.Sendable {
    /// The details of the requested router output, including its configuration, state, and other attributes.
    /// This member is required.
    public var routerOutput: MediaConnectClientTypes.RouterOutput?

    public init(
        routerOutput: MediaConnectClientTypes.RouterOutput? = nil
    ) {
        self.routerOutput = routerOutput
    }
}

extension MediaConnectClientTypes {

    /// A summary of a router input, including its name, type, ARN, ID, state, and other key details. This structure is used in the response of the ListRouterInputs operation.
    public struct ListedRouterInput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router input.
        /// This member is required.
        public var arn: Swift.String?
        /// The Availability Zone of the router input.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// The timestamp when the router input was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router input.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the router input.
        /// This member is required.
        public var inputType: MediaConnectClientTypes.RouterInputType?
        /// The details of the maintenance schedule for the listed router input.
        public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
        /// The type of maintenance schedule currently associated with the listed router input.
        public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
        /// The maximum bitrate of the router input.
        /// This member is required.
        public var maximumBitrate: Swift.Int?
        /// The number of messages associated with the router input.
        /// This member is required.
        public var messageCount: Swift.Int?
        /// The name of the router input.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the network interface associated with the router input.
        public var networkInterfaceArn: Swift.String?
        /// The AWS Region where the router input is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The number of router outputs that are associated with this router input.
        /// This member is required.
        public var routedOutputs: Swift.Int?
        /// Indicates whether the router input is configured for Regional or global routing.
        /// This member is required.
        public var routingScope: MediaConnectClientTypes.RoutingScope?
        /// The overall state of the router input.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterInputState?
        /// The timestamp when the router input was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            inputType: MediaConnectClientTypes.RouterInputType? = nil,
            maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
            maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
            maximumBitrate: Swift.Int? = nil,
            messageCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            networkInterfaceArn: Swift.String? = nil,
            regionName: Swift.String? = nil,
            routedOutputs: Swift.Int? = nil,
            routingScope: MediaConnectClientTypes.RoutingScope? = nil,
            state: MediaConnectClientTypes.RouterInputState? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.createdAt = createdAt
            self.id = id
            self.inputType = inputType
            self.maintenanceSchedule = maintenanceSchedule
            self.maintenanceScheduleType = maintenanceScheduleType
            self.maximumBitrate = maximumBitrate
            self.messageCount = messageCount
            self.name = name
            self.networkInterfaceArn = networkInterfaceArn
            self.regionName = regionName
            self.routedOutputs = routedOutputs
            self.routingScope = routingScope
            self.state = state
            self.updatedAt = updatedAt
        }
    }
}

extension MediaConnectClientTypes {

    /// A summary of a router network interface, including its name, type, ARN, ID, associated input/output counts, state, and other key details. This structure is used in the response of the ListRouterNetworkInterfaces operation.
    public struct ListedRouterNetworkInterface: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router network interface.
        /// This member is required.
        public var arn: Swift.String?
        /// The number of router inputs associated with the network interface.
        /// This member is required.
        public var associatedInputCount: Swift.Int?
        /// The number of router outputs associated with the network interface.
        /// This member is required.
        public var associatedOutputCount: Swift.Int?
        /// The timestamp when the network interface was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router network interface.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the router network interface.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the router network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.RouterNetworkInterfaceType?
        /// The AWS Region where the router network interface is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The current state of the router network interface.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterNetworkInterfaceState?
        /// The timestamp when the router network interface was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedInputCount: Swift.Int? = nil,
            associatedOutputCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.RouterNetworkInterfaceType? = nil,
            regionName: Swift.String? = nil,
            state: MediaConnectClientTypes.RouterNetworkInterfaceState? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedInputCount = associatedInputCount
            self.associatedOutputCount = associatedOutputCount
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.regionName = regionName
            self.state = state
            self.updatedAt = updatedAt
        }
    }
}

extension MediaConnectClientTypes {

    /// A summary of a router output, including its name, type, ARN, ID, state, routed state, and other key details. This structure is used in the response of the ListRouterOutputs operation.
    public struct ListedRouterOutput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the router output.
        /// This member is required.
        public var arn: Swift.String?
        /// The Availability Zone of the router output.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// The timestamp when the router output was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the router output.
        /// This member is required.
        public var id: Swift.String?
        /// The details of the maintenance schedule for the listed router output.
        public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
        /// The type of maintenance schedule currently associated with the listed router output.
        public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
        /// The maximum bitrate of the router output.
        /// This member is required.
        public var maximumBitrate: Swift.Int?
        /// The number of messages associated with the router output.
        /// This member is required.
        public var messageCount: Swift.Int?
        /// The name of the router output.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the network interface associated with the router output.
        public var networkInterfaceArn: Swift.String?
        /// The type of the router output.
        /// This member is required.
        public var outputType: MediaConnectClientTypes.RouterOutputType?
        /// The AWS Region where the router output is located.
        /// This member is required.
        public var regionName: Swift.String?
        /// The ARN of the router input associated with the output.
        public var routedInputArn: Swift.String?
        /// The current state of the association between the router output and its input.
        /// This member is required.
        public var routedState: MediaConnectClientTypes.RouterOutputRoutedState?
        /// Indicates whether the router output is configured for Regional or global routing.
        /// This member is required.
        public var routingScope: MediaConnectClientTypes.RoutingScope?
        /// The overall state of the router output.
        /// This member is required.
        public var state: MediaConnectClientTypes.RouterOutputState?
        /// The timestamp when the router output was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
            maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
            maximumBitrate: Swift.Int? = nil,
            messageCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            networkInterfaceArn: Swift.String? = nil,
            outputType: MediaConnectClientTypes.RouterOutputType? = nil,
            regionName: Swift.String? = nil,
            routedInputArn: Swift.String? = nil,
            routedState: MediaConnectClientTypes.RouterOutputRoutedState? = nil,
            routingScope: MediaConnectClientTypes.RoutingScope? = nil,
            state: MediaConnectClientTypes.RouterOutputState? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.createdAt = createdAt
            self.id = id
            self.maintenanceSchedule = maintenanceSchedule
            self.maintenanceScheduleType = maintenanceScheduleType
            self.maximumBitrate = maximumBitrate
            self.messageCount = messageCount
            self.name = name
            self.networkInterfaceArn = networkInterfaceArn
            self.outputType = outputType
            self.regionName = regionName
            self.routedInputArn = routedInputArn
            self.routedState = routedState
            self.routingScope = routingScope
            self.state = state
            self.updatedAt = updatedAt
        }
    }
}

public struct ListEntitlementsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEntitlementsOutput: Swift.Sendable {
    /// A list of entitlements that have been granted to you from other Amazon Web Services accounts.
    public var entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.ListedEntitlement]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

public struct ListOfferingsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOfferingsOutput: Swift.Sendable {
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of offerings that are available to this account in the current Amazon Web Services Region.
    public var offerings: [MediaConnectClientTypes.Offering]?

    public init(
        nextToken: Swift.String? = nil,
        offerings: [MediaConnectClientTypes.Offering]? = nil
    ) {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

public struct ListReservationsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReservationsOutput: Swift.Sendable {
    /// The token that identifies the batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListReservations request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of all reservations that have been purchased by this account in the current Amazon Web Services Region.
    public var reservations: [MediaConnectClientTypes.Reservation]?

    public init(
        nextToken: Swift.String? = nil,
        reservations: [MediaConnectClientTypes.Reservation]? = nil
    ) {
        self.nextToken = nextToken
        self.reservations = reservations
    }
}

extension MediaConnectClientTypes {

    /// A filter that can be used to retrieve a list of router inputs.
    public enum RouterInputFilter: Swift.Sendable {
        /// The AWS Regions of the router inputs to include in the filter.
        case regionnames([Swift.String])
        /// The types of router inputs to include in the filter.
        case inputtypes([MediaConnectClientTypes.RouterInputType])
        /// The names of the router inputs to include in the filter.
        case namecontains([Swift.String])
        /// The Amazon Resource Names (ARNs) of the network interfaces associated with the router inputs to include in the filter.
        case networkinterfacearns([Swift.String])
        /// Filter criteria to list router inputs based on their routing scope (REGIONAL or GLOBAL).
        case routingscopes([MediaConnectClientTypes.RoutingScope])
        case sdkUnknown(Swift.String)
    }
}

public struct ListRouterInputsInput: Swift.Sendable {
    /// The filters to apply when retrieving the list of router inputs.
    public var filters: [MediaConnectClientTypes.RouterInputFilter]?
    /// The maximum number of router inputs to return in the response.
    public var maxResults: Swift.Int?
    /// A token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [MediaConnectClientTypes.RouterInputFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRouterInputsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The summary information for the retrieved router inputs.
    /// This member is required.
    public var routerInputs: [MediaConnectClientTypes.ListedRouterInput]?

    public init(
        nextToken: Swift.String? = nil,
        routerInputs: [MediaConnectClientTypes.ListedRouterInput]? = nil
    ) {
        self.nextToken = nextToken
        self.routerInputs = routerInputs
    }
}

extension MediaConnectClientTypes {

    /// A filter that can be used to retrieve a list of router network interfaces.
    public enum RouterNetworkInterfaceFilter: Swift.Sendable {
        /// The AWS Regions of the router network interfaces to include in the filter.
        case regionnames([Swift.String])
        /// The types of router network interfaces to include in the filter.
        case networkinterfacetypes([MediaConnectClientTypes.RouterNetworkInterfaceType])
        /// The names of the router network interfaces to include in the filter.
        case namecontains([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

public struct ListRouterNetworkInterfacesInput: Swift.Sendable {
    /// The filters to apply when retrieving the list of router network interfaces.
    public var filters: [MediaConnectClientTypes.RouterNetworkInterfaceFilter]?
    /// The maximum number of router network interfaces to return in the response.
    public var maxResults: Swift.Int?
    /// A token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [MediaConnectClientTypes.RouterNetworkInterfaceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRouterNetworkInterfacesOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The summary information for the retrieved router network interfaces.
    /// This member is required.
    public var routerNetworkInterfaces: [MediaConnectClientTypes.ListedRouterNetworkInterface]?

    public init(
        nextToken: Swift.String? = nil,
        routerNetworkInterfaces: [MediaConnectClientTypes.ListedRouterNetworkInterface]? = nil
    ) {
        self.nextToken = nextToken
        self.routerNetworkInterfaces = routerNetworkInterfaces
    }
}

extension MediaConnectClientTypes {

    /// A filter that can be used to retrieve a list of router outputs.
    public enum RouterOutputFilter: Swift.Sendable {
        /// The AWS Regions of the router outputs to include in the filter.
        case regionnames([Swift.String])
        /// The types of router outputs to include in the filter.
        case outputtypes([MediaConnectClientTypes.RouterOutputType])
        /// The names of the router outputs to include in the filter.
        case namecontains([Swift.String])
        /// The Amazon Resource Names (ARNs) of the network interfaces associated with the router outputs to include in the filter.
        case networkinterfacearns([Swift.String])
        /// The ARNs of the router inputs associated with the router outputs to include in the filter.
        case routedinputarns([Swift.String])
        /// Filter criteria to list router outputs based on their routing scope.
        case routingscopes([MediaConnectClientTypes.RoutingScope])
        case sdkUnknown(Swift.String)
    }
}

public struct ListRouterOutputsInput: Swift.Sendable {
    /// The filters to apply when retrieving the list of router outputs.
    public var filters: [MediaConnectClientTypes.RouterOutputFilter]?
    /// The maximum number of router outputs to return in the response.
    public var maxResults: Swift.Int?
    /// A token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [MediaConnectClientTypes.RouterOutputFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRouterOutputsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The summary information for the retrieved router outputs.
    /// This member is required.
    public var routerOutputs: [MediaConnectClientTypes.ListedRouterOutput]?

    public init(
        nextToken: Swift.String? = nil,
        routerOutputs: [MediaConnectClientTypes.ListedRouterOutput]? = nil
    ) {
        self.nextToken = nextToken
        self.routerOutputs = routerOutputs
    }
}

public struct ListTagsForGlobalResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the global resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForGlobalResourceOutput: Swift.Sendable {
    /// A map of tag keys and values associated with the global resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the MediaConnect resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct PurchaseOfferingInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?
    /// The name that you want to use for the reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
    /// This member is required.
    public var start: Swift.String?

    public init(
        offeringArn: Swift.String? = nil,
        reservationName: Swift.String? = nil,
        start: Swift.String? = nil
    ) {
        self.offeringArn = offeringArn
        self.reservationName = reservationName
        self.start = start
    }
}

public struct PurchaseOfferingOutput: Swift.Sendable {
    /// The details of the reservation that you just created when you purchased the offering.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    ) {
        self.reservation = reservation
    }
}

public struct RestartRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to restart.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct RestartRouterInputOutput: Swift.Sendable {
    /// The ARN of the router input that was restarted.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router input that was restarted.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router input after the restart operation.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterInputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterInputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct StartRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to start.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct StartRouterInputOutput: Swift.Sendable {
    /// The ARN of the router input that was started.
    /// This member is required.
    public var arn: Swift.String?
    /// The details of the maintenance schedule for the router input.
    /// This member is required.
    public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
    /// The type of maintenance schedule associated with the router input.
    /// This member is required.
    public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
    /// The name of the router input that was started.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router input after being started.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterInputState?

    public init(
        arn: Swift.String? = nil,
        maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
        maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterInputState? = nil
    ) {
        self.arn = arn
        self.maintenanceSchedule = maintenanceSchedule
        self.maintenanceScheduleType = maintenanceScheduleType
        self.name = name
        self.state = state
    }
}

public struct StopRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct StopRouterInputOutput: Swift.Sendable {
    /// The ARN of the router input that was stopped.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router input that was stopped.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router input after being stopped.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterInputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterInputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct UpdateRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated configuration settings for the router input. Changing the type of the configuration is not supported.
    public var configuration: MediaConnectClientTypes.RouterInputConfiguration?
    /// The updated maintenance configuration settings for the router input, including any changes to preferred maintenance windows and schedules.
    public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
    /// The updated maximum bitrate for the router input.
    public var maximumBitrate: Swift.Int?
    /// The updated name for the router input.
    public var name: Swift.String?
    /// Specifies whether the router input can be assigned to outputs in different Regions. REGIONAL (default) - can be assigned only to outputs in the same Region. GLOBAL - can be assigned to outputs in any Region.
    public var routingScope: MediaConnectClientTypes.RoutingScope?
    /// The updated tier level for the router input.
    public var tier: MediaConnectClientTypes.RouterInputTier?
    /// The updated transit encryption settings for the router input.
    public var transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption?

    public init(
        arn: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterInputConfiguration? = nil,
        maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
        maximumBitrate: Swift.Int? = nil,
        name: Swift.String? = nil,
        routingScope: MediaConnectClientTypes.RoutingScope? = nil,
        tier: MediaConnectClientTypes.RouterInputTier? = nil,
        transitEncryption: MediaConnectClientTypes.RouterInputTransitEncryption? = nil
    ) {
        self.arn = arn
        self.configuration = configuration
        self.maintenanceConfiguration = maintenanceConfiguration
        self.maximumBitrate = maximumBitrate
        self.name = name
        self.routingScope = routingScope
        self.tier = tier
        self.transitEncryption = transitEncryption
    }
}

public struct UpdateRouterInputOutput: Swift.Sendable {
    /// The updated router input.
    /// This member is required.
    public var routerInput: MediaConnectClientTypes.RouterInput?

    public init(
        routerInput: MediaConnectClientTypes.RouterInput? = nil
    ) {
        self.routerInput = routerInput
    }
}

public struct UpdateRouterNetworkInterfaceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router network interface that you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated configuration settings for the router network interface. Changing the type of the configuration is not supported.
    public var configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration?
    /// The updated name for the router network interface.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.arn = arn
        self.configuration = configuration
        self.name = name
    }
}

public struct UpdateRouterNetworkInterfaceOutput: Swift.Sendable {
    /// The updated router network interface.
    /// This member is required.
    public var routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface?

    public init(
        routerNetworkInterface: MediaConnectClientTypes.RouterNetworkInterface? = nil
    ) {
        self.routerNetworkInterface = routerNetworkInterface
    }
}

public struct RestartRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to restart.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct RestartRouterOutputOutput: Swift.Sendable {
    /// The ARN of the router output that was restarted.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router output that was restarted.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router output after the restart operation.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterOutputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterOutputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct StartRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to start.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct StartRouterOutputOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that was started.
    /// This member is required.
    public var arn: Swift.String?
    /// The details of the maintenance schedule for the router output.
    /// This member is required.
    public var maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule?
    /// The type of maintenance schedule associated with the router output.
    /// This member is required.
    public var maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType?
    /// The name of the router output that was started.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router output after being started.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterOutputState?

    public init(
        arn: Swift.String? = nil,
        maintenanceSchedule: MediaConnectClientTypes.MaintenanceSchedule? = nil,
        maintenanceScheduleType: MediaConnectClientTypes.MaintenanceScheduleType? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterOutputState? = nil
    ) {
        self.arn = arn
        self.maintenanceSchedule = maintenanceSchedule
        self.maintenanceScheduleType = maintenanceScheduleType
        self.name = name
        self.state = state
    }
}

public struct StopRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct StopRouterOutputOutput: Swift.Sendable {
    /// The ARN of the router output that was stopped.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the router output that was stopped.
    /// This member is required.
    public var name: Swift.String?
    /// The current state of the router output after being stopped.
    /// This member is required.
    public var state: MediaConnectClientTypes.RouterOutputState?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        state: MediaConnectClientTypes.RouterOutputState? = nil
    ) {
        self.arn = arn
        self.name = name
        self.state = state
    }
}

public struct TakeRouterInputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router input that you want to associate with a router output.
    public var routerInputArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the router output that you want to associate with a router input.
    /// This member is required.
    public var routerOutputArn: Swift.String?

    public init(
        routerInputArn: Swift.String? = nil,
        routerOutputArn: Swift.String? = nil
    ) {
        self.routerInputArn = routerInputArn
        self.routerOutputArn = routerOutputArn
    }
}

public struct TakeRouterInputOutput: Swift.Sendable {
    /// The state of the association between the router input and output.
    /// This member is required.
    public var routedState: MediaConnectClientTypes.RouterOutputRoutedState?
    /// The ARN of the associated router input.
    public var routerInputArn: Swift.String?
    /// The name of the associated router input.
    public var routerInputName: Swift.String?
    /// The ARN of the associated router output.
    /// This member is required.
    public var routerOutputArn: Swift.String?
    /// The name of the associated router output.
    /// This member is required.
    public var routerOutputName: Swift.String?

    public init(
        routedState: MediaConnectClientTypes.RouterOutputRoutedState? = nil,
        routerInputArn: Swift.String? = nil,
        routerInputName: Swift.String? = nil,
        routerOutputArn: Swift.String? = nil,
        routerOutputName: Swift.String? = nil
    ) {
        self.routedState = routedState
        self.routerInputArn = routerInputArn
        self.routerInputName = routerInputName
        self.routerOutputArn = routerOutputArn
        self.routerOutputName = routerOutputName
    }
}

public struct UpdateRouterOutputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the router output that you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated configuration settings for the router output. Changing the type of the configuration is not supported.
    public var configuration: MediaConnectClientTypes.RouterOutputConfiguration?
    /// The updated maintenance configuration settings for the router output, including any changes to preferred maintenance windows and schedules.
    public var maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration?
    /// The updated maximum bitrate for the router output.
    public var maximumBitrate: Swift.Int?
    /// The updated name for the router output.
    public var name: Swift.String?
    /// Specifies whether the router output can take inputs that are in different Regions. REGIONAL (default) - can only take inputs from same Region. GLOBAL - can take inputs from any Region.
    public var routingScope: MediaConnectClientTypes.RoutingScope?
    /// The updated tier level for the router output.
    public var tier: MediaConnectClientTypes.RouterOutputTier?

    public init(
        arn: Swift.String? = nil,
        configuration: MediaConnectClientTypes.RouterOutputConfiguration? = nil,
        maintenanceConfiguration: MediaConnectClientTypes.MaintenanceConfiguration? = nil,
        maximumBitrate: Swift.Int? = nil,
        name: Swift.String? = nil,
        routingScope: MediaConnectClientTypes.RoutingScope? = nil,
        tier: MediaConnectClientTypes.RouterOutputTier? = nil
    ) {
        self.arn = arn
        self.configuration = configuration
        self.maintenanceConfiguration = maintenanceConfiguration
        self.maximumBitrate = maximumBitrate
        self.name = name
        self.routingScope = routingScope
        self.tier = tier
    }
}

public struct UpdateRouterOutputOutput: Swift.Sendable {
    /// The updated router output.
    /// This member is required.
    public var routerOutput: MediaConnectClientTypes.RouterOutput?

    public init(
        routerOutput: MediaConnectClientTypes.RouterOutput? = nil
    ) {
        self.routerOutput = routerOutput
    }
}

public struct TagGlobalResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the global resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of tag keys and values to add to the global resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the MediaConnect resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagGlobalResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the global resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the global resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension AddBridgeOutputsInput {

    static func urlPathProvider(_ value: AddBridgeOutputsInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs"
    }
}

extension AddBridgeSourcesInput {

    static func urlPathProvider(_ value: AddBridgeSourcesInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources"
    }
}

extension AddFlowMediaStreamsInput {

    static func urlPathProvider(_ value: AddFlowMediaStreamsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams"
    }
}

extension AddFlowOutputsInput {

    static func urlPathProvider(_ value: AddFlowOutputsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs"
    }
}

extension AddFlowSourcesInput {

    static func urlPathProvider(_ value: AddFlowSourcesInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source"
    }
}

extension AddFlowVpcInterfacesInput {

    static func urlPathProvider(_ value: AddFlowVpcInterfacesInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces"
    }
}

extension BatchGetRouterInputInput {

    static func urlPathProvider(_ value: BatchGetRouterInputInput) -> Swift.String? {
        return "/v1/routerInputs"
    }
}

extension BatchGetRouterInputInput {

    static func queryItemProvider(_ value: BatchGetRouterInputInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arns = value.arns else {
            let message = "Creating a URL Query Item failed. arns is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        arns.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "arns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension BatchGetRouterNetworkInterfaceInput {

    static func urlPathProvider(_ value: BatchGetRouterNetworkInterfaceInput) -> Swift.String? {
        return "/v1/routerNetworkInterfaces"
    }
}

extension BatchGetRouterNetworkInterfaceInput {

    static func queryItemProvider(_ value: BatchGetRouterNetworkInterfaceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arns = value.arns else {
            let message = "Creating a URL Query Item failed. arns is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        arns.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "arns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension BatchGetRouterOutputInput {

    static func urlPathProvider(_ value: BatchGetRouterOutputInput) -> Swift.String? {
        return "/v1/routerOutputs"
    }
}

extension BatchGetRouterOutputInput {

    static func queryItemProvider(_ value: BatchGetRouterOutputInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arns = value.arns else {
            let message = "Creating a URL Query Item failed. arns is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        arns.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "arns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CreateBridgeInput {

    static func urlPathProvider(_ value: CreateBridgeInput) -> Swift.String? {
        return "/v1/bridges"
    }
}

extension CreateFlowInput {

    static func urlPathProvider(_ value: CreateFlowInput) -> Swift.String? {
        return "/v1/flows"
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/v1/gateways"
    }
}

extension CreateRouterInputInput {

    static func urlPathProvider(_ value: CreateRouterInputInput) -> Swift.String? {
        return "/v1/routerInput"
    }
}

extension CreateRouterNetworkInterfaceInput {

    static func urlPathProvider(_ value: CreateRouterNetworkInterfaceInput) -> Swift.String? {
        return "/v1/routerNetworkInterface"
    }
}

extension CreateRouterOutputInput {

    static func urlPathProvider(_ value: CreateRouterOutputInput) -> Swift.String? {
        return "/v1/routerOutput"
    }
}

extension DeleteBridgeInput {

    static func urlPathProvider(_ value: DeleteBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension DeleteFlowInput {

    static func urlPathProvider(_ value: DeleteFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        guard let gatewayArn = value.gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

extension DeleteRouterInputInput {

    static func urlPathProvider(_ value: DeleteRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/\(arn.urlPercentEncoding())"
    }
}

extension DeleteRouterNetworkInterfaceInput {

    static func urlPathProvider(_ value: DeleteRouterNetworkInterfaceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerNetworkInterface/\(arn.urlPercentEncoding())"
    }
}

extension DeleteRouterOutputInput {

    static func urlPathProvider(_ value: DeleteRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/\(arn.urlPercentEncoding())"
    }
}

extension DeregisterGatewayInstanceInput {

    static func urlPathProvider(_ value: DeregisterGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension DeregisterGatewayInstanceInput {

    static func queryItemProvider(_ value: DeregisterGatewayInstanceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DescribeBridgeInput {

    static func urlPathProvider(_ value: DescribeBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension DescribeFlowInput {

    static func urlPathProvider(_ value: DescribeFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension DescribeFlowSourceMetadataInput {

    static func urlPathProvider(_ value: DescribeFlowSourceMetadataInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source-metadata"
    }
}

extension DescribeFlowSourceThumbnailInput {

    static func urlPathProvider(_ value: DescribeFlowSourceThumbnailInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source-thumbnail"
    }
}

extension DescribeGatewayInput {

    static func urlPathProvider(_ value: DescribeGatewayInput) -> Swift.String? {
        guard let gatewayArn = value.gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

extension DescribeGatewayInstanceInput {

    static func urlPathProvider(_ value: DescribeGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension DescribeOfferingInput {

    static func urlPathProvider(_ value: DescribeOfferingInput) -> Swift.String? {
        guard let offeringArn = value.offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

extension DescribeReservationInput {

    static func urlPathProvider(_ value: DescribeReservationInput) -> Swift.String? {
        guard let reservationArn = value.reservationArn else {
            return nil
        }
        return "/v1/reservations/\(reservationArn.urlPercentEncoding())"
    }
}

extension GetRouterInputInput {

    static func urlPathProvider(_ value: GetRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/\(arn.urlPercentEncoding())"
    }
}

extension GetRouterInputSourceMetadataInput {

    static func urlPathProvider(_ value: GetRouterInputSourceMetadataInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/\(arn.urlPercentEncoding())/source-metadata"
    }
}

extension GetRouterInputThumbnailInput {

    static func urlPathProvider(_ value: GetRouterInputThumbnailInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/\(arn.urlPercentEncoding())/thumbnail"
    }
}

extension GetRouterNetworkInterfaceInput {

    static func urlPathProvider(_ value: GetRouterNetworkInterfaceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerNetworkInterface/\(arn.urlPercentEncoding())"
    }
}

extension GetRouterOutputInput {

    static func urlPathProvider(_ value: GetRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/\(arn.urlPercentEncoding())"
    }
}

extension GrantFlowEntitlementsInput {

    static func urlPathProvider(_ value: GrantFlowEntitlementsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements"
    }
}

extension ListBridgesInput {

    static func urlPathProvider(_ value: ListBridgesInput) -> Swift.String? {
        return "/v1/bridges"
    }
}

extension ListBridgesInput {

    static func queryItemProvider(_ value: ListBridgesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filterArn = value.filterArn {
            let filterArnQueryItem = Smithy.URIQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
            items.append(filterArnQueryItem)
        }
        return items
    }
}

extension ListEntitlementsInput {

    static func urlPathProvider(_ value: ListEntitlementsInput) -> Swift.String? {
        return "/v1/entitlements"
    }
}

extension ListEntitlementsInput {

    static func queryItemProvider(_ value: ListEntitlementsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFlowsInput {

    static func urlPathProvider(_ value: ListFlowsInput) -> Swift.String? {
        return "/v1/flows"
    }
}

extension ListFlowsInput {

    static func queryItemProvider(_ value: ListFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGatewayInstancesInput {

    static func urlPathProvider(_ value: ListGatewayInstancesInput) -> Swift.String? {
        return "/v1/gateway-instances"
    }
}

extension ListGatewayInstancesInput {

    static func queryItemProvider(_ value: ListGatewayInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filterArn = value.filterArn {
            let filterArnQueryItem = Smithy.URIQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
            items.append(filterArnQueryItem)
        }
        return items
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/v1/gateways"
    }
}

extension ListGatewaysInput {

    static func queryItemProvider(_ value: ListGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOfferingsInput {

    static func urlPathProvider(_ value: ListOfferingsInput) -> Swift.String? {
        return "/v1/offerings"
    }
}

extension ListOfferingsInput {

    static func queryItemProvider(_ value: ListOfferingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReservationsInput {

    static func urlPathProvider(_ value: ListReservationsInput) -> Swift.String? {
        return "/v1/reservations"
    }
}

extension ListReservationsInput {

    static func queryItemProvider(_ value: ListReservationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRouterInputsInput {

    static func urlPathProvider(_ value: ListRouterInputsInput) -> Swift.String? {
        return "/v1/routerInputs"
    }
}

extension ListRouterInputsInput {

    static func queryItemProvider(_ value: ListRouterInputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRouterNetworkInterfacesInput {

    static func urlPathProvider(_ value: ListRouterNetworkInterfacesInput) -> Swift.String? {
        return "/v1/routerNetworkInterfaces"
    }
}

extension ListRouterNetworkInterfacesInput {

    static func queryItemProvider(_ value: ListRouterNetworkInterfacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRouterOutputsInput {

    static func urlPathProvider(_ value: ListRouterOutputsInput) -> Swift.String? {
        return "/v1/routerOutputs"
    }
}

extension ListRouterOutputsInput {

    static func queryItemProvider(_ value: ListRouterOutputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForGlobalResourceInput {

    static func urlPathProvider(_ value: ListTagsForGlobalResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/global/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PurchaseOfferingInput {

    static func urlPathProvider(_ value: PurchaseOfferingInput) -> Swift.String? {
        guard let offeringArn = value.offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

extension RemoveBridgeOutputInput {

    static func urlPathProvider(_ value: RemoveBridgeOutputInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let outputName = value.outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

extension RemoveBridgeSourceInput {

    static func urlPathProvider(_ value: RemoveBridgeSourceInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let sourceName = value.sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

extension RemoveFlowMediaStreamInput {

    static func urlPathProvider(_ value: RemoveFlowMediaStreamInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let mediaStreamName = value.mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

extension RemoveFlowOutputInput {

    static func urlPathProvider(_ value: RemoveFlowOutputInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let outputArn = value.outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

extension RemoveFlowSourceInput {

    static func urlPathProvider(_ value: RemoveFlowSourceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let sourceArn = value.sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

extension RemoveFlowVpcInterfaceInput {

    static func urlPathProvider(_ value: RemoveFlowVpcInterfaceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let vpcInterfaceName = value.vpcInterfaceName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces/\(vpcInterfaceName.urlPercentEncoding())"
    }
}

extension RestartRouterInputInput {

    static func urlPathProvider(_ value: RestartRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/restart/\(arn.urlPercentEncoding())"
    }
}

extension RestartRouterOutputInput {

    static func urlPathProvider(_ value: RestartRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/restart/\(arn.urlPercentEncoding())"
    }
}

extension RevokeFlowEntitlementInput {

    static func urlPathProvider(_ value: RevokeFlowEntitlementInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let entitlementArn = value.entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

extension StartFlowInput {

    static func urlPathProvider(_ value: StartFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/start/\(flowArn.urlPercentEncoding())"
    }
}

extension StartRouterInputInput {

    static func urlPathProvider(_ value: StartRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/start/\(arn.urlPercentEncoding())"
    }
}

extension StartRouterOutputInput {

    static func urlPathProvider(_ value: StartRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/start/\(arn.urlPercentEncoding())"
    }
}

extension StopFlowInput {

    static func urlPathProvider(_ value: StopFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/stop/\(flowArn.urlPercentEncoding())"
    }
}

extension StopRouterInputInput {

    static func urlPathProvider(_ value: StopRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/stop/\(arn.urlPercentEncoding())"
    }
}

extension StopRouterOutputInput {

    static func urlPathProvider(_ value: StopRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/stop/\(arn.urlPercentEncoding())"
    }
}

extension TagGlobalResourceInput {

    static func urlPathProvider(_ value: TagGlobalResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/global/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TakeRouterInputInput {

    static func urlPathProvider(_ value: TakeRouterInputInput) -> Swift.String? {
        guard let routerOutputArn = value.routerOutputArn else {
            return nil
        }
        return "/v1/routerOutput/takeRouterInput/\(routerOutputArn.urlPercentEncoding())"
    }
}

extension UntagGlobalResourceInput {

    static func urlPathProvider(_ value: UntagGlobalResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/global/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagGlobalResourceInput {

    static func queryItemProvider(_ value: UntagGlobalResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateBridgeInput {

    static func urlPathProvider(_ value: UpdateBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension UpdateBridgeOutputInput {

    static func urlPathProvider(_ value: UpdateBridgeOutputInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let outputName = value.outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

extension UpdateBridgeSourceInput {

    static func urlPathProvider(_ value: UpdateBridgeSourceInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let sourceName = value.sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

extension UpdateBridgeStateInput {

    static func urlPathProvider(_ value: UpdateBridgeStateInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/state"
    }
}

extension UpdateFlowInput {

    static func urlPathProvider(_ value: UpdateFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension UpdateFlowEntitlementInput {

    static func urlPathProvider(_ value: UpdateFlowEntitlementInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let entitlementArn = value.entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

extension UpdateFlowMediaStreamInput {

    static func urlPathProvider(_ value: UpdateFlowMediaStreamInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let mediaStreamName = value.mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

extension UpdateFlowOutputInput {

    static func urlPathProvider(_ value: UpdateFlowOutputInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let outputArn = value.outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

extension UpdateFlowSourceInput {

    static func urlPathProvider(_ value: UpdateFlowSourceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let sourceArn = value.sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

extension UpdateGatewayInstanceInput {

    static func urlPathProvider(_ value: UpdateGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension UpdateRouterInputInput {

    static func urlPathProvider(_ value: UpdateRouterInputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerInput/\(arn.urlPercentEncoding())"
    }
}

extension UpdateRouterNetworkInterfaceInput {

    static func urlPathProvider(_ value: UpdateRouterNetworkInterfaceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerNetworkInterface/\(arn.urlPercentEncoding())"
    }
}

extension UpdateRouterOutputInput {

    static func urlPathProvider(_ value: UpdateRouterOutputInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/v1/routerOutput/\(arn.urlPercentEncoding())"
    }
}

extension AddBridgeOutputsInput {

    static func write(value: AddBridgeOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddBridgeOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddBridgeSourcesInput {

    static func write(value: AddBridgeSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.AddBridgeSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowMediaStreamsInput {

    static func write(value: AddFlowMediaStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mediaStreams"].writeList(value.mediaStreams, memberWritingClosure: MediaConnectClientTypes.AddMediaStreamRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowOutputsInput {

    static func write(value: AddFlowOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowSourcesInput {

    static func write(value: AddFlowSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.SetSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowVpcInterfacesInput {

    static func write(value: AddFlowVpcInterfacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcInterfaces"].writeList(value.vpcInterfaces, memberWritingClosure: MediaConnectClientTypes.VpcInterfaceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBridgeInput {

    static func write(value: CreateBridgeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressGatewayBridge"].write(value.egressGatewayBridge, with: MediaConnectClientTypes.AddEgressGatewayBridgeRequest.write(value:to:))
        try writer["ingressGatewayBridge"].write(value.ingressGatewayBridge, with: MediaConnectClientTypes.AddIngressGatewayBridgeRequest.write(value:to:))
        try writer["name"].write(value.name)
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddBridgeOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["placementArn"].write(value.placementArn)
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.FailoverConfig.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.AddBridgeSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFlowInput {

    static func write(value: CreateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["entitlements"].writeList(value.entitlements, memberWritingClosure: MediaConnectClientTypes.GrantEntitlementRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["flowSize"].write(value.flowSize)
        try writer["flowTags"].writeMap(value.flowTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maintenance"].write(value.maintenance, with: MediaConnectClientTypes.AddMaintenance.write(value:to:))
        try writer["mediaStreams"].writeList(value.mediaStreams, memberWritingClosure: MediaConnectClientTypes.AddMediaStreamRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["ndiConfig"].write(value.ndiConfig, with: MediaConnectClientTypes.NdiConfig.write(value:to:))
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source, with: MediaConnectClientTypes.SetSourceRequest.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.FailoverConfig.write(value:to:))
        try writer["sourceMonitoringConfig"].write(value.sourceMonitoringConfig, with: MediaConnectClientTypes.MonitoringConfig.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.SetSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcInterfaces"].writeList(value.vpcInterfaces, memberWritingClosure: MediaConnectClientTypes.VpcInterfaceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressCidrBlocks"].writeList(value.egressCidrBlocks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["networks"].writeList(value.networks, memberWritingClosure: MediaConnectClientTypes.GatewayNetwork.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRouterInputInput {

    static func write(value: CreateRouterInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterInputConfiguration.write(value:to:))
        try writer["maintenanceConfiguration"].write(value.maintenanceConfiguration, with: MediaConnectClientTypes.MaintenanceConfiguration.write(value:to:))
        try writer["maximumBitrate"].write(value.maximumBitrate)
        try writer["name"].write(value.name)
        try writer["regionName"].write(value.regionName)
        try writer["routingScope"].write(value.routingScope)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tier"].write(value.tier)
        try writer["transitEncryption"].write(value.transitEncryption, with: MediaConnectClientTypes.RouterInputTransitEncryption.write(value:to:))
    }
}

extension CreateRouterNetworkInterfaceInput {

    static func write(value: CreateRouterNetworkInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["regionName"].write(value.regionName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRouterOutputInput {

    static func write(value: CreateRouterOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterOutputConfiguration.write(value:to:))
        try writer["maintenanceConfiguration"].write(value.maintenanceConfiguration, with: MediaConnectClientTypes.MaintenanceConfiguration.write(value:to:))
        try writer["maximumBitrate"].write(value.maximumBitrate)
        try writer["name"].write(value.name)
        try writer["regionName"].write(value.regionName)
        try writer["routingScope"].write(value.routingScope)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tier"].write(value.tier)
    }
}

extension GrantFlowEntitlementsInput {

    static func write(value: GrantFlowEntitlementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entitlements"].writeList(value.entitlements, memberWritingClosure: MediaConnectClientTypes.GrantEntitlementRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListRouterInputsInput {

    static func write(value: ListRouterInputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: MediaConnectClientTypes.RouterInputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListRouterNetworkInterfacesInput {

    static func write(value: ListRouterNetworkInterfacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: MediaConnectClientTypes.RouterNetworkInterfaceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListRouterOutputsInput {

    static func write(value: ListRouterOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: MediaConnectClientTypes.RouterOutputFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PurchaseOfferingInput {

    static func write(value: PurchaseOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reservationName"].write(value.reservationName)
        try writer["start"].write(value.start)
    }
}

extension TagGlobalResourceInput {

    static func write(value: TagGlobalResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TakeRouterInputInput {

    static func write(value: TakeRouterInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["routerInputArn"].write(value.routerInputArn)
    }
}

extension UpdateBridgeInput {

    static func write(value: UpdateBridgeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressGatewayBridge"].write(value.egressGatewayBridge, with: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest.write(value:to:))
        try writer["ingressGatewayBridge"].write(value.ingressGatewayBridge, with: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.UpdateFailoverConfig.write(value:to:))
    }
}

extension UpdateBridgeOutputInput {

    static func write(value: UpdateBridgeOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkOutput"].write(value.networkOutput, with: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest.write(value:to:))
    }
}

extension UpdateBridgeSourceInput {

    static func write(value: UpdateBridgeSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowSource"].write(value.flowSource, with: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest.write(value:to:))
        try writer["networkSource"].write(value.networkSource, with: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest.write(value:to:))
    }
}

extension UpdateBridgeStateInput {

    static func write(value: UpdateBridgeStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredState"].write(value.desiredState)
    }
}

extension UpdateFlowInput {

    static func write(value: UpdateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowSize"].write(value.flowSize)
        try writer["maintenance"].write(value.maintenance, with: MediaConnectClientTypes.UpdateMaintenance.write(value:to:))
        try writer["ndiConfig"].write(value.ndiConfig, with: MediaConnectClientTypes.NdiConfig.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.UpdateFailoverConfig.write(value:to:))
        try writer["sourceMonitoringConfig"].write(value.sourceMonitoringConfig, with: MediaConnectClientTypes.MonitoringConfig.write(value:to:))
    }
}

extension UpdateFlowEntitlementInput {

    static func write(value: UpdateFlowEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["entitlementStatus"].write(value.entitlementStatus)
        try writer["subscribers"].writeList(value.subscribers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFlowMediaStreamInput {

    static func write(value: UpdateFlowMediaStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: MediaConnectClientTypes.MediaStreamAttributesRequest.write(value:to:))
        try writer["clockRate"].write(value.clockRate)
        try writer["description"].write(value.description)
        try writer["mediaStreamType"].write(value.mediaStreamType)
        try writer["videoFormat"].write(value.videoFormat)
    }
}

extension UpdateFlowOutputInput {

    static func write(value: UpdateFlowOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrAllowList"].writeList(value.cidrAllowList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["destination"].write(value.destination)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["maxLatency"].write(value.maxLatency)
        try writer["mediaStreamOutputConfigurations"].writeList(value.mediaStreamOutputConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["ndiProgramName"].write(value.ndiProgramName)
        try writer["ndiSpeedHqQuality"].write(value.ndiSpeedHqQuality)
        try writer["outputStatus"].write(value.outputStatus)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["remoteId"].write(value.remoteId)
        try writer["routerIntegrationState"].write(value.routerIntegrationState)
        try writer["routerIntegrationTransitEncryption"].write(value.routerIntegrationTransitEncryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["smoothingLatency"].write(value.smoothingLatency)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension UpdateFlowSourceInput {

    static func write(value: UpdateFlowSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryption"].write(value.decryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["description"].write(value.description)
        try writer["entitlementArn"].write(value.entitlementArn)
        try writer["gatewayBridgeSource"].write(value.gatewayBridgeSource, with: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest.write(value:to:))
        try writer["ingestPort"].write(value.ingestPort)
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxLatency"].write(value.maxLatency)
        try writer["maxSyncBuffer"].write(value.maxSyncBuffer)
        try writer["mediaStreamSourceConfigurations"].writeList(value.mediaStreamSourceConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["protocol"].write(value.`protocol`)
        try writer["routerIntegrationState"].write(value.routerIntegrationState)
        try writer["routerIntegrationTransitDecryption"].write(value.routerIntegrationTransitDecryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["sourceListenerAddress"].write(value.sourceListenerAddress)
        try writer["sourceListenerPort"].write(value.sourceListenerPort)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
        try writer["whitelistCidr"].write(value.whitelistCidr)
    }
}

extension UpdateGatewayInstanceInput {

    static func write(value: UpdateGatewayInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgePlacement"].write(value.bridgePlacement)
    }
}

extension UpdateRouterInputInput {

    static func write(value: UpdateRouterInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterInputConfiguration.write(value:to:))
        try writer["maintenanceConfiguration"].write(value.maintenanceConfiguration, with: MediaConnectClientTypes.MaintenanceConfiguration.write(value:to:))
        try writer["maximumBitrate"].write(value.maximumBitrate)
        try writer["name"].write(value.name)
        try writer["routingScope"].write(value.routingScope)
        try writer["tier"].write(value.tier)
        try writer["transitEncryption"].write(value.transitEncryption, with: MediaConnectClientTypes.RouterInputTransitEncryption.write(value:to:))
    }
}

extension UpdateRouterNetworkInterfaceInput {

    static func write(value: UpdateRouterNetworkInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateRouterOutputInput {

    static func write(value: UpdateRouterOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: MediaConnectClientTypes.RouterOutputConfiguration.write(value:to:))
        try writer["maintenanceConfiguration"].write(value.maintenanceConfiguration, with: MediaConnectClientTypes.MaintenanceConfiguration.write(value:to:))
        try writer["maximumBitrate"].write(value.maximumBitrate)
        try writer["name"].write(value.name)
        try writer["routingScope"].write(value.routingScope)
        try writer["tier"].write(value.tier)
    }
}

extension AddBridgeOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddBridgeOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddBridgeOutputsOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddBridgeSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddBridgeSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddBridgeSourcesOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowMediaStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowMediaStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowMediaStreamsOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStreams = try reader["mediaStreams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStream.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowOutputsOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Output.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowSourcesOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowVpcInterfacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowVpcInterfacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowVpcInterfacesOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.vpcInterfaces = try reader["vpcInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.VpcInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRouterInputOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BatchGetRouterInputError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routerInputs = try reader["routerInputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterInput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetRouterNetworkInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRouterNetworkInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRouterNetworkInterfaceOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routerNetworkInterfaces = try reader["routerNetworkInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterNetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRouterOutputOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BatchGetRouterOutputError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routerOutputs = try reader["routerOutputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension CreateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        return value
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.gateway = try reader["gateway"].readIfPresent(with: MediaConnectClientTypes.Gateway.read(from:))
        return value
    }
}

extension CreateRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouterInputOutput()
        value.routerInput = try reader["routerInput"].readIfPresent(with: MediaConnectClientTypes.RouterInput.read(from:))
        return value
    }
}

extension CreateRouterNetworkInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouterNetworkInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouterNetworkInterfaceOutput()
        value.routerNetworkInterface = try reader["routerNetworkInterface"].readIfPresent(with: MediaConnectClientTypes.RouterNetworkInterface.read(from:))
        return value
    }
}

extension CreateRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouterOutputOutput()
        value.routerOutput = try reader["routerOutput"].readIfPresent(with: MediaConnectClientTypes.RouterOutput.read(from:))
        return value
    }
}

extension DeleteBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBridgeOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        return value
    }
}

extension DeleteFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent()
        return value
    }
}

extension DeleteRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRouterInputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteRouterNetworkInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouterNetworkInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRouterNetworkInterfaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRouterOutputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeregisterGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterGatewayInstanceOutput()
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent()
        value.instanceState = try reader["instanceState"].readIfPresent()
        return value
    }
}

extension DescribeBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension DescribeFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        value.messages = try reader["messages"].readIfPresent(with: MediaConnectClientTypes.Messages.read(from:))
        return value
    }
}

extension DescribeFlowSourceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowSourceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowSourceMetadataOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.transportMediaInfo = try reader["transportMediaInfo"].readIfPresent(with: MediaConnectClientTypes.TransportMediaInfo.read(from:))
        return value
    }
}

extension DescribeFlowSourceThumbnailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowSourceThumbnailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowSourceThumbnailOutput()
        value.thumbnailDetails = try reader["thumbnailDetails"].readIfPresent(with: MediaConnectClientTypes.ThumbnailDetails.read(from:))
        return value
    }
}

extension DescribeGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayOutput()
        value.gateway = try reader["gateway"].readIfPresent(with: MediaConnectClientTypes.Gateway.read(from:))
        return value
    }
}

extension DescribeGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayInstanceOutput()
        value.gatewayInstance = try reader["gatewayInstance"].readIfPresent(with: MediaConnectClientTypes.GatewayInstance.read(from:))
        return value
    }
}

extension DescribeOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOfferingOutput()
        value.offering = try reader["offering"].readIfPresent(with: MediaConnectClientTypes.Offering.read(from:))
        return value
    }
}

extension DescribeReservationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservationOutput()
        value.reservation = try reader["reservation"].readIfPresent(with: MediaConnectClientTypes.Reservation.read(from:))
        return value
    }
}

extension GetRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouterInputOutput()
        value.routerInput = try reader["routerInput"].readIfPresent(with: MediaConnectClientTypes.RouterInput.read(from:))
        return value
    }
}

extension GetRouterInputSourceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouterInputSourceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouterInputSourceMetadataOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sourceMetadataDetails = try reader["sourceMetadataDetails"].readIfPresent(with: MediaConnectClientTypes.RouterInputSourceMetadataDetails.read(from:))
        return value
    }
}

extension GetRouterInputThumbnailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouterInputThumbnailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouterInputThumbnailOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.thumbnailDetails = try reader["thumbnailDetails"].readIfPresent(with: MediaConnectClientTypes.RouterInputThumbnailDetails.read(from:))
        return value
    }
}

extension GetRouterNetworkInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouterNetworkInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouterNetworkInterfaceOutput()
        value.routerNetworkInterface = try reader["routerNetworkInterface"].readIfPresent(with: MediaConnectClientTypes.RouterNetworkInterface.read(from:))
        return value
    }
}

extension GetRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouterOutputOutput()
        value.routerOutput = try reader["routerOutput"].readIfPresent(with: MediaConnectClientTypes.RouterOutput.read(from:))
        return value
    }
}

extension GrantFlowEntitlementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GrantFlowEntitlementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GrantFlowEntitlementsOutput()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension ListBridgesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBridgesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBridgesOutput()
        value.bridges = try reader["bridges"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedBridge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEntitlementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitlementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntitlementsOutput()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedEntitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowsOutput()
        value.flows = try reader["flows"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedFlow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewayInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewayInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewayInstancesOutput()
        value.instances = try reader["instances"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedGatewayInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["gateways"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedGateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOfferingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOfferingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOfferingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.offerings = try reader["offerings"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Offering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListReservationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReservationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReservationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.reservations = try reader["reservations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Reservation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRouterInputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRouterInputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRouterInputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routerInputs = try reader["routerInputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedRouterInput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRouterNetworkInterfacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRouterNetworkInterfacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRouterNetworkInterfacesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routerNetworkInterfaces = try reader["routerNetworkInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedRouterNetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRouterOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRouterOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRouterOutputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routerOutputs = try reader["routerOutputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedRouterOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForGlobalResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForGlobalResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForGlobalResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PurchaseOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PurchaseOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PurchaseOfferingOutput()
        value.reservation = try reader["reservation"].readIfPresent(with: MediaConnectClientTypes.Reservation.read(from:))
        return value
    }
}

extension RemoveBridgeOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveBridgeOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveBridgeOutputOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.outputName = try reader["outputName"].readIfPresent()
        return value
    }
}

extension RemoveBridgeSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveBridgeSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveBridgeSourceOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.sourceName = try reader["sourceName"].readIfPresent()
        return value
    }
}

extension RemoveFlowMediaStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowMediaStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowMediaStreamOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent()
        return value
    }
}

extension RemoveFlowOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowOutputOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.outputArn = try reader["outputArn"].readIfPresent()
        return value
    }
}

extension RemoveFlowSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowSourceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.sourceArn = try reader["sourceArn"].readIfPresent()
        return value
    }
}

extension RemoveFlowVpcInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowVpcInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowVpcInterfaceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.nonDeletedNetworkInterfaceIds = try reader["nonDeletedNetworkInterfaceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        return value
    }
}

extension RestartRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestartRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestartRouterInputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RestartRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestartRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestartRouterOutputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RevokeFlowEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeFlowEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RevokeFlowEntitlementOutput()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension StartFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension StartRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRouterInputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StartRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRouterOutputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StopFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension StopRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopRouterInputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StopRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopRouterOutputOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TagGlobalResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagGlobalResourceOutput {
        return TagGlobalResourceOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TakeRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TakeRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TakeRouterInputOutput()
        value.routedState = try reader["routedState"].readIfPresent() ?? .sdkUnknown("")
        value.routerInputArn = try reader["routerInputArn"].readIfPresent()
        value.routerInputName = try reader["routerInputName"].readIfPresent()
        value.routerOutputArn = try reader["routerOutputArn"].readIfPresent() ?? ""
        value.routerOutputName = try reader["routerOutputName"].readIfPresent() ?? ""
        return value
    }
}

extension UntagGlobalResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagGlobalResourceOutput {
        return UntagGlobalResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension UpdateBridgeOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeOutputOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: MediaConnectClientTypes.BridgeOutput.read(from:))
        return value
    }
}

extension UpdateBridgeSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeSourceOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.BridgeSource.read(from:))
        return value
    }
}

extension UpdateBridgeStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeStateOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.desiredState = try reader["desiredState"].readIfPresent()
        return value
    }
}

extension UpdateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        return value
    }
}

extension UpdateFlowEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowEntitlementOutput()
        value.entitlement = try reader["entitlement"].readIfPresent(with: MediaConnectClientTypes.Entitlement.read(from:))
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension UpdateFlowMediaStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowMediaStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowMediaStreamOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStream = try reader["mediaStream"].readIfPresent(with: MediaConnectClientTypes.MediaStream.read(from:))
        return value
    }
}

extension UpdateFlowOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutputOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: MediaConnectClientTypes.Output.read(from:))
        return value
    }
}

extension UpdateFlowSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowSourceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.Source.read(from:))
        return value
    }
}

extension UpdateGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayInstanceOutput()
        value.bridgePlacement = try reader["bridgePlacement"].readIfPresent()
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent()
        return value
    }
}

extension UpdateRouterInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouterInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouterInputOutput()
        value.routerInput = try reader["routerInput"].readIfPresent(with: MediaConnectClientTypes.RouterInput.read(from:))
        return value
    }
}

extension UpdateRouterNetworkInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouterNetworkInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouterNetworkInterfaceOutput()
        value.routerNetworkInterface = try reader["routerNetworkInterface"].readIfPresent(with: MediaConnectClientTypes.RouterNetworkInterface.read(from:))
        return value
    }
}

extension UpdateRouterOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouterOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouterOutputOutput()
        value.routerOutput = try reader["routerOutput"].readIfPresent(with: MediaConnectClientTypes.RouterOutput.read(from:))
        return value
    }
}

enum AddBridgeOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddBridgeSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowMediaStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AddFlowOutputs420Exception": return try AddFlowOutputs420Exception.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowVpcInterfacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetRouterNetworkInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CreateBridge420Exception": return try CreateBridge420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CreateFlow420Exception": return try CreateFlow420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CreateGateway420Exception": return try CreateGateway420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "RouterInputServiceQuotaExceededException": return try RouterInputServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouterNetworkInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "RouterNetworkInterfaceServiceQuotaExceededException": return try RouterNetworkInterfaceServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "RouterOutputServiceQuotaExceededException": return try RouterOutputServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouterNetworkInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowSourceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowSourceThumbnailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouterInputSourceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouterInputThumbnailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouterNetworkInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GrantFlowEntitlementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "GrantFlowEntitlements420Exception": return try GrantFlowEntitlements420Exception.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBridgesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitlementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewayInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOfferingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReservationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRouterInputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRouterNetworkInterfacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRouterOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForGlobalResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PurchaseOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveBridgeOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveBridgeSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowMediaStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowVpcInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestartRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestartRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeFlowEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagGlobalResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TakeRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagGlobalResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowMediaStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouterInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouterNetworkInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouterOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AddFlowOutputs420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AddFlowOutputs420Exception {
        let reader = baseError.errorBodyReader
        var value = AddFlowOutputs420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateBridge420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateBridge420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateBridge420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateFlow420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateFlow420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateFlow420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateGateway420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateGateway420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateGateway420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RouterInputServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RouterInputServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = RouterInputServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RouterNetworkInterfaceServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RouterNetworkInterfaceServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = RouterNetworkInterfaceServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RouterOutputServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RouterOutputServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = RouterOutputServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GrantFlowEntitlements420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GrantFlowEntitlements420Exception {
        let reader = baseError.errorBodyReader
        var value = GrantFlowEntitlements420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MediaConnectClientTypes.BridgeOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeOutput()
        value.flowOutput = try reader["flowOutput"].readIfPresent(with: MediaConnectClientTypes.BridgeFlowOutput.read(from:))
        value.networkOutput = try reader["networkOutput"].readIfPresent(with: MediaConnectClientTypes.BridgeNetworkOutput.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.BridgeNetworkOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeNetworkOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeNetworkOutput()
        value.ipAddress = try reader["ipAddress"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.ttl = try reader["ttl"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.BridgeFlowOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeFlowOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.flowSourceArn = try reader["flowSourceArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.BridgeSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeSource()
        value.flowSource = try reader["flowSource"].readIfPresent(with: MediaConnectClientTypes.BridgeFlowSource.read(from:))
        value.networkSource = try reader["networkSource"].readIfPresent(with: MediaConnectClientTypes.BridgeNetworkSource.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.BridgeNetworkSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeNetworkSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeNetworkSource()
        value.multicastIp = try reader["multicastIp"].readIfPresent() ?? ""
        value.multicastSourceSettings = try reader["multicastSourceSettings"].readIfPresent(with: MediaConnectClientTypes.MulticastSourceSettings.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.MulticastSourceSettings {

    static func write(value: MediaConnectClientTypes.MulticastSourceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["multicastSourceIp"].write(value.multicastSourceIp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MulticastSourceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MulticastSourceSettings()
        value.multicastSourceIp = try reader["multicastSourceIp"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.BridgeFlowSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeFlowSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeFlowSource()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.flowVpcInterfaceAttachment = try reader["flowVpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputArn = try reader["outputArn"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.VpcInterfaceAttachment {

    static func write(value: MediaConnectClientTypes.VpcInterfaceAttachment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VpcInterfaceAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VpcInterfaceAttachment()
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStream {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStream()
        value.attributes = try reader["attributes"].readIfPresent(with: MediaConnectClientTypes.MediaStreamAttributes.read(from:))
        value.clockRate = try reader["clockRate"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.fmt = try reader["fmt"].readIfPresent() ?? 0
        value.mediaStreamId = try reader["mediaStreamId"].readIfPresent() ?? 0
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        value.mediaStreamType = try reader["mediaStreamType"].readIfPresent() ?? .sdkUnknown("")
        value.videoFormat = try reader["videoFormat"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamAttributes()
        value.fmtp = try reader["fmtp"].readIfPresent(with: MediaConnectClientTypes.Fmtp.read(from:))
        value.lang = try reader["lang"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Fmtp {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Fmtp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Fmtp()
        value.channelOrder = try reader["channelOrder"].readIfPresent()
        value.colorimetry = try reader["colorimetry"].readIfPresent()
        value.exactFramerate = try reader["exactFramerate"].readIfPresent()
        value.par = try reader["par"].readIfPresent()
        value.range = try reader["range"].readIfPresent()
        value.scanMode = try reader["scanMode"].readIfPresent()
        value.tcs = try reader["tcs"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Output {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Output {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Output()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.listenerAddress = try reader["listenerAddress"].readIfPresent()
        value.mediaLiveInputArn = try reader["mediaLiveInputArn"].readIfPresent()
        value.mediaStreamOutputConfigurations = try reader["mediaStreamOutputConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStreamOutputConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputArn = try reader["outputArn"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent()
        value.transport = try reader["transport"].readIfPresent(with: MediaConnectClientTypes.Transport.read(from:))
        value.vpcInterfaceAttachment = try reader["vpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.bridgePorts = try reader["bridgePorts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputStatus = try reader["outputStatus"].readIfPresent()
        value.peerIpAddress = try reader["peerIpAddress"].readIfPresent()
        value.routerIntegrationState = try reader["routerIntegrationState"].readIfPresent()
        value.routerIntegrationTransitEncryption = try reader["routerIntegrationTransitEncryption"].readIfPresent(with: MediaConnectClientTypes.FlowTransitEncryption.read(from:))
        value.connectedRouterInputArn = try reader["connectedRouterInputArn"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.FlowTransitEncryption {

    static func write(value: MediaConnectClientTypes.FlowTransitEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKeyConfiguration"].write(value.encryptionKeyConfiguration, with: MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration.write(value:to:))
        try writer["encryptionKeyType"].write(value.encryptionKeyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FlowTransitEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FlowTransitEncryption()
        value.encryptionKeyType = try reader["encryptionKeyType"].readIfPresent()
        value.encryptionKeyConfiguration = try reader["encryptionKeyConfiguration"].readIfPresent(with: MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration {

    static func write(value: MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automatic(automatic):
                try writer["automatic"].write(automatic, with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.write(value:to:))
            case let .secretsmanager(secretsmanager):
                try writer["secretsManager"].write(secretsmanager, with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FlowTransitEncryptionKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "secretsManager":
                return .secretsmanager(try reader["secretsManager"].read(with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.read(from:)))
            case "automatic":
                return .automatic(try reader["automatic"].read(with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration {

    static func write(value: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration()
    }
}

extension MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration {

    static func write(value: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration()
        value.secretArn = try reader["secretArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Transport {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Transport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Transport()
        value.cidrAllowList = try reader["cidrAllowList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxBitrate = try reader["maxBitrate"].readIfPresent()
        value.maxLatency = try reader["maxLatency"].readIfPresent()
        value.maxSyncBuffer = try reader["maxSyncBuffer"].readIfPresent()
        value.minLatency = try reader["minLatency"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.remoteId = try reader["remoteId"].readIfPresent()
        value.senderControlPort = try reader["senderControlPort"].readIfPresent()
        value.senderIpAddress = try reader["senderIpAddress"].readIfPresent()
        value.smoothingLatency = try reader["smoothingLatency"].readIfPresent()
        value.sourceListenerAddress = try reader["sourceListenerAddress"].readIfPresent()
        value.sourceListenerPort = try reader["sourceListenerPort"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.ndiSpeedHqQuality = try reader["ndiSpeedHqQuality"].readIfPresent()
        value.ndiProgramName = try reader["ndiProgramName"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamOutputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamOutputConfiguration()
        value.destinationConfigurations = try reader["destinationConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.DestinationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.encodingName = try reader["encodingName"].readIfPresent() ?? .sdkUnknown("")
        value.encodingParameters = try reader["encodingParameters"].readIfPresent(with: MediaConnectClientTypes.EncodingParameters.read(from:))
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.EncodingParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.EncodingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.EncodingParameters()
        value.compressionFactor = try reader["compressionFactor"].readIfPresent() ?? 0.0
        value.encoderProfile = try reader["encoderProfile"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.DestinationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.DestinationConfiguration()
        value.destinationIp = try reader["destinationIp"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent() ?? 0
        value.interface = try reader["interface"].readIfPresent(with: MediaConnectClientTypes.Interface.read(from:))
        value.outboundIp = try reader["outboundIp"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Interface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Interface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Interface()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Encryption {

    static func write(value: MediaConnectClientTypes.Encryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithm"].write(value.algorithm)
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["deviceId"].write(value.deviceId)
        try writer["keyType"].write(value.keyType)
        try writer["region"].write(value.region)
        try writer["resourceId"].write(value.resourceId)
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Encryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Encryption()
        value.algorithm = try reader["algorithm"].readIfPresent()
        value.constantInitializationVector = try reader["constantInitializationVector"].readIfPresent()
        value.deviceId = try reader["deviceId"].readIfPresent()
        value.keyType = try reader["keyType"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.secretArn = try reader["secretArn"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Source {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Source()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.decryption = try reader["decryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.ingestIp = try reader["ingestIp"].readIfPresent()
        value.ingestPort = try reader["ingestPort"].readIfPresent()
        value.mediaStreamSourceConfigurations = try reader["mediaStreamSourceConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStreamSourceConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.senderControlPort = try reader["senderControlPort"].readIfPresent()
        value.senderIpAddress = try reader["senderIpAddress"].readIfPresent()
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.transport = try reader["transport"].readIfPresent(with: MediaConnectClientTypes.Transport.read(from:))
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        value.whitelistCidr = try reader["whitelistCidr"].readIfPresent()
        value.gatewayBridgeSource = try reader["gatewayBridgeSource"].readIfPresent(with: MediaConnectClientTypes.GatewayBridgeSource.read(from:))
        value.peerIpAddress = try reader["peerIpAddress"].readIfPresent()
        value.routerIntegrationState = try reader["routerIntegrationState"].readIfPresent()
        value.routerIntegrationTransitDecryption = try reader["routerIntegrationTransitDecryption"].readIfPresent(with: MediaConnectClientTypes.FlowTransitEncryption.read(from:))
        value.connectedRouterOutputArn = try reader["connectedRouterOutputArn"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.GatewayBridgeSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayBridgeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayBridgeSource()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.vpcInterfaceAttachment = try reader["vpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamSourceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamSourceConfiguration()
        value.encodingName = try reader["encodingName"].readIfPresent() ?? .sdkUnknown("")
        value.inputConfigurations = try reader["inputConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.InputConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.InputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.InputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.InputConfiguration()
        value.inputIp = try reader["inputIp"].readIfPresent() ?? ""
        value.inputPort = try reader["inputPort"].readIfPresent() ?? 0
        value.interface = try reader["interface"].readIfPresent(with: MediaConnectClientTypes.Interface.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.VpcInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VpcInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VpcInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkInterfaceIds = try reader["networkInterfaceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.networkInterfaceType = try reader["networkInterfaceType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetId = try reader["subnetId"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterInput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterInput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.inputType = try reader["inputType"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: MediaConnectClientTypes.RouterInputConfiguration.read(from:))
        value.routedOutputs = try reader["routedOutputs"].readIfPresent() ?? 0
        value.maximumRoutedOutputs = try reader["maximumRoutedOutputs"].readIfPresent()
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.maximumBitrate = try reader["maximumBitrate"].readIfPresent() ?? 0
        value.tier = try reader["tier"].readIfPresent() ?? .sdkUnknown("")
        value.routingScope = try reader["routingScope"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterInputMessage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.transitEncryption = try reader["transitEncryption"].readIfPresent(with: MediaConnectClientTypes.RouterInputTransitEncryption.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.streamDetails = try reader["streamDetails"].readIfPresent(with: MediaConnectClientTypes.RouterInputStreamDetails.read(from:))
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.maintenanceType = try reader["maintenanceType"].readIfPresent() ?? .sdkUnknown("")
        value.maintenanceConfiguration = try reader["maintenanceConfiguration"].readIfPresent(with: MediaConnectClientTypes.MaintenanceConfiguration.read(from:))
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent()
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MaintenanceSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MaintenanceSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "window":
                return .window(try reader["window"].read(with: MediaConnectClientTypes.WindowMaintenanceSchedule.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.WindowMaintenanceSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.WindowMaintenanceSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.WindowMaintenanceSchedule()
        value.start = try reader["start"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.end = try reader["end"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.scheduledTime = try reader["scheduledTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension MediaConnectClientTypes.MaintenanceConfiguration {

    static func write(value: MediaConnectClientTypes.MaintenanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .`default`(`default`):
                try writer["default"].write(`default`, with: MediaConnectClientTypes.DefaultMaintenanceConfiguration.write(value:to:))
            case let .preferreddaytime(preferreddaytime):
                try writer["preferredDayTime"].write(preferreddaytime, with: MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MaintenanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "preferredDayTime":
                return .preferreddaytime(try reader["preferredDayTime"].read(with: MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration.read(from:)))
            case "default":
                return .`default`(try reader["default"].read(with: MediaConnectClientTypes.DefaultMaintenanceConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.DefaultMaintenanceConfiguration {

    static func write(value: MediaConnectClientTypes.DefaultMaintenanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.DefaultMaintenanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MediaConnectClientTypes.DefaultMaintenanceConfiguration()
    }
}

extension MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration {

    static func write(value: MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["day"].write(value.day)
        try writer["time"].write(value.time)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.PreferredDayTimeMaintenanceConfiguration()
        value.day = try reader["day"].readIfPresent() ?? .sdkUnknown("")
        value.time = try reader["time"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterInputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "standard":
                return .standard(try reader["standard"].read(with: MediaConnectClientTypes.StandardRouterInputStreamDetails.read(from:)))
            case "failover":
                return .failover(try reader["failover"].read(with: MediaConnectClientTypes.FailoverRouterInputStreamDetails.read(from:)))
            case "merge":
                return .merge(try reader["merge"].read(with: MediaConnectClientTypes.MergeRouterInputStreamDetails.read(from:)))
            case "mediaConnectFlow":
                return .mediaconnectflow(try reader["mediaConnectFlow"].read(with: MediaConnectClientTypes.MediaConnectFlowRouterInputStreamDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.MediaConnectFlowRouterInputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaConnectFlowRouterInputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MediaConnectClientTypes.MediaConnectFlowRouterInputStreamDetails()
    }
}

extension MediaConnectClientTypes.MergeRouterInputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MergeRouterInputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MergeRouterInputStreamDetails()
        value.sourceIndexZeroStreamDetails = try reader["sourceIndexZeroStreamDetails"].readIfPresent(with: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails.read(from:))
        value.sourceIndexOneStreamDetails = try reader["sourceIndexOneStreamDetails"].readIfPresent(with: MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MergeRouterInputIndexedStreamDetails()
        value.sourceIndex = try reader["sourceIndex"].readIfPresent() ?? 0
        value.sourceIpAddress = try reader["sourceIpAddress"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.FailoverRouterInputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverRouterInputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FailoverRouterInputStreamDetails()
        value.sourceIndexZeroStreamDetails = try reader["sourceIndexZeroStreamDetails"].readIfPresent(with: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails.read(from:))
        value.sourceIndexOneStreamDetails = try reader["sourceIndexOneStreamDetails"].readIfPresent(with: MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FailoverRouterInputIndexedStreamDetails()
        value.sourceIndex = try reader["sourceIndex"].readIfPresent() ?? 0
        value.sourceIpAddress = try reader["sourceIpAddress"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.StandardRouterInputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.StandardRouterInputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.StandardRouterInputStreamDetails()
        value.sourceIpAddress = try reader["sourceIpAddress"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.RouterInputTransitEncryption {

    static func write(value: MediaConnectClientTypes.RouterInputTransitEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKeyConfiguration"].write(value.encryptionKeyConfiguration, with: MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration.write(value:to:))
        try writer["encryptionKeyType"].write(value.encryptionKeyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputTransitEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterInputTransitEncryption()
        value.encryptionKeyType = try reader["encryptionKeyType"].readIfPresent()
        value.encryptionKeyConfiguration = try reader["encryptionKeyConfiguration"].readIfPresent(with: MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration {

    static func write(value: MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automatic(automatic):
                try writer["automatic"].write(automatic, with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.write(value:to:))
            case let .secretsmanager(secretsmanager):
                try writer["secretsManager"].write(secretsmanager, with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputTransitEncryptionKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "secretsManager":
                return .secretsmanager(try reader["secretsManager"].read(with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.read(from:)))
            case "automatic":
                return .automatic(try reader["automatic"].read(with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.RouterInputMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterInputMessage()
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.RouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .failover(failover):
                try writer["failover"].write(failover, with: MediaConnectClientTypes.FailoverRouterInputConfiguration.write(value:to:))
            case let .mediaconnectflow(mediaconnectflow):
                try writer["mediaConnectFlow"].write(mediaconnectflow, with: MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration.write(value:to:))
            case let .merge(merge):
                try writer["merge"].write(merge, with: MediaConnectClientTypes.MergeRouterInputConfiguration.write(value:to:))
            case let .standard(standard):
                try writer["standard"].write(standard, with: MediaConnectClientTypes.StandardRouterInputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "standard":
                return .standard(try reader["standard"].read(with: MediaConnectClientTypes.StandardRouterInputConfiguration.read(from:)))
            case "failover":
                return .failover(try reader["failover"].read(with: MediaConnectClientTypes.FailoverRouterInputConfiguration.read(from:)))
            case "merge":
                return .merge(try reader["merge"].read(with: MediaConnectClientTypes.MergeRouterInputConfiguration.read(from:)))
            case "mediaConnectFlow":
                return .mediaconnectflow(try reader["mediaConnectFlow"].read(with: MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowArn"].write(value.flowArn)
        try writer["flowOutputArn"].write(value.flowOutputArn)
        try writer["sourceTransitDecryption"].write(value.sourceTransitDecryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaConnectFlowRouterInputConfiguration()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowOutputArn = try reader["flowOutputArn"].readIfPresent()
        value.sourceTransitDecryption = try reader["sourceTransitDecryption"].readIfPresent(with: MediaConnectClientTypes.FlowTransitEncryption.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MergeRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.MergeRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mergeRecoveryWindowMilliseconds"].write(value.mergeRecoveryWindowMilliseconds)
        try writer["networkInterfaceArn"].write(value.networkInterfaceArn)
        try writer["protocolConfigurations"].writeList(value.protocolConfigurations, memberWritingClosure: MediaConnectClientTypes.MergeRouterInputProtocolConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MergeRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MergeRouterInputConfiguration()
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent() ?? ""
        value.protocolConfigurations = try reader["protocolConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MergeRouterInputProtocolConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.mergeRecoveryWindowMilliseconds = try reader["mergeRecoveryWindowMilliseconds"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.MergeRouterInputProtocolConfiguration {

    static func write(value: MediaConnectClientTypes.MergeRouterInputProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rist(rist):
                try writer["rist"].write(rist, with: MediaConnectClientTypes.RistRouterInputConfiguration.write(value:to:))
            case let .rtp(rtp):
                try writer["rtp"].write(rtp, with: MediaConnectClientTypes.RtpRouterInputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MergeRouterInputProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rtp":
                return .rtp(try reader["rtp"].read(with: MediaConnectClientTypes.RtpRouterInputConfiguration.read(from:)))
            case "rist":
                return .rist(try reader["rist"].read(with: MediaConnectClientTypes.RistRouterInputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.RistRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.RistRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["port"].write(value.port)
        try writer["recoveryLatencyMilliseconds"].write(value.recoveryLatencyMilliseconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RistRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RistRouterInputConfiguration()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.recoveryLatencyMilliseconds = try reader["recoveryLatencyMilliseconds"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.RtpRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.RtpRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["forwardErrorCorrection"].write(value.forwardErrorCorrection)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RtpRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RtpRouterInputConfiguration()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.forwardErrorCorrection = try reader["forwardErrorCorrection"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.FailoverRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.FailoverRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkInterfaceArn"].write(value.networkInterfaceArn)
        try writer["primarySourceIndex"].write(value.primarySourceIndex)
        try writer["protocolConfigurations"].writeList(value.protocolConfigurations, memberWritingClosure: MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sourcePriorityMode"].write(value.sourcePriorityMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FailoverRouterInputConfiguration()
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent() ?? ""
        value.protocolConfigurations = try reader["protocolConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sourcePriorityMode = try reader["sourcePriorityMode"].readIfPresent() ?? .sdkUnknown("")
        value.primarySourceIndex = try reader["primarySourceIndex"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration {

    static func write(value: MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rist(rist):
                try writer["rist"].write(rist, with: MediaConnectClientTypes.RistRouterInputConfiguration.write(value:to:))
            case let .rtp(rtp):
                try writer["rtp"].write(rtp, with: MediaConnectClientTypes.RtpRouterInputConfiguration.write(value:to:))
            case let .srtcaller(srtcaller):
                try writer["srtCaller"].write(srtcaller, with: MediaConnectClientTypes.SrtCallerRouterInputConfiguration.write(value:to:))
            case let .srtlistener(srtlistener):
                try writer["srtListener"].write(srtlistener, with: MediaConnectClientTypes.SrtListenerRouterInputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverRouterInputProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rtp":
                return .rtp(try reader["rtp"].read(with: MediaConnectClientTypes.RtpRouterInputConfiguration.read(from:)))
            case "rist":
                return .rist(try reader["rist"].read(with: MediaConnectClientTypes.RistRouterInputConfiguration.read(from:)))
            case "srtListener":
                return .srtlistener(try reader["srtListener"].read(with: MediaConnectClientTypes.SrtListenerRouterInputConfiguration.read(from:)))
            case "srtCaller":
                return .srtcaller(try reader["srtCaller"].read(with: MediaConnectClientTypes.SrtCallerRouterInputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.SrtCallerRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.SrtCallerRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryptionConfiguration"].write(value.decryptionConfiguration, with: MediaConnectClientTypes.SrtDecryptionConfiguration.write(value:to:))
        try writer["minimumLatencyMilliseconds"].write(value.minimumLatencyMilliseconds)
        try writer["sourceAddress"].write(value.sourceAddress)
        try writer["sourcePort"].write(value.sourcePort)
        try writer["streamId"].write(value.streamId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtCallerRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtCallerRouterInputConfiguration()
        value.sourceAddress = try reader["sourceAddress"].readIfPresent() ?? ""
        value.sourcePort = try reader["sourcePort"].readIfPresent() ?? 0
        value.minimumLatencyMilliseconds = try reader["minimumLatencyMilliseconds"].readIfPresent() ?? 0
        value.streamId = try reader["streamId"].readIfPresent()
        value.decryptionConfiguration = try reader["decryptionConfiguration"].readIfPresent(with: MediaConnectClientTypes.SrtDecryptionConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.SrtDecryptionConfiguration {

    static func write(value: MediaConnectClientTypes.SrtDecryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKey"].write(value.encryptionKey, with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtDecryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtDecryptionConfiguration()
        value.encryptionKey = try reader["encryptionKey"].readIfPresent(with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.SrtListenerRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.SrtListenerRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryptionConfiguration"].write(value.decryptionConfiguration, with: MediaConnectClientTypes.SrtDecryptionConfiguration.write(value:to:))
        try writer["minimumLatencyMilliseconds"].write(value.minimumLatencyMilliseconds)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtListenerRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtListenerRouterInputConfiguration()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.minimumLatencyMilliseconds = try reader["minimumLatencyMilliseconds"].readIfPresent() ?? 0
        value.decryptionConfiguration = try reader["decryptionConfiguration"].readIfPresent(with: MediaConnectClientTypes.SrtDecryptionConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.StandardRouterInputConfiguration {

    static func write(value: MediaConnectClientTypes.StandardRouterInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkInterfaceArn"].write(value.networkInterfaceArn)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: MediaConnectClientTypes.RouterInputProtocolConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.StandardRouterInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.StandardRouterInputConfiguration()
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent() ?? ""
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: MediaConnectClientTypes.RouterInputProtocolConfiguration.read(from:))
        value.`protocol` = try reader["protocol"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.RouterInputProtocolConfiguration {

    static func write(value: MediaConnectClientTypes.RouterInputProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rist(rist):
                try writer["rist"].write(rist, with: MediaConnectClientTypes.RistRouterInputConfiguration.write(value:to:))
            case let .rtp(rtp):
                try writer["rtp"].write(rtp, with: MediaConnectClientTypes.RtpRouterInputConfiguration.write(value:to:))
            case let .srtcaller(srtcaller):
                try writer["srtCaller"].write(srtcaller, with: MediaConnectClientTypes.SrtCallerRouterInputConfiguration.write(value:to:))
            case let .srtlistener(srtlistener):
                try writer["srtListener"].write(srtlistener, with: MediaConnectClientTypes.SrtListenerRouterInputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rtp":
                return .rtp(try reader["rtp"].read(with: MediaConnectClientTypes.RtpRouterInputConfiguration.read(from:)))
            case "rist":
                return .rist(try reader["rist"].read(with: MediaConnectClientTypes.RistRouterInputConfiguration.read(from:)))
            case "srtListener":
                return .srtlistener(try reader["srtListener"].read(with: MediaConnectClientTypes.SrtListenerRouterInputConfiguration.read(from:)))
            case "srtCaller":
                return .srtcaller(try reader["srtCaller"].read(with: MediaConnectClientTypes.SrtCallerRouterInputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.BatchGetRouterInputError {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BatchGetRouterInputError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BatchGetRouterInputError()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterNetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterNetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterNetworkInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.networkInterfaceType = try reader["networkInterfaceType"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration.read(from:))
        value.associatedOutputCount = try reader["associatedOutputCount"].readIfPresent() ?? 0
        value.associatedInputCount = try reader["associatedInputCount"].readIfPresent() ?? 0
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension MediaConnectClientTypes.RouterNetworkInterfaceConfiguration {

    static func write(value: MediaConnectClientTypes.RouterNetworkInterfaceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .`public`(`public`):
                try writer["public"].write(`public`, with: MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration.write(value:to:))
            case let .vpc(vpc):
                try writer["vpc"].write(vpc, with: MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterNetworkInterfaceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "public":
                return .`public`(try reader["public"].read(with: MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration.read(from:)))
            case "vpc":
                return .vpc(try reader["vpc"].read(with: MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration {

    static func write(value: MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VpcRouterNetworkInterfaceConfiguration()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetId = try reader["subnetId"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration {

    static func write(value: MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowRules"].writeList(value.allowRules, memberWritingClosure: MediaConnectClientTypes.PublicRouterNetworkInterfaceRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.PublicRouterNetworkInterfaceConfiguration()
        value.allowRules = try reader["allowRules"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.PublicRouterNetworkInterfaceRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.PublicRouterNetworkInterfaceRule {

    static func write(value: MediaConnectClientTypes.PublicRouterNetworkInterfaceRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.PublicRouterNetworkInterfaceRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.PublicRouterNetworkInterfaceRule()
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BatchGetRouterNetworkInterfaceError()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterOutput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.outputType = try reader["outputType"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: MediaConnectClientTypes.RouterOutputConfiguration.read(from:))
        value.routedState = try reader["routedState"].readIfPresent() ?? .sdkUnknown("")
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.maximumBitrate = try reader["maximumBitrate"].readIfPresent() ?? 0
        value.routingScope = try reader["routingScope"].readIfPresent() ?? .sdkUnknown("")
        value.tier = try reader["tier"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterOutputMessage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.streamDetails = try reader["streamDetails"].readIfPresent(with: MediaConnectClientTypes.RouterOutputStreamDetails.read(from:))
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.routedInputArn = try reader["routedInputArn"].readIfPresent()
        value.maintenanceType = try reader["maintenanceType"].readIfPresent() ?? .sdkUnknown("")
        value.maintenanceConfiguration = try reader["maintenanceConfiguration"].readIfPresent(with: MediaConnectClientTypes.MaintenanceConfiguration.read(from:))
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent()
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.RouterOutputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterOutputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "standard":
                return .standard(try reader["standard"].read(with: MediaConnectClientTypes.StandardRouterOutputStreamDetails.read(from:)))
            case "mediaConnectFlow":
                return .mediaconnectflow(try reader["mediaConnectFlow"].read(with: MediaConnectClientTypes.MediaConnectFlowRouterOutputStreamDetails.read(from:)))
            case "mediaLiveInput":
                return .medialiveinput(try reader["mediaLiveInput"].read(with: MediaConnectClientTypes.MediaLiveInputRouterOutputStreamDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.MediaLiveInputRouterOutputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaLiveInputRouterOutputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MediaConnectClientTypes.MediaLiveInputRouterOutputStreamDetails()
    }
}

extension MediaConnectClientTypes.MediaConnectFlowRouterOutputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaConnectFlowRouterOutputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return MediaConnectClientTypes.MediaConnectFlowRouterOutputStreamDetails()
    }
}

extension MediaConnectClientTypes.StandardRouterOutputStreamDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.StandardRouterOutputStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.StandardRouterOutputStreamDetails()
        value.destinationIpAddress = try reader["destinationIpAddress"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.RouterOutputMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterOutputMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterOutputMessage()
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.RouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .mediaconnectflow(mediaconnectflow):
                try writer["mediaConnectFlow"].write(mediaconnectflow, with: MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration.write(value:to:))
            case let .medialiveinput(medialiveinput):
                try writer["mediaLiveInput"].write(medialiveinput, with: MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration.write(value:to:))
            case let .standard(standard):
                try writer["standard"].write(standard, with: MediaConnectClientTypes.StandardRouterOutputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "standard":
                return .standard(try reader["standard"].read(with: MediaConnectClientTypes.StandardRouterOutputConfiguration.read(from:)))
            case "mediaConnectFlow":
                return .mediaconnectflow(try reader["mediaConnectFlow"].read(with: MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration.read(from:)))
            case "mediaLiveInput":
                return .medialiveinput(try reader["mediaLiveInput"].read(with: MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationTransitEncryption"].write(value.destinationTransitEncryption, with: MediaConnectClientTypes.MediaLiveTransitEncryption.write(value:to:))
        try writer["mediaLiveInputArn"].write(value.mediaLiveInputArn)
        try writer["mediaLivePipelineId"].write(value.mediaLivePipelineId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaLiveInputRouterOutputConfiguration()
        value.mediaLiveInputArn = try reader["mediaLiveInputArn"].readIfPresent()
        value.mediaLivePipelineId = try reader["mediaLivePipelineId"].readIfPresent()
        value.destinationTransitEncryption = try reader["destinationTransitEncryption"].readIfPresent(with: MediaConnectClientTypes.MediaLiveTransitEncryption.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MediaLiveTransitEncryption {

    static func write(value: MediaConnectClientTypes.MediaLiveTransitEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKeyConfiguration"].write(value.encryptionKeyConfiguration, with: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration.write(value:to:))
        try writer["encryptionKeyType"].write(value.encryptionKeyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaLiveTransitEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaLiveTransitEncryption()
        value.encryptionKeyType = try reader["encryptionKeyType"].readIfPresent()
        value.encryptionKeyConfiguration = try reader["encryptionKeyConfiguration"].readIfPresent(with: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration {

    static func write(value: MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automatic(automatic):
                try writer["automatic"].write(automatic, with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.write(value:to:))
            case let .secretsmanager(secretsmanager):
                try writer["secretsManager"].write(secretsmanager, with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaLiveTransitEncryptionKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "secretsManager":
                return .secretsmanager(try reader["secretsManager"].read(with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.read(from:)))
            case "automatic":
                return .automatic(try reader["automatic"].read(with: MediaConnectClientTypes.AutomaticEncryptionKeyConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationTransitEncryption"].write(value.destinationTransitEncryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
        try writer["flowArn"].write(value.flowArn)
        try writer["flowSourceArn"].write(value.flowSourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaConnectFlowRouterOutputConfiguration()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowSourceArn = try reader["flowSourceArn"].readIfPresent()
        value.destinationTransitEncryption = try reader["destinationTransitEncryption"].readIfPresent(with: MediaConnectClientTypes.FlowTransitEncryption.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.StandardRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.StandardRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkInterfaceArn"].write(value.networkInterfaceArn)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolConfiguration"].write(value.protocolConfiguration, with: MediaConnectClientTypes.RouterOutputProtocolConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.StandardRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.StandardRouterOutputConfiguration()
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent() ?? ""
        value.protocolConfiguration = try reader["protocolConfiguration"].readIfPresent(with: MediaConnectClientTypes.RouterOutputProtocolConfiguration.read(from:))
        value.`protocol` = try reader["protocol"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.RouterOutputProtocolConfiguration {

    static func write(value: MediaConnectClientTypes.RouterOutputProtocolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rist(rist):
                try writer["rist"].write(rist, with: MediaConnectClientTypes.RistRouterOutputConfiguration.write(value:to:))
            case let .rtp(rtp):
                try writer["rtp"].write(rtp, with: MediaConnectClientTypes.RtpRouterOutputConfiguration.write(value:to:))
            case let .srtcaller(srtcaller):
                try writer["srtCaller"].write(srtcaller, with: MediaConnectClientTypes.SrtCallerRouterOutputConfiguration.write(value:to:))
            case let .srtlistener(srtlistener):
                try writer["srtListener"].write(srtlistener, with: MediaConnectClientTypes.SrtListenerRouterOutputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterOutputProtocolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rtp":
                return .rtp(try reader["rtp"].read(with: MediaConnectClientTypes.RtpRouterOutputConfiguration.read(from:)))
            case "rist":
                return .rist(try reader["rist"].read(with: MediaConnectClientTypes.RistRouterOutputConfiguration.read(from:)))
            case "srtListener":
                return .srtlistener(try reader["srtListener"].read(with: MediaConnectClientTypes.SrtListenerRouterOutputConfiguration.read(from:)))
            case "srtCaller":
                return .srtcaller(try reader["srtCaller"].read(with: MediaConnectClientTypes.SrtCallerRouterOutputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.SrtCallerRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.SrtCallerRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationAddress"].write(value.destinationAddress)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: MediaConnectClientTypes.SrtEncryptionConfiguration.write(value:to:))
        try writer["minimumLatencyMilliseconds"].write(value.minimumLatencyMilliseconds)
        try writer["streamId"].write(value.streamId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtCallerRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtCallerRouterOutputConfiguration()
        value.destinationAddress = try reader["destinationAddress"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent() ?? 0
        value.minimumLatencyMilliseconds = try reader["minimumLatencyMilliseconds"].readIfPresent() ?? 0
        value.streamId = try reader["streamId"].readIfPresent()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: MediaConnectClientTypes.SrtEncryptionConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.SrtEncryptionConfiguration {

    static func write(value: MediaConnectClientTypes.SrtEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKey"].write(value.encryptionKey, with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtEncryptionConfiguration()
        value.encryptionKey = try reader["encryptionKey"].readIfPresent(with: MediaConnectClientTypes.SecretsManagerEncryptionKeyConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.SrtListenerRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.SrtListenerRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: MediaConnectClientTypes.SrtEncryptionConfiguration.write(value:to:))
        try writer["minimumLatencyMilliseconds"].write(value.minimumLatencyMilliseconds)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SrtListenerRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SrtListenerRouterOutputConfiguration()
        value.port = try reader["port"].readIfPresent() ?? 0
        value.minimumLatencyMilliseconds = try reader["minimumLatencyMilliseconds"].readIfPresent() ?? 0
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: MediaConnectClientTypes.SrtEncryptionConfiguration.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.RistRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.RistRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationAddress"].write(value.destinationAddress)
        try writer["destinationPort"].write(value.destinationPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RistRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RistRouterOutputConfiguration()
        value.destinationAddress = try reader["destinationAddress"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.RtpRouterOutputConfiguration {

    static func write(value: MediaConnectClientTypes.RtpRouterOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationAddress"].write(value.destinationAddress)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["forwardErrorCorrection"].write(value.forwardErrorCorrection)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RtpRouterOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RtpRouterOutputConfiguration()
        value.destinationAddress = try reader["destinationAddress"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent() ?? 0
        value.forwardErrorCorrection = try reader["forwardErrorCorrection"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.BatchGetRouterOutputError {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BatchGetRouterOutputError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BatchGetRouterOutputError()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Bridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Bridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Bridge()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.bridgeMessages = try reader["bridgeMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bridgeState = try reader["bridgeState"].readIfPresent() ?? .sdkUnknown("")
        value.egressGatewayBridge = try reader["egressGatewayBridge"].readIfPresent(with: MediaConnectClientTypes.EgressGatewayBridge.read(from:))
        value.ingressGatewayBridge = try reader["ingressGatewayBridge"].readIfPresent(with: MediaConnectClientTypes.IngressGatewayBridge.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.placementArn = try reader["placementArn"].readIfPresent() ?? ""
        value.sourceFailoverConfig = try reader["sourceFailoverConfig"].readIfPresent(with: MediaConnectClientTypes.FailoverConfig.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaConnectClientTypes.FailoverConfig {

    static func write(value: MediaConnectClientTypes.FailoverConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failoverMode"].write(value.failoverMode)
        try writer["recoveryWindow"].write(value.recoveryWindow)
        try writer["sourcePriority"].write(value.sourcePriority, with: MediaConnectClientTypes.SourcePriority.write(value:to:))
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FailoverConfig()
        value.failoverMode = try reader["failoverMode"].readIfPresent()
        value.recoveryWindow = try reader["recoveryWindow"].readIfPresent()
        value.sourcePriority = try reader["sourcePriority"].readIfPresent(with: MediaConnectClientTypes.SourcePriority.read(from:))
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.SourcePriority {

    static func write(value: MediaConnectClientTypes.SourcePriority?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["primarySource"].write(value.primarySource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SourcePriority {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SourcePriority()
        value.primarySource = try reader["primarySource"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.IngressGatewayBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.IngressGatewayBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.IngressGatewayBridge()
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.maxBitrate = try reader["maxBitrate"].readIfPresent() ?? 0
        value.maxOutputs = try reader["maxOutputs"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.EgressGatewayBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.EgressGatewayBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.EgressGatewayBridge()
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.maxBitrate = try reader["maxBitrate"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.MessageDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MessageDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MessageDetail()
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Flow {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Flow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Flow()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.egressIp = try reader["egressIp"].readIfPresent()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.mediaStreams = try reader["mediaStreams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStream.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Output.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.Source.read(from:))
        value.sourceFailoverConfig = try reader["sourceFailoverConfig"].readIfPresent(with: MediaConnectClientTypes.FailoverConfig.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.vpcInterfaces = try reader["vpcInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.VpcInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maintenance = try reader["maintenance"].readIfPresent(with: MediaConnectClientTypes.Maintenance.read(from:))
        value.sourceMonitoringConfig = try reader["sourceMonitoringConfig"].readIfPresent(with: MediaConnectClientTypes.MonitoringConfig.read(from:))
        value.flowSize = try reader["flowSize"].readIfPresent()
        value.ndiConfig = try reader["ndiConfig"].readIfPresent(with: MediaConnectClientTypes.NdiConfig.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.NdiConfig {

    static func write(value: MediaConnectClientTypes.NdiConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["machineName"].write(value.machineName)
        try writer["ndiDiscoveryServers"].writeList(value.ndiDiscoveryServers, memberWritingClosure: MediaConnectClientTypes.NdiDiscoveryServerConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ndiState"].write(value.ndiState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.NdiConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.NdiConfig()
        value.ndiState = try reader["ndiState"].readIfPresent()
        value.machineName = try reader["machineName"].readIfPresent()
        value.ndiDiscoveryServers = try reader["ndiDiscoveryServers"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.NdiDiscoveryServerConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaConnectClientTypes.NdiDiscoveryServerConfig {

    static func write(value: MediaConnectClientTypes.NdiDiscoveryServerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["discoveryServerAddress"].write(value.discoveryServerAddress)
        try writer["discoveryServerPort"].write(value.discoveryServerPort)
        try writer["vpcInterfaceAdapter"].write(value.vpcInterfaceAdapter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.NdiDiscoveryServerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.NdiDiscoveryServerConfig()
        value.discoveryServerAddress = try reader["discoveryServerAddress"].readIfPresent() ?? ""
        value.discoveryServerPort = try reader["discoveryServerPort"].readIfPresent()
        value.vpcInterfaceAdapter = try reader["vpcInterfaceAdapter"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.MonitoringConfig {

    static func write(value: MediaConnectClientTypes.MonitoringConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audioMonitoringSettings"].writeList(value.audioMonitoringSettings, memberWritingClosure: MediaConnectClientTypes.AudioMonitoringSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["contentQualityAnalysisState"].write(value.contentQualityAnalysisState)
        try writer["thumbnailState"].write(value.thumbnailState)
        try writer["videoMonitoringSettings"].writeList(value.videoMonitoringSettings, memberWritingClosure: MediaConnectClientTypes.VideoMonitoringSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MonitoringConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MonitoringConfig()
        value.thumbnailState = try reader["thumbnailState"].readIfPresent()
        value.audioMonitoringSettings = try reader["audioMonitoringSettings"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.AudioMonitoringSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contentQualityAnalysisState = try reader["contentQualityAnalysisState"].readIfPresent()
        value.videoMonitoringSettings = try reader["videoMonitoringSettings"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.VideoMonitoringSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaConnectClientTypes.VideoMonitoringSetting {

    static func write(value: MediaConnectClientTypes.VideoMonitoringSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blackFrames"].write(value.blackFrames, with: MediaConnectClientTypes.BlackFrames.write(value:to:))
        try writer["frozenFrames"].write(value.frozenFrames, with: MediaConnectClientTypes.FrozenFrames.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VideoMonitoringSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VideoMonitoringSetting()
        value.blackFrames = try reader["blackFrames"].readIfPresent(with: MediaConnectClientTypes.BlackFrames.read(from:))
        value.frozenFrames = try reader["frozenFrames"].readIfPresent(with: MediaConnectClientTypes.FrozenFrames.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.FrozenFrames {

    static func write(value: MediaConnectClientTypes.FrozenFrames?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["thresholdSeconds"].write(value.thresholdSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FrozenFrames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FrozenFrames()
        value.state = try reader["state"].readIfPresent()
        value.thresholdSeconds = try reader["thresholdSeconds"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.BlackFrames {

    static func write(value: MediaConnectClientTypes.BlackFrames?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["thresholdSeconds"].write(value.thresholdSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BlackFrames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BlackFrames()
        value.state = try reader["state"].readIfPresent()
        value.thresholdSeconds = try reader["thresholdSeconds"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.AudioMonitoringSetting {

    static func write(value: MediaConnectClientTypes.AudioMonitoringSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["silentAudio"].write(value.silentAudio, with: MediaConnectClientTypes.SilentAudio.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.AudioMonitoringSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.AudioMonitoringSetting()
        value.silentAudio = try reader["silentAudio"].readIfPresent(with: MediaConnectClientTypes.SilentAudio.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.SilentAudio {

    static func write(value: MediaConnectClientTypes.SilentAudio?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["thresholdSeconds"].write(value.thresholdSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SilentAudio {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SilentAudio()
        value.state = try reader["state"].readIfPresent()
        value.thresholdSeconds = try reader["thresholdSeconds"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Maintenance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Maintenance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Maintenance()
        value.maintenanceDay = try reader["maintenanceDay"].readIfPresent()
        value.maintenanceDeadline = try reader["maintenanceDeadline"].readIfPresent()
        value.maintenanceScheduledDate = try reader["maintenanceScheduledDate"].readIfPresent()
        value.maintenanceStartHour = try reader["maintenanceStartHour"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Entitlement {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Entitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Entitlement()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.entitlementArn = try reader["entitlementArn"].readIfPresent() ?? ""
        value.entitlementStatus = try reader["entitlementStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.subscribers = try reader["subscribers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.Gateway {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Gateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Gateway()
        value.egressCidrBlocks = try reader["egressCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayMessages = try reader["gatewayMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayState = try reader["gatewayState"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networks = try reader["networks"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.GatewayNetwork.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.GatewayNetwork {

    static func write(value: MediaConnectClientTypes.GatewayNetwork?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrBlock"].write(value.cidrBlock)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayNetwork()
        value.cidrBlock = try reader["cidrBlock"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Messages {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Messages {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Messages()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportMediaInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportMediaInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportMediaInfo()
        value.programs = try reader["programs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.TransportStreamProgram.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportStreamProgram {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportStreamProgram {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportStreamProgram()
        value.pcrPid = try reader["pcrPid"].readIfPresent() ?? 0
        value.programName = try reader["programName"].readIfPresent()
        value.programNumber = try reader["programNumber"].readIfPresent() ?? 0
        value.programPid = try reader["programPid"].readIfPresent() ?? 0
        value.streams = try reader["streams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.TransportStream.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportStream {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportStream()
        value.channels = try reader["channels"].readIfPresent()
        value.codec = try reader["codec"].readIfPresent()
        value.frameRate = try reader["frameRate"].readIfPresent()
        value.frameResolution = try reader["frameResolution"].readIfPresent(with: MediaConnectClientTypes.FrameResolution.read(from:))
        value.pid = try reader["pid"].readIfPresent() ?? 0
        value.sampleRate = try reader["sampleRate"].readIfPresent()
        value.sampleSize = try reader["sampleSize"].readIfPresent()
        value.streamType = try reader["streamType"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.FrameResolution {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FrameResolution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FrameResolution()
        value.frameHeight = try reader["frameHeight"].readIfPresent() ?? 0
        value.frameWidth = try reader["frameWidth"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.ThumbnailDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ThumbnailDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ThumbnailDetails()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.thumbnail = try reader["thumbnail"].readIfPresent()
        value.thumbnailMessages = try reader["thumbnailMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timecode = try reader["timecode"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MediaConnectClientTypes.GatewayInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayInstance()
        value.bridgePlacement = try reader["bridgePlacement"].readIfPresent() ?? .sdkUnknown("")
        value.connectionStatus = try reader["connectionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent() ?? ""
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.instanceMessages = try reader["instanceMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceState = try reader["instanceState"].readIfPresent() ?? .sdkUnknown("")
        value.runningBridgeCount = try reader["runningBridgeCount"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.Offering {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Offering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Offering()
        value.currencyCode = try reader["currencyCode"].readIfPresent() ?? ""
        value.duration = try reader["duration"].readIfPresent() ?? 0
        value.durationUnits = try reader["durationUnits"].readIfPresent() ?? .sdkUnknown("")
        value.offeringArn = try reader["offeringArn"].readIfPresent() ?? ""
        value.offeringDescription = try reader["offeringDescription"].readIfPresent() ?? ""
        value.pricePerUnit = try reader["pricePerUnit"].readIfPresent() ?? ""
        value.priceUnits = try reader["priceUnits"].readIfPresent() ?? .sdkUnknown("")
        value.resourceSpecification = try reader["resourceSpecification"].readIfPresent(with: MediaConnectClientTypes.ResourceSpecification.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.ResourceSpecification {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ResourceSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ResourceSpecification()
        value.reservedBitrate = try reader["reservedBitrate"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.Reservation {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Reservation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Reservation()
        value.currencyCode = try reader["currencyCode"].readIfPresent() ?? ""
        value.duration = try reader["duration"].readIfPresent() ?? 0
        value.durationUnits = try reader["durationUnits"].readIfPresent() ?? .sdkUnknown("")
        value.end = try reader["end"].readIfPresent() ?? ""
        value.offeringArn = try reader["offeringArn"].readIfPresent() ?? ""
        value.offeringDescription = try reader["offeringDescription"].readIfPresent() ?? ""
        value.pricePerUnit = try reader["pricePerUnit"].readIfPresent() ?? ""
        value.priceUnits = try reader["priceUnits"].readIfPresent() ?? .sdkUnknown("")
        value.reservationArn = try reader["reservationArn"].readIfPresent() ?? ""
        value.reservationName = try reader["reservationName"].readIfPresent() ?? ""
        value.reservationState = try reader["reservationState"].readIfPresent() ?? .sdkUnknown("")
        value.resourceSpecification = try reader["resourceSpecification"].readIfPresent(with: MediaConnectClientTypes.ResourceSpecification.read(from:))
        value.start = try reader["start"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.RouterInputSourceMetadataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputSourceMetadataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterInputSourceMetadataDetails()
        value.sourceMetadataMessages = try reader["sourceMetadataMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterInputMessage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.routerInputMetadata = try reader["routerInputMetadata"].readIfPresent(with: MediaConnectClientTypes.RouterInputMetadata.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.RouterInputMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "transportStreamMediaInfo":
                return .transportstreammediainfo(try reader["transportStreamMediaInfo"].read(with: MediaConnectClientTypes.TransportMediaInfo.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MediaConnectClientTypes.RouterInputThumbnailDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.RouterInputThumbnailDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.RouterInputThumbnailDetails()
        value.thumbnailMessages = try reader["thumbnailMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.RouterInputMessage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.thumbnail = try reader["thumbnail"].readIfPresent()
        value.timecode = try reader["timecode"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MediaConnectClientTypes.ListedBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedBridge()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.bridgeState = try reader["bridgeState"].readIfPresent() ?? .sdkUnknown("")
        value.bridgeType = try reader["bridgeType"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.placementArn = try reader["placementArn"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedEntitlement {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedEntitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedEntitlement()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent() ?? ""
        value.entitlementName = try reader["entitlementName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedFlow {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedFlow()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.maintenance = try reader["maintenance"].readIfPresent(with: MediaConnectClientTypes.Maintenance.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.ListedGatewayInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedGatewayInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedGatewayInstance()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent() ?? ""
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.instanceState = try reader["instanceState"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.ListedGateway {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedGateway()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayState = try reader["gatewayState"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedRouterInput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedRouterInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedRouterInput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.inputType = try reader["inputType"].readIfPresent() ?? .sdkUnknown("")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.routedOutputs = try reader["routedOutputs"].readIfPresent() ?? 0
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.maximumBitrate = try reader["maximumBitrate"].readIfPresent() ?? 0
        value.routingScope = try reader["routingScope"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.messageCount = try reader["messageCount"].readIfPresent() ?? 0
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent()
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent()
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.ListedRouterNetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedRouterNetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedRouterNetworkInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.networkInterfaceType = try reader["networkInterfaceType"].readIfPresent() ?? .sdkUnknown("")
        value.associatedOutputCount = try reader["associatedOutputCount"].readIfPresent() ?? 0
        value.associatedInputCount = try reader["associatedInputCount"].readIfPresent() ?? 0
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension MediaConnectClientTypes.ListedRouterOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedRouterOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedRouterOutput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.outputType = try reader["outputType"].readIfPresent() ?? .sdkUnknown("")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.routedState = try reader["routedState"].readIfPresent() ?? .sdkUnknown("")
        value.regionName = try reader["regionName"].readIfPresent() ?? ""
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.maximumBitrate = try reader["maximumBitrate"].readIfPresent() ?? 0
        value.routingScope = try reader["routingScope"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.messageCount = try reader["messageCount"].readIfPresent() ?? 0
        value.routedInputArn = try reader["routedInputArn"].readIfPresent()
        value.networkInterfaceArn = try reader["networkInterfaceArn"].readIfPresent()
        value.maintenanceScheduleType = try reader["maintenanceScheduleType"].readIfPresent()
        value.maintenanceSchedule = try reader["maintenanceSchedule"].readIfPresent(with: MediaConnectClientTypes.MaintenanceSchedule.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.AddBridgeOutputRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkOutput"].write(value.networkOutput, with: MediaConnectClientTypes.AddBridgeNetworkOutputRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.AddBridgeNetworkOutputRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeNetworkOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
        try writer["name"].write(value.name)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["ttl"].write(value.ttl)
    }
}

extension MediaConnectClientTypes.AddBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowSource"].write(value.flowSource, with: MediaConnectClientTypes.AddBridgeFlowSourceRequest.write(value:to:))
        try writer["networkSource"].write(value.networkSource, with: MediaConnectClientTypes.AddBridgeNetworkSourceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.AddBridgeNetworkSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeNetworkSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["multicastIp"].write(value.multicastIp)
        try writer["multicastSourceSettings"].write(value.multicastSourceSettings, with: MediaConnectClientTypes.MulticastSourceSettings.write(value:to:))
        try writer["name"].write(value.name)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }
}

extension MediaConnectClientTypes.AddBridgeFlowSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeFlowSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowArn"].write(value.flowArn)
        try writer["flowVpcInterfaceAttachment"].write(value.flowVpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension MediaConnectClientTypes.AddMediaStreamRequest {

    static func write(value: MediaConnectClientTypes.AddMediaStreamRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: MediaConnectClientTypes.MediaStreamAttributesRequest.write(value:to:))
        try writer["clockRate"].write(value.clockRate)
        try writer["description"].write(value.description)
        try writer["mediaStreamId"].write(value.mediaStreamId)
        try writer["mediaStreamName"].write(value.mediaStreamName)
        try writer["mediaStreamTags"].writeMap(value.mediaStreamTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["mediaStreamType"].write(value.mediaStreamType)
        try writer["videoFormat"].write(value.videoFormat)
    }
}

extension MediaConnectClientTypes.MediaStreamAttributesRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamAttributesRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fmtp"].write(value.fmtp, with: MediaConnectClientTypes.FmtpRequest.write(value:to:))
        try writer["lang"].write(value.lang)
    }
}

extension MediaConnectClientTypes.FmtpRequest {

    static func write(value: MediaConnectClientTypes.FmtpRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelOrder"].write(value.channelOrder)
        try writer["colorimetry"].write(value.colorimetry)
        try writer["exactFramerate"].write(value.exactFramerate)
        try writer["par"].write(value.par)
        try writer["range"].write(value.range)
        try writer["scanMode"].write(value.scanMode)
        try writer["tcs"].write(value.tcs)
    }
}

extension MediaConnectClientTypes.AddOutputRequest {

    static func write(value: MediaConnectClientTypes.AddOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrAllowList"].writeList(value.cidrAllowList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["destination"].write(value.destination)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["maxLatency"].write(value.maxLatency)
        try writer["mediaStreamOutputConfigurations"].writeList(value.mediaStreamOutputConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["name"].write(value.name)
        try writer["ndiProgramName"].write(value.ndiProgramName)
        try writer["ndiSpeedHqQuality"].write(value.ndiSpeedHqQuality)
        try writer["outputStatus"].write(value.outputStatus)
        try writer["outputTags"].writeMap(value.outputTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["remoteId"].write(value.remoteId)
        try writer["routerIntegrationState"].write(value.routerIntegrationState)
        try writer["routerIntegrationTransitEncryption"].write(value.routerIntegrationTransitEncryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["smoothingLatency"].write(value.smoothingLatency)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.MediaStreamOutputConfigurationRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfigurations"].writeList(value.destinationConfigurations, memberWritingClosure: MediaConnectClientTypes.DestinationConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["encodingName"].write(value.encodingName)
        try writer["encodingParameters"].write(value.encodingParameters, with: MediaConnectClientTypes.EncodingParametersRequest.write(value:to:))
        try writer["mediaStreamName"].write(value.mediaStreamName)
    }
}

extension MediaConnectClientTypes.EncodingParametersRequest {

    static func write(value: MediaConnectClientTypes.EncodingParametersRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compressionFactor"].write(value.compressionFactor)
        try writer["encoderProfile"].write(value.encoderProfile)
    }
}

extension MediaConnectClientTypes.DestinationConfigurationRequest {

    static func write(value: MediaConnectClientTypes.DestinationConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationIp"].write(value.destinationIp)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["interface"].write(value.interface, with: MediaConnectClientTypes.InterfaceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.InterfaceRequest {

    static func write(value: MediaConnectClientTypes.InterfaceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension MediaConnectClientTypes.SetSourceRequest {

    static func write(value: MediaConnectClientTypes.SetSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryption"].write(value.decryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["description"].write(value.description)
        try writer["entitlementArn"].write(value.entitlementArn)
        try writer["gatewayBridgeSource"].write(value.gatewayBridgeSource, with: MediaConnectClientTypes.SetGatewayBridgeSourceRequest.write(value:to:))
        try writer["ingestPort"].write(value.ingestPort)
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxLatency"].write(value.maxLatency)
        try writer["maxSyncBuffer"].write(value.maxSyncBuffer)
        try writer["mediaStreamSourceConfigurations"].writeList(value.mediaStreamSourceConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["name"].write(value.name)
        try writer["protocol"].write(value.`protocol`)
        try writer["routerIntegrationState"].write(value.routerIntegrationState)
        try writer["routerIntegrationTransitDecryption"].write(value.routerIntegrationTransitDecryption, with: MediaConnectClientTypes.FlowTransitEncryption.write(value:to:))
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["sourceListenerAddress"].write(value.sourceListenerAddress)
        try writer["sourceListenerPort"].write(value.sourceListenerPort)
        try writer["sourceTags"].writeMap(value.sourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
        try writer["whitelistCidr"].write(value.whitelistCidr)
    }
}

extension MediaConnectClientTypes.SetGatewayBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.SetGatewayBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgeArn"].write(value.bridgeArn)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.MediaStreamSourceConfigurationRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encodingName"].write(value.encodingName)
        try writer["inputConfigurations"].writeList(value.inputConfigurations, memberWritingClosure: MediaConnectClientTypes.InputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mediaStreamName"].write(value.mediaStreamName)
    }
}

extension MediaConnectClientTypes.InputConfigurationRequest {

    static func write(value: MediaConnectClientTypes.InputConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputPort"].write(value.inputPort)
        try writer["interface"].write(value.interface, with: MediaConnectClientTypes.InterfaceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.VpcInterfaceRequest {

    static func write(value: MediaConnectClientTypes.VpcInterfaceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["networkInterfaceType"].write(value.networkInterfaceType)
        try writer["roleArn"].write(value.roleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetId"].write(value.subnetId)
        try writer["vpcInterfaceTags"].writeMap(value.vpcInterfaceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension MediaConnectClientTypes.AddEgressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
    }
}

extension MediaConnectClientTypes.AddIngressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxOutputs"].write(value.maxOutputs)
    }
}

extension MediaConnectClientTypes.GrantEntitlementRequest {

    static func write(value: MediaConnectClientTypes.GrantEntitlementRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTransferSubscriberFeePercent"].write(value.dataTransferSubscriberFeePercent)
        try writer["description"].write(value.description)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["entitlementStatus"].write(value.entitlementStatus)
        try writer["entitlementTags"].writeMap(value.entitlementTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["subscribers"].writeList(value.subscribers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MediaConnectClientTypes.AddMaintenance {

    static func write(value: MediaConnectClientTypes.AddMaintenance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maintenanceDay"].write(value.maintenanceDay)
        try writer["maintenanceStartHour"].write(value.maintenanceStartHour)
    }
}

extension MediaConnectClientTypes.RouterInputFilter {

    static func write(value: MediaConnectClientTypes.RouterInputFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .inputtypes(inputtypes):
                try writer["inputTypes"].writeList(inputtypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaConnectClientTypes.RouterInputType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .namecontains(namecontains):
                try writer["nameContains"].writeList(namecontains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .networkinterfacearns(networkinterfacearns):
                try writer["networkInterfaceArns"].writeList(networkinterfacearns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .regionnames(regionnames):
                try writer["regionNames"].writeList(regionnames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .routingscopes(routingscopes):
                try writer["routingScopes"].writeList(routingscopes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaConnectClientTypes.RoutingScope>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MediaConnectClientTypes.RouterNetworkInterfaceFilter {

    static func write(value: MediaConnectClientTypes.RouterNetworkInterfaceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .namecontains(namecontains):
                try writer["nameContains"].writeList(namecontains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .networkinterfacetypes(networkinterfacetypes):
                try writer["networkInterfaceTypes"].writeList(networkinterfacetypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaConnectClientTypes.RouterNetworkInterfaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .regionnames(regionnames):
                try writer["regionNames"].writeList(regionnames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MediaConnectClientTypes.RouterOutputFilter {

    static func write(value: MediaConnectClientTypes.RouterOutputFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .namecontains(namecontains):
                try writer["nameContains"].writeList(namecontains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .networkinterfacearns(networkinterfacearns):
                try writer["networkInterfaceArns"].writeList(networkinterfacearns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .outputtypes(outputtypes):
                try writer["outputTypes"].writeList(outputtypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaConnectClientTypes.RouterOutputType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .regionnames(regionnames):
                try writer["regionNames"].writeList(regionnames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .routedinputarns(routedinputarns):
                try writer["routedInputArns"].writeList(routedinputarns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .routingscopes(routingscopes):
                try writer["routingScopes"].writeList(routingscopes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaConnectClientTypes.RoutingScope>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
    }
}

extension MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxOutputs"].write(value.maxOutputs)
    }
}

extension MediaConnectClientTypes.UpdateFailoverConfig {

    static func write(value: MediaConnectClientTypes.UpdateFailoverConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failoverMode"].write(value.failoverMode)
        try writer["recoveryWindow"].write(value.recoveryWindow)
        try writer["sourcePriority"].write(value.sourcePriority, with: MediaConnectClientTypes.SourcePriority.write(value:to:))
        try writer["state"].write(value.state)
    }
}

extension MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["ttl"].write(value.ttl)
    }
}

extension MediaConnectClientTypes.UpdateBridgeFlowSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowArn"].write(value.flowArn)
        try writer["flowVpcInterfaceAttachment"].write(value.flowVpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["multicastIp"].write(value.multicastIp)
        try writer["multicastSourceSettings"].write(value.multicastSourceSettings, with: MediaConnectClientTypes.MulticastSourceSettings.write(value:to:))
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }
}

extension MediaConnectClientTypes.UpdateMaintenance {

    static func write(value: MediaConnectClientTypes.UpdateMaintenance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maintenanceDay"].write(value.maintenanceDay)
        try writer["maintenanceScheduledDate"].write(value.maintenanceScheduledDate)
        try writer["maintenanceStartHour"].write(value.maintenanceStartHour)
    }
}

extension MediaConnectClientTypes.UpdateEncryption {

    static func write(value: MediaConnectClientTypes.UpdateEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithm"].write(value.algorithm)
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["deviceId"].write(value.deviceId)
        try writer["keyType"].write(value.keyType)
        try writer["region"].write(value.region)
        try writer["resourceId"].write(value.resourceId)
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["url"].write(value.url)
    }
}

extension MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgeArn"].write(value.bridgeArn)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

public enum MediaConnectClientTypes {}
