//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension MediaConnectClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cdi
        case fujitsuQos
        case rist
        case rtp
        case rtpFec
        case srtCaller
        case srtListener
        case st2110Jpegxs
        case udp
        case zixiPull
        case zixiPush
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .cdi,
                .fujitsuQos,
                .rist,
                .rtp,
                .rtpFec,
                .srtCaller,
                .srtListener,
                .st2110Jpegxs,
                .udp,
                .zixiPull,
                .zixiPush
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cdi: return "cdi"
            case .fujitsuQos: return "fujitsu-qos"
            case .rist: return "rist"
            case .rtp: return "rtp"
            case .rtpFec: return "rtp-fec"
            case .srtCaller: return "srt-caller"
            case .srtListener: return "srt-listener"
            case .st2110Jpegxs: return "st2110-jpegxs"
            case .udp: return "udp"
            case .zixiPull: return "zixi-pull"
            case .zixiPush: return "zixi-push"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a network output to an existing bridge.
    public struct AddBridgeNetworkOutputRequest: Swift.Sendable {
        /// The network output IP Address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name. This name is used to reference the output and must be unique among outputs in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

extension MediaConnectClientTypes {

    /// Add an output to a bridge.
    public struct AddBridgeOutputRequest: Swift.Sendable {
        /// Add a network output to an existing bridge.
        public var networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest?

        public init(
            networkOutput: MediaConnectClientTypes.AddBridgeNetworkOutputRequest? = nil
        )
        {
            self.networkOutput = networkOutput
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for attaching a VPC interface to an resource.
    public struct VpcInterfaceAttachment: Swift.Sendable {
        /// The name of the VPC interface to use for this resource.
        public var vpcInterfaceName: Swift.String?

        public init(
            vpcInterfaceName: Swift.String? = nil
        )
        {
            self.vpcInterfaceName = vpcInterfaceName
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a flow source to an existing bridge.
    public struct AddBridgeFlowSourceRequest: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the cloud flow to use as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a network source to an existing bridge.
    public struct AddBridgeNetworkSourceRequest: Swift.Sendable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The name of the network source. This name is used to reference the source and must be unique among sources in this bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

extension MediaConnectClientTypes {

    /// Add a source to an existing bridge.
    public struct AddBridgeSourceRequest: Swift.Sendable {
        /// Add a flow source to an existing bridge.
        public var flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest?
        /// Add a network source to an existing bridge.
        public var networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest?

        public init(
            flowSource: MediaConnectClientTypes.AddBridgeFlowSourceRequest? = nil,
            networkSource: MediaConnectClientTypes.AddBridgeNetworkSourceRequest? = nil
        )
        {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }
}

extension MediaConnectClientTypes {

    public enum Colorimetry: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bt2020
        case bt2100
        case bt601
        case bt709
        case st20651
        case st20653
        case xyz
        case sdkUnknown(Swift.String)

        public static var allCases: [Colorimetry] {
            return [
                .bt2020,
                .bt2100,
                .bt601,
                .bt709,
                .st20651,
                .st20653,
                .xyz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bt2020: return "BT2020"
            case .bt2100: return "BT2100"
            case .bt601: return "BT601"
            case .bt709: return "BT709"
            case .st20651: return "ST2065-1"
            case .st20653: return "ST2065-3"
            case .xyz: return "XYZ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Range: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case fullprotect
        case narrow
        case sdkUnknown(Swift.String)

        public static var allCases: [Range] {
            return [
                .full,
                .fullprotect,
                .narrow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .fullprotect: return "FULLPROTECT"
            case .narrow: return "NARROW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ScanMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interlace
        case progressive
        case progressiveSegmentedFrame
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanMode] {
            return [
                .interlace,
                .progressive,
                .progressiveSegmentedFrame
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interlace: return "interlace"
            case .progressive: return "progressive"
            case .progressiveSegmentedFrame: return "progressive-segmented-frame"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Tcs: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bt2100linhlg
        case bt2100linpq
        case density
        case hlg
        case linear
        case pq
        case sdr
        case st20651
        case st4281
        case sdkUnknown(Swift.String)

        public static var allCases: [Tcs] {
            return [
                .bt2100linhlg,
                .bt2100linpq,
                .density,
                .hlg,
                .linear,
                .pq,
                .sdr,
                .st20651,
                .st4281
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bt2100linhlg: return "BT2100LINHLG"
            case .bt2100linpq: return "BT2100LINPQ"
            case .density: return "DENSITY"
            case .hlg: return "HLG"
            case .linear: return "LINEAR"
            case .pq: return "PQ"
            case .sdr: return "SDR"
            case .st20651: return "ST2065-1"
            case .st4281: return "ST428-1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings that you want to use to define the media stream.
    public struct FmtpRequest: Swift.Sendable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance.
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributesRequest: Swift.Sendable {
        /// The settings that you want to use to define the media stream.
        public var fmtp: MediaConnectClientTypes.FmtpRequest?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.FmtpRequest? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }
}

extension MediaConnectClientTypes {

    public enum MediaStreamType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ancillaryData
        case audio
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .ancillaryData,
                .audio,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ancillaryData: return "ancillary-data"
            case .audio: return "audio"
            case .video: return "video"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that you want to add to the flow.
    public struct AddMediaStreamRequest: Swift.Sendable {
        /// The attributes that you want to assign to the new media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
        /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }
}

extension MediaConnectClientTypes {

    public enum Algorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case sdkUnknown(Swift.String)

        public static var allCases: [Algorithm] {
            return [
                .aes128,
                .aes192,
                .aes256
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "aes128"
            case .aes192: return "aes192"
            case .aes256: return "aes256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum KeyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case speke
        case srtPassword
        case staticKey
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .speke,
                .srtPassword,
                .staticKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .speke: return "speke"
            case .srtPassword: return "srt-password"
            case .staticKey: return "static-key"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Information about the encryption of the flow.
    public struct Encryption: Swift.Sendable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }
}

extension MediaConnectClientTypes {

    /// The VPC interface that you want to designate where the media stream is coming from or going to.
    public struct InterfaceRequest: Swift.Sendable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that you want to associate with an outbound media stream.
    public struct DestinationConfigurationRequest: Swift.Sendable {
        /// The IP address where you want MediaConnect to send contents of the media stream.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port that you want MediaConnect to use when it distributes the media stream to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that you want to use for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    public enum EncodingName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jxsv
        case pcm
        case raw
        case smpte291
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingName] {
            return [
                .jxsv,
                .pcm,
                .raw,
                .smpte291
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jxsv: return "jxsv"
            case .pcm: return "pcm"
            case .raw: return "raw"
            case .smpte291: return "smpte291"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum EncoderProfile: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case main
        case sdkUnknown(Swift.String)

        public static var allCases: [EncoderProfile] {
            return [
                .high,
                .main
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .main: return "main"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParametersRequest: Swift.Sendable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, if at least one source on the flow uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that you want to associate with the output, and the parameters for that association.
    public struct MediaStreamOutputConfigurationRequest: Swift.Sendable {
        /// The transport parameters that you want to associate with the media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]?
        /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        public var encodingParameters: MediaConnectClientTypes.EncodingParametersRequest?
        /// The name of the media stream that is associated with the output.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParametersRequest? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    public enum OutputStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The output that you want to add to this flow.
    public struct AddOutputRequest: Swift.Sendable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The media streams that are associated with the output, and the parameters for those associations.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the output. This value must be unique within the current flow.
        public var name: Swift.String?
        /// An indication of whether the new output should be enabled or disabled as soon as it is created. If you don't specify the outputStatus field in your request, MediaConnect sets it to ENABLED.
        public var outputStatus: MediaConnectClientTypes.OutputStatus?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// The protocol to use for the output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull output stream.
        public var remoteId: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            maxLatency: Swift.Int? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            smoothingLatency: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.maxLatency = maxLatency
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.minLatency = minLatency
            self.name = name
            self.outputStatus = outputStatus
            self.port = port
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.senderControlPort = senderControlPort
            self.smoothingLatency = smoothingLatency
            self.streamId = streamId
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge. A flow output is delivered to the AWS cloud.
    public struct BridgeFlowOutput: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the cloud flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The Amazon Resource Number (ARN) of the flow source.
        /// This member is required.
        public var flowSourceArn: Swift.String?
        /// The name of the bridge's output.
        /// This member is required.
        public var name: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowSourceArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowSourceArn = flowSourceArn
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge. A network output is delivered to your premises.
    public struct BridgeNetworkOutput: Swift.Sendable {
        /// The network output IP Address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The network output name.
        /// This member is required.
        public var name: Swift.String?
        /// The network output's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network output port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network output protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

extension MediaConnectClientTypes {

    /// The output of the bridge.
    public struct BridgeOutput: Swift.Sendable {
        /// The output of the bridge. A flow output is delivered to the AWS cloud.
        public var flowOutput: MediaConnectClientTypes.BridgeFlowOutput?
        /// The output of the bridge. A network output is delivered to your premises.
        public var networkOutput: MediaConnectClientTypes.BridgeNetworkOutput?

        public init(
            flowOutput: MediaConnectClientTypes.BridgeFlowOutput? = nil,
            networkOutput: MediaConnectClientTypes.BridgeNetworkOutput? = nil
        )
        {
            self.flowOutput = flowOutput
            self.networkOutput = networkOutput
        }
    }
}

extension MediaConnectClientTypes {

    /// The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
    public struct BridgeFlowSource: Swift.Sendable {
        /// The ARN of the cloud flow used as a source of this bridge.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
        /// The name of the flow source.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Number (ARN) of the output.
        public var outputArn: Swift.String?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
            self.name = name
            self.outputArn = outputArn
        }
    }
}

extension MediaConnectClientTypes {

    /// The source of the bridge. A network source originates at your premises.
    public struct BridgeNetworkSource: Swift.Sendable {
        /// The network source multicast IP.
        /// This member is required.
        public var multicastIp: Swift.String?
        /// The name of the network source.
        /// This member is required.
        public var name: Swift.String?
        /// The network source's gateway network name.
        /// This member is required.
        public var networkName: Swift.String?
        /// The network source port.
        /// This member is required.
        public var port: Swift.Int?
        /// The network source protocol.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            name: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.name = name
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

extension MediaConnectClientTypes {

    /// The bridge's source.
    public struct BridgeSource: Swift.Sendable {
        /// The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        public var flowSource: MediaConnectClientTypes.BridgeFlowSource?
        /// The source of the bridge. A network source originates at your premises.
        public var networkSource: MediaConnectClientTypes.BridgeNetworkSource?

        public init(
            flowSource: MediaConnectClientTypes.BridgeFlowSource? = nil,
            networkSource: MediaConnectClientTypes.BridgeNetworkSource? = nil
        )
        {
            self.flowSource = flowSource
            self.networkSource = networkSource
        }
    }
}

extension MediaConnectClientTypes {

    /// The VPC interface that is used for the media stream associated with the source or output.
    public struct Interface: Swift.Sendable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that are associated with an outbound media stream.
    public struct DestinationConfiguration: Swift.Sendable {
        /// The IP address where contents of the media stream will be sent.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port to use when the content of the media stream is distributed to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that is used for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?
        /// The IP address that the receiver requires in order to establish a connection with the flow. This value is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the CDI or ST 2110 JPEG XS protocol.
        /// This member is required.
        public var outboundIp: Swift.String?

        public init(
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil,
            outboundIp: Swift.String? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
            self.outboundIp = outboundIp
        }
    }
}

extension MediaConnectClientTypes {

    public enum EntitlementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for a flow entitlement.
    public struct Entitlement: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// An indication of whether the entitlement is enabled.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }
}

extension MediaConnectClientTypes {

    /// The network settings for a gateway.
    public struct GatewayNetwork: Swift.Sendable {
        /// A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var cidrBlock: Swift.String?
        /// The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            cidrBlock: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    /// The entitlements that you want to grant on a flow.
    public struct GrantEntitlementRequest: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement. Allowable encryption types: static-key, speke.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you don’t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that are associated with an incoming media stream.
    public struct InputConfiguration: Swift.Sendable {
        /// The IP address that the flow listens on for incoming content for a media stream.
        /// This member is required.
        public var inputIp: Swift.String?
        /// The port that the flow listens on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface where the media stream comes in from.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?

        public init(
            inputIp: Swift.String? = nil,
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil
        )
        {
            self.inputIp = inputIp
            self.inputPort = inputPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    /// The transport parameters that you want to associate with an incoming media stream.
    public struct InputConfigurationRequest: Swift.Sendable {
        /// The port that you want the flow to listen on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface that you want to use for the incoming media stream.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init(
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.inputPort = inputPort
            self.interface = interface
        }
    }
}

extension MediaConnectClientTypes {

    public enum BridgeState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case deploying
        case standby
        case starting
        case startFailed
        case startPending
        case stopping
        case stopFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgeState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .deploying,
                .standby,
                .starting,
                .startFailed,
                .startPending,
                .stopping,
                .stopFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deploying: return "DEPLOYING"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .startPending: return "START_PENDING"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Displays details of the selected bridge.
    public struct ListedBridge: Swift.Sendable {
        /// The ARN of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        /// The type of the bridge.
        /// This member is required.
        public var bridgeType: Swift.String?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the gateway associated with the bridge.
        /// This member is required.
        public var placementArn: Swift.String?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            bridgeType: Swift.String? = nil,
            name: Swift.String? = nil,
            placementArn: Swift.String? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgeState = bridgeState
            self.bridgeType = bridgeType
            self.name = name
            self.placementArn = placementArn
        }
    }
}

extension MediaConnectClientTypes {

    /// An entitlement that has been granted to you from other AWS accounts.
    public struct ListedEntitlement: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// The name of the entitlement.
        /// This member is required.
        public var entitlementName: Swift.String?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementName: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.entitlementArn = entitlementArn
            self.entitlementName = entitlementName
        }
    }
}

extension MediaConnectClientTypes {

    public enum MaintenanceDay: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceDay] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "Friday"
            case .monday: return "Monday"
            case .saturday: return "Saturday"
            case .sunday: return "Sunday"
            case .thursday: return "Thursday"
            case .tuesday: return "Tuesday"
            case .wednesday: return "Wednesday"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The maintenance setting of a flow
    public struct Maintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// The Maintenance has to be performed before this deadline in ISO UTC format. Example: 2021-01-30T08:30:00Z.
        public var maintenanceDeadline: Swift.String?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceDeadline: Swift.String? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceDeadline = maintenanceDeadline
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

extension MediaConnectClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .entitled,
                .owned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case error
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .deleting,
                .error,
                .standby,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Provides a summary of a flow, including its ARN, Availability Zone, and source type.
    public struct ListedFlow: Swift.Sendable {
        /// The Availability Zone that the flow was created in.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow.
        /// This member is required.
        public var description: Swift.String?
        /// The ARN of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The maintenance setting of a flow
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of source. This value is either owned (originated somewhere other than an AWS Elemental MediaConnect flow owned by another AWS account) or entitled (originated at an AWS Elemental MediaConnect flow owned by another AWS account).
        /// This member is required.
        public var sourceType: MediaConnectClientTypes.SourceType?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            flowArn: Swift.String? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            name: Swift.String? = nil,
            sourceType: MediaConnectClientTypes.SourceType? = nil,
            status: MediaConnectClientTypes.Status? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.flowArn = flowArn
            self.maintenance = maintenance
            self.name = name
            self.sourceType = sourceType
            self.status = status
        }
    }
}

extension MediaConnectClientTypes {

    public enum GatewayState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .error,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Provides a summary of a gateway, including its name, ARN, and status.
    public struct ListedGateway: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// This member is required.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway.
        /// This member is required.
        public var name: Swift.String?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayState = gatewayState
            self.name = name
        }
    }
}

extension MediaConnectClientTypes {

    public enum InstanceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deregistered
        case deregistering
        case deregistrationError
        case registering
        case registrationError
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceState] {
            return [
                .active,
                .deregistered,
                .deregistering,
                .deregistrationError,
                .registering,
                .registrationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .deregistrationError: return "DEREGISTRATION_ERROR"
            case .registering: return "REGISTERING"
            case .registrationError: return "REGISTRATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// Provides a summary of an instance.
    public struct ListedGatewayInstance: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The managed instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of the instance.
        public var instanceState: MediaConnectClientTypes.InstanceState?

        public init(
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil
        )
        {
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceState = instanceState
        }
    }
}

extension MediaConnectClientTypes {

    /// FMTP
    public struct Fmtp: Swift.Sendable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init(
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributes: Swift.Sendable {
        /// A set of parameters that define the media stream.
        /// This member is required.
        public var fmtp: MediaConnectClientTypes.Fmtp?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init(
            fmtp: MediaConnectClientTypes.Fmtp? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }
}

extension MediaConnectClientTypes {

    /// A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
    public struct MediaStream: Swift.Sendable {
        /// Attributes that are related to the media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributes?
        /// The sample rate for the stream. This value is measured in Hz.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        /// This member is required.
        public var fmt: Swift.Int?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init(
            attributes: MediaConnectClientTypes.MediaStreamAttributes? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            fmt: Swift.Int? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.fmt = fmt
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }
}

extension MediaConnectClientTypes {

    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParameters: Swift.Sendable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init(
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that is associated with the output, and the parameters for that association.
    public struct MediaStreamOutputConfiguration: Swift.Sendable {
        /// The transport parameters that are associated with each outbound media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]?
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// Encoding parameters
        public var encodingParameters: MediaConnectClientTypes.EncodingParameters?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParameters? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    /// The media stream that is associated with the source, and the parameters for that association.
    public struct MediaStreamSourceConfiguration: Swift.Sendable {
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that are associated with an incoming media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfiguration]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfiguration]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    /// The definition of a media stream that you want to associate with the source.
    public struct MediaStreamSourceConfigurationRequest: Swift.Sendable {
        /// The format you want to use to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that you want to associate with the media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init(
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }
}

extension MediaConnectClientTypes {

    public struct MessageDetail: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: Swift.String?
        /// The specific error message that MediaConnect returns to help you understand the reason that the request did not succeed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.resourceName = resourceName
        }
    }
}

extension MediaConnectClientTypes {

    public enum DurationUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnits] {
            return [
                .months
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .months: return "MONTHS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum PriceUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hourly
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceUnits] {
            return [
                .hourly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hourly: return "HOURLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mbpsOutboundBandwidth
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .mbpsOutboundBandwidth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mbpsOutboundBandwidth: return "Mbps_Outbound_Bandwidth"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A definition of what is being billed for, including the type and amount.
    public struct ResourceSpecification: Swift.Sendable {
        /// The amount of outbound bandwidth that is discounted in the offering.
        public var reservedBitrate: Swift.Int?
        /// The type of resource and the unit that is being billed for.
        /// This member is required.
        public var resourceType: MediaConnectClientTypes.ResourceType?

        public init(
            reservedBitrate: Swift.Int? = nil,
            resourceType: MediaConnectClientTypes.ResourceType? = nil
        )
        {
            self.reservedBitrate = reservedBitrate
            self.resourceType = resourceType
        }
    }
}

extension MediaConnectClientTypes {

    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public struct Offering: Swift.Sendable {
        /// The type of currency that is used for billing. The currencyCode used for all reservations is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that your reservation would be active.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.resourceSpecification = resourceSpecification
        }
    }
}

extension MediaConnectClientTypes {

    /// Attributes related to the transport stream that are used in a source or output.
    public struct Transport: Swift.Sendable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The protocol that is used by the source or output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull stream.
        public var remoteId: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?

        public init(
            cidrAllowList: [Swift.String]? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            minLatency: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            smoothingLatency: Swift.Int? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.minLatency = minLatency
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.smoothingLatency = smoothingLatency
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.streamId = streamId
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for an output.
    public struct Output: Swift.Sendable {
        /// The ARN of the bridge that added this output.
        public var bridgeArn: Swift.String?
        /// The bridge output ports currently in use.
        public var bridgePorts: [Swift.Int]?
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the output.
        public var description: Swift.String?
        /// The address where you want to send the output.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.
        public var entitlementArn: Swift.String?
        /// The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.
        public var listenerAddress: Swift.String?
        /// The input ARN of the AWS Elemental MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.
        public var mediaLiveInputArn: Swift.String?
        /// The configuration for each media stream that is associated with the output.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]?
        /// The name of the output. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the output.
        /// This member is required.
        public var outputArn: Swift.String?
        /// An indication of whether the output is transmitting data or not.
        public var outputStatus: MediaConnectClientTypes.OutputStatus?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// Attributes related to the transport stream that are used in the output.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgePorts: [Swift.Int]? = nil,
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            listenerAddress: Swift.String? = nil,
            mediaLiveInputArn: Swift.String? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil,
            outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
            port: Swift.Int? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgePorts = bridgePorts
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.listenerAddress = listenerAddress
            self.mediaLiveInputArn = mediaLiveInputArn
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.name = name
            self.outputArn = outputArn
            self.outputStatus = outputStatus
            self.port = port
            self.transport = transport
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    public enum ReservationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case expired
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservationState] {
            return [
                .active,
                .canceled,
                .expired,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public struct Reservation: Swift.Sendable {
        /// The type of currency that is used for billing. The currencyCode used for your reservation is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that this reservation is active. MediaConnect defines this value in the offering.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the reservation. MediaConnect defines this value in the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The day and time that this reservation expires. This value is calculated based on the start date and time that you set and the offering's duration.
        /// This member is required.
        public var end: Swift.String?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering. MediaConnect defines this value in the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the reservation when you purchase an offering.
        /// This member is required.
        public var reservationArn: Swift.String?
        /// The name that you assigned to the reservation when you purchased the offering.
        /// This member is required.
        public var reservationName: Swift.String?
        /// The status of your reservation.
        /// This member is required.
        public var reservationState: MediaConnectClientTypes.ReservationState?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering. MediaConnect defines the values that make up the resourceSpecification in the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?
        /// The day and time that the reservation becomes active. You set this value when you purchase the offering.
        /// This member is required.
        public var start: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            end: Swift.String? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            reservationArn: Swift.String? = nil,
            reservationName: Swift.String? = nil,
            reservationState: MediaConnectClientTypes.ReservationState? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil,
            start: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.end = end
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.reservationArn = reservationArn
            self.reservationName = reservationName
            self.reservationState = reservationState
            self.resourceSpecification = resourceSpecification
            self.start = start
        }
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct SetGatewayBridgeSourceRequest: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for the source of the flow.
    public struct SetSourceRequest: Swift.Sendable {
        /// The type of encryption that is used on the content ingested from this source. Allowable encryption types: static-key.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the source.
        public var name: Swift.String?
        /// The protocol that is used by the source.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// Source IP or domain name for SRT-caller protocol.
        public var sourceListenerAddress: Swift.String?
        /// Source port for SRT-caller protocol.
        public var sourceListenerPort: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface to use for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.SetGatewayBridgeSourceRequest? = nil,
            ingestPort: Swift.Int? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceListenerAddress: Swift.String? = nil,
            sourceListenerPort: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestPort = ingestPort
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.minLatency = minLatency
            self.name = name
            self.`protocol` = `protocol`
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceListenerAddress = sourceListenerAddress
            self.sourceListenerPort = sourceListenerPort
            self.streamId = streamId
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct GatewayBridgeSource: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        /// This member is required.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for the source of the flow.
    public struct Source: Swift.Sendable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The type of encryption that is used on the content ingested from this source.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The source configuration for cloud flows receiving a stream from a bridge.
        public var gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource?
        /// The IP address that the flow will be listening on for incoming content.
        public var ingestIp: Swift.String?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]?
        /// The name of the source.
        /// This member is required.
        public var name: Swift.String?
        /// The port that the flow uses to send outbound requests to initiate connection with the sender.
        public var senderControlPort: Swift.Int?
        /// The IP address that the flow communicates with to initiate connection with the sender.
        public var senderIpAddress: Swift.String?
        /// The ARN of the source.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// Attributes related to the transport stream that are used in the source.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface that is used for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init(
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            gatewayBridgeSource: MediaConnectClientTypes.GatewayBridgeSource? = nil,
            ingestIp: Swift.String? = nil,
            ingestPort: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil,
            name: Swift.String? = nil,
            senderControlPort: Swift.Int? = nil,
            senderIpAddress: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.gatewayBridgeSource = gatewayBridgeSource
            self.ingestIp = ingestIp
            self.ingestPort = ingestPort
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.name = name
            self.senderControlPort = senderControlPort
            self.senderIpAddress = senderIpAddress
            self.sourceArn = sourceArn
            self.transport = transport
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }
}

extension MediaConnectClientTypes {

    /// The frame resolution used by the video stream.
    public struct FrameResolution: Swift.Sendable {
        /// The number of pixels in the height of the video frame.
        /// This member is required.
        public var frameHeight: Swift.Int?
        /// The number of pixels in the width of the video frame.
        /// This member is required.
        public var frameWidth: Swift.Int?

        public init(
            frameHeight: Swift.Int? = nil,
            frameWidth: Swift.Int? = nil
        )
        {
            self.frameHeight = frameHeight
            self.frameWidth = frameWidth
        }
    }
}

extension MediaConnectClientTypes {

    /// The metadata of an elementary transport stream.
    public struct TransportStream: Swift.Sendable {
        /// The number of channels in the audio stream.
        public var channels: Swift.Int?
        /// The codec used by the stream.
        public var codec: Swift.String?
        /// The frame rate used by the video stream.
        public var frameRate: Swift.String?
        /// The frame resolution used by the video stream.
        public var frameResolution: MediaConnectClientTypes.FrameResolution?
        /// The Packet ID (PID) as it is reported in the Program Map Table.
        /// This member is required.
        public var pid: Swift.Int?
        /// The sample rate used by the audio stream.
        public var sampleRate: Swift.Int?
        /// The sample bit size used by the audio stream.
        public var sampleSize: Swift.Int?
        /// The Stream Type as it is reported in the Program Map Table.
        /// This member is required.
        public var streamType: Swift.String?

        public init(
            channels: Swift.Int? = nil,
            codec: Swift.String? = nil,
            frameRate: Swift.String? = nil,
            frameResolution: MediaConnectClientTypes.FrameResolution? = nil,
            pid: Swift.Int? = nil,
            sampleRate: Swift.Int? = nil,
            sampleSize: Swift.Int? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.channels = channels
            self.codec = codec
            self.frameRate = frameRate
            self.frameResolution = frameResolution
            self.pid = pid
            self.sampleRate = sampleRate
            self.sampleSize = sampleSize
            self.streamType = streamType
        }
    }
}

extension MediaConnectClientTypes {

    /// The metadata of a single transport stream program.
    public struct TransportStreamProgram: Swift.Sendable {
        /// The Program Clock Reference (PCR) Packet ID (PID) as it is reported in the Program Association Table.
        /// This member is required.
        public var pcrPid: Swift.Int?
        /// The program name as it is reported in the Program Association Table.
        public var programName: Swift.String?
        /// The program number as it is reported in the Program Association Table.
        /// This member is required.
        public var programNumber: Swift.Int?
        /// The program Packet ID (PID) as it is reported in the Program Association Table.
        /// This member is required.
        public var programPid: Swift.Int?
        /// The list of elementary transport streams in the program. The list includes video, audio, and data streams.
        /// This member is required.
        public var streams: [MediaConnectClientTypes.TransportStream]?

        public init(
            pcrPid: Swift.Int? = nil,
            programName: Swift.String? = nil,
            programNumber: Swift.Int? = nil,
            programPid: Swift.Int? = nil,
            streams: [MediaConnectClientTypes.TransportStream]? = nil
        )
        {
            self.pcrPid = pcrPid
            self.programName = programName
            self.programNumber = programNumber
            self.programPid = programPid
            self.streams = streams
        }
    }
}

extension MediaConnectClientTypes {

    public enum NetworkInterfaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case efa
        case ena
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .efa,
                .ena
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .ena: return "ena"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for a VPC Source.
    public struct VpcInterface: Swift.Sendable {
        /// Immutable and has to be a unique against other VpcInterfaces in this Flow.
        /// This member is required.
        public var name: Swift.String?
        /// IDs of the network interfaces created in customer's account by MediaConnect.
        /// This member is required.
        public var networkInterfaceIds: [Swift.String]?
        /// The type of network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            networkInterfaceIds: [Swift.String]? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceIds = networkInterfaceIds
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }
}

extension MediaConnectClientTypes {

    /// Desired VPC Interface for a Flow
    public struct VpcInterfaceRequest: Swift.Sendable {
        /// The name of the VPC Interface. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of network interface. If this value is not included in the request, MediaConnect uses ENA as the networkInterfaceType.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A request to add outputs to the specified bridge.
public struct AddBridgeOutputsInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The outputs that you want to add to this bridge.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

public struct AddBridgeOutputsOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The outputs that you added to this bridge.
    public var outputs: [MediaConnectClientTypes.BridgeOutput]?

    public init(
        bridgeArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.BridgeOutput]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputs = outputs
    }
}

/// A request to add sources to the specified bridge.
public struct AddBridgeSourcesInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

public struct AddBridgeSourcesOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The sources that you added to this bridge.
    public var sources: [MediaConnectClientTypes.BridgeSource]?

    public init(
        bridgeArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.BridgeSource]? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sources = sources
    }
}

extension MediaConnectClientTypes {

    public struct AddEgressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps).
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
        }
    }
}

/// A request to add media streams to the flow.
public struct AddFlowMediaStreamsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The media streams that you want to add to the flow.
    /// This member is required.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

public struct AddFlowMediaStreamsOutput: Swift.Sendable {
    /// The ARN of the flow that you added media streams to.
    public var flowArn: Swift.String?
    /// The media streams that you added to the flow.
    public var mediaStreams: [MediaConnectClientTypes.MediaStream]?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct AddFlowOutputs420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AddFlowOutputs420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A request to add outputs to the specified flow.
public struct AddFlowOutputsInput: Swift.Sendable {
    /// The flow that you want to add outputs to.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of outputs that you want to add.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

public struct AddFlowOutputsOutput: Swift.Sendable {
    /// The ARN of the flow that these outputs were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added outputs.
    public var outputs: [MediaConnectClientTypes.Output]?

    public init(
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.Output]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

/// A request to add sources to the flow.
public struct AddFlowSourcesInput: Swift.Sendable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of sources that you want to add.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

public struct AddFlowSourcesOutput: Swift.Sendable {
    /// The ARN of the flow that these sources were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added sources.
    public var sources: [MediaConnectClientTypes.Source]?

    public init(
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.Source]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

/// A request to add VPC interfaces to the flow.
public struct AddFlowVpcInterfacesInput: Swift.Sendable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of VPC interfaces that you want to add.
    /// This member is required.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

public struct AddFlowVpcInterfacesOutput: Swift.Sendable {
    /// The ARN of the flow that these VPC interfaces were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added VPC interfaces.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

extension MediaConnectClientTypes {

    public struct AddIngressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps).
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    /// Create maintenance setting for a flow
    public struct AddMaintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        /// This member is required.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        /// This member is required.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

extension MediaConnectClientTypes {

    public struct EgressGatewayBridge: Swift.Sendable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the egress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
        }
    }
}

extension MediaConnectClientTypes {

    public struct IngressGatewayBridge: Swift.Sendable {
        /// The ID of the instance running this bridge.
        public var instanceId: Swift.String?
        /// The maximum expected bitrate (in bps) of the ingress bridge.
        /// This member is required.
        public var maxBitrate: Swift.Int?
        /// The maximum number of outputs on the ingress bridge.
        /// This member is required.
        public var maxOutputs: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    public enum FailoverMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case merge
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverMode] {
            return [
                .failover,
                .merge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .merge: return "MERGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
    public struct SourcePriority: Swift.Sendable {
        /// The name of the source you choose as the primary source for this flow.
        public var primarySource: Swift.String?

        public init(
            primarySource: Swift.String? = nil
        )
        {
            self.primarySource = primarySource
        }
    }
}

extension MediaConnectClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source failover.
    public struct FailoverConfig: Swift.Sendable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Search window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }
}

extension MediaConnectClientTypes {

    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public struct Bridge: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var bridgeArn: Swift.String?
        public var bridgeMessages: [MediaConnectClientTypes.MessageDetail]?
        /// This member is required.
        public var bridgeState: MediaConnectClientTypes.BridgeState?
        public var egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge?
        public var ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge?
        /// The name of the bridge.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs on this bridge.
        public var outputs: [MediaConnectClientTypes.BridgeOutput]?
        /// The placement Amazon Resource Number (ARN) of the bridge.
        /// This member is required.
        public var placementArn: Swift.String?
        /// The settings for source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        /// The sources on this bridge.
        public var sources: [MediaConnectClientTypes.BridgeSource]?

        public init(
            bridgeArn: Swift.String? = nil,
            bridgeMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            bridgeState: MediaConnectClientTypes.BridgeState? = nil,
            egressGatewayBridge: MediaConnectClientTypes.EgressGatewayBridge? = nil,
            ingressGatewayBridge: MediaConnectClientTypes.IngressGatewayBridge? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.BridgeOutput]? = nil,
            placementArn: Swift.String? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sources: [MediaConnectClientTypes.BridgeSource]? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.bridgeMessages = bridgeMessages
            self.bridgeState = bridgeState
            self.egressGatewayBridge = egressGatewayBridge
            self.ingressGatewayBridge = ingressGatewayBridge
            self.name = name
            self.outputs = outputs
            self.placementArn = placementArn
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sources = sources
        }
    }
}

extension MediaConnectClientTypes {

    public enum BridgePlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case locked
        case sdkUnknown(Swift.String)

        public static var allCases: [BridgePlacement] {
            return [
                .available,
                .locked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .locked: return "LOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateBridge420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateBridge420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Creates a new bridge. The request must include one source.
public struct CreateBridgeInput: Swift.Sendable {
    /// Create a bridge with the egress bridge type. An egress bridge is a cloud-to-ground bridge. The content comes from an existing MediaConnect flow and is delivered to your premises.
    public var egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?
    /// Create a bridge with the ingress bridge type. An ingress bridge is a ground-to-cloud bridge. The content originates at your premises and is delivered to the cloud.
    public var ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?
    /// The name of the bridge. This name can not be modified after the bridge is created.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this bridge.
    public var outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]?
    /// The bridge placement Amazon Resource Number (ARN).
    /// This member is required.
    public var placementArn: Swift.String?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    /// The sources that you want to add to this bridge.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.AddBridgeSourceRequest]?

    public init(
        egressGatewayBridge: MediaConnectClientTypes.AddEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.AddIngressGatewayBridgeRequest? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddBridgeOutputRequest]? = nil,
        placementArn: Swift.String? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sources: [MediaConnectClientTypes.AddBridgeSourceRequest]? = nil
    )
    {
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.name = name
        self.outputs = outputs
        self.placementArn = placementArn
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
    }
}

public struct CreateBridgeOutput: Swift.Sendable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateFlow420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateFlow420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MediaConnectClientTypes {

    public enum ThumbnailState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source monitoring.
    public struct MonitoringConfig: Swift.Sendable {
        /// The state of thumbnail monitoring.
        public var thumbnailState: MediaConnectClientTypes.ThumbnailState?

        public init(
            thumbnailState: MediaConnectClientTypes.ThumbnailState? = nil
        )
        {
            self.thumbnailState = thumbnailState
        }
    }
}

/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
public struct CreateFlowInput: Swift.Sendable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
    public var availabilityZone: Swift.String?
    /// The entitlements that you want to grant on a flow.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// Create maintenance setting for a flow
    public var maintenance: MediaConnectClientTypes.AddMaintenance?
    /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this flow.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.SetSourceRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    /// The settings for source monitoring.
    public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?
    /// The VPC interfaces you want on the flow.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init(
        availabilityZone: Swift.String? = nil,
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        maintenance: MediaConnectClientTypes.AddMaintenance? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil,
        source: MediaConnectClientTypes.SetSourceRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.entitlements = entitlements
        self.maintenance = maintenance
        self.mediaStreams = mediaStreams
        self.name = name
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sourceMonitoringConfig = sourceMonitoringConfig
        self.sources = sources
        self.vpcInterfaces = vpcInterfaces
    }
}

extension MediaConnectClientTypes {

    /// The settings for a flow, including its source, outputs, and entitlements.
    public struct Flow: Swift.Sendable {
        /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var egressIp: Swift.String?
        /// The entitlements in this flow.
        /// This member is required.
        public var entitlements: [MediaConnectClientTypes.Entitlement]?
        /// The Amazon Resource Name (ARN) of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The maintenance setting of a flow
        public var maintenance: MediaConnectClientTypes.Maintenance?
        /// The media streams that are associated with the flow. After you associate a media stream with a source, you can also associate it with outputs on the flow.
        public var mediaStreams: [MediaConnectClientTypes.MediaStream]?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs in this flow.
        /// This member is required.
        public var outputs: [MediaConnectClientTypes.Output]?
        /// The settings for the source of the flow.
        /// This member is required.
        public var source: MediaConnectClientTypes.Source?
        /// The settings for source failover.
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        /// The settings for source monitoring.
        public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?
        public var sources: [MediaConnectClientTypes.Source]?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?
        /// The VPC Interfaces for this flow.
        public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            egressIp: Swift.String? = nil,
            entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
            flowArn: Swift.String? = nil,
            maintenance: MediaConnectClientTypes.Maintenance? = nil,
            mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.Output]? = nil,
            source: MediaConnectClientTypes.Source? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil,
            sources: [MediaConnectClientTypes.Source]? = nil,
            status: MediaConnectClientTypes.Status? = nil,
            vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.egressIp = egressIp
            self.entitlements = entitlements
            self.flowArn = flowArn
            self.maintenance = maintenance
            self.mediaStreams = mediaStreams
            self.name = name
            self.outputs = outputs
            self.source = source
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sourceMonitoringConfig = sourceMonitoringConfig
            self.sources = sources
            self.status = status
            self.vpcInterfaces = vpcInterfaces
        }
    }
}

public struct CreateFlowOutput: Swift.Sendable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateGateway420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreateGateway420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Creates a new gateway. The request must include at least one network (up to 4).
public struct CreateGatewayInput: Swift.Sendable {
    /// The range of IP addresses that are allowed to contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    /// This member is required.
    public var egressCidrBlocks: [Swift.String]?
    /// The name of the gateway. This name can not be modified after the gateway is created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of networks that you want to add.
    /// This member is required.
    public var networks: [MediaConnectClientTypes.GatewayNetwork]?

    public init(
        egressCidrBlocks: [Swift.String]? = nil,
        name: Swift.String? = nil,
        networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
    )
    {
        self.egressCidrBlocks = egressCidrBlocks
        self.name = name
        self.networks = networks
    }
}

extension MediaConnectClientTypes {

    /// The settings for a gateway, including its networks.
    public struct Gateway: Swift.Sendable {
        /// The range of IP addresses that contribute content or initiate output requests for flows communicating with this gateway. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        /// This member is required.
        public var egressCidrBlocks: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayArn: Swift.String?
        public var gatewayMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The current status of the gateway.
        public var gatewayState: MediaConnectClientTypes.GatewayState?
        /// The name of the gateway. This name can not be modified after the gateway is created.
        /// This member is required.
        public var name: Swift.String?
        /// The list of networks in the gateway.
        /// This member is required.
        public var networks: [MediaConnectClientTypes.GatewayNetwork]?

        public init(
            egressCidrBlocks: [Swift.String]? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            gatewayState: MediaConnectClientTypes.GatewayState? = nil,
            name: Swift.String? = nil,
            networks: [MediaConnectClientTypes.GatewayNetwork]? = nil
        )
        {
            self.egressCidrBlocks = egressCidrBlocks
            self.gatewayArn = gatewayArn
            self.gatewayMessages = gatewayMessages
            self.gatewayState = gatewayState
            self.name = name
            self.networks = networks
        }
    }
}

public struct CreateGatewayOutput: Swift.Sendable {
    /// The settings for a gateway, including its networks.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

public struct DeleteBridgeInput: Swift.Sendable {
    /// The ARN of the bridge that you want to delete.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

public struct DeleteBridgeOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the deleted bridge.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

public struct DeleteFlowInput: Swift.Sendable {
    /// The ARN of the flow that you want to delete.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

public struct DeleteFlowOutput: Swift.Sendable {
    /// The ARN of the flow that was deleted.
    public var flowArn: Swift.String?
    /// The status of the flow when the DeleteFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

public struct DeleteGatewayInput: Swift.Sendable {
    /// The ARN of the gateway that you want to delete.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DeleteGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway that was deleted.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DeregisterGatewayInstanceInput: Swift.Sendable {
    /// Force the deregistration of an instance. Force will deregister an instance, even if there are bridges running on it.
    public var force: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the gateway that contains the instance that you want to deregister.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.force = force
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

public struct DeregisterGatewayInstanceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the instance.
    public var gatewayInstanceArn: Swift.String?
    /// The status of the instance.
    public var instanceState: MediaConnectClientTypes.InstanceState?

    public init(
        gatewayInstanceArn: Swift.String? = nil,
        instanceState: MediaConnectClientTypes.InstanceState? = nil
    )
    {
        self.gatewayInstanceArn = gatewayInstanceArn
        self.instanceState = instanceState
    }
}

public struct DescribeBridgeInput: Swift.Sendable {
    /// The ARN of the bridge that you want to describe.
    /// This member is required.
    public var bridgeArn: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
    }
}

public struct DescribeBridgeOutput: Swift.Sendable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

public struct DescribeFlowInput: Swift.Sendable {
    /// The ARN of the flow that you want to describe.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// Messages that provide the state of the flow.
    public struct Messages: Swift.Sendable {
        /// A list of errors that might have been generated from processes on this flow.
        /// This member is required.
        public var errors: [Swift.String]?

        public init(
            errors: [Swift.String]? = nil
        )
        {
            self.errors = errors
        }
    }
}

public struct DescribeFlowOutput: Swift.Sendable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?
    /// Messages that provide the state of the flow.
    public var messages: MediaConnectClientTypes.Messages?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil,
        messages: MediaConnectClientTypes.Messages? = nil
    )
    {
        self.flow = flow
        self.messages = messages
    }
}

public struct DescribeFlowSourceMetadataInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// The metadata of the transport stream in the current flow's source.
    public struct TransportMediaInfo: Swift.Sendable {
        /// The list of transport stream programs in the current flow's source.
        /// This member is required.
        public var programs: [MediaConnectClientTypes.TransportStreamProgram]?

        public init(
            programs: [MediaConnectClientTypes.TransportStreamProgram]? = nil
        )
        {
            self.programs = programs
        }
    }
}

public struct DescribeFlowSourceMetadataOutput: Swift.Sendable {
    /// The ARN of the flow that DescribeFlowSourceMetadata was performed on.
    public var flowArn: Swift.String?
    /// Provides a status code and message regarding issues found with the flow source metadata.
    public var messages: [MediaConnectClientTypes.MessageDetail]?
    /// The timestamp of the most recent change in metadata for this flow’s source.
    public var timestamp: Foundation.Date?
    /// The metadata of the transport stream in the current flow's source.
    public var transportMediaInfo: MediaConnectClientTypes.TransportMediaInfo?

    public init(
        flowArn: Swift.String? = nil,
        messages: [MediaConnectClientTypes.MessageDetail]? = nil,
        timestamp: Foundation.Date? = nil,
        transportMediaInfo: MediaConnectClientTypes.TransportMediaInfo? = nil
    )
    {
        self.flowArn = flowArn
        self.messages = messages
        self.timestamp = timestamp
        self.transportMediaInfo = transportMediaInfo
    }
}

public struct DescribeFlowSourceThumbnailInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

extension MediaConnectClientTypes {

    /// The details of the thumbnail, including thumbnail base64 string, timecode and the time when thumbnail was generated.
    public struct ThumbnailDetails: Swift.Sendable {
        /// The ARN of the flow that DescribeFlowSourceThumbnail was performed on.
        /// This member is required.
        public var flowArn: Swift.String?
        /// Thumbnail Base64 string.
        public var thumbnail: Swift.String?
        /// Status code and messages about the flow source thumbnail.
        /// This member is required.
        public var thumbnailMessages: [MediaConnectClientTypes.MessageDetail]?
        /// Timecode of thumbnail.
        public var timecode: Swift.String?
        /// The timestamp of when thumbnail was generated.
        public var timestamp: Foundation.Date?

        public init(
            flowArn: Swift.String? = nil,
            thumbnail: Swift.String? = nil,
            thumbnailMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            timecode: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.flowArn = flowArn
            self.thumbnail = thumbnail
            self.thumbnailMessages = thumbnailMessages
            self.timecode = timecode
            self.timestamp = timestamp
        }
    }
}

public struct DescribeFlowSourceThumbnailOutput: Swift.Sendable {
    /// The details of the thumbnail, including thumbnail base64 string, timecode and the time when thumbnail was generated.
    public var thumbnailDetails: MediaConnectClientTypes.ThumbnailDetails?

    public init(
        thumbnailDetails: MediaConnectClientTypes.ThumbnailDetails? = nil
    )
    {
        self.thumbnailDetails = thumbnailDetails
    }
}

public struct DescribeGatewayInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway that you want to describe.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

public struct DescribeGatewayOutput: Swift.Sendable {
    /// The settings for a gateway, including its networks.
    public var gateway: MediaConnectClientTypes.Gateway?

    public init(
        gateway: MediaConnectClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

public struct DescribeGatewayInstanceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the gateway instance that you want to describe.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

extension MediaConnectClientTypes {

    /// The settings for an instance in a gateway.
    public struct GatewayInstance: Swift.Sendable {
        /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
        /// This member is required.
        public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
        /// The connection state of the instance.
        /// This member is required.
        public var connectionStatus: MediaConnectClientTypes.ConnectionStatus?
        /// The Amazon Resource Name (ARN) of the instance.
        /// This member is required.
        public var gatewayArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the gateway.
        /// This member is required.
        public var gatewayInstanceArn: Swift.String?
        /// The managed instance ID generated by the SSM install. This will begin with "mi-".
        /// This member is required.
        public var instanceId: Swift.String?
        public var instanceMessages: [MediaConnectClientTypes.MessageDetail]?
        /// The status of the instance.
        /// This member is required.
        public var instanceState: MediaConnectClientTypes.InstanceState?
        /// The running bridge count.
        /// This member is required.
        public var runningBridgeCount: Swift.Int?

        public init(
            bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
            connectionStatus: MediaConnectClientTypes.ConnectionStatus? = nil,
            gatewayArn: Swift.String? = nil,
            gatewayInstanceArn: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceMessages: [MediaConnectClientTypes.MessageDetail]? = nil,
            instanceState: MediaConnectClientTypes.InstanceState? = nil,
            runningBridgeCount: Swift.Int? = nil
        )
        {
            self.bridgePlacement = bridgePlacement
            self.connectionStatus = connectionStatus
            self.gatewayArn = gatewayArn
            self.gatewayInstanceArn = gatewayInstanceArn
            self.instanceId = instanceId
            self.instanceMessages = instanceMessages
            self.instanceState = instanceState
            self.runningBridgeCount = runningBridgeCount
        }
    }
}

public struct DescribeGatewayInstanceOutput: Swift.Sendable {
    /// The settings for an instance in a gateway.
    public var gatewayInstance: MediaConnectClientTypes.GatewayInstance?

    public init(
        gatewayInstance: MediaConnectClientTypes.GatewayInstance? = nil
    )
    {
        self.gatewayInstance = gatewayInstance
    }
}

public struct DescribeOfferingInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?

    public init(
        offeringArn: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
    }
}

public struct DescribeOfferingOutput: Swift.Sendable {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public var offering: MediaConnectClientTypes.Offering?

    public init(
        offering: MediaConnectClientTypes.Offering? = nil
    )
    {
        self.offering = offering
    }
}

public struct DescribeReservationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the reservation.
    /// This member is required.
    public var reservationArn: Swift.String?

    public init(
        reservationArn: Swift.String? = nil
    )
    {
        self.reservationArn = reservationArn
    }
}

public struct DescribeReservationOutput: Swift.Sendable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

extension MediaConnectClientTypes {

    public enum DesiredState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .active,
                .deleted,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct GrantFlowEntitlements420Exception: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message returned by AWS Elemental MediaConnect.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GrantFlowEntitlements420Exception" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A request to grant entitlements on a flow.
public struct GrantFlowEntitlementsInput: Swift.Sendable {
    /// The list of entitlements that you want to grant.
    /// This member is required.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// The flow that you want to grant entitlements on.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

public struct GrantFlowEntitlementsOutput: Swift.Sendable {
    /// The entitlements that were just granted.
    public var entitlements: [MediaConnectClientTypes.Entitlement]?
    /// The ARN of the flow that these entitlements were granted to.
    public var flowArn: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

public struct ListBridgesInput: Swift.Sendable {
    /// Filter the list results to display only the bridges associated with the selected Amazon Resource Name (ARN).
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListBridges request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBridgesOutput: Swift.Sendable {
    /// A list of bridge summaries.
    public var bridges: [MediaConnectClientTypes.ListedBridge]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListBridges request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListBridges request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        bridges: [MediaConnectClientTypes.ListedBridge]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bridges = bridges
        self.nextToken = nextToken
    }
}

public struct ListEntitlementsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEntitlementsOutput: Swift.Sendable {
    /// A list of entitlements that have been granted to you from other AWS accounts.
    public var entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        entitlements: [MediaConnectClientTypes.ListedEntitlement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

public struct ListFlowsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFlowsOutput: Swift.Sendable {
    /// A list of flow summaries.
    public var flows: [MediaConnectClientTypes.ListedFlow]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        flows: [MediaConnectClientTypes.ListedFlow]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

public struct ListGatewayInstancesInput: Swift.Sendable {
    /// Filter the list results to display only the instances associated with the selected Gateway Amazon Resource Name (ARN).
    public var filterArn: Swift.String?
    /// The maximum number of results to return per API request. For example, you submit a ListInstances request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        filterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGatewayInstancesOutput: Swift.Sendable {
    /// A list of instance summaries.
    public var instances: [MediaConnectClientTypes.ListedGatewayInstance]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListInstances request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListInstances request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        instances: [MediaConnectClientTypes.ListedGatewayInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

public struct ListGatewaysInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListGateways request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGatewaysOutput: Swift.Sendable {
    /// A list of gateway summaries.
    public var gateways: [MediaConnectClientTypes.ListedGateway]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListGateways request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListGateways request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        gateways: [MediaConnectClientTypes.ListedGateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

public struct ListOfferingsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOfferingsOutput: Swift.Sendable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of offerings that are available to this account in the current AWS Region.
    public var offerings: [MediaConnectClientTypes.Offering]?

    public init(
        nextToken: Swift.String? = nil,
        offerings: [MediaConnectClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

public struct ListReservationsInput: Swift.Sendable {
    /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReservationsOutput: Swift.Sendable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListReservations request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of all reservations that have been purchased by this account in the current AWS Region.
    public var reservations: [MediaConnectClientTypes.Reservation]?

    public init(
        nextToken: Swift.String? = nil,
        reservations: [MediaConnectClientTypes.Reservation]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservations = reservations
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// A request to purchase a offering.
public struct PurchaseOfferingInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?
    /// The name that you want to use for the reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
    /// This member is required.
    public var start: Swift.String?

    public init(
        offeringArn: Swift.String? = nil,
        reservationName: Swift.String? = nil,
        start: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
        self.reservationName = reservationName
        self.start = start
    }
}

public struct PurchaseOfferingOutput: Swift.Sendable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init(
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

public struct RemoveBridgeOutputInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge output that you want to remove.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

public struct RemoveBridgeOutputOutput: Swift.Sendable {
    public var bridgeArn: Swift.String?
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.outputName = outputName
    }
}

public struct RemoveBridgeSourceInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// The name of the bridge source that you want to remove.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

public struct RemoveBridgeSourceOutput: Swift.Sendable {
    public var bridgeArn: Swift.String?
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.sourceName = sourceName
    }
}

public struct RemoveFlowMediaStreamInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to remove.
    /// This member is required.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

public struct RemoveFlowMediaStreamOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    public var flowArn: Swift.String?
    /// The name of the media stream that was removed.
    public var mediaStreamName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

public struct RemoveFlowOutputInput: Swift.Sendable {
    /// The flow that you want to remove an output from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the output that you want to remove.
    /// This member is required.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

public struct RemoveFlowOutputOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the output you removed.
    public var flowArn: Swift.String?
    /// The ARN of the output that was removed.
    public var outputArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

public struct RemoveFlowSourceInput: Swift.Sendable {
    /// The flow that you want to remove a source from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the source that you want to remove.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

public struct RemoveFlowSourceOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the source you removed.
    public var flowArn: Swift.String?
    /// The ARN of the source that was removed.
    public var sourceArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

public struct RemoveFlowVpcInterfaceInput: Swift.Sendable {
    /// The flow that you want to remove a VPC interface from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the VPC interface that you want to remove.
    /// This member is required.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaceName = vpcInterfaceName
    }
}

public struct RemoveFlowVpcInterfaceOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the VPC interface you removed.
    public var flowArn: Swift.String?
    /// IDs of network interfaces associated with the removed VPC interface that Media Connect was unable to remove.
    public var nonDeletedNetworkInterfaceIds: [Swift.String]?
    /// The name of the VPC interface that was removed.
    public var vpcInterfaceName: Swift.String?

    public init(
        flowArn: Swift.String? = nil,
        nonDeletedNetworkInterfaceIds: [Swift.String]? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIds
        self.vpcInterfaceName = vpcInterfaceName
    }
}

public struct RevokeFlowEntitlementInput: Swift.Sendable {
    /// The ARN of the entitlement that you want to revoke.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// The flow that you want to revoke an entitlement from.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

public struct RevokeFlowEntitlementOutput: Swift.Sendable {
    /// The ARN of the entitlement that was revoked.
    public var entitlementArn: Swift.String?
    /// The ARN of the flow that the entitlement was revoked from.
    public var flowArn: Swift.String?

    public init(
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

public struct StartFlowInput: Swift.Sendable {
    /// The ARN of the flow that you want to start.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

public struct StartFlowOutput: Swift.Sendable {
    /// The ARN of the flow that you started.
    public var flowArn: Swift.String?
    /// The status of the flow when the StartFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

public struct StopFlowInput: Swift.Sendable {
    /// The ARN of the flow that you want to stop.
    /// This member is required.
    public var flowArn: Swift.String?

    public init(
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

public struct StopFlowOutput: Swift.Sendable {
    /// The ARN of the flow that you stopped.
    public var flowArn: Swift.String?
    /// The status of the flow when the StopFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init(
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension MediaConnectClientTypes {

    public struct UpdateEgressGatewayBridgeRequest: Swift.Sendable {
        /// Update an existing egress-type bridge.
        public var maxBitrate: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
        }
    }
}

extension MediaConnectClientTypes {

    public struct UpdateIngressGatewayBridgeRequest: Swift.Sendable {
        /// The maximum expected bitrate (in bps).
        public var maxBitrate: Swift.Int?
        /// The maximum number of expected outputs.
        public var maxOutputs: Swift.Int?

        public init(
            maxBitrate: Swift.Int? = nil,
            maxOutputs: Swift.Int? = nil
        )
        {
            self.maxBitrate = maxBitrate
            self.maxOutputs = maxOutputs
        }
    }
}

extension MediaConnectClientTypes {

    /// The settings for source failover.
    public struct UpdateFailoverConfig: Swift.Sendable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Recovery window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init(
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }
}

/// A request to update the bridge.
public struct UpdateBridgeInput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    public var egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?
    public var ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?

    public init(
        bridgeArn: Swift.String? = nil,
        egressGatewayBridge: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest? = nil,
        ingressGatewayBridge: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.egressGatewayBridge = egressGatewayBridge
        self.ingressGatewayBridge = ingressGatewayBridge
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

public struct UpdateBridgeOutput: Swift.Sendable {
    /// A Bridge is the connection between your datacenter's Instances and the AWS cloud. A bridge can be used to send video from the AWS cloud to your datacenter or from your datacenter to the AWS cloud.
    public var bridge: MediaConnectClientTypes.Bridge?

    public init(
        bridge: MediaConnectClientTypes.Bridge? = nil
    )
    {
        self.bridge = bridge
    }
}

extension MediaConnectClientTypes {

    /// Update an existing network output.
    public struct UpdateBridgeNetworkOutputRequest: Swift.Sendable {
        /// The network output IP Address.
        public var ipAddress: Swift.String?
        /// The network output's gateway network name.
        public var networkName: Swift.String?
        /// The network output port.
        public var port: Swift.Int?
        /// The network output protocol.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The network output TTL.
        public var ttl: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            ttl: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
            self.ttl = ttl
        }
    }
}

/// The fields that you want to update in the bridge output.
public struct UpdateBridgeOutputInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// Update an existing network output.
    public var networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?
    /// The name of the bridge output that you want to update.
    /// This member is required.
    public var outputName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        networkOutput: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest? = nil,
        outputName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.networkOutput = networkOutput
        self.outputName = outputName
    }
}

public struct UpdateBridgeOutputOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The output that you updated.
    public var output: MediaConnectClientTypes.BridgeOutput?

    public init(
        bridgeArn: Swift.String? = nil,
        output: MediaConnectClientTypes.BridgeOutput? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.output = output
    }
}

extension MediaConnectClientTypes {

    /// Update the flow source of the bridge.
    public struct UpdateBridgeFlowSourceRequest: Swift.Sendable {
        /// The ARN of the cloud flow to use as a source of this bridge.
        public var flowArn: Swift.String?
        /// The name of the VPC interface attachment to use for this source.
        public var flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            flowArn: Swift.String? = nil,
            flowVpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.flowArn = flowArn
            self.flowVpcInterfaceAttachment = flowVpcInterfaceAttachment
        }
    }
}

extension MediaConnectClientTypes {

    /// Update the network source of the bridge.
    public struct UpdateBridgeNetworkSourceRequest: Swift.Sendable {
        /// The network source multicast IP.
        public var multicastIp: Swift.String?
        /// The network source's gateway network name.
        public var networkName: Swift.String?
        /// The network source port.
        public var port: Swift.Int?
        /// The network source protocol.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?

        public init(
            multicastIp: Swift.String? = nil,
            networkName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil
        )
        {
            self.multicastIp = multicastIp
            self.networkName = networkName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

/// The fields that you want to update in the bridge source.
public struct UpdateBridgeSourceInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// Update the flow source of the bridge.
    public var flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?
    /// Update the network source of the bridge.
    public var networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?
    /// The name of the source that you want to update.
    /// This member is required.
    public var sourceName: Swift.String?

    public init(
        bridgeArn: Swift.String? = nil,
        flowSource: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest? = nil,
        networkSource: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest? = nil,
        sourceName: Swift.String? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.flowSource = flowSource
        self.networkSource = networkSource
        self.sourceName = sourceName
    }
}

public struct UpdateBridgeSourceOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The bridge's source.
    public var source: MediaConnectClientTypes.BridgeSource?

    public init(
        bridgeArn: Swift.String? = nil,
        source: MediaConnectClientTypes.BridgeSource? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.source = source
    }
}

/// A request to update the bridge state.
public struct UpdateBridgeStateInput: Swift.Sendable {
    /// The ARN of the bridge that you want to update.
    /// This member is required.
    public var bridgeArn: Swift.String?
    /// This member is required.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

public struct UpdateBridgeStateOutput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the bridge.
    public var bridgeArn: Swift.String?
    /// The state of the bridge. ACTIVE or STANDBY.
    public var desiredState: MediaConnectClientTypes.DesiredState?

    public init(
        bridgeArn: Swift.String? = nil,
        desiredState: MediaConnectClientTypes.DesiredState? = nil
    )
    {
        self.bridgeArn = bridgeArn
        self.desiredState = desiredState
    }
}

extension MediaConnectClientTypes {

    /// Update maintenance setting for a flow
    public struct UpdateMaintenance: Swift.Sendable {
        /// A day of a week when the maintenance will happen. use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        public var maintenanceDay: MediaConnectClientTypes.MaintenanceDay?
        /// A scheduled date in ISO UTC format when the maintenance will happen. Use YYYY-MM-DD format. Example: 2021-01-30.
        public var maintenanceScheduledDate: Swift.String?
        /// UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        public var maintenanceStartHour: Swift.String?

        public init(
            maintenanceDay: MediaConnectClientTypes.MaintenanceDay? = nil,
            maintenanceScheduledDate: Swift.String? = nil,
            maintenanceStartHour: Swift.String? = nil
        )
        {
            self.maintenanceDay = maintenanceDay
            self.maintenanceScheduledDate = maintenanceScheduledDate
            self.maintenanceStartHour = maintenanceStartHour
        }
    }
}

/// A request to update flow.
public struct UpdateFlowInput: Swift.Sendable {
    /// The flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// Update maintenance setting for a flow
    public var maintenance: MediaConnectClientTypes.UpdateMaintenance?
    /// The settings for source failover.
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?
    /// The settings for source monitoring.
    public var sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig?

    public init(
        flowArn: Swift.String? = nil,
        maintenance: MediaConnectClientTypes.UpdateMaintenance? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil,
        sourceMonitoringConfig: MediaConnectClientTypes.MonitoringConfig? = nil
    )
    {
        self.flowArn = flowArn
        self.maintenance = maintenance
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sourceMonitoringConfig = sourceMonitoringConfig
    }
}

public struct UpdateFlowOutput: Swift.Sendable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init(
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

extension MediaConnectClientTypes {

    /// Information about the encryption of the flow.
    public struct UpdateEncryption: Swift.Sendable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init(
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }
}

/// The entitlement fields that you want to update.
public struct UpdateFlowEntitlementInput: Swift.Sendable {
    /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
    public var description: Swift.String?
    /// The type of encryption that will be used on the output associated with this entitlement. Allowable encryption types: static-key, speke.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The ARN of the entitlement that you want to update.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscriber’s flow temporarily. If you don’t specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
    public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    /// The flow that is associated with the entitlement that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public var subscribers: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        entitlementArn: Swift.String? = nil,
        entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
        flowArn: Swift.String? = nil,
        subscribers: [Swift.String]? = nil
    )
    {
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.flowArn = flowArn
        self.subscribers = subscribers
    }
}

public struct UpdateFlowEntitlementOutput: Swift.Sendable {
    /// The new configuration of the entitlement that you updated.
    public var entitlement: MediaConnectClientTypes.Entitlement?
    /// The ARN of the flow that this entitlement was granted on.
    public var flowArn: Swift.String?

    public init(
        entitlement: MediaConnectClientTypes.Entitlement? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlement = entitlement
        self.flowArn = flowArn
    }
}

/// The fields that you want to update in the media stream.
public struct UpdateFlowMediaStreamInput: Swift.Sendable {
    /// The attributes that you want to assign to the media stream.
    public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
    public var clockRate: Swift.Int?
    /// Description
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to update.
    /// This member is required.
    public var mediaStreamName: Swift.String?
    /// The type of media stream.
    public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    /// The resolution of the video.
    public var videoFormat: Swift.String?

    public init(
        attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
        clockRate: Swift.Int? = nil,
        description: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil,
        mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
        videoFormat: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

public struct UpdateFlowMediaStreamOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the media stream that you updated.
    public var flowArn: Swift.String?
    /// The media stream that you updated.
    public var mediaStream: MediaConnectClientTypes.MediaStream?

    public init(
        flowArn: Swift.String? = nil,
        mediaStream: MediaConnectClientTypes.MediaStream? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStream = mediaStream
    }
}

/// The fields that you want to update in the output.
public struct UpdateFlowOutputInput: Swift.Sendable {
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var cidrAllowList: [Swift.String]?
    /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
    public var description: Swift.String?
    /// The IP address where you want to send the output.
    public var destination: Swift.String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key). Allowable encryption types: static-key.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The flow that is associated with the output that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
    public var maxLatency: Swift.Int?
    /// The media streams that are associated with the output, and the parameters for those associations.
    public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// The ARN of the output that you want to update.
    /// This member is required.
    public var outputArn: Swift.String?
    /// An indication of whether the output should transmit data or not. If you don't specify the outputStatus field in your request, MediaConnect leaves the value unchanged.
    public var outputStatus: MediaConnectClientTypes.OutputStatus?
    /// The port to use when content is distributed to this output.
    public var port: Swift.Int?
    /// The protocol to use for the output.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The remote ID for the Zixi-pull stream.
    public var remoteId: Swift.String?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public var smoothingLatency: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface attachment to use for this output.
    public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

    public init(
        cidrAllowList: [Swift.String]? = nil,
        description: Swift.String? = nil,
        destination: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        flowArn: Swift.String? = nil,
        maxLatency: Swift.Int? = nil,
        mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        outputArn: Swift.String? = nil,
        outputStatus: MediaConnectClientTypes.OutputStatus? = nil,
        port: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        remoteId: Swift.String? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        smoothingLatency: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
    )
    {
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.flowArn = flowArn
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.outputArn = outputArn
        self.outputStatus = outputStatus
        self.port = port
        self.`protocol` = `protocol`
        self.remoteId = remoteId
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

public struct UpdateFlowOutputOutput: Swift.Sendable {
    /// The ARN of the flow that is associated with the updated output.
    public var flowArn: Swift.String?
    /// The new settings of the output that you updated.
    public var output: MediaConnectClientTypes.Output?

    public init(
        flowArn: Swift.String? = nil,
        output: MediaConnectClientTypes.Output? = nil
    )
    {
        self.flowArn = flowArn
        self.output = output
    }
}

extension MediaConnectClientTypes {

    /// The source configuration for cloud flows receiving a stream from a bridge.
    public struct UpdateGatewayBridgeSourceRequest: Swift.Sendable {
        /// The ARN of the bridge feeding this flow.
        public var bridgeArn: Swift.String?
        /// The name of the VPC interface attachment to use for this bridge source.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init(
            bridgeArn: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.bridgeArn = bridgeArn
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }
}

/// A request to update the source of a flow.
public struct UpdateFlowSourceInput: Swift.Sendable {
    /// The type of encryption used on the content ingested from this source. Allowable encryption types: static-key.
    public var decryption: MediaConnectClientTypes.UpdateEncryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public var description: Swift.String?
    /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
    public var entitlementArn: Swift.String?
    /// The flow that is associated with the source that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The source configuration for cloud flows receiving a stream from a bridge.
    public var gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?
    /// The port that the flow will be listening on for incoming content.
    public var ingestPort: Swift.Int?
    /// The smoothing max bitrate (in bps) for RIST, RTP, and RTP-FEC streams.
    public var maxBitrate: Swift.Int?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.
    public var maxLatency: Swift.Int?
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public var maxSyncBuffer: Swift.Int?
    /// The media streams that are associated with the source, and the parameters for those associations.
    public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// The protocol that is used by the source.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The port that the flow uses to send outbound requests to initiate connection with the sender.
    public var senderControlPort: Swift.Int?
    /// The IP address that the flow communicates with to initiate connection with the sender.
    public var senderIpAddress: Swift.String?
    /// The ARN of the source that you want to update.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source IP or domain name for SRT-caller protocol.
    public var sourceListenerAddress: Swift.String?
    /// Source port for SRT-caller protocol.
    public var sourceListenerPort: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface to use for this source.
    public var vpcInterfaceName: Swift.String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var whitelistCidr: Swift.String?

    public init(
        decryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        description: Swift.String? = nil,
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        gatewayBridgeSource: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest? = nil,
        ingestPort: Swift.Int? = nil,
        maxBitrate: Swift.Int? = nil,
        maxLatency: Swift.Int? = nil,
        maxSyncBuffer: Swift.Int? = nil,
        mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        senderControlPort: Swift.Int? = nil,
        senderIpAddress: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceListenerAddress: Swift.String? = nil,
        sourceListenerPort: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil,
        whitelistCidr: Swift.String? = nil
    )
    {
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
        self.gatewayBridgeSource = gatewayBridgeSource
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.`protocol` = `protocol`
        self.senderControlPort = senderControlPort
        self.senderIpAddress = senderIpAddress
        self.sourceArn = sourceArn
        self.sourceListenerAddress = sourceListenerAddress
        self.sourceListenerPort = sourceListenerPort
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

public struct UpdateFlowSourceOutput: Swift.Sendable {
    /// The ARN of the flow that you want to update.
    public var flowArn: Swift.String?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.Source?

    public init(
        flowArn: Swift.String? = nil,
        source: MediaConnectClientTypes.Source? = nil
    )
    {
        self.flowArn = flowArn
        self.source = source
    }
}

/// A request to update gateway instance state.
public struct UpdateGatewayInstanceInput: Swift.Sendable {
    /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The Amazon Resource Name (ARN) of the instance that you want to update.
    /// This member is required.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

public struct UpdateGatewayInstanceOutput: Swift.Sendable {
    /// The availability of the instance to host new bridges. The bridgePlacement property can be LOCKED or AVAILABLE. If it is LOCKED, no new bridges can be deployed to this instance. If it is AVAILABLE, new bridges can be added to this instance.
    public var bridgePlacement: MediaConnectClientTypes.BridgePlacement?
    /// The Amazon Resource Name (ARN) of the instance.
    public var gatewayInstanceArn: Swift.String?

    public init(
        bridgePlacement: MediaConnectClientTypes.BridgePlacement? = nil,
        gatewayInstanceArn: Swift.String? = nil
    )
    {
        self.bridgePlacement = bridgePlacement
        self.gatewayInstanceArn = gatewayInstanceArn
    }
}

extension AddBridgeOutputsInput {

    static func urlPathProvider(_ value: AddBridgeOutputsInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs"
    }
}

extension AddBridgeSourcesInput {

    static func urlPathProvider(_ value: AddBridgeSourcesInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources"
    }
}

extension AddFlowMediaStreamsInput {

    static func urlPathProvider(_ value: AddFlowMediaStreamsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams"
    }
}

extension AddFlowOutputsInput {

    static func urlPathProvider(_ value: AddFlowOutputsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs"
    }
}

extension AddFlowSourcesInput {

    static func urlPathProvider(_ value: AddFlowSourcesInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source"
    }
}

extension AddFlowVpcInterfacesInput {

    static func urlPathProvider(_ value: AddFlowVpcInterfacesInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces"
    }
}

extension CreateBridgeInput {

    static func urlPathProvider(_ value: CreateBridgeInput) -> Swift.String? {
        return "/v1/bridges"
    }
}

extension CreateFlowInput {

    static func urlPathProvider(_ value: CreateFlowInput) -> Swift.String? {
        return "/v1/flows"
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/v1/gateways"
    }
}

extension DeleteBridgeInput {

    static func urlPathProvider(_ value: DeleteBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension DeleteFlowInput {

    static func urlPathProvider(_ value: DeleteFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        guard let gatewayArn = value.gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

extension DeregisterGatewayInstanceInput {

    static func urlPathProvider(_ value: DeregisterGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension DeregisterGatewayInstanceInput {

    static func queryItemProvider(_ value: DeregisterGatewayInstanceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DescribeBridgeInput {

    static func urlPathProvider(_ value: DescribeBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension DescribeFlowInput {

    static func urlPathProvider(_ value: DescribeFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension DescribeFlowSourceMetadataInput {

    static func urlPathProvider(_ value: DescribeFlowSourceMetadataInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source-metadata"
    }
}

extension DescribeFlowSourceThumbnailInput {

    static func urlPathProvider(_ value: DescribeFlowSourceThumbnailInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source-thumbnail"
    }
}

extension DescribeGatewayInput {

    static func urlPathProvider(_ value: DescribeGatewayInput) -> Swift.String? {
        guard let gatewayArn = value.gatewayArn else {
            return nil
        }
        return "/v1/gateways/\(gatewayArn.urlPercentEncoding())"
    }
}

extension DescribeGatewayInstanceInput {

    static func urlPathProvider(_ value: DescribeGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension DescribeOfferingInput {

    static func urlPathProvider(_ value: DescribeOfferingInput) -> Swift.String? {
        guard let offeringArn = value.offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

extension DescribeReservationInput {

    static func urlPathProvider(_ value: DescribeReservationInput) -> Swift.String? {
        guard let reservationArn = value.reservationArn else {
            return nil
        }
        return "/v1/reservations/\(reservationArn.urlPercentEncoding())"
    }
}

extension GrantFlowEntitlementsInput {

    static func urlPathProvider(_ value: GrantFlowEntitlementsInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements"
    }
}

extension ListBridgesInput {

    static func urlPathProvider(_ value: ListBridgesInput) -> Swift.String? {
        return "/v1/bridges"
    }
}

extension ListBridgesInput {

    static func queryItemProvider(_ value: ListBridgesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filterArn = value.filterArn {
            let filterArnQueryItem = Smithy.URIQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
            items.append(filterArnQueryItem)
        }
        return items
    }
}

extension ListEntitlementsInput {

    static func urlPathProvider(_ value: ListEntitlementsInput) -> Swift.String? {
        return "/v1/entitlements"
    }
}

extension ListEntitlementsInput {

    static func queryItemProvider(_ value: ListEntitlementsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFlowsInput {

    static func urlPathProvider(_ value: ListFlowsInput) -> Swift.String? {
        return "/v1/flows"
    }
}

extension ListFlowsInput {

    static func queryItemProvider(_ value: ListFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGatewayInstancesInput {

    static func urlPathProvider(_ value: ListGatewayInstancesInput) -> Swift.String? {
        return "/v1/gateway-instances"
    }
}

extension ListGatewayInstancesInput {

    static func queryItemProvider(_ value: ListGatewayInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let filterArn = value.filterArn {
            let filterArnQueryItem = Smithy.URIQueryItem(name: "filterArn".urlPercentEncoding(), value: Swift.String(filterArn).urlPercentEncoding())
            items.append(filterArnQueryItem)
        }
        return items
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/v1/gateways"
    }
}

extension ListGatewaysInput {

    static func queryItemProvider(_ value: ListGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOfferingsInput {

    static func urlPathProvider(_ value: ListOfferingsInput) -> Swift.String? {
        return "/v1/offerings"
    }
}

extension ListOfferingsInput {

    static func queryItemProvider(_ value: ListOfferingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReservationsInput {

    static func urlPathProvider(_ value: ListReservationsInput) -> Swift.String? {
        return "/v1/reservations"
    }
}

extension ListReservationsInput {

    static func queryItemProvider(_ value: ListReservationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PurchaseOfferingInput {

    static func urlPathProvider(_ value: PurchaseOfferingInput) -> Swift.String? {
        guard let offeringArn = value.offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

extension RemoveBridgeOutputInput {

    static func urlPathProvider(_ value: RemoveBridgeOutputInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let outputName = value.outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

extension RemoveBridgeSourceInput {

    static func urlPathProvider(_ value: RemoveBridgeSourceInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let sourceName = value.sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

extension RemoveFlowMediaStreamInput {

    static func urlPathProvider(_ value: RemoveFlowMediaStreamInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let mediaStreamName = value.mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

extension RemoveFlowOutputInput {

    static func urlPathProvider(_ value: RemoveFlowOutputInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let outputArn = value.outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

extension RemoveFlowSourceInput {

    static func urlPathProvider(_ value: RemoveFlowSourceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let sourceArn = value.sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

extension RemoveFlowVpcInterfaceInput {

    static func urlPathProvider(_ value: RemoveFlowVpcInterfaceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let vpcInterfaceName = value.vpcInterfaceName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces/\(vpcInterfaceName.urlPercentEncoding())"
    }
}

extension RevokeFlowEntitlementInput {

    static func urlPathProvider(_ value: RevokeFlowEntitlementInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let entitlementArn = value.entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

extension StartFlowInput {

    static func urlPathProvider(_ value: StartFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/start/\(flowArn.urlPercentEncoding())"
    }
}

extension StopFlowInput {

    static func urlPathProvider(_ value: StopFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/stop/\(flowArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateBridgeInput {

    static func urlPathProvider(_ value: UpdateBridgeInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())"
    }
}

extension UpdateBridgeOutputInput {

    static func urlPathProvider(_ value: UpdateBridgeOutputInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let outputName = value.outputName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/outputs/\(outputName.urlPercentEncoding())"
    }
}

extension UpdateBridgeSourceInput {

    static func urlPathProvider(_ value: UpdateBridgeSourceInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        guard let sourceName = value.sourceName else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/sources/\(sourceName.urlPercentEncoding())"
    }
}

extension UpdateBridgeStateInput {

    static func urlPathProvider(_ value: UpdateBridgeStateInput) -> Swift.String? {
        guard let bridgeArn = value.bridgeArn else {
            return nil
        }
        return "/v1/bridges/\(bridgeArn.urlPercentEncoding())/state"
    }
}

extension UpdateFlowInput {

    static func urlPathProvider(_ value: UpdateFlowInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

extension UpdateFlowEntitlementInput {

    static func urlPathProvider(_ value: UpdateFlowEntitlementInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let entitlementArn = value.entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

extension UpdateFlowMediaStreamInput {

    static func urlPathProvider(_ value: UpdateFlowMediaStreamInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let mediaStreamName = value.mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

extension UpdateFlowOutputInput {

    static func urlPathProvider(_ value: UpdateFlowOutputInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let outputArn = value.outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

extension UpdateFlowSourceInput {

    static func urlPathProvider(_ value: UpdateFlowSourceInput) -> Swift.String? {
        guard let flowArn = value.flowArn else {
            return nil
        }
        guard let sourceArn = value.sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

extension UpdateGatewayInstanceInput {

    static func urlPathProvider(_ value: UpdateGatewayInstanceInput) -> Swift.String? {
        guard let gatewayInstanceArn = value.gatewayInstanceArn else {
            return nil
        }
        return "/v1/gateway-instances/\(gatewayInstanceArn.urlPercentEncoding())"
    }
}

extension AddBridgeOutputsInput {

    static func write(value: AddBridgeOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddBridgeOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddBridgeSourcesInput {

    static func write(value: AddBridgeSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.AddBridgeSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowMediaStreamsInput {

    static func write(value: AddFlowMediaStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mediaStreams"].writeList(value.mediaStreams, memberWritingClosure: MediaConnectClientTypes.AddMediaStreamRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowOutputsInput {

    static func write(value: AddFlowOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowSourcesInput {

    static func write(value: AddFlowSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.SetSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddFlowVpcInterfacesInput {

    static func write(value: AddFlowVpcInterfacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcInterfaces"].writeList(value.vpcInterfaces, memberWritingClosure: MediaConnectClientTypes.VpcInterfaceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBridgeInput {

    static func write(value: CreateBridgeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressGatewayBridge"].write(value.egressGatewayBridge, with: MediaConnectClientTypes.AddEgressGatewayBridgeRequest.write(value:to:))
        try writer["ingressGatewayBridge"].write(value.ingressGatewayBridge, with: MediaConnectClientTypes.AddIngressGatewayBridgeRequest.write(value:to:))
        try writer["name"].write(value.name)
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddBridgeOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["placementArn"].write(value.placementArn)
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.FailoverConfig.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.AddBridgeSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFlowInput {

    static func write(value: CreateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["entitlements"].writeList(value.entitlements, memberWritingClosure: MediaConnectClientTypes.GrantEntitlementRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maintenance"].write(value.maintenance, with: MediaConnectClientTypes.AddMaintenance.write(value:to:))
        try writer["mediaStreams"].writeList(value.mediaStreams, memberWritingClosure: MediaConnectClientTypes.AddMediaStreamRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: MediaConnectClientTypes.AddOutputRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source, with: MediaConnectClientTypes.SetSourceRequest.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.FailoverConfig.write(value:to:))
        try writer["sourceMonitoringConfig"].write(value.sourceMonitoringConfig, with: MediaConnectClientTypes.MonitoringConfig.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: MediaConnectClientTypes.SetSourceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcInterfaces"].writeList(value.vpcInterfaces, memberWritingClosure: MediaConnectClientTypes.VpcInterfaceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressCidrBlocks"].writeList(value.egressCidrBlocks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["networks"].writeList(value.networks, memberWritingClosure: MediaConnectClientTypes.GatewayNetwork.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GrantFlowEntitlementsInput {

    static func write(value: GrantFlowEntitlementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entitlements"].writeList(value.entitlements, memberWritingClosure: MediaConnectClientTypes.GrantEntitlementRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PurchaseOfferingInput {

    static func write(value: PurchaseOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reservationName"].write(value.reservationName)
        try writer["start"].write(value.start)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateBridgeInput {

    static func write(value: UpdateBridgeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressGatewayBridge"].write(value.egressGatewayBridge, with: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest.write(value:to:))
        try writer["ingressGatewayBridge"].write(value.ingressGatewayBridge, with: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.UpdateFailoverConfig.write(value:to:))
    }
}

extension UpdateBridgeOutputInput {

    static func write(value: UpdateBridgeOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkOutput"].write(value.networkOutput, with: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest.write(value:to:))
    }
}

extension UpdateBridgeSourceInput {

    static func write(value: UpdateBridgeSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowSource"].write(value.flowSource, with: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest.write(value:to:))
        try writer["networkSource"].write(value.networkSource, with: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest.write(value:to:))
    }
}

extension UpdateBridgeStateInput {

    static func write(value: UpdateBridgeStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredState"].write(value.desiredState)
    }
}

extension UpdateFlowInput {

    static func write(value: UpdateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maintenance"].write(value.maintenance, with: MediaConnectClientTypes.UpdateMaintenance.write(value:to:))
        try writer["sourceFailoverConfig"].write(value.sourceFailoverConfig, with: MediaConnectClientTypes.UpdateFailoverConfig.write(value:to:))
        try writer["sourceMonitoringConfig"].write(value.sourceMonitoringConfig, with: MediaConnectClientTypes.MonitoringConfig.write(value:to:))
    }
}

extension UpdateFlowEntitlementInput {

    static func write(value: UpdateFlowEntitlementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["entitlementStatus"].write(value.entitlementStatus)
        try writer["subscribers"].writeList(value.subscribers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFlowMediaStreamInput {

    static func write(value: UpdateFlowMediaStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: MediaConnectClientTypes.MediaStreamAttributesRequest.write(value:to:))
        try writer["clockRate"].write(value.clockRate)
        try writer["description"].write(value.description)
        try writer["mediaStreamType"].write(value.mediaStreamType)
        try writer["videoFormat"].write(value.videoFormat)
    }
}

extension UpdateFlowOutputInput {

    static func write(value: UpdateFlowOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrAllowList"].writeList(value.cidrAllowList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["destination"].write(value.destination)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["maxLatency"].write(value.maxLatency)
        try writer["mediaStreamOutputConfigurations"].writeList(value.mediaStreamOutputConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["outputStatus"].write(value.outputStatus)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["remoteId"].write(value.remoteId)
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["smoothingLatency"].write(value.smoothingLatency)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension UpdateFlowSourceInput {

    static func write(value: UpdateFlowSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryption"].write(value.decryption, with: MediaConnectClientTypes.UpdateEncryption.write(value:to:))
        try writer["description"].write(value.description)
        try writer["entitlementArn"].write(value.entitlementArn)
        try writer["gatewayBridgeSource"].write(value.gatewayBridgeSource, with: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest.write(value:to:))
        try writer["ingestPort"].write(value.ingestPort)
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxLatency"].write(value.maxLatency)
        try writer["maxSyncBuffer"].write(value.maxSyncBuffer)
        try writer["mediaStreamSourceConfigurations"].writeList(value.mediaStreamSourceConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["protocol"].write(value.`protocol`)
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["sourceListenerAddress"].write(value.sourceListenerAddress)
        try writer["sourceListenerPort"].write(value.sourceListenerPort)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
        try writer["whitelistCidr"].write(value.whitelistCidr)
    }
}

extension UpdateGatewayInstanceInput {

    static func write(value: UpdateGatewayInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgePlacement"].write(value.bridgePlacement)
    }
}

extension AddBridgeOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddBridgeOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddBridgeOutputsOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddBridgeSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddBridgeSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddBridgeSourcesOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowMediaStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowMediaStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowMediaStreamsOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStreams = try reader["mediaStreams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStream.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowOutputsOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Output.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowSourcesOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AddFlowVpcInterfacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFlowVpcInterfacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddFlowVpcInterfacesOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.vpcInterfaces = try reader["vpcInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.VpcInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension CreateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        return value
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.gateway = try reader["gateway"].readIfPresent(with: MediaConnectClientTypes.Gateway.read(from:))
        return value
    }
}

extension DeleteBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBridgeOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        return value
    }
}

extension DeleteFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGatewayOutput()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent()
        return value
    }
}

extension DeregisterGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterGatewayInstanceOutput()
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent()
        value.instanceState = try reader["instanceState"].readIfPresent()
        return value
    }
}

extension DescribeBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension DescribeFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        value.messages = try reader["messages"].readIfPresent(with: MediaConnectClientTypes.Messages.read(from:))
        return value
    }
}

extension DescribeFlowSourceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowSourceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowSourceMetadataOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.transportMediaInfo = try reader["transportMediaInfo"].readIfPresent(with: MediaConnectClientTypes.TransportMediaInfo.read(from:))
        return value
    }
}

extension DescribeFlowSourceThumbnailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowSourceThumbnailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowSourceThumbnailOutput()
        value.thumbnailDetails = try reader["thumbnailDetails"].readIfPresent(with: MediaConnectClientTypes.ThumbnailDetails.read(from:))
        return value
    }
}

extension DescribeGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayOutput()
        value.gateway = try reader["gateway"].readIfPresent(with: MediaConnectClientTypes.Gateway.read(from:))
        return value
    }
}

extension DescribeGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayInstanceOutput()
        value.gatewayInstance = try reader["gatewayInstance"].readIfPresent(with: MediaConnectClientTypes.GatewayInstance.read(from:))
        return value
    }
}

extension DescribeOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOfferingOutput()
        value.offering = try reader["offering"].readIfPresent(with: MediaConnectClientTypes.Offering.read(from:))
        return value
    }
}

extension DescribeReservationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservationOutput()
        value.reservation = try reader["reservation"].readIfPresent(with: MediaConnectClientTypes.Reservation.read(from:))
        return value
    }
}

extension GrantFlowEntitlementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GrantFlowEntitlementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GrantFlowEntitlementsOutput()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension ListBridgesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBridgesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBridgesOutput()
        value.bridges = try reader["bridges"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedBridge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEntitlementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitlementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntitlementsOutput()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedEntitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowsOutput()
        value.flows = try reader["flows"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedFlow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewayInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewayInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewayInstancesOutput()
        value.instances = try reader["instances"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedGatewayInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["gateways"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.ListedGateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOfferingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOfferingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOfferingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.offerings = try reader["offerings"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Offering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListReservationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReservationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReservationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.reservations = try reader["reservations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Reservation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PurchaseOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PurchaseOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PurchaseOfferingOutput()
        value.reservation = try reader["reservation"].readIfPresent(with: MediaConnectClientTypes.Reservation.read(from:))
        return value
    }
}

extension RemoveBridgeOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveBridgeOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveBridgeOutputOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.outputName = try reader["outputName"].readIfPresent()
        return value
    }
}

extension RemoveBridgeSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveBridgeSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveBridgeSourceOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.sourceName = try reader["sourceName"].readIfPresent()
        return value
    }
}

extension RemoveFlowMediaStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowMediaStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowMediaStreamOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent()
        return value
    }
}

extension RemoveFlowOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowOutputOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.outputArn = try reader["outputArn"].readIfPresent()
        return value
    }
}

extension RemoveFlowSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowSourceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.sourceArn = try reader["sourceArn"].readIfPresent()
        return value
    }
}

extension RemoveFlowVpcInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFlowVpcInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveFlowVpcInterfaceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.nonDeletedNetworkInterfaceIds = try reader["nonDeletedNetworkInterfaceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        return value
    }
}

extension RevokeFlowEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeFlowEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RevokeFlowEntitlementOutput()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension StartFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension StopFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeOutput()
        value.bridge = try reader["bridge"].readIfPresent(with: MediaConnectClientTypes.Bridge.read(from:))
        return value
    }
}

extension UpdateBridgeOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeOutputOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: MediaConnectClientTypes.BridgeOutput.read(from:))
        return value
    }
}

extension UpdateBridgeSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeSourceOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.BridgeSource.read(from:))
        return value
    }
}

extension UpdateBridgeStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBridgeStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBridgeStateOutput()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.desiredState = try reader["desiredState"].readIfPresent()
        return value
    }
}

extension UpdateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: MediaConnectClientTypes.Flow.read(from:))
        return value
    }
}

extension UpdateFlowEntitlementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowEntitlementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowEntitlementOutput()
        value.entitlement = try reader["entitlement"].readIfPresent(with: MediaConnectClientTypes.Entitlement.read(from:))
        value.flowArn = try reader["flowArn"].readIfPresent()
        return value
    }
}

extension UpdateFlowMediaStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowMediaStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowMediaStreamOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.mediaStream = try reader["mediaStream"].readIfPresent(with: MediaConnectClientTypes.MediaStream.read(from:))
        return value
    }
}

extension UpdateFlowOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutputOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: MediaConnectClientTypes.Output.read(from:))
        return value
    }
}

extension UpdateFlowSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowSourceOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.Source.read(from:))
        return value
    }
}

extension UpdateGatewayInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayInstanceOutput()
        value.bridgePlacement = try reader["bridgePlacement"].readIfPresent()
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent()
        return value
    }
}

enum AddBridgeOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddBridgeSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowMediaStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AddFlowOutputs420Exception": return try AddFlowOutputs420Exception.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddFlowVpcInterfacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CreateBridge420Exception": return try CreateBridge420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CreateFlow420Exception": return try CreateFlow420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CreateGateway420Exception": return try CreateGateway420Exception.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowSourceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowSourceThumbnailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GrantFlowEntitlementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "GrantFlowEntitlements420Exception": return try GrantFlowEntitlements420Exception.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBridgesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitlementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewayInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOfferingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReservationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PurchaseOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveBridgeOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveBridgeSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowMediaStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFlowVpcInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeFlowEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBridgeStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowEntitlementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowMediaStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AddFlowOutputs420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AddFlowOutputs420Exception {
        let reader = baseError.errorBodyReader
        var value = AddFlowOutputs420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateBridge420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateBridge420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateBridge420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateFlow420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateFlow420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateFlow420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreateGateway420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CreateGateway420Exception {
        let reader = baseError.errorBodyReader
        var value = CreateGateway420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GrantFlowEntitlements420Exception {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GrantFlowEntitlements420Exception {
        let reader = baseError.errorBodyReader
        var value = GrantFlowEntitlements420Exception()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MediaConnectClientTypes.BridgeOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeOutput()
        value.flowOutput = try reader["flowOutput"].readIfPresent(with: MediaConnectClientTypes.BridgeFlowOutput.read(from:))
        value.networkOutput = try reader["networkOutput"].readIfPresent(with: MediaConnectClientTypes.BridgeNetworkOutput.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.BridgeNetworkOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeNetworkOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeNetworkOutput()
        value.ipAddress = try reader["ipAddress"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.ttl = try reader["ttl"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.BridgeFlowOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeFlowOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.flowSourceArn = try reader["flowSourceArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.BridgeSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeSource()
        value.flowSource = try reader["flowSource"].readIfPresent(with: MediaConnectClientTypes.BridgeFlowSource.read(from:))
        value.networkSource = try reader["networkSource"].readIfPresent(with: MediaConnectClientTypes.BridgeNetworkSource.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.BridgeNetworkSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeNetworkSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeNetworkSource()
        value.multicastIp = try reader["multicastIp"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.BridgeFlowSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.BridgeFlowSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.BridgeFlowSource()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.flowVpcInterfaceAttachment = try reader["flowVpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputArn = try reader["outputArn"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.VpcInterfaceAttachment {

    static func write(value: MediaConnectClientTypes.VpcInterfaceAttachment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VpcInterfaceAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VpcInterfaceAttachment()
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStream {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStream()
        value.attributes = try reader["attributes"].readIfPresent(with: MediaConnectClientTypes.MediaStreamAttributes.read(from:))
        value.clockRate = try reader["clockRate"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.fmt = try reader["fmt"].readIfPresent() ?? 0
        value.mediaStreamId = try reader["mediaStreamId"].readIfPresent() ?? 0
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        value.mediaStreamType = try reader["mediaStreamType"].readIfPresent() ?? .sdkUnknown("")
        value.videoFormat = try reader["videoFormat"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamAttributes()
        value.fmtp = try reader["fmtp"].readIfPresent(with: MediaConnectClientTypes.Fmtp.read(from:))
        value.lang = try reader["lang"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Fmtp {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Fmtp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Fmtp()
        value.channelOrder = try reader["channelOrder"].readIfPresent()
        value.colorimetry = try reader["colorimetry"].readIfPresent()
        value.exactFramerate = try reader["exactFramerate"].readIfPresent()
        value.par = try reader["par"].readIfPresent()
        value.range = try reader["range"].readIfPresent()
        value.scanMode = try reader["scanMode"].readIfPresent()
        value.tcs = try reader["tcs"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Output {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Output {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Output()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.listenerAddress = try reader["listenerAddress"].readIfPresent()
        value.mediaLiveInputArn = try reader["mediaLiveInputArn"].readIfPresent()
        value.mediaStreamOutputConfigurations = try reader["mediaStreamOutputConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStreamOutputConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputArn = try reader["outputArn"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent()
        value.transport = try reader["transport"].readIfPresent(with: MediaConnectClientTypes.Transport.read(from:))
        value.vpcInterfaceAttachment = try reader["vpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        value.bridgeArn = try reader["bridgeArn"].readIfPresent()
        value.bridgePorts = try reader["bridgePorts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputStatus = try reader["outputStatus"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Transport {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Transport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Transport()
        value.cidrAllowList = try reader["cidrAllowList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxBitrate = try reader["maxBitrate"].readIfPresent()
        value.maxLatency = try reader["maxLatency"].readIfPresent()
        value.maxSyncBuffer = try reader["maxSyncBuffer"].readIfPresent()
        value.minLatency = try reader["minLatency"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.remoteId = try reader["remoteId"].readIfPresent()
        value.senderControlPort = try reader["senderControlPort"].readIfPresent()
        value.senderIpAddress = try reader["senderIpAddress"].readIfPresent()
        value.smoothingLatency = try reader["smoothingLatency"].readIfPresent()
        value.sourceListenerAddress = try reader["sourceListenerAddress"].readIfPresent()
        value.sourceListenerPort = try reader["sourceListenerPort"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamOutputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamOutputConfiguration()
        value.destinationConfigurations = try reader["destinationConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.DestinationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.encodingName = try reader["encodingName"].readIfPresent() ?? .sdkUnknown("")
        value.encodingParameters = try reader["encodingParameters"].readIfPresent(with: MediaConnectClientTypes.EncodingParameters.read(from:))
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.EncodingParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.EncodingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.EncodingParameters()
        value.compressionFactor = try reader["compressionFactor"].readIfPresent() ?? 0.0
        value.encoderProfile = try reader["encoderProfile"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.DestinationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.DestinationConfiguration()
        value.destinationIp = try reader["destinationIp"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent() ?? 0
        value.interface = try reader["interface"].readIfPresent(with: MediaConnectClientTypes.Interface.read(from:))
        value.outboundIp = try reader["outboundIp"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Interface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Interface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Interface()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Encryption {

    static func write(value: MediaConnectClientTypes.Encryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithm"].write(value.algorithm)
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["deviceId"].write(value.deviceId)
        try writer["keyType"].write(value.keyType)
        try writer["region"].write(value.region)
        try writer["resourceId"].write(value.resourceId)
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Encryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Encryption()
        value.algorithm = try reader["algorithm"].readIfPresent()
        value.constantInitializationVector = try reader["constantInitializationVector"].readIfPresent()
        value.deviceId = try reader["deviceId"].readIfPresent()
        value.keyType = try reader["keyType"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.secretArn = try reader["secretArn"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Source {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Source()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.decryption = try reader["decryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent()
        value.ingestIp = try reader["ingestIp"].readIfPresent()
        value.ingestPort = try reader["ingestPort"].readIfPresent()
        value.mediaStreamSourceConfigurations = try reader["mediaStreamSourceConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStreamSourceConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.senderControlPort = try reader["senderControlPort"].readIfPresent()
        value.senderIpAddress = try reader["senderIpAddress"].readIfPresent()
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.transport = try reader["transport"].readIfPresent(with: MediaConnectClientTypes.Transport.read(from:))
        value.vpcInterfaceName = try reader["vpcInterfaceName"].readIfPresent()
        value.whitelistCidr = try reader["whitelistCidr"].readIfPresent()
        value.gatewayBridgeSource = try reader["gatewayBridgeSource"].readIfPresent(with: MediaConnectClientTypes.GatewayBridgeSource.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.GatewayBridgeSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayBridgeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayBridgeSource()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.vpcInterfaceAttachment = try reader["vpcInterfaceAttachment"].readIfPresent(with: MediaConnectClientTypes.VpcInterfaceAttachment.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MediaStreamSourceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MediaStreamSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MediaStreamSourceConfiguration()
        value.encodingName = try reader["encodingName"].readIfPresent() ?? .sdkUnknown("")
        value.inputConfigurations = try reader["inputConfigurations"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.InputConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mediaStreamName = try reader["mediaStreamName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.InputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.InputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.InputConfiguration()
        value.inputIp = try reader["inputIp"].readIfPresent() ?? ""
        value.inputPort = try reader["inputPort"].readIfPresent() ?? 0
        value.interface = try reader["interface"].readIfPresent(with: MediaConnectClientTypes.Interface.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.VpcInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.VpcInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.VpcInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networkInterfaceIds = try reader["networkInterfaceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.networkInterfaceType = try reader["networkInterfaceType"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetId = try reader["subnetId"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Bridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Bridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Bridge()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.bridgeMessages = try reader["bridgeMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bridgeState = try reader["bridgeState"].readIfPresent() ?? .sdkUnknown("")
        value.egressGatewayBridge = try reader["egressGatewayBridge"].readIfPresent(with: MediaConnectClientTypes.EgressGatewayBridge.read(from:))
        value.ingressGatewayBridge = try reader["ingressGatewayBridge"].readIfPresent(with: MediaConnectClientTypes.IngressGatewayBridge.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.placementArn = try reader["placementArn"].readIfPresent() ?? ""
        value.sourceFailoverConfig = try reader["sourceFailoverConfig"].readIfPresent(with: MediaConnectClientTypes.FailoverConfig.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.BridgeSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaConnectClientTypes.FailoverConfig {

    static func write(value: MediaConnectClientTypes.FailoverConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failoverMode"].write(value.failoverMode)
        try writer["recoveryWindow"].write(value.recoveryWindow)
        try writer["sourcePriority"].write(value.sourcePriority, with: MediaConnectClientTypes.SourcePriority.write(value:to:))
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FailoverConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FailoverConfig()
        value.failoverMode = try reader["failoverMode"].readIfPresent()
        value.recoveryWindow = try reader["recoveryWindow"].readIfPresent()
        value.sourcePriority = try reader["sourcePriority"].readIfPresent(with: MediaConnectClientTypes.SourcePriority.read(from:))
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.SourcePriority {

    static func write(value: MediaConnectClientTypes.SourcePriority?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["primarySource"].write(value.primarySource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.SourcePriority {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.SourcePriority()
        value.primarySource = try reader["primarySource"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.IngressGatewayBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.IngressGatewayBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.IngressGatewayBridge()
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.maxBitrate = try reader["maxBitrate"].readIfPresent() ?? 0
        value.maxOutputs = try reader["maxOutputs"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.EgressGatewayBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.EgressGatewayBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.EgressGatewayBridge()
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.maxBitrate = try reader["maxBitrate"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.MessageDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MessageDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MessageDetail()
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Flow {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Flow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Flow()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.egressIp = try reader["egressIp"].readIfPresent()
        value.entitlements = try reader["entitlements"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.mediaStreams = try reader["mediaStreams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MediaStream.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Output.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.source = try reader["source"].readIfPresent(with: MediaConnectClientTypes.Source.read(from:))
        value.sourceFailoverConfig = try reader["sourceFailoverConfig"].readIfPresent(with: MediaConnectClientTypes.FailoverConfig.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.vpcInterfaces = try reader["vpcInterfaces"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.VpcInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maintenance = try reader["maintenance"].readIfPresent(with: MediaConnectClientTypes.Maintenance.read(from:))
        value.sourceMonitoringConfig = try reader["sourceMonitoringConfig"].readIfPresent(with: MediaConnectClientTypes.MonitoringConfig.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.MonitoringConfig {

    static func write(value: MediaConnectClientTypes.MonitoringConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thumbnailState"].write(value.thumbnailState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.MonitoringConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.MonitoringConfig()
        value.thumbnailState = try reader["thumbnailState"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Maintenance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Maintenance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Maintenance()
        value.maintenanceDay = try reader["maintenanceDay"].readIfPresent()
        value.maintenanceDeadline = try reader["maintenanceDeadline"].readIfPresent()
        value.maintenanceScheduledDate = try reader["maintenanceScheduledDate"].readIfPresent()
        value.maintenanceStartHour = try reader["maintenanceStartHour"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.Entitlement {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Entitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Entitlement()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaConnectClientTypes.Encryption.read(from:))
        value.entitlementArn = try reader["entitlementArn"].readIfPresent() ?? ""
        value.entitlementStatus = try reader["entitlementStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.subscribers = try reader["subscribers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.Gateway {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Gateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Gateway()
        value.egressCidrBlocks = try reader["egressCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayMessages = try reader["gatewayMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayState = try reader["gatewayState"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.networks = try reader["networks"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.GatewayNetwork.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.GatewayNetwork {

    static func write(value: MediaConnectClientTypes.GatewayNetwork?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrBlock"].write(value.cidrBlock)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayNetwork()
        value.cidrBlock = try reader["cidrBlock"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.Messages {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Messages {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Messages()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportMediaInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportMediaInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportMediaInfo()
        value.programs = try reader["programs"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.TransportStreamProgram.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportStreamProgram {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportStreamProgram {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportStreamProgram()
        value.pcrPid = try reader["pcrPid"].readIfPresent() ?? 0
        value.programName = try reader["programName"].readIfPresent()
        value.programNumber = try reader["programNumber"].readIfPresent() ?? 0
        value.programPid = try reader["programPid"].readIfPresent() ?? 0
        value.streams = try reader["streams"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.TransportStream.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MediaConnectClientTypes.TransportStream {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.TransportStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.TransportStream()
        value.channels = try reader["channels"].readIfPresent()
        value.codec = try reader["codec"].readIfPresent()
        value.frameRate = try reader["frameRate"].readIfPresent()
        value.frameResolution = try reader["frameResolution"].readIfPresent(with: MediaConnectClientTypes.FrameResolution.read(from:))
        value.pid = try reader["pid"].readIfPresent() ?? 0
        value.sampleRate = try reader["sampleRate"].readIfPresent()
        value.sampleSize = try reader["sampleSize"].readIfPresent()
        value.streamType = try reader["streamType"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.FrameResolution {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.FrameResolution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.FrameResolution()
        value.frameHeight = try reader["frameHeight"].readIfPresent() ?? 0
        value.frameWidth = try reader["frameWidth"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.ThumbnailDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ThumbnailDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ThumbnailDetails()
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.thumbnail = try reader["thumbnail"].readIfPresent()
        value.thumbnailMessages = try reader["thumbnailMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timecode = try reader["timecode"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MediaConnectClientTypes.GatewayInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.GatewayInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.GatewayInstance()
        value.bridgePlacement = try reader["bridgePlacement"].readIfPresent() ?? .sdkUnknown("")
        value.connectionStatus = try reader["connectionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent() ?? ""
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.instanceMessages = try reader["instanceMessages"].readListIfPresent(memberReadingClosure: MediaConnectClientTypes.MessageDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceState = try reader["instanceState"].readIfPresent() ?? .sdkUnknown("")
        value.runningBridgeCount = try reader["runningBridgeCount"].readIfPresent() ?? 0
        return value
    }
}

extension MediaConnectClientTypes.Offering {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Offering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Offering()
        value.currencyCode = try reader["currencyCode"].readIfPresent() ?? ""
        value.duration = try reader["duration"].readIfPresent() ?? 0
        value.durationUnits = try reader["durationUnits"].readIfPresent() ?? .sdkUnknown("")
        value.offeringArn = try reader["offeringArn"].readIfPresent() ?? ""
        value.offeringDescription = try reader["offeringDescription"].readIfPresent() ?? ""
        value.pricePerUnit = try reader["pricePerUnit"].readIfPresent() ?? ""
        value.priceUnits = try reader["priceUnits"].readIfPresent() ?? .sdkUnknown("")
        value.resourceSpecification = try reader["resourceSpecification"].readIfPresent(with: MediaConnectClientTypes.ResourceSpecification.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.ResourceSpecification {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ResourceSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ResourceSpecification()
        value.reservedBitrate = try reader["reservedBitrate"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaConnectClientTypes.Reservation {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.Reservation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.Reservation()
        value.currencyCode = try reader["currencyCode"].readIfPresent() ?? ""
        value.duration = try reader["duration"].readIfPresent() ?? 0
        value.durationUnits = try reader["durationUnits"].readIfPresent() ?? .sdkUnknown("")
        value.end = try reader["end"].readIfPresent() ?? ""
        value.offeringArn = try reader["offeringArn"].readIfPresent() ?? ""
        value.offeringDescription = try reader["offeringDescription"].readIfPresent() ?? ""
        value.pricePerUnit = try reader["pricePerUnit"].readIfPresent() ?? ""
        value.priceUnits = try reader["priceUnits"].readIfPresent() ?? .sdkUnknown("")
        value.reservationArn = try reader["reservationArn"].readIfPresent() ?? ""
        value.reservationName = try reader["reservationName"].readIfPresent() ?? ""
        value.reservationState = try reader["reservationState"].readIfPresent() ?? .sdkUnknown("")
        value.resourceSpecification = try reader["resourceSpecification"].readIfPresent(with: MediaConnectClientTypes.ResourceSpecification.read(from:))
        value.start = try reader["start"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedBridge {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedBridge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedBridge()
        value.bridgeArn = try reader["bridgeArn"].readIfPresent() ?? ""
        value.bridgeState = try reader["bridgeState"].readIfPresent() ?? .sdkUnknown("")
        value.bridgeType = try reader["bridgeType"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.placementArn = try reader["placementArn"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedEntitlement {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedEntitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedEntitlement()
        value.dataTransferSubscriberFeePercent = try reader["dataTransferSubscriberFeePercent"].readIfPresent()
        value.entitlementArn = try reader["entitlementArn"].readIfPresent() ?? ""
        value.entitlementName = try reader["entitlementName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.ListedFlow {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedFlow()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.flowArn = try reader["flowArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.maintenance = try reader["maintenance"].readIfPresent(with: MediaConnectClientTypes.Maintenance.read(from:))
        return value
    }
}

extension MediaConnectClientTypes.ListedGatewayInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedGatewayInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedGatewayInstance()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayInstanceArn = try reader["gatewayInstanceArn"].readIfPresent() ?? ""
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.instanceState = try reader["instanceState"].readIfPresent()
        return value
    }
}

extension MediaConnectClientTypes.ListedGateway {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaConnectClientTypes.ListedGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaConnectClientTypes.ListedGateway()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayState = try reader["gatewayState"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension MediaConnectClientTypes.AddBridgeOutputRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkOutput"].write(value.networkOutput, with: MediaConnectClientTypes.AddBridgeNetworkOutputRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.AddBridgeNetworkOutputRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeNetworkOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
        try writer["name"].write(value.name)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["ttl"].write(value.ttl)
    }
}

extension MediaConnectClientTypes.AddBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowSource"].write(value.flowSource, with: MediaConnectClientTypes.AddBridgeFlowSourceRequest.write(value:to:))
        try writer["networkSource"].write(value.networkSource, with: MediaConnectClientTypes.AddBridgeNetworkSourceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.AddBridgeNetworkSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeNetworkSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["multicastIp"].write(value.multicastIp)
        try writer["name"].write(value.name)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }
}

extension MediaConnectClientTypes.AddBridgeFlowSourceRequest {

    static func write(value: MediaConnectClientTypes.AddBridgeFlowSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowArn"].write(value.flowArn)
        try writer["flowVpcInterfaceAttachment"].write(value.flowVpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension MediaConnectClientTypes.AddMediaStreamRequest {

    static func write(value: MediaConnectClientTypes.AddMediaStreamRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: MediaConnectClientTypes.MediaStreamAttributesRequest.write(value:to:))
        try writer["clockRate"].write(value.clockRate)
        try writer["description"].write(value.description)
        try writer["mediaStreamId"].write(value.mediaStreamId)
        try writer["mediaStreamName"].write(value.mediaStreamName)
        try writer["mediaStreamType"].write(value.mediaStreamType)
        try writer["videoFormat"].write(value.videoFormat)
    }
}

extension MediaConnectClientTypes.MediaStreamAttributesRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamAttributesRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fmtp"].write(value.fmtp, with: MediaConnectClientTypes.FmtpRequest.write(value:to:))
        try writer["lang"].write(value.lang)
    }
}

extension MediaConnectClientTypes.FmtpRequest {

    static func write(value: MediaConnectClientTypes.FmtpRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelOrder"].write(value.channelOrder)
        try writer["colorimetry"].write(value.colorimetry)
        try writer["exactFramerate"].write(value.exactFramerate)
        try writer["par"].write(value.par)
        try writer["range"].write(value.range)
        try writer["scanMode"].write(value.scanMode)
        try writer["tcs"].write(value.tcs)
    }
}

extension MediaConnectClientTypes.AddOutputRequest {

    static func write(value: MediaConnectClientTypes.AddOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrAllowList"].writeList(value.cidrAllowList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["destination"].write(value.destination)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["maxLatency"].write(value.maxLatency)
        try writer["mediaStreamOutputConfigurations"].writeList(value.mediaStreamOutputConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["name"].write(value.name)
        try writer["outputStatus"].write(value.outputStatus)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["remoteId"].write(value.remoteId)
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["smoothingLatency"].write(value.smoothingLatency)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.MediaStreamOutputConfigurationRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfigurations"].writeList(value.destinationConfigurations, memberWritingClosure: MediaConnectClientTypes.DestinationConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["encodingName"].write(value.encodingName)
        try writer["encodingParameters"].write(value.encodingParameters, with: MediaConnectClientTypes.EncodingParametersRequest.write(value:to:))
        try writer["mediaStreamName"].write(value.mediaStreamName)
    }
}

extension MediaConnectClientTypes.EncodingParametersRequest {

    static func write(value: MediaConnectClientTypes.EncodingParametersRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compressionFactor"].write(value.compressionFactor)
        try writer["encoderProfile"].write(value.encoderProfile)
    }
}

extension MediaConnectClientTypes.DestinationConfigurationRequest {

    static func write(value: MediaConnectClientTypes.DestinationConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationIp"].write(value.destinationIp)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["interface"].write(value.interface, with: MediaConnectClientTypes.InterfaceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.InterfaceRequest {

    static func write(value: MediaConnectClientTypes.InterfaceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension MediaConnectClientTypes.SetSourceRequest {

    static func write(value: MediaConnectClientTypes.SetSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decryption"].write(value.decryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["description"].write(value.description)
        try writer["entitlementArn"].write(value.entitlementArn)
        try writer["gatewayBridgeSource"].write(value.gatewayBridgeSource, with: MediaConnectClientTypes.SetGatewayBridgeSourceRequest.write(value:to:))
        try writer["ingestPort"].write(value.ingestPort)
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxLatency"].write(value.maxLatency)
        try writer["maxSyncBuffer"].write(value.maxSyncBuffer)
        try writer["mediaStreamSourceConfigurations"].writeList(value.mediaStreamSourceConfigurations, memberWritingClosure: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["minLatency"].write(value.minLatency)
        try writer["name"].write(value.name)
        try writer["protocol"].write(value.`protocol`)
        try writer["senderControlPort"].write(value.senderControlPort)
        try writer["senderIpAddress"].write(value.senderIpAddress)
        try writer["sourceListenerAddress"].write(value.sourceListenerAddress)
        try writer["sourceListenerPort"].write(value.sourceListenerPort)
        try writer["streamId"].write(value.streamId)
        try writer["vpcInterfaceName"].write(value.vpcInterfaceName)
        try writer["whitelistCidr"].write(value.whitelistCidr)
    }
}

extension MediaConnectClientTypes.SetGatewayBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.SetGatewayBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgeArn"].write(value.bridgeArn)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.MediaStreamSourceConfigurationRequest {

    static func write(value: MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encodingName"].write(value.encodingName)
        try writer["inputConfigurations"].writeList(value.inputConfigurations, memberWritingClosure: MediaConnectClientTypes.InputConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mediaStreamName"].write(value.mediaStreamName)
    }
}

extension MediaConnectClientTypes.InputConfigurationRequest {

    static func write(value: MediaConnectClientTypes.InputConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputPort"].write(value.inputPort)
        try writer["interface"].write(value.interface, with: MediaConnectClientTypes.InterfaceRequest.write(value:to:))
    }
}

extension MediaConnectClientTypes.VpcInterfaceRequest {

    static func write(value: MediaConnectClientTypes.VpcInterfaceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["networkInterfaceType"].write(value.networkInterfaceType)
        try writer["roleArn"].write(value.roleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetId"].write(value.subnetId)
    }
}

extension MediaConnectClientTypes.AddEgressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.AddEgressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
    }
}

extension MediaConnectClientTypes.AddIngressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.AddIngressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxOutputs"].write(value.maxOutputs)
    }
}

extension MediaConnectClientTypes.GrantEntitlementRequest {

    static func write(value: MediaConnectClientTypes.GrantEntitlementRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTransferSubscriberFeePercent"].write(value.dataTransferSubscriberFeePercent)
        try writer["description"].write(value.description)
        try writer["encryption"].write(value.encryption, with: MediaConnectClientTypes.Encryption.write(value:to:))
        try writer["entitlementStatus"].write(value.entitlementStatus)
        try writer["name"].write(value.name)
        try writer["subscribers"].writeList(value.subscribers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MediaConnectClientTypes.AddMaintenance {

    static func write(value: MediaConnectClientTypes.AddMaintenance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maintenanceDay"].write(value.maintenanceDay)
        try writer["maintenanceStartHour"].write(value.maintenanceStartHour)
    }
}

extension MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.UpdateEgressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
    }
}

extension MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest {

    static func write(value: MediaConnectClientTypes.UpdateIngressGatewayBridgeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBitrate"].write(value.maxBitrate)
        try writer["maxOutputs"].write(value.maxOutputs)
    }
}

extension MediaConnectClientTypes.UpdateFailoverConfig {

    static func write(value: MediaConnectClientTypes.UpdateFailoverConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failoverMode"].write(value.failoverMode)
        try writer["recoveryWindow"].write(value.recoveryWindow)
        try writer["sourcePriority"].write(value.sourcePriority, with: MediaConnectClientTypes.SourcePriority.write(value:to:))
        try writer["state"].write(value.state)
    }
}

extension MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeNetworkOutputRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["ttl"].write(value.ttl)
    }
}

extension MediaConnectClientTypes.UpdateBridgeFlowSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeFlowSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowArn"].write(value.flowArn)
        try writer["flowVpcInterfaceAttachment"].write(value.flowVpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

extension MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateBridgeNetworkSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["multicastIp"].write(value.multicastIp)
        try writer["networkName"].write(value.networkName)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }
}

extension MediaConnectClientTypes.UpdateMaintenance {

    static func write(value: MediaConnectClientTypes.UpdateMaintenance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maintenanceDay"].write(value.maintenanceDay)
        try writer["maintenanceScheduledDate"].write(value.maintenanceScheduledDate)
        try writer["maintenanceStartHour"].write(value.maintenanceStartHour)
    }
}

extension MediaConnectClientTypes.UpdateEncryption {

    static func write(value: MediaConnectClientTypes.UpdateEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithm"].write(value.algorithm)
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["deviceId"].write(value.deviceId)
        try writer["keyType"].write(value.keyType)
        try writer["region"].write(value.region)
        try writer["resourceId"].write(value.resourceId)
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
        try writer["url"].write(value.url)
    }
}

extension MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest {

    static func write(value: MediaConnectClientTypes.UpdateGatewayBridgeSourceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bridgeArn"].write(value.bridgeArn)
        try writer["vpcInterfaceAttachment"].write(value.vpcInterfaceAttachment, with: MediaConnectClientTypes.VpcInterfaceAttachment.write(value:to:))
    }
}

public enum MediaConnectClientTypes {}
