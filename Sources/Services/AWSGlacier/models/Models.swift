// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads/\(uploadId.urlPercentEncoding())"
    }
}

/// Provides options to abort a multipart upload identified by the upload ID. For information about the underlying REST API, see [Abort Multipart Upload](https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html). For conceptual information, see [Working with Archives in Amazon S3 Glacier](https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html).
public struct AbortMultipartUploadInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The upload ID of the multipart upload to delete.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct AbortMultipartUploadInputBody: Swift.Equatable {
}

extension AbortMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AbortMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AbortMultipartUploadOutputResponse: Swift.Equatable {

    public init () { }
}

extension AbortVaultLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/lock-policy"
    }
}

/// The input values for AbortVaultLock.
public struct AbortVaultLockInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct AbortVaultLockInputBody: Swift.Equatable {
}

extension AbortVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AbortVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AbortVaultLockOutputResponse: Swift.Equatable {

    public init () { }
}

extension GlacierClientTypes {
    public enum ActionCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archiveretrieval
        case inventoryretrieval
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCode] {
            return [
                .archiveretrieval,
                .inventoryretrieval,
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archiveretrieval: return "ArchiveRetrieval"
            case .inventoryretrieval: return "InventoryRetrieval"
            case .select: return "Select"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionCode(rawValue: rawValue) ?? ActionCode.sdkUnknown(rawValue)
        }
    }
}

extension AddTagsToVaultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension AddTagsToVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
            return items
        }
    }
}

extension AddTagsToVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/tags"
    }
}

/// The input values for AddTagsToVault.
public struct AddTagsToVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The tags to add to the vault. Each tag is composed of a key and a value. The value can be an empty string.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.tags = tags
        self.vaultName = vaultName
    }
}

struct AddTagsToVaultInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension AddTagsToVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsToVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToVaultOutputResponse: Swift.Equatable {

    public init () { }
}

extension GlacierClientTypes.CSVInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "Comments"
        case fieldDelimiter = "FieldDelimiter"
        case fileHeaderInfo = "FileHeaderInfo"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = self.comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let fieldDelimiter = self.fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let fileHeaderInfo = self.fileHeaderInfo {
            try encodeContainer.encode(fileHeaderInfo.rawValue, forKey: .fileHeaderInfo)
        }
        if let quoteCharacter = self.quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = self.quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let recordDelimiter = self.recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileHeaderInfoDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.FileHeaderInfo.self, forKey: .fileHeaderInfo)
        fileHeaderInfo = fileHeaderInfoDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the comma-separated value (CSV) file to select from.
    public struct CSVInput: Swift.Equatable {
        /// A single character used to indicate that a row should be ignored when the character is present at the start of that row.
        public var comments: Swift.String?
        /// A value used to separate individual fields from each other within a record.
        public var fieldDelimiter: Swift.String?
        /// Describes the first line of input. Valid values are None, Ignore, and Use.
        public var fileHeaderInfo: GlacierClientTypes.FileHeaderInfo?
        /// A value used as an escape character where the field delimiter is part of the value.
        public var quoteCharacter: Swift.String?
        /// A single character used for escaping the quotation-mark character inside an already escaped value.
        public var quoteEscapeCharacter: Swift.String?
        /// A value used to separate individual records from each other.
        public var recordDelimiter: Swift.String?

        public init (
            comments: Swift.String? = nil,
            fieldDelimiter: Swift.String? = nil,
            fileHeaderInfo: GlacierClientTypes.FileHeaderInfo? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.comments = comments
            self.fieldDelimiter = fieldDelimiter
            self.fileHeaderInfo = fileHeaderInfo
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension GlacierClientTypes.CSVOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldDelimiter = "FieldDelimiter"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case quoteFields = "QuoteFields"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldDelimiter = self.fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let quoteCharacter = self.quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = self.quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let quoteFields = self.quoteFields {
            try encodeContainer.encode(quoteFields.rawValue, forKey: .quoteFields)
        }
        if let recordDelimiter = self.recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quoteFieldsDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.QuoteFields.self, forKey: .quoteFields)
        quoteFields = quoteFieldsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the comma-separated value (CSV) file that the job results are stored in.
    public struct CSVOutput: Swift.Equatable {
        /// A value used to separate individual fields from each other within a record.
        public var fieldDelimiter: Swift.String?
        /// A value used as an escape character where the field delimiter is part of the value.
        public var quoteCharacter: Swift.String?
        /// A single character used for escaping the quotation-mark character inside an already escaped value.
        public var quoteEscapeCharacter: Swift.String?
        /// A value that indicates whether all output fields should be contained within quotation marks.
        public var quoteFields: GlacierClientTypes.QuoteFields?
        /// A value used to separate individual records from each other.
        public var recordDelimiter: Swift.String?

        public init (
            fieldDelimiter: Swift.String? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            quoteFields: GlacierClientTypes.QuoteFields? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.fieldDelimiter = fieldDelimiter
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.quoteFields = quoteFields
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension GlacierClientTypes {
    public enum CannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedread
        case awsexecread
        case bucketownerfullcontrol
        case bucketownerread
        case `private`
        case publicread
        case publicreadwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedACL] {
            return [
                .authenticatedread,
                .awsexecread,
                .bucketownerfullcontrol,
                .bucketownerread,
                .private,
                .publicread,
                .publicreadwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedread: return "authenticated-read"
            case .awsexecread: return "aws-exec-read"
            case .bucketownerfullcontrol: return "bucket-owner-full-control"
            case .bucketownerread: return "bucket-owner-read"
            case .private: return "private"
            case .publicread: return "public-read"
            case .publicreadwrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CannedACL(rawValue: rawValue) ?? CannedACL.sdkUnknown(rawValue)
        }
    }
}

extension CompleteMultipartUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let archiveSize = archiveSize {
            items.add(Header(name: "x-amz-archive-size", value: Swift.String(archiveSize)))
        }
        if let checksum = checksum {
            items.add(Header(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum)))
        }
        return items
    }
}

extension CompleteMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads/\(uploadId.urlPercentEncoding())"
    }
}

/// Provides options to complete a multipart upload operation. This informs Amazon Glacier that all the archive parts have been uploaded and Amazon S3 Glacier (Glacier) can now assemble the archive from the uploaded parts. After assembling and saving the archive to the vault, Glacier returns the URI path of the newly created archive resource.
public struct CompleteMultipartUploadInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The total size, in bytes, of the entire archive. This value should be the sum of all the sizes of the individual parts that you uploaded.
    public var archiveSize: Swift.String?
    /// The SHA256 tree hash of the entire archive. It is the tree hash of SHA256 tree hash of the individual parts. If the value you specify in the request does not match the SHA256 tree hash of the final assembled archive as computed by Amazon S3 Glacier (Glacier), Glacier returns an error and the request fails.
    public var checksum: Swift.String?
    /// The upload ID of the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveSize: Swift.String? = nil,
        checksum: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveSize = archiveSize
        self.checksum = checksum
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct CompleteMultipartUploadInputBody: Swift.Equatable {
}

extension CompleteMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CompleteMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request. For information about the underlying REST API, see [Upload Archive](https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html). For conceptual information, see [Working with Archives in Amazon S3 Glacier](https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html).
public struct CompleteMultipartUploadOutputResponse: Swift.Equatable {
    /// The ID of the archive. This value is also included as part of the location.
    public var archiveId: Swift.String?
    /// The checksum of the archive computed by Amazon S3 Glacier.
    public var checksum: Swift.String?
    /// The relative URI path of the newly added archive resource.
    public var location: Swift.String?

    public init (
        archiveId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

extension CompleteVaultLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let lockId = lockId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/lock-policy/\(lockId.urlPercentEncoding())"
    }
}

/// The input values for CompleteVaultLock.
public struct CompleteVaultLockInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The lockId value is the lock ID obtained from a [InitiateVaultLock] request.
    /// This member is required.
    public var lockId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        lockId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.lockId = lockId
        self.vaultName = vaultName
    }
}

struct CompleteVaultLockInputBody: Swift.Equatable {
}

extension CompleteVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CompleteVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CompleteVaultLockOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())"
    }
}

/// Provides options to create a vault.
public struct CreateVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct CreateVaultInputBody: Swift.Equatable {
}

extension CreateVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct CreateVaultOutputResponse: Swift.Equatable {
    /// The URI of the vault that was created.
    public var location: Swift.String?

    public init (
        location: Swift.String? = nil
    )
    {
        self.location = location
    }
}

extension GlacierClientTypes.DataRetrievalPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for dataretrievalrule0 in rules {
                try rulesContainer.encode(dataretrievalrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([GlacierClientTypes.DataRetrievalRule?].self, forKey: .rules)
        var rulesDecoded0:[GlacierClientTypes.DataRetrievalRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [GlacierClientTypes.DataRetrievalRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension GlacierClientTypes {
    /// Data retrieval policy.
    public struct DataRetrievalPolicy: Swift.Equatable {
        /// The policy rule. Although this is a list type, currently there must be only one rule, which contains a Strategy field and optionally a BytesPerHour field.
        public var rules: [GlacierClientTypes.DataRetrievalRule]?

        public init (
            rules: [GlacierClientTypes.DataRetrievalRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension GlacierClientTypes.DataRetrievalRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesPerHour = "BytesPerHour"
        case strategy = "Strategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesPerHour = self.bytesPerHour {
            try encodeContainer.encode(bytesPerHour, forKey: .bytesPerHour)
        }
        if let strategy = self.strategy {
            try encodeContainer.encode(strategy, forKey: .strategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .strategy)
        strategy = strategyDecoded
        let bytesPerHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesPerHour)
        bytesPerHour = bytesPerHourDecoded
    }
}

extension GlacierClientTypes {
    /// Data retrieval policy rule.
    public struct DataRetrievalRule: Swift.Equatable {
        /// The maximum number of bytes that can be retrieved in an hour. This field is required only if the value of the Strategy field is BytesPerHour. Your PUT operation will be rejected if the Strategy field is not set to BytesPerHour and you set this field.
        public var bytesPerHour: Swift.Int?
        /// The type of data retrieval policy to set. Valid values: BytesPerHour|FreeTier|None
        public var strategy: Swift.String?

        public init (
            bytesPerHour: Swift.Int? = nil,
            strategy: Swift.String? = nil
        )
        {
            self.bytesPerHour = bytesPerHour
            self.strategy = strategy
        }
    }

}

extension DeleteArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let archiveId = archiveId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/archives/\(archiveId.urlPercentEncoding())"
    }
}

/// Provides options for deleting an archive from an Amazon S3 Glacier vault.
public struct DeleteArchiveInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the archive to delete.
    /// This member is required.
    public var archiveId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveId = archiveId
        self.vaultName = vaultName
    }
}

struct DeleteArchiveInputBody: Swift.Equatable {
}

extension DeleteArchiveInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteArchiveOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/access-policy"
    }
}

/// DeleteVaultAccessPolicy input.
public struct DeleteVaultAccessPolicyInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())"
    }
}

/// Provides options for deleting a vault from Amazon S3 Glacier.
public struct DeleteVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultInputBody: Swift.Equatable {
}

extension DeleteVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/notification-configuration"
    }
}

/// Provides options for deleting a vault notification configuration from an Amazon Glacier vault.
public struct DeleteVaultNotificationsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultNotificationsInputBody: Swift.Equatable {
}

extension DeleteVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultNotificationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

/// Provides options for retrieving a job description.
public struct DescribeJobInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the job to describe.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.vaultName = vaultName
    }
}

struct DescribeJobInputBody: Swift.Equatable {
}

extension DescribeJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.archiveId = output.archiveId
            self.archiveSHA256TreeHash = output.archiveSHA256TreeHash
            self.archiveSizeInBytes = output.archiveSizeInBytes
            self.completed = output.completed
            self.completionDate = output.completionDate
            self.creationDate = output.creationDate
            self.inventoryRetrievalParameters = output.inventoryRetrievalParameters
            self.inventorySizeInBytes = output.inventorySizeInBytes
            self.jobDescription = output.jobDescription
            self.jobId = output.jobId
            self.jobOutputPath = output.jobOutputPath
            self.outputLocation = output.outputLocation
            self.retrievalByteRange = output.retrievalByteRange
            self.selectParameters = output.selectParameters
            self.sha256TreeHash = output.sha256TreeHash
            self.snsTopic = output.snsTopic
            self.statusCode = output.statusCode
            self.statusMessage = output.statusMessage
            self.tier = output.tier
            self.vaultARN = output.vaultARN
        } else {
            self.action = nil
            self.archiveId = nil
            self.archiveSHA256TreeHash = nil
            self.archiveSizeInBytes = nil
            self.completed = false
            self.completionDate = nil
            self.creationDate = nil
            self.inventoryRetrievalParameters = nil
            self.inventorySizeInBytes = nil
            self.jobDescription = nil
            self.jobId = nil
            self.jobOutputPath = nil
            self.outputLocation = nil
            self.retrievalByteRange = nil
            self.sha256TreeHash = nil
            self.snsTopic = nil
            self.selectParameters = nil
            self.statusCode = nil
            self.statusMessage = nil
            self.tier = nil
            self.vaultARN = nil
        }
    }
}

/// Contains the description of an Amazon S3 Glacier job.
public struct DescribeJobOutputResponse: Swift.Equatable {
    /// The job type. This value is either ArchiveRetrieval, InventoryRetrieval, or Select.
    public var action: GlacierClientTypes.ActionCode?
    /// The archive ID requested for a select job or archive retrieval. Otherwise, this field is null.
    public var archiveId: Swift.String?
    /// The SHA256 tree hash of the entire archive for an archive retrieval. For inventory retrieval or select jobs, this field is null.
    public var archiveSHA256TreeHash: Swift.String?
    /// For an archive retrieval job, this value is the size in bytes of the archive being requested for download. For an inventory retrieval or select job, this value is null.
    public var archiveSizeInBytes: Swift.Int?
    /// The job status. When a job is completed, you get the job's output using Get Job Output (GET output).
    public var completed: Swift.Bool
    /// The UTC time that the job request completed. While the job is in progress, the value is null.
    public var completionDate: Swift.String?
    /// The UTC date when the job was created. This value is a string representation of ISO 8601 date format, for example "2012-03-20T17:03:43.221Z".
    public var creationDate: Swift.String?
    /// Parameters used for range inventory retrieval.
    public var inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
    /// For an inventory retrieval job, this value is the size in bytes of the inventory requested for download. For an archive retrieval or select job, this value is null.
    public var inventorySizeInBytes: Swift.Int?
    /// The job description provided when initiating the job.
    public var jobDescription: Swift.String?
    /// An opaque string that identifies an Amazon S3 Glacier job.
    public var jobId: Swift.String?
    /// Contains the job output location.
    public var jobOutputPath: Swift.String?
    /// Contains the location where the data from the select job is stored.
    public var outputLocation: GlacierClientTypes.OutputLocation?
    /// The retrieved byte range for archive retrieval jobs in the form StartByteValue-EndByteValue. If no range was specified in the archive retrieval, then the whole archive is retrieved. In this case, StartByteValue equals 0 and EndByteValue equals the size of the archive minus 1. For inventory retrieval or select jobs, this field is null.
    public var retrievalByteRange: Swift.String?
    /// Contains the parameters used for a select.
    public var selectParameters: GlacierClientTypes.SelectParameters?
    /// For an archive retrieval job, this value is the checksum of the archive. Otherwise, this value is null. The SHA256 tree hash value for the requested range of an archive. If the InitiateJob request for an archive specified a tree-hash aligned range, then this field returns a value. If the whole archive is retrieved, this value is the same as the ArchiveSHA256TreeHash value. This field is null for the following:
    ///
    /// * Archive retrieval jobs that specify a range that is not tree-hash aligned
    ///
    ///
    ///
    ///
    /// * Archival jobs that specify a range that is equal to the whole archive, when the job status is InProgress
    ///
    ///
    ///
    ///
    /// * Inventory jobs
    ///
    /// * Select jobs
    public var sha256TreeHash: Swift.String?
    /// An Amazon SNS topic that receives notification.
    public var snsTopic: Swift.String?
    /// The status code can be InProgress, Succeeded, or Failed, and indicates the status of the job.
    public var statusCode: GlacierClientTypes.StatusCode?
    /// A friendly message that describes the job status.
    public var statusMessage: Swift.String?
    /// The tier to use for a select or an archive retrieval. Valid values are Expedited, Standard, or Bulk. Standard is the default.
    public var tier: Swift.String?
    /// The Amazon Resource Name (ARN) of the vault from which an archive retrieval was requested.
    public var vaultARN: Swift.String?

    public init (
        action: GlacierClientTypes.ActionCode? = nil,
        archiveId: Swift.String? = nil,
        archiveSHA256TreeHash: Swift.String? = nil,
        archiveSizeInBytes: Swift.Int? = nil,
        completed: Swift.Bool = false,
        completionDate: Swift.String? = nil,
        creationDate: Swift.String? = nil,
        inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription? = nil,
        inventorySizeInBytes: Swift.Int? = nil,
        jobDescription: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobOutputPath: Swift.String? = nil,
        outputLocation: GlacierClientTypes.OutputLocation? = nil,
        retrievalByteRange: Swift.String? = nil,
        selectParameters: GlacierClientTypes.SelectParameters? = nil,
        sha256TreeHash: Swift.String? = nil,
        snsTopic: Swift.String? = nil,
        statusCode: GlacierClientTypes.StatusCode? = nil,
        statusMessage: Swift.String? = nil,
        tier: Swift.String? = nil,
        vaultARN: Swift.String? = nil
    )
    {
        self.action = action
        self.archiveId = archiveId
        self.archiveSHA256TreeHash = archiveSHA256TreeHash
        self.archiveSizeInBytes = archiveSizeInBytes
        self.completed = completed
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.inventoryRetrievalParameters = inventoryRetrievalParameters
        self.inventorySizeInBytes = inventorySizeInBytes
        self.jobDescription = jobDescription
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.outputLocation = outputLocation
        self.retrievalByteRange = retrievalByteRange
        self.selectParameters = selectParameters
        self.sha256TreeHash = sha256TreeHash
        self.snsTopic = snsTopic
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.tier = tier
        self.vaultARN = vaultARN
    }
}

struct DescribeJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobDescription: Swift.String?
    let action: GlacierClientTypes.ActionCode?
    let archiveId: Swift.String?
    let vaultARN: Swift.String?
    let creationDate: Swift.String?
    let completed: Swift.Bool
    let statusCode: GlacierClientTypes.StatusCode?
    let statusMessage: Swift.String?
    let archiveSizeInBytes: Swift.Int?
    let inventorySizeInBytes: Swift.Int?
    let snsTopic: Swift.String?
    let completionDate: Swift.String?
    let sha256TreeHash: Swift.String?
    let archiveSHA256TreeHash: Swift.String?
    let retrievalByteRange: Swift.String?
    let tier: Swift.String?
    let inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
    let jobOutputPath: Swift.String?
    let selectParameters: GlacierClientTypes.SelectParameters?
    let outputLocation: GlacierClientTypes.OutputLocation?
}

extension DescribeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sha256TreeHash = "SHA256TreeHash"
        case snsTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .completed) ?? false
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sha256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha256TreeHash)
        sha256TreeHash = sha256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension DescribeVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())"
    }
}

/// Provides options for retrieving metadata for a specific vault in Amazon Glacier.
public struct DescribeVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DescribeVaultInputBody: Swift.Equatable {
}

extension DescribeVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.DescribeVaultOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let lastInventoryDate = self.lastInventoryDate {
            try encodeContainer.encode(lastInventoryDate, forKey: .lastInventoryDate)
        }
        if numberOfArchives != 0 {
            try encodeContainer.encode(numberOfArchives, forKey: .numberOfArchives)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let vaultARN = self.vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
        if let vaultName = self.vaultName {
            try encodeContainer.encode(vaultName, forKey: .vaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfArchives) ?? 0
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytes) ?? 0
        sizeInBytes = sizeInBytesDecoded
    }
}

extension GlacierClientTypes {
    /// Contains the Amazon S3 Glacier response to your request.
    public struct DescribeVaultOutput: Swift.Equatable {
        /// The Universal Coordinated Time (UTC) date when the vault was created. This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
        public var creationDate: Swift.String?
        /// The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last vault inventory. This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
        public var lastInventoryDate: Swift.String?
        /// The number of archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
        public var numberOfArchives: Swift.Int
        /// Total size, in bytes, of the archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
        public var sizeInBytes: Swift.Int
        /// The Amazon Resource Name (ARN) of the vault.
        public var vaultARN: Swift.String?
        /// The name of the vault.
        public var vaultName: Swift.String?

        public init (
            creationDate: Swift.String? = nil,
            lastInventoryDate: Swift.String? = nil,
            numberOfArchives: Swift.Int = 0,
            sizeInBytes: Swift.Int = 0,
            vaultARN: Swift.String? = nil,
            vaultName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastInventoryDate = lastInventoryDate
            self.numberOfArchives = numberOfArchives
            self.sizeInBytes = sizeInBytes
            self.vaultARN = vaultARN
            self.vaultName = vaultName
        }
    }

}

extension DescribeVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeVaultOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .invalidParameterValueException: return "InvalidParameterValueException"
        case .missingParameterValueException: return "MissingParameterValueException"
        case .resourceNotFoundException: return "ResourceNotFoundException"
        case .serviceUnavailableException: return "ServiceUnavailableException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastInventoryDate = output.lastInventoryDate
            self.numberOfArchives = output.numberOfArchives
            self.sizeInBytes = output.sizeInBytes
            self.vaultARN = output.vaultARN
            self.vaultName = output.vaultName
        } else {
            self.creationDate = nil
            self.lastInventoryDate = nil
            self.numberOfArchives = 0
            self.sizeInBytes = 0
            self.vaultARN = nil
            self.vaultName = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct DescribeVaultOutputResponse: Swift.Equatable {
    /// The Universal Coordinated Time (UTC) date when the vault was created. This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
    public var creationDate: Swift.String?
    /// The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last vault inventory. This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
    public var lastInventoryDate: Swift.String?
    /// The number of archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
    public var numberOfArchives: Swift.Int
    /// Total size, in bytes, of the archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
    public var sizeInBytes: Swift.Int
    /// The Amazon Resource Name (ARN) of the vault.
    public var vaultARN: Swift.String?
    /// The name of the vault.
    public var vaultName: Swift.String?

    public init (
        creationDate: Swift.String? = nil,
        lastInventoryDate: Swift.String? = nil,
        numberOfArchives: Swift.Int = 0,
        sizeInBytes: Swift.Int = 0,
        vaultARN: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.lastInventoryDate = lastInventoryDate
        self.numberOfArchives = numberOfArchives
        self.sizeInBytes = sizeInBytes
        self.vaultARN = vaultARN
        self.vaultName = vaultName
    }
}

struct DescribeVaultOutputResponseBody: Swift.Equatable {
    let vaultARN: Swift.String?
    let vaultName: Swift.String?
    let creationDate: Swift.String?
    let lastInventoryDate: Swift.String?
    let numberOfArchives: Swift.Int
    let sizeInBytes: Swift.Int
}

extension DescribeVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfArchives) ?? 0
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInBytes) ?? 0
        sizeInBytes = sizeInBytesDecoded
    }
}

extension GlacierClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case kmsContext = "KMSContext"
        case kmsKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsContext = self.kmsContext {
            try encodeContainer.encode(kmsContext, forKey: .kmsContext)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kmsContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsContext)
        kmsContext = kmsContextDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the encryption used to store the job results in Amazon S3.
    public struct Encryption: Swift.Equatable {
        /// The server-side encryption algorithm used when storing job results in Amazon S3, for example AES256 or aws:kms.
        public var encryptionType: GlacierClientTypes.EncryptionType?
        /// Optional. If the encryption type is aws:kms, you can use this value to specify the encryption context for the job results.
        public var kmsContext: Swift.String?
        /// The AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS fail if not made by using Secure Sockets Layer (SSL) or Signature Version 4.
        public var kmsKeyId: Swift.String?

        public init (
            encryptionType: GlacierClientTypes.EncryptionType? = nil,
            kmsContext: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsContext = kmsContext
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension GlacierClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "aws:kms"
            case .s3: return "AES256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .sql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum FileHeaderInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignore
        case `none`
        case use
        case sdkUnknown(Swift.String)

        public static var allCases: [FileHeaderInfo] {
            return [
                .ignore,
                .none,
                .use,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .none: return "NONE"
            case .use: return "USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileHeaderInfo(rawValue: rawValue) ?? FileHeaderInfo.sdkUnknown(rawValue)
        }
    }
}

extension GetDataRetrievalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/policies/data-retrieval"
    }
}

/// Input for GetDataRetrievalPolicy.
public struct GetDataRetrievalPolicyInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetDataRetrievalPolicyInputBody: Swift.Equatable {
}

extension GetDataRetrievalPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataRetrievalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataRetrievalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataRetrievalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataRetrievalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataRetrievalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to the GetDataRetrievalPolicy request.
public struct GetDataRetrievalPolicyOutputResponse: Swift.Equatable {
    /// Contains the returned data retrieval policy in JSON format.
    public var policy: GlacierClientTypes.DataRetrievalPolicy?

    public init (
        policy: GlacierClientTypes.DataRetrievalPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDataRetrievalPolicyOutputResponseBody: Swift.Equatable {
    let policy: GlacierClientTypes.DataRetrievalPolicy?
}

extension GetDataRetrievalPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetJobOutputInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetJobOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/output"
    }
}

/// Provides options for downloading output of an Amazon S3 Glacier job.
public struct GetJobOutputInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The job ID whose data is downloaded.
    /// This member is required.
    public var jobId: Swift.String?
    /// The range of bytes to retrieve from the output. For example, if you want to download the first 1,048,576 bytes, specify the range as bytes=0-1048575. By default, this operation downloads the entire output. If the job output is large, then you can use a range to retrieve a portion of the output. This allows you to download the entire output in smaller chunks of bytes. For example, suppose you have 1 GB of job output you want to download and you decide to download 128 MB chunks of data at a time, which is a total of eight Get Job Output requests. You use the following process to download the job output:
    ///
    /// * Download a 128 MB chunk of output by specifying the appropriate byte range. Verify that all 128 MB of data was received.
    ///
    /// * Along with the data, the response includes a SHA256 tree hash of the payload. You compute the checksum of the payload on the client and compare it with the checksum you received in the response to ensure you received all the expected data.
    ///
    /// * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data, each time specifying the appropriate byte range.
    ///
    /// * After downloading all the parts of the job output, you have a list of eight checksum values. Compute the tree hash of these values to find the checksum of the entire output. Using the [DescribeJob] API, obtain job information of the job that provided you the output. The response includes the checksum of the entire archive stored in Amazon S3 Glacier. You compare this value with the checksum you computed to ensure you have downloaded the entire archive content with no errors.
    public var range: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        range: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.range = range
        self.vaultName = vaultName
    }
}

struct GetJobOutputInputBody: Swift.Equatable {
}

extension GetJobOutputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetJobOutputOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "Accept-Ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let archiveDescriptionHeaderValue = httpResponse.headers.value(for: "x-amz-archive-description") {
            self.archiveDescription = archiveDescriptionHeaderValue
        } else {
            self.archiveDescription = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.body = ByteStream.from(data: data)
        } else {
            self.body = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct GetJobOutputOutputResponse: Swift.Equatable {
    /// Indicates the range units accepted. For more information, see [RFC2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
    public var acceptRanges: Swift.String?
    /// The description of an archive.
    public var archiveDescription: Swift.String?
    /// The job data, either archive data or inventory data.
    public var body: ClientRuntime.ByteStream?
    /// The checksum of the data in the response. This header is returned only when retrieving the output for an archive retrieval job. Furthermore, this header appears only under the following conditions:
    ///
    /// * You get the entire range of the archive.
    ///
    /// * You request a range to return of the archive that starts and ends on a multiple of 1 MB. For example, if you have an 3.1 MB archive and you specify a range to return that starts at 1 MB and ends at 2 MB, then the x-amz-sha256-tree-hash is returned as a response header.
    ///
    /// * You request a range of the archive to return that starts on a multiple of 1 MB and goes to the end of the archive. For example, if you have a 3.1 MB archive and you specify a range that starts at 2 MB and ends at 3.1 MB (the end of the archive), then the x-amz-sha256-tree-hash is returned as a response header.
    public var checksum: Swift.String?
    /// The range of bytes returned by Amazon S3 Glacier. If only partial output is downloaded, the response provides the range of bytes Amazon S3 Glacier returned. For example, bytes 0-1048575/8388608 returns the first 1 MB from 8 MB.
    public var contentRange: Swift.String?
    /// The Content-Type depends on whether the job output is an archive or a vault inventory. For archive data, the Content-Type is application/octet-stream. For vault inventory, if you requested CSV format when you initiated the job, the Content-Type is text/csv. Otherwise, by default, vault inventory is returned as JSON, and the Content-Type is application/json.
    public var contentType: Swift.String?
    /// The HTTP response code for a job output request. The value depends on whether a range was specified in the request.
    public var status: Swift.Int

    public init (
        acceptRanges: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.acceptRanges = acceptRanges
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.contentRange = contentRange
        self.contentType = contentType
        self.status = status
    }
}

struct GetJobOutputOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
    let status: Swift.Int
}

extension GetJobOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension GetVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/access-policy"
    }
}

/// Input for GetVaultAccessPolicy.
public struct GetVaultAccessPolicyInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultAccessPolicyInputBody: Swift.Equatable {
}

extension GetVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: GlacierClientTypes.VaultAccessPolicy = try responseDecoder.decode(responseBody: data)
                self.policy = output
            } else {
                self.policy = nil
            }
        } else {
            self.policy = nil
        }
    }
}

/// Output for GetVaultAccessPolicy.
public struct GetVaultAccessPolicyOutputResponse: Swift.Equatable {
    /// Contains the returned vault access policy as a JSON string.
    public var policy: GlacierClientTypes.VaultAccessPolicy?

    public init (
        policy: GlacierClientTypes.VaultAccessPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetVaultAccessPolicyOutputResponseBody: Swift.Equatable {
    let policy: GlacierClientTypes.VaultAccessPolicy?
}

extension GetVaultAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetVaultLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/lock-policy"
    }
}

/// The input values for GetVaultLock.
public struct GetVaultLockInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultLockInputBody: Swift.Equatable {
}

extension GetVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVaultLockOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.expirationDate = output.expirationDate
            self.policy = output.policy
            self.state = output.state
        } else {
            self.creationDate = nil
            self.expirationDate = nil
            self.policy = nil
            self.state = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct GetVaultLockOutputResponse: Swift.Equatable {
    /// The UTC date and time at which the vault lock was put into the InProgress state.
    public var creationDate: Swift.String?
    /// The UTC date and time at which the lock ID expires. This value can be null if the vault lock is in a Locked state.
    public var expirationDate: Swift.String?
    /// The vault lock policy as a JSON string, which uses "\" as an escape character.
    public var policy: Swift.String?
    /// The state of the vault lock. InProgress or Locked.
    public var state: Swift.String?

    public init (
        creationDate: Swift.String? = nil,
        expirationDate: Swift.String? = nil,
        policy: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.expirationDate = expirationDate
        self.policy = policy
        self.state = state
    }
}

struct GetVaultLockOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let state: Swift.String?
    let expirationDate: Swift.String?
    let creationDate: Swift.String?
}

extension GetVaultLockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case expirationDate = "ExpirationDate"
        case policy = "Policy"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GetVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/notification-configuration"
    }
}

/// Provides options for retrieving the notification configuration set on an Amazon Glacier vault.
public struct GetVaultNotificationsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultNotificationsInputBody: Swift.Equatable {
}

extension GetVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: GlacierClientTypes.VaultNotificationConfig = try responseDecoder.decode(responseBody: data)
                self.vaultNotificationConfig = output
            } else {
                self.vaultNotificationConfig = nil
            }
        } else {
            self.vaultNotificationConfig = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct GetVaultNotificationsOutputResponse: Swift.Equatable {
    /// Returns the notification configuration set on the vault.
    public var vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?

    public init (
        vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig? = nil
    )
    {
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct GetVaultNotificationsOutputResponseBody: Swift.Equatable {
    let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?
}

extension GetVaultNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension GlacierClientTypes.GlacierJobDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sha256TreeHash = "SHA256TreeHash"
        case snsTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let archiveId = self.archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let archiveSHA256TreeHash = self.archiveSHA256TreeHash {
            try encodeContainer.encode(archiveSHA256TreeHash, forKey: .archiveSHA256TreeHash)
        }
        if let archiveSizeInBytes = self.archiveSizeInBytes {
            try encodeContainer.encode(archiveSizeInBytes, forKey: .archiveSizeInBytes)
        }
        if completed != false {
            try encodeContainer.encode(completed, forKey: .completed)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let inventoryRetrievalParameters = self.inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let inventorySizeInBytes = self.inventorySizeInBytes {
            try encodeContainer.encode(inventorySizeInBytes, forKey: .inventorySizeInBytes)
        }
        if let jobDescription = self.jobDescription {
            try encodeContainer.encode(jobDescription, forKey: .jobDescription)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobOutputPath = self.jobOutputPath {
            try encodeContainer.encode(jobOutputPath, forKey: .jobOutputPath)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = self.retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let sha256TreeHash = self.sha256TreeHash {
            try encodeContainer.encode(sha256TreeHash, forKey: .sha256TreeHash)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
        if let selectParameters = self.selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let vaultARN = self.vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .completed) ?? false
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sha256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha256TreeHash)
        sha256TreeHash = sha256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension GlacierClientTypes {
    /// Contains the description of an Amazon S3 Glacier job.
    public struct GlacierJobDescription: Swift.Equatable {
        /// The job type. This value is either ArchiveRetrieval, InventoryRetrieval, or Select.
        public var action: GlacierClientTypes.ActionCode?
        /// The archive ID requested for a select job or archive retrieval. Otherwise, this field is null.
        public var archiveId: Swift.String?
        /// The SHA256 tree hash of the entire archive for an archive retrieval. For inventory retrieval or select jobs, this field is null.
        public var archiveSHA256TreeHash: Swift.String?
        /// For an archive retrieval job, this value is the size in bytes of the archive being requested for download. For an inventory retrieval or select job, this value is null.
        public var archiveSizeInBytes: Swift.Int?
        /// The job status. When a job is completed, you get the job's output using Get Job Output (GET output).
        public var completed: Swift.Bool
        /// The UTC time that the job request completed. While the job is in progress, the value is null.
        public var completionDate: Swift.String?
        /// The UTC date when the job was created. This value is a string representation of ISO 8601 date format, for example "2012-03-20T17:03:43.221Z".
        public var creationDate: Swift.String?
        /// Parameters used for range inventory retrieval.
        public var inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
        /// For an inventory retrieval job, this value is the size in bytes of the inventory requested for download. For an archive retrieval or select job, this value is null.
        public var inventorySizeInBytes: Swift.Int?
        /// The job description provided when initiating the job.
        public var jobDescription: Swift.String?
        /// An opaque string that identifies an Amazon S3 Glacier job.
        public var jobId: Swift.String?
        /// Contains the job output location.
        public var jobOutputPath: Swift.String?
        /// Contains the location where the data from the select job is stored.
        public var outputLocation: GlacierClientTypes.OutputLocation?
        /// The retrieved byte range for archive retrieval jobs in the form StartByteValue-EndByteValue. If no range was specified in the archive retrieval, then the whole archive is retrieved. In this case, StartByteValue equals 0 and EndByteValue equals the size of the archive minus 1. For inventory retrieval or select jobs, this field is null.
        public var retrievalByteRange: Swift.String?
        /// Contains the parameters used for a select.
        public var selectParameters: GlacierClientTypes.SelectParameters?
        /// For an archive retrieval job, this value is the checksum of the archive. Otherwise, this value is null. The SHA256 tree hash value for the requested range of an archive. If the InitiateJob request for an archive specified a tree-hash aligned range, then this field returns a value. If the whole archive is retrieved, this value is the same as the ArchiveSHA256TreeHash value. This field is null for the following:
        ///
        /// * Archive retrieval jobs that specify a range that is not tree-hash aligned
        ///
        ///
        ///
        ///
        /// * Archival jobs that specify a range that is equal to the whole archive, when the job status is InProgress
        ///
        ///
        ///
        ///
        /// * Inventory jobs
        ///
        /// * Select jobs
        public var sha256TreeHash: Swift.String?
        /// An Amazon SNS topic that receives notification.
        public var snsTopic: Swift.String?
        /// The status code can be InProgress, Succeeded, or Failed, and indicates the status of the job.
        public var statusCode: GlacierClientTypes.StatusCode?
        /// A friendly message that describes the job status.
        public var statusMessage: Swift.String?
        /// The tier to use for a select or an archive retrieval. Valid values are Expedited, Standard, or Bulk. Standard is the default.
        public var tier: Swift.String?
        /// The Amazon Resource Name (ARN) of the vault from which an archive retrieval was requested.
        public var vaultARN: Swift.String?

        public init (
            action: GlacierClientTypes.ActionCode? = nil,
            archiveId: Swift.String? = nil,
            archiveSHA256TreeHash: Swift.String? = nil,
            archiveSizeInBytes: Swift.Int? = nil,
            completed: Swift.Bool = false,
            completionDate: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription? = nil,
            inventorySizeInBytes: Swift.Int? = nil,
            jobDescription: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobOutputPath: Swift.String? = nil,
            outputLocation: GlacierClientTypes.OutputLocation? = nil,
            retrievalByteRange: Swift.String? = nil,
            selectParameters: GlacierClientTypes.SelectParameters? = nil,
            sha256TreeHash: Swift.String? = nil,
            snsTopic: Swift.String? = nil,
            statusCode: GlacierClientTypes.StatusCode? = nil,
            statusMessage: Swift.String? = nil,
            tier: Swift.String? = nil,
            vaultARN: Swift.String? = nil
        )
        {
            self.action = action
            self.archiveId = archiveId
            self.archiveSHA256TreeHash = archiveSHA256TreeHash
            self.archiveSizeInBytes = archiveSizeInBytes
            self.completed = completed
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.inventorySizeInBytes = inventorySizeInBytes
            self.jobDescription = jobDescription
            self.jobId = jobId
            self.jobOutputPath = jobOutputPath
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.selectParameters = selectParameters
            self.sha256TreeHash = sha256TreeHash
            self.snsTopic = snsTopic
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tier = tier
            self.vaultARN = vaultARN
        }
    }

}

extension GlacierClientTypes.Grant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = self.grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about a grant.
    public struct Grant: Swift.Equatable {
        /// The grantee.
        public var grantee: GlacierClientTypes.Grantee?
        /// Specifies the permission given to the grantee.
        public var permission: GlacierClientTypes.Permission?

        public init (
            grantee: GlacierClientTypes.Grantee? = nil,
            permission: GlacierClientTypes.Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension GlacierClientTypes.Grantee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case emailAddress = "EmailAddress"
        case id = "ID"
        case type = "Type"
        case uri = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the grantee.
    public struct Grantee: Swift.Equatable {
        /// Screen name of the grantee.
        public var displayName: Swift.String?
        /// Email address of the grantee.
        public var emailAddress: Swift.String?
        /// The canonical user ID of the grantee.
        public var id: Swift.String?
        /// Type of grantee
        /// This member is required.
        public var type: GlacierClientTypes.ModelType?
        /// URI of the grantee group.
        public var uri: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            type: GlacierClientTypes.ModelType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.id = id
            self.type = type
            self.uri = uri
        }
    }

}

public struct InitiateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateJobInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InitiateJobOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let jobParameters = input.operationInput.jobParameters {
                let jobParametersdata = try encoder.encode(jobParameters)
                let jobParametersbody = ClientRuntime.HttpBody.data(jobParametersdata)
                input.builder.withBody(jobParametersbody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let jobParametersdata = "{}".data(using: .utf8)!
                    let jobParametersbody = ClientRuntime.HttpBody.data(jobParametersdata)
                    input.builder.withBody(jobParametersbody)
                }
            }
        } catch let err {
            throw SdkError<InitiateJobOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension InitiateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobParameters = self.jobParameters {
            try encodeContainer.encode(jobParameters, forKey: .jobParameters)
        }
    }
}

extension InitiateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/jobs"
    }
}

/// Provides options for initiating an Amazon S3 Glacier job.
public struct InitiateJobInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// Provides options for specifying job information.
    public var jobParameters: GlacierClientTypes.JobParameters?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobParameters: GlacierClientTypes.JobParameters? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobParameters = jobParameters
        self.vaultName = vaultName
    }
}

struct InitiateJobInputBody: Swift.Equatable {
    let jobParameters: GlacierClientTypes.JobParameters?
}

extension InitiateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.JobParameters.self, forKey: .jobParameters)
        jobParameters = jobParametersDecoded
    }
}

extension InitiateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEnforcedException" : self = .policyEnforcedException(try PolicyEnforcedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InitiateJobOutputError: Swift.Error, Swift.Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case policyEnforcedException(PolicyEnforcedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let jobIdHeaderValue = httpResponse.headers.value(for: "x-amz-job-id") {
            self.jobId = jobIdHeaderValue
        } else {
            self.jobId = nil
        }
        if let jobOutputPathHeaderValue = httpResponse.headers.value(for: "x-amz-job-output-path") {
            self.jobOutputPath = jobOutputPathHeaderValue
        } else {
            self.jobOutputPath = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct InitiateJobOutputResponse: Swift.Equatable {
    /// The ID of the job.
    public var jobId: Swift.String?
    /// The path to the location of where the select results are stored.
    public var jobOutputPath: Swift.String?
    /// The relative URI path of the job.
    public var location: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        jobOutputPath: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.location = location
    }
}

extension InitiateMultipartUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let archiveDescription = archiveDescription {
            items.add(Header(name: "x-amz-archive-description", value: Swift.String(archiveDescription)))
        }
        if let partSize = partSize {
            items.add(Header(name: "x-amz-part-size", value: Swift.String(partSize)))
        }
        return items
    }
}

extension InitiateMultipartUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads"
    }
}

/// Provides options for initiating a multipart upload to an Amazon S3 Glacier vault.
public struct InitiateMultipartUploadInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The archive description that you are uploading in parts. The part size must be a megabyte (1024 KB) multiplied by a power of 2, for example 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is 1 MB, and the maximum is 4 GB (4096 MB).
    public var archiveDescription: Swift.String?
    /// The size of each part except the last, in bytes. The last part can be smaller than this part size.
    public var partSize: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        partSize: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.partSize = partSize
        self.vaultName = vaultName
    }
}

struct InitiateMultipartUploadInputBody: Swift.Equatable {
}

extension InitiateMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitiateMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InitiateMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let uploadIdHeaderValue = httpResponse.headers.value(for: "x-amz-multipart-upload-id") {
            self.uploadId = uploadIdHeaderValue
        } else {
            self.uploadId = nil
        }
    }
}

/// The Amazon S3 Glacier response to your request.
public struct InitiateMultipartUploadOutputResponse: Swift.Equatable {
    /// The relative URI path of the multipart upload ID Amazon S3 Glacier created.
    public var location: Swift.String?
    /// The ID of the multipart upload. This value is also included as part of the location.
    public var uploadId: Swift.String?

    public init (
        location: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.location = location
        self.uploadId = uploadId
    }
}

public struct InitiateVaultLockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateVaultLockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateVaultLockInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let policy = input.operationInput.policy {
                let policydata = try encoder.encode(policy)
                let policybody = ClientRuntime.HttpBody.data(policydata)
                input.builder.withBody(policybody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let policydata = "{}".data(using: .utf8)!
                    let policybody = ClientRuntime.HttpBody.data(policydata)
                    input.builder.withBody(policybody)
                }
            }
        } catch let err {
            throw SdkError<InitiateVaultLockOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension InitiateVaultLockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension InitiateVaultLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/lock-policy"
    }
}

/// The input values for InitiateVaultLock.
public struct InitiateVaultLockInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The vault lock policy as a JSON string, which uses "\" as an escape character.
    public var policy: GlacierClientTypes.VaultLockPolicy?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.VaultLockPolicy? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct InitiateVaultLockInputBody: Swift.Equatable {
    let policy: GlacierClientTypes.VaultLockPolicy?
}

extension InitiateVaultLockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultLockPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InitiateVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InitiateVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let lockIdHeaderValue = httpResponse.headers.value(for: "x-amz-lock-id") {
            self.lockId = lockIdHeaderValue
        } else {
            self.lockId = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct InitiateVaultLockOutputResponse: Swift.Equatable {
    /// The lock ID, which is used to complete the vault locking process.
    public var lockId: Swift.String?

    public init (
        lockId: Swift.String? = nil
    )
    {
        self.lockId = lockId
    }
}

extension GlacierClientTypes.InputSerialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CSVInput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension GlacierClientTypes {
    /// Describes how the archive is serialized.
    public struct InputSerialization: Swift.Equatable {
        /// Describes the serialization of a CSV-encoded object.
        public var csv: GlacierClientTypes.CSVInput?

        public init (
            csv: GlacierClientTypes.CSVInput? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension InsufficientCapacityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if there is insufficient capacity to process this expedited request. This error only applies to expedited retrievals and not to standard or bulk retrievals.
public struct InsufficientCapacityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InsufficientCapacityExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension InsufficientCapacityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a parameter of the request is incorrectly specified.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 400 Bad Request
    public var code: Swift.String?
    /// Returned if a parameter of the request is incorrectly specified.
    public var message: Swift.String?
    /// Client
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.InventoryRetrievalJobDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case format = "Format"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = self.startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GlacierClientTypes {
    /// Describes the options for a range inventory retrieval job.
    public struct InventoryRetrievalJobDescription: Swift.Equatable {
        /// The end of the date range in UTC for vault inventory retrieval that includes archives created before this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public var endDate: Swift.String?
        /// The output format for the vault inventory list, which is set by the InitiateJob request when initiating a job to retrieve a vault inventory. Valid values are CSV and JSON.
        public var format: Swift.String?
        /// The maximum number of inventory items returned per vault inventory retrieval request. This limit is set when initiating the job with the a InitiateJob request.
        public var limit: Swift.String?
        /// An opaque string that represents where to continue pagination of the vault inventory retrieval results. You use the marker in a new InitiateJob request to obtain additional inventory items. If there are no more inventory items, this value is null. For more information, see [ Range Inventory Retrieval](https://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html#api-initiate-job-post-vault-inventory-list-filtering).
        public var marker: Swift.String?
        /// The start of the date range in Universal Coordinated Time (UTC) for vault inventory retrieval that includes archives created on or after this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public var startDate: Swift.String?

        public init (
            endDate: Swift.String? = nil,
            format: Swift.String? = nil,
            limit: Swift.String? = nil,
            marker: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.format = format
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }
    }

}

extension GlacierClientTypes.InventoryRetrievalJobInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = self.startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GlacierClientTypes {
    /// Provides options for specifying a range inventory retrieval job.
    public struct InventoryRetrievalJobInput: Swift.Equatable {
        /// The end of the date range in UTC for vault inventory retrieval that includes archives created before this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public var endDate: Swift.String?
        /// Specifies the maximum number of inventory items returned per vault inventory retrieval request. Valid values are greater than or equal to 1.
        public var limit: Swift.String?
        /// An opaque string that represents where to continue pagination of the vault inventory retrieval results. You use the marker in a new InitiateJob request to obtain additional inventory items. If there are no more inventory items, this value is null.
        public var marker: Swift.String?
        /// The start of the date range in UTC for vault inventory retrieval that includes archives created on or after this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public var startDate: Swift.String?

        public init (
            endDate: Swift.String? = nil,
            limit: Swift.String? = nil,
            marker: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }
    }

}

extension GlacierClientTypes.JobParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveId = "ArchiveId"
        case description = "Description"
        case format = "Format"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case snsTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case tier = "Tier"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveId = self.archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let inventoryRetrievalParameters = self.inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = self.retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
        if let selectParameters = self.selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobInput.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension GlacierClientTypes {
    /// Provides options for defining a job.
    public struct JobParameters: Swift.Equatable {
        /// The ID of the archive that you want to retrieve. This field is required only if Type is set to select or archive-retrievalcode>. An error occurs if you specify this request parameter for an inventory retrieval job request.
        public var archiveId: Swift.String?
        /// The optional description for the job. The description must be less than or equal to 1,024 bytes. The allowable characters are 7-bit ASCII without control codes-specifically, ASCII values 32-126 decimal or 0x20-0x7E hexadecimal.
        public var description: Swift.String?
        /// When initiating a job to retrieve a vault inventory, you can optionally add this parameter to your request to specify the output format. If you are initiating an inventory job and do not specify a Format field, JSON is the default format. Valid values are "CSV" and "JSON".
        public var format: Swift.String?
        /// Input parameters used for range inventory retrieval.
        public var inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobInput?
        /// Contains information about the location where the select job results are stored.
        public var outputLocation: GlacierClientTypes.OutputLocation?
        /// The byte range to retrieve for an archive retrieval. in the form "StartByteValue-EndByteValue" If not specified, the whole archive is retrieved. If specified, the byte range must be megabyte (1024*1024) aligned which means that StartByteValue must be divisible by 1 MB and EndByteValue plus 1 must be divisible by 1 MB or be the end of the archive specified as the archive byte size value minus 1. If RetrievalByteRange is not megabyte aligned, this operation returns a 400 response. An error occurs if you specify this field for an inventory retrieval job request.
        public var retrievalByteRange: Swift.String?
        /// Contains the parameters that define a job.
        public var selectParameters: GlacierClientTypes.SelectParameters?
        /// The Amazon SNS topic ARN to which Amazon S3 Glacier sends a notification when the job is completed and the output is ready for you to download. The specified topic publishes the notification to its subscribers. The SNS topic must exist.
        public var snsTopic: Swift.String?
        /// The tier to use for a select or an archive retrieval job. Valid values are Expedited, Standard, or Bulk. Standard is the default.
        public var tier: Swift.String?
        /// The job type. You can initiate a job to perform a select query on an archive, retrieve an archive, or get an inventory of a vault. Valid values are "select", "archive-retrieval" and "inventory-retrieval".
        public var type: Swift.String?

        public init (
            archiveId: Swift.String? = nil,
            description: Swift.String? = nil,
            format: Swift.String? = nil,
            inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobInput? = nil,
            outputLocation: GlacierClientTypes.OutputLocation? = nil,
            retrievalByteRange: Swift.String? = nil,
            selectParameters: GlacierClientTypes.SelectParameters? = nil,
            snsTopic: Swift.String? = nil,
            tier: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.archiveId = archiveId
            self.description = description
            self.format = format
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.selectParameters = selectParameters
            self.snsTopic = snsTopic
            self.tier = tier
            self.type = type
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the request results in a vault or account limit being exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 400 Bad Request
    public var code: Swift.String?
    /// Returned if the request results in a vault limit or tags limit being exceeded.
    public var message: Swift.String?
    /// Client
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let statuscode = statuscode {
                let statuscodeQueryItem = ClientRuntime.URLQueryItem(name: "statuscode".urlPercentEncoding(), value: Swift.String(statuscode).urlPercentEncoding())
                items.append(statuscodeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let completed = completed {
                let completedQueryItem = ClientRuntime.URLQueryItem(name: "completed".urlPercentEncoding(), value: Swift.String(completed).urlPercentEncoding())
                items.append(completedQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/jobs"
    }
}

/// Provides options for retrieving a job list for an Amazon S3 Glacier vault.
public struct ListJobsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The state of the jobs to return. You can specify true or false.
    public var completed: Swift.String?
    /// The maximum number of jobs to be returned. The default limit is 50. The number of jobs returned might be fewer than the specified limit, but the number of returned jobs never exceeds the limit.
    public var limit: Swift.Int?
    /// An opaque string used for pagination. This value specifies the job at which the listing of jobs should begin. Get the marker value from a previous List Jobs response. You only need to include the marker if you are continuing the pagination of results started in a previous List Jobs request.
    public var marker: Swift.String?
    /// The type of job status to return. You can specify the following values: InProgress, Succeeded, or Failed.
    public var statuscode: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        completed: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        statuscode: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.completed = completed
        self.limit = limit
        self.marker = marker
        self.statuscode = statuscode
        self.vaultName = vaultName
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobList = output.jobList
            self.marker = output.marker
        } else {
            self.jobList = nil
            self.marker = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct ListJobsOutputResponse: Swift.Equatable {
    /// A list of job objects. Each job object contains metadata describing the job.
    public var jobList: [GlacierClientTypes.GlacierJobDescription]?
    /// An opaque string used for pagination that specifies the job at which the listing of jobs should begin. You get the marker value from a previous List Jobs response. You only need to include the marker if you are continuing the pagination of the results started in a previous List Jobs request.
    public var marker: Swift.String?

    public init (
        jobList: [GlacierClientTypes.GlacierJobDescription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.jobList = jobList
        self.marker = marker
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    let jobList: [GlacierClientTypes.GlacierJobDescription]?
    let marker: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobList = "JobList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.GlacierJobDescription?].self, forKey: .jobList)
        var jobListDecoded0:[GlacierClientTypes.GlacierJobDescription]? = nil
        if let jobListContainer = jobListContainer {
            jobListDecoded0 = [GlacierClientTypes.GlacierJobDescription]()
            for structure0 in jobListContainer {
                if let structure0 = structure0 {
                    jobListDecoded0?.append(structure0)
                }
            }
        }
        jobList = jobListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListMultipartUploadsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListMultipartUploadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads"
    }
}

/// Provides options for retrieving list of in-progress multipart uploads for an Amazon Glacier vault.
public struct ListMultipartUploadsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the maximum number of uploads returned in the response body. If this value is not specified, the List Uploads operation returns up to 50 uploads.
    public var limit: Swift.Int?
    /// An opaque string used for pagination. This value specifies the upload at which the listing of uploads should begin. Get the marker value from a previous List Uploads response. You need only include the marker if you are continuing the pagination of results started in a previous List Uploads request.
    public var marker: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.vaultName = vaultName
    }
}

struct ListMultipartUploadsInputBody: Swift.Equatable {
}

extension ListMultipartUploadsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMultipartUploadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMultipartUploadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMultipartUploadsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMultipartUploadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMultipartUploadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.uploadsList = output.uploadsList
        } else {
            self.marker = nil
            self.uploadsList = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct ListMultipartUploadsOutputResponse: Swift.Equatable {
    /// An opaque string that represents where to continue pagination of the results. You use the marker in a new List Multipart Uploads request to obtain more uploads in the list. If there are no more uploads, this value is null.
    public var marker: Swift.String?
    /// A list of in-progress multipart uploads.
    public var uploadsList: [GlacierClientTypes.UploadListElement]?

    public init (
        marker: Swift.String? = nil,
        uploadsList: [GlacierClientTypes.UploadListElement]? = nil
    )
    {
        self.marker = marker
        self.uploadsList = uploadsList
    }
}

struct ListMultipartUploadsOutputResponseBody: Swift.Equatable {
    let uploadsList: [GlacierClientTypes.UploadListElement]?
    let marker: Swift.String?
}

extension ListMultipartUploadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case uploadsList = "UploadsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.UploadListElement?].self, forKey: .uploadsList)
        var uploadsListDecoded0:[GlacierClientTypes.UploadListElement]? = nil
        if let uploadsListContainer = uploadsListContainer {
            uploadsListDecoded0 = [GlacierClientTypes.UploadListElement]()
            for structure0 in uploadsListContainer {
                if let structure0 = structure0 {
                    uploadsListDecoded0?.append(structure0)
                }
            }
        }
        uploadsList = uploadsListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads/\(uploadId.urlPercentEncoding())"
    }
}

/// Provides options for retrieving a list of parts of an archive that have been uploaded in a specific multipart upload.
public struct ListPartsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of parts to be returned. The default limit is 50. The number of parts returned might be fewer than the specified limit, but the number of returned parts never exceeds the limit.
    public var limit: Swift.Int?
    /// An opaque string used for pagination. This value specifies the part at which the listing of parts should begin. Get the marker value from the response of a previous List Parts response. You need only include the marker if you are continuing the pagination of results started in a previous List Parts request.
    public var marker: Swift.String?
    /// The upload ID of the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct ListPartsInputBody: Swift.Equatable {
}

extension ListPartsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPartsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPartsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveDescription = output.archiveDescription
            self.creationDate = output.creationDate
            self.marker = output.marker
            self.multipartUploadId = output.multipartUploadId
            self.partSizeInBytes = output.partSizeInBytes
            self.parts = output.parts
            self.vaultARN = output.vaultARN
        } else {
            self.archiveDescription = nil
            self.creationDate = nil
            self.marker = nil
            self.multipartUploadId = nil
            self.partSizeInBytes = 0
            self.parts = nil
            self.vaultARN = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct ListPartsOutputResponse: Swift.Equatable {
    /// The description of the archive that was specified in the Initiate Multipart Upload request.
    public var archiveDescription: Swift.String?
    /// The UTC time at which the multipart upload was initiated.
    public var creationDate: Swift.String?
    /// An opaque string that represents where to continue pagination of the results. You use the marker in a new List Parts request to obtain more jobs in the list. If there are no more parts, this value is null.
    public var marker: Swift.String?
    /// The ID of the upload to which the parts are associated.
    public var multipartUploadId: Swift.String?
    /// The part size in bytes. This is the same value that you specified in the Initiate Multipart Upload request.
    public var partSizeInBytes: Swift.Int
    /// A list of the part sizes of the multipart upload. Each object in the array contains a RangeBytes and sha256-tree-hash name/value pair.
    public var parts: [GlacierClientTypes.PartListElement]?
    /// The Amazon Resource Name (ARN) of the vault to which the multipart upload was initiated.
    public var vaultARN: Swift.String?

    public init (
        archiveDescription: Swift.String? = nil,
        creationDate: Swift.String? = nil,
        marker: Swift.String? = nil,
        multipartUploadId: Swift.String? = nil,
        partSizeInBytes: Swift.Int = 0,
        parts: [GlacierClientTypes.PartListElement]? = nil,
        vaultARN: Swift.String? = nil
    )
    {
        self.archiveDescription = archiveDescription
        self.creationDate = creationDate
        self.marker = marker
        self.multipartUploadId = multipartUploadId
        self.partSizeInBytes = partSizeInBytes
        self.parts = parts
        self.vaultARN = vaultARN
    }
}

struct ListPartsOutputResponseBody: Swift.Equatable {
    let multipartUploadId: Swift.String?
    let vaultARN: Swift.String?
    let archiveDescription: Swift.String?
    let partSizeInBytes: Swift.Int
    let creationDate: Swift.String?
    let parts: [GlacierClientTypes.PartListElement]?
    let marker: Swift.String?
}

extension ListPartsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case marker = "Marker"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case parts = "Parts"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSizeInBytes) ?? 0
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let partsContainer = try containerValues.decodeIfPresent([GlacierClientTypes.PartListElement?].self, forKey: .parts)
        var partsDecoded0:[GlacierClientTypes.PartListElement]? = nil
        if let partsContainer = partsContainer {
            partsDecoded0 = [GlacierClientTypes.PartListElement]()
            for structure0 in partsContainer {
                if let structure0 = structure0 {
                    partsDecoded0?.append(structure0)
                }
            }
        }
        parts = partsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListProvisionedCapacityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/provisioned-capacity"
    }
}

public struct ListProvisionedCapacityInput: Swift.Equatable {
    /// The AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, don't include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct ListProvisionedCapacityInputBody: Swift.Equatable {
}

extension ListProvisionedCapacityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProvisionedCapacityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProvisionedCapacityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.provisionedCapacityList = output.provisionedCapacityList
        } else {
            self.provisionedCapacityList = nil
        }
    }
}

public struct ListProvisionedCapacityOutputResponse: Swift.Equatable {
    /// The response body contains the following JSON fields.
    public var provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]?

    public init (
        provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]? = nil
    )
    {
        self.provisionedCapacityList = provisionedCapacityList
    }
}

struct ListProvisionedCapacityOutputResponseBody: Swift.Equatable {
    let provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]?
}

extension ListProvisionedCapacityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedCapacityList = "ProvisionedCapacityList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedCapacityListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.ProvisionedCapacityDescription?].self, forKey: .provisionedCapacityList)
        var provisionedCapacityListDecoded0:[GlacierClientTypes.ProvisionedCapacityDescription]? = nil
        if let provisionedCapacityListContainer = provisionedCapacityListContainer {
            provisionedCapacityListDecoded0 = [GlacierClientTypes.ProvisionedCapacityDescription]()
            for structure0 in provisionedCapacityListContainer {
                if let structure0 = structure0 {
                    provisionedCapacityListDecoded0?.append(structure0)
                }
            }
        }
        provisionedCapacityList = provisionedCapacityListDecoded0
    }
}

extension ListTagsForVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/tags"
    }
}

/// The input value for ListTagsForVaultInput.
public struct ListTagsForVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct ListTagsForVaultInputBody: Swift.Equatable {
}

extension ListTagsForVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct ListTagsForVaultOutputResponse: Swift.Equatable {
    /// The tags attached to the vault. Each tag is composed of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForVaultOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVaultsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            return items
        }
    }
}

extension ListVaultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults"
    }
}

/// Provides options to retrieve the vault list owned by the calling user's account. The list provides metadata information for each vault.
public struct ListVaultsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of vaults to be returned. The default limit is 10. The number of vaults returned might be fewer than the specified limit, but the number of returned vaults never exceeds the limit.
    public var limit: Swift.Int?
    /// A string used for pagination. The marker specifies the vault ARN after which the listing of vaults should begin.
    public var marker: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
    }
}

struct ListVaultsInputBody: Swift.Equatable {
}

extension ListVaultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVaultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVaultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVaultsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVaultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVaultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.vaultList = output.vaultList
        } else {
            self.marker = nil
            self.vaultList = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct ListVaultsOutputResponse: Swift.Equatable {
    /// The vault ARN at which to continue pagination of the results. You use the marker in another List Vaults request to obtain more vaults in the list.
    public var marker: Swift.String?
    /// List of vaults.
    public var vaultList: [GlacierClientTypes.DescribeVaultOutput]?

    public init (
        marker: Swift.String? = nil,
        vaultList: [GlacierClientTypes.DescribeVaultOutput]? = nil
    )
    {
        self.marker = marker
        self.vaultList = vaultList
    }
}

struct ListVaultsOutputResponseBody: Swift.Equatable {
    let vaultList: [GlacierClientTypes.DescribeVaultOutput]?
    let marker: Swift.String?
}

extension ListVaultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case vaultList = "VaultList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.DescribeVaultOutput?].self, forKey: .vaultList)
        var vaultListDecoded0:[GlacierClientTypes.DescribeVaultOutput]? = nil
        if let vaultListContainer = vaultListContainer {
            vaultListDecoded0 = [GlacierClientTypes.DescribeVaultOutput]()
            for structure0 in vaultListContainer {
                if let structure0 = structure0 {
                    vaultListDecoded0?.append(structure0)
                }
            }
        }
        vaultList = vaultListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension MissingParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a required header or parameter is missing from the request.
public struct MissingParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 400 Bad Request
    public var code: Swift.String?
    /// Returned if no authentication data is found for the request.
    public var message: Swift.String?
    /// Client.
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension MissingParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.OutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(GlacierClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the location where the select job results are stored.
    public struct OutputLocation: Swift.Equatable {
        /// Describes an S3 location that will receive the results of the job request.
        public var s3: GlacierClientTypes.S3Location?

        public init (
            s3: GlacierClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension GlacierClientTypes.OutputSerialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CSVOutput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension GlacierClientTypes {
    /// Describes how the select output is serialized.
    public struct OutputSerialization: Swift.Equatable {
        /// Describes the serialization of CSV-encoded query results.
        public var csv: GlacierClientTypes.CSVOutput?

        public init (
            csv: GlacierClientTypes.CSVOutput? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension GlacierClientTypes.PartListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rangeInBytes = "RangeInBytes"
        case sha256TreeHash = "SHA256TreeHash"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rangeInBytes = self.rangeInBytes {
            try encodeContainer.encode(rangeInBytes, forKey: .rangeInBytes)
        }
        if let sha256TreeHash = self.sha256TreeHash {
            try encodeContainer.encode(sha256TreeHash, forKey: .sha256TreeHash)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangeInBytesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeInBytes)
        rangeInBytes = rangeInBytesDecoded
        let sha256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha256TreeHash)
        sha256TreeHash = sha256TreeHashDecoded
    }
}

extension GlacierClientTypes {
    /// A list of the part sizes of the multipart upload.
    public struct PartListElement: Swift.Equatable {
        /// The byte range of a part, inclusive of the upper value of the range.
        public var rangeInBytes: Swift.String?
        /// The SHA256 tree hash value that Amazon S3 Glacier calculated for the part. This field is never null.
        public var sha256TreeHash: Swift.String?

        public init (
            rangeInBytes: Swift.String? = nil,
            sha256TreeHash: Swift.String? = nil
        )
        {
            self.rangeInBytes = rangeInBytes
            self.sha256TreeHash = sha256TreeHash
        }
    }

}

extension GlacierClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension PolicyEnforcedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PolicyEnforcedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a retrieval job would exceed the current data policy's retrieval rate limit. For more information about data retrieval policies,
public struct PolicyEnforcedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// PolicyEnforcedException
    public var code: Swift.String?
    /// InitiateJob request denied by current data retrieval policy.
    public var message: Swift.String?
    /// Client
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct PolicyEnforcedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension PolicyEnforcedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.ProvisionedCapacityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityId = "CapacityId"
        case expirationDate = "ExpirationDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityId = self.capacityId {
            try encodeContainer.encode(capacityId, forKey: .capacityId)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encode(expirationDate, forKey: .expirationDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityId)
        capacityId = capacityIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension GlacierClientTypes {
    /// The definition for a provisioned capacity unit.
    public struct ProvisionedCapacityDescription: Swift.Equatable {
        /// The ID that identifies the provisioned capacity unit.
        public var capacityId: Swift.String?
        /// The date that the provisioned capacity unit expires, in Universal Coordinated Time (UTC).
        public var expirationDate: Swift.String?
        /// The date that the provisioned capacity unit was purchased, in Universal Coordinated Time (UTC).
        public var startDate: Swift.String?

        public init (
            capacityId: Swift.String? = nil,
            expirationDate: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.capacityId = capacityId
            self.expirationDate = expirationDate
            self.startDate = startDate
        }
    }

}

extension PurchaseProvisionedCapacityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/provisioned-capacity"
    }
}

public struct PurchaseProvisionedCapacityInput: Swift.Equatable {
    /// The AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, don't include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct PurchaseProvisionedCapacityInputBody: Swift.Equatable {
}

extension PurchaseProvisionedCapacityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PurchaseProvisionedCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseProvisionedCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PurchaseProvisionedCapacityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseProvisionedCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let capacityIdHeaderValue = httpResponse.headers.value(for: "x-amz-capacity-id") {
            self.capacityId = capacityIdHeaderValue
        } else {
            self.capacityId = nil
        }
    }
}

public struct PurchaseProvisionedCapacityOutputResponse: Swift.Equatable {
    /// The ID that identifies the provisioned capacity unit.
    public var capacityId: Swift.String?

    public init (
        capacityId: Swift.String? = nil
    )
    {
        self.capacityId = capacityId
    }
}

extension GlacierClientTypes {
    public enum QuoteFields: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case asneeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QuoteFields] {
            return [
                .always,
                .asneeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .asneeded: return "ASNEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuoteFields(rawValue: rawValue) ?? QuoteFields.sdkUnknown(rawValue)
        }
    }
}

extension RemoveTagsFromVaultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension RemoveTagsFromVaultInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "remove"))
            return items
        }
    }
}

extension RemoveTagsFromVaultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/tags"
    }
}

/// The input value for RemoveTagsFromVaultInput.
public struct RemoveTagsFromVaultInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// A list of tag keys. Each corresponding tag is removed from the vault.
    public var tagKeys: [Swift.String]?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.tagKeys = tagKeys
        self.vaultName = vaultName
    }
}

struct RemoveTagsFromVaultInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsFromVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromVaultOutputResponse: Swift.Equatable {

    public init () { }
}

extension RequestTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the upload.
public struct RequestTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 408 Request Timeout
    public var code: Swift.String?
    /// Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the upload.
    public var message: Swift.String?
    /// Client
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// 404 Not Found
    public var code: Swift.String?
    /// Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't exist.
    public var message: Swift.String?
    /// Client
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case bucketName = "BucketName"
        case cannedACL = "CannedACL"
        case encryption = "Encryption"
        case `prefix` = "Prefix"
        case storageClass = "StorageClass"
        case tagging = "Tagging"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            var accessControlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlList)
            for grant0 in accessControlList {
                try accessControlListContainer.encode(grant0)
            }
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedACL = self.cannedACL {
            try encodeContainer.encode(cannedACL.rawValue, forKey: .cannedACL)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tagging = tagging {
            var taggingContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagging)
            for (dictKey0, hashmap0) in tagging {
                try taggingContainer.encode(hashmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userMetadata)
            for (dictKey0, hashmap0) in userMetadata {
                try userMetadataContainer.encode(hashmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let cannedACLDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CannedACL.self, forKey: .cannedACL)
        cannedACL = cannedACLDecoded
        let accessControlListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.Grant?].self, forKey: .accessControlList)
        var accessControlListDecoded0:[GlacierClientTypes.Grant]? = nil
        if let accessControlListContainer = accessControlListContainer {
            accessControlListDecoded0 = [GlacierClientTypes.Grant]()
            for structure0 in accessControlListContainer {
                if let structure0 = structure0 {
                    accessControlListDecoded0?.append(structure0)
                }
            }
        }
        accessControlList = accessControlListDecoded0
        let taggingContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagging)
        var taggingDecoded0: [Swift.String:Swift.String]? = nil
        if let taggingContainer = taggingContainer {
            taggingDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in taggingContainer {
                if let string0 = string0 {
                    taggingDecoded0?[key0] = string0
                }
            }
        }
        tagging = taggingDecoded0
        let userMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
        let storageClassDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the location in Amazon S3 where the select job results are stored.
    public struct S3Location: Swift.Equatable {
        /// A list of grants that control access to the staged results.
        public var accessControlList: [GlacierClientTypes.Grant]?
        /// The name of the Amazon S3 bucket where the job results are stored.
        public var bucketName: Swift.String?
        /// The canned access control list (ACL) to apply to the job results.
        public var cannedACL: GlacierClientTypes.CannedACL?
        /// Contains information about the encryption used to store the job results in Amazon S3.
        public var encryption: GlacierClientTypes.Encryption?
        /// The prefix that is prepended to the results for this request.
        public var `prefix`: Swift.String?
        /// The storage class used to store the job results.
        public var storageClass: GlacierClientTypes.StorageClass?
        /// The tag-set that is applied to the job results.
        public var tagging: [Swift.String:Swift.String]?
        /// A map of metadata to store with the job results in Amazon S3.
        public var userMetadata: [Swift.String:Swift.String]?

        public init (
            accessControlList: [GlacierClientTypes.Grant]? = nil,
            bucketName: Swift.String? = nil,
            cannedACL: GlacierClientTypes.CannedACL? = nil,
            encryption: GlacierClientTypes.Encryption? = nil,
            `prefix`: Swift.String? = nil,
            storageClass: GlacierClientTypes.StorageClass? = nil,
            tagging: [Swift.String:Swift.String]? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessControlList = accessControlList
            self.bucketName = bucketName
            self.cannedACL = cannedACL
            self.encryption = encryption
            self.`prefix` = `prefix`
            self.storageClass = storageClass
            self.tagging = tagging
            self.userMetadata = userMetadata
        }
    }

}

extension GlacierClientTypes.SelectParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = self.expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let inputSerialization = self.inputSerialization {
            try encodeContainer.encode(inputSerialization, forKey: .inputSerialization)
        }
        if let outputSerialization = self.outputSerialization {
            try encodeContainer.encode(outputSerialization, forKey: .outputSerialization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSerializationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
    }
}

extension GlacierClientTypes {
    /// Contains information about the parameters used for a select.
    public struct SelectParameters: Swift.Equatable {
        /// The expression that is used to select the object.
        public var expression: Swift.String?
        /// The type of the provided expression, for example SQL.
        public var expressionType: GlacierClientTypes.ExpressionType?
        /// Describes the serialization format of the object.
        public var inputSerialization: GlacierClientTypes.InputSerialization?
        /// Describes how the results of the select job are serialized.
        public var outputSerialization: GlacierClientTypes.OutputSerialization?

        public init (
            expression: Swift.String? = nil,
            expressionType: GlacierClientTypes.ExpressionType? = nil,
            inputSerialization: GlacierClientTypes.InputSerialization? = nil,
            outputSerialization: GlacierClientTypes.OutputSerialization? = nil
        )
        {
            self.expression = expression
            self.expressionType = expressionType
            self.inputSerialization = inputSerialization
            self.outputSerialization = outputSerialization
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the service cannot complete the request.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// 500 Internal Server Error
    public var code: Swift.String?
    /// Returned if the service cannot complete the request.
    public var message: Swift.String?
    /// Server
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let code: Swift.String?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetDataRetrievalPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension SetDataRetrievalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/policies/data-retrieval"
    }
}

/// SetDataRetrievalPolicy input.
public struct SetDataRetrievalPolicyInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The data retrieval policy in JSON format.
    public var policy: GlacierClientTypes.DataRetrievalPolicy?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.DataRetrievalPolicy? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
    }
}

struct SetDataRetrievalPolicyInputBody: Swift.Equatable {
    let policy: GlacierClientTypes.DataRetrievalPolicy?
}

extension SetDataRetrievalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetDataRetrievalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetDataRetrievalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetDataRetrievalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDataRetrievalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetDataRetrievalPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

public struct SetVaultAccessPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let policy = input.operationInput.policy {
                let policydata = try encoder.encode(policy)
                let policybody = ClientRuntime.HttpBody.data(policydata)
                input.builder.withBody(policybody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let policydata = "{}".data(using: .utf8)!
                    let policybody = ClientRuntime.HttpBody.data(policydata)
                    input.builder.withBody(policybody)
                }
            }
        } catch let err {
            throw SdkError<SetVaultAccessPolicyOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension SetVaultAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension SetVaultAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/access-policy"
    }
}

/// SetVaultAccessPolicy input.
public struct SetVaultAccessPolicyInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The vault access policy as a JSON string.
    public var policy: GlacierClientTypes.VaultAccessPolicy?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.VaultAccessPolicy? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct SetVaultAccessPolicyInputBody: Swift.Equatable {
    let policy: GlacierClientTypes.VaultAccessPolicy?
}

extension SetVaultAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

public struct SetVaultNotificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let vaultNotificationConfig = input.operationInput.vaultNotificationConfig {
                let vaultNotificationConfigdata = try encoder.encode(vaultNotificationConfig)
                let vaultNotificationConfigbody = ClientRuntime.HttpBody.data(vaultNotificationConfigdata)
                input.builder.withBody(vaultNotificationConfigbody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let vaultNotificationConfigdata = "{}".data(using: .utf8)!
                    let vaultNotificationConfigbody = ClientRuntime.HttpBody.data(vaultNotificationConfigdata)
                    input.builder.withBody(vaultNotificationConfigbody)
                }
            }
        } catch let err {
            throw SdkError<SetVaultNotificationsOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension SetVaultNotificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vaultNotificationConfig = self.vaultNotificationConfig {
            try encodeContainer.encode(vaultNotificationConfig, forKey: .vaultNotificationConfig)
        }
    }
}

extension SetVaultNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/notification-configuration"
    }
}

/// Provides options to configure notifications that will be sent when specific events happen to a vault.
public struct SetVaultNotificationsInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?
    /// Provides options for specifying notification configuration.
    public var vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil,
        vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct SetVaultNotificationsInputBody: Swift.Equatable {
    let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?
}

extension SetVaultNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension SetVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultNotificationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension GlacierClientTypes {
    public enum StatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusCode] {
            return [
                .failed,
                .inprogress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusCode(rawValue: rawValue) ?? StatusCode.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reducedredundancy
        case standard
        case standardinfrequentaccess
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .reducedredundancy,
                .standard,
                .standardinfrequentaccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reducedredundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardinfrequentaccess: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazoncustomerbyemail
        case canonicaluser
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .amazoncustomerbyemail,
                .canonicaluser,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazoncustomerbyemail: return "AmazonCustomerByEmail"
            case .canonicaluser: return "CanonicalUser"
            case .group: return "Group"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

public struct UploadArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadArchiveInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UploadArchiveOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UploadArchiveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.toBytes().getData(), forKey: .body)
        }
    }
}

extension UploadArchiveInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let archiveDescription = archiveDescription {
            items.add(Header(name: "x-amz-archive-description", value: Swift.String(archiveDescription)))
        }
        if let checksum = checksum {
            items.add(Header(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum)))
        }
        return items
    }
}

extension UploadArchiveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/archives"
    }
}

/// Provides options to add an archive to a vault.
public struct UploadArchiveInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The optional description of the archive you are uploading.
    public var archiveDescription: Swift.String?
    /// The data to upload.
    public var body: ClientRuntime.ByteStream?
    /// The SHA256 tree hash of the data being uploaded.
    public var checksum: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.vaultName = vaultName
    }
}

struct UploadArchiveInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension UploadArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadArchiveOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request. For information about the underlying REST API, see [Upload Archive](https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html). For conceptual information, see [Working with Archives in Amazon S3 Glacier](https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html).
public struct UploadArchiveOutputResponse: Swift.Equatable {
    /// The ID of the archive. This value is also included as part of the location.
    public var archiveId: Swift.String?
    /// The checksum of the archive computed by Amazon S3 Glacier.
    public var checksum: Swift.String?
    /// The relative URI path of the newly added archive resource.
    public var location: Swift.String?

    public init (
        archiveId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

extension GlacierClientTypes.UploadListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveDescription = self.archiveDescription {
            try encodeContainer.encode(archiveDescription, forKey: .archiveDescription)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let multipartUploadId = self.multipartUploadId {
            try encodeContainer.encode(multipartUploadId, forKey: .multipartUploadId)
        }
        if partSizeInBytes != 0 {
            try encodeContainer.encode(partSizeInBytes, forKey: .partSizeInBytes)
        }
        if let vaultARN = self.vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSizeInBytes) ?? 0
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GlacierClientTypes {
    /// A list of in-progress multipart uploads for a vault.
    public struct UploadListElement: Swift.Equatable {
        /// The description of the archive that was specified in the Initiate Multipart Upload request.
        public var archiveDescription: Swift.String?
        /// The UTC time at which the multipart upload was initiated.
        public var creationDate: Swift.String?
        /// The ID of a multipart upload.
        public var multipartUploadId: Swift.String?
        /// The part size, in bytes, specified in the Initiate Multipart Upload request. This is the size of all the parts in the upload except the last part, which may be smaller than this size.
        public var partSizeInBytes: Swift.Int
        /// The Amazon Resource Name (ARN) of the vault that contains the archive.
        public var vaultARN: Swift.String?

        public init (
            archiveDescription: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            multipartUploadId: Swift.String? = nil,
            partSizeInBytes: Swift.Int = 0,
            vaultARN: Swift.String? = nil
        )
        {
            self.archiveDescription = archiveDescription
            self.creationDate = creationDate
            self.multipartUploadId = multipartUploadId
            self.partSizeInBytes = partSizeInBytes
            self.vaultARN = vaultARN
        }
    }

}

public struct UploadMultipartPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadMultipartPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadMultipartPartInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UploadMultipartPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.toBytes().getData(), forKey: .body)
        }
    }
}

extension UploadMultipartPartInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let checksum = checksum {
            items.add(Header(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum)))
        }
        if let range = range {
            items.add(Header(name: "Content-Range", value: Swift.String(range)))
        }
        return items
    }
}

extension UploadMultipartPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let vaultName = vaultName else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/\(accountId.urlPercentEncoding())/vaults/\(vaultName.urlPercentEncoding())/multipart-uploads/\(uploadId.urlPercentEncoding())"
    }
}

/// Provides options to upload a part of an archive in a multipart upload operation.
public struct UploadMultipartPartInput: Swift.Equatable {
    /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The data to upload.
    public var body: ClientRuntime.ByteStream?
    /// The SHA256 tree hash of the data being uploaded.
    public var checksum: Swift.String?
    /// Identifies the range of bytes in the assembled archive that will be uploaded in this part. Amazon S3 Glacier uses this information to assemble the archive in the proper sequence. The format of this header follows RFC 2616. An example header is Content-Range:bytes 0-4194303/*.
    public var range: Swift.String?
    /// The upload ID of the multipart upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The name of the vault.
    /// This member is required.
    public var vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        range: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.body = body
        self.checksum = checksum
        self.range = range
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct UploadMultipartPartInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension UploadMultipartPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadMultipartPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadMultipartPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadMultipartPartOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadMultipartPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
    }
}

/// Contains the Amazon S3 Glacier response to your request.
public struct UploadMultipartPartOutputResponse: Swift.Equatable {
    /// The SHA256 tree hash that Amazon S3 Glacier computed for the uploaded part.
    public var checksum: Swift.String?

    public init (
        checksum: Swift.String? = nil
    )
    {
        self.checksum = checksum
    }
}

extension GlacierClientTypes.VaultAccessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GlacierClientTypes {
    /// Contains the vault access policy.
    public struct VaultAccessPolicy: Swift.Equatable {
        /// The vault access policy.
        public var policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension GlacierClientTypes.VaultLockPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GlacierClientTypes {
    /// Contains the vault lock policy.
    public struct VaultLockPolicy: Swift.Equatable {
        /// The vault lock policy.
        public var policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension GlacierClientTypes.VaultNotificationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case snsTopic = "SNSTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for string0 in events {
                try eventsContainer.encode(string0)
            }
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlacierClientTypes {
    /// Represents a vault's notification configuration.
    public struct VaultNotificationConfig: Swift.Equatable {
        /// A list of one or more events for which Amazon S3 Glacier will send a notification to the specified Amazon SNS topic.
        public var events: [Swift.String]?
        /// The Amazon Simple Notification Service (Amazon SNS) topic Amazon Resource Name (ARN).
        public var snsTopic: Swift.String?

        public init (
            events: [Swift.String]? = nil,
            snsTopic: Swift.String? = nil
        )
        {
            self.events = events
            self.snsTopic = snsTopic
        }
    }

}
