// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DataZoneClientTypes.AcceptChoice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictionChoice
        case predictionTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictionChoice = self.predictionChoice {
            try encodeContainer.encode(predictionChoice, forKey: .predictionChoice)
        }
        if let predictionTarget = self.predictionTarget {
            try encodeContainer.encode(predictionTarget, forKey: .predictionTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictionTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionTarget)
        predictionTarget = predictionTargetDecoded
        let predictionChoiceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionChoice)
        predictionChoice = predictionChoiceDecoded
    }
}

extension DataZoneClientTypes {
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
    public struct AcceptChoice: Swift.Equatable {
        /// Specifies the prediction (aka, the automatically generated piece of metadata) that can be accepted.
        public var predictionChoice: Swift.Int?
        /// Specifies the target (for example, a column name) where a prediction can be accepted.
        public var predictionTarget: Swift.String?

        public init(
            predictionChoice: Swift.Int? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.predictionChoice = predictionChoice
            self.predictionTarget = predictionTarget
        }
    }

}

extension AcceptPredictionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptChoices
        case acceptRule
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptChoices = acceptChoices {
            var acceptChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceptChoices)
            for acceptchoice0 in acceptChoices {
                try acceptChoicesContainer.encode(acceptchoice0)
            }
        }
        if let acceptRule = self.acceptRule {
            try encodeContainer.encode(acceptRule, forKey: .acceptRule)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension AcceptPredictionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revision = revision {
                let revisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
                items.append(revisionQueryItem)
            }
            return items
        }
    }
}

extension AcceptPredictionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/accept-predictions"
    }
}

public struct AcceptPredictionsInput: Swift.Equatable {
    ///
    public var acceptChoices: [DataZoneClientTypes.AcceptChoice]?
    /// Specifies the rule (or the conditions) under which a prediction can be accepted.
    public var acceptRule: DataZoneClientTypes.AcceptRule?
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    ///
    /// This member is required.
    public var identifier: Swift.String?
    ///
    public var revision: Swift.String?

    public init(
        acceptChoices: [DataZoneClientTypes.AcceptChoice]? = nil,
        acceptRule: DataZoneClientTypes.AcceptRule? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.acceptChoices = acceptChoices
        self.acceptRule = acceptRule
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

struct AcceptPredictionsInputBody: Swift.Equatable {
    let acceptRule: DataZoneClientTypes.AcceptRule?
    let acceptChoices: [DataZoneClientTypes.AcceptChoice]?
    let clientToken: Swift.String?
}

extension AcceptPredictionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptChoices
        case acceptRule
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptRuleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AcceptRule.self, forKey: .acceptRule)
        acceptRule = acceptRuleDecoded
        let acceptChoicesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.AcceptChoice?].self, forKey: .acceptChoices)
        var acceptChoicesDecoded0:[DataZoneClientTypes.AcceptChoice]? = nil
        if let acceptChoicesContainer = acceptChoicesContainer {
            acceptChoicesDecoded0 = [DataZoneClientTypes.AcceptChoice]()
            for structure0 in acceptChoicesContainer {
                if let structure0 = structure0 {
                    acceptChoicesDecoded0?.append(structure0)
                }
            }
        }
        acceptChoices = acceptChoicesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcceptPredictionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptPredictionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetId = output.assetId
            self.domainId = output.domainId
            self.revision = output.revision
        } else {
            self.assetId = nil
            self.domainId = nil
            self.revision = nil
        }
    }
}

public struct AcceptPredictionsOutput: Swift.Equatable {
    ///
    /// This member is required.
    public var assetId: Swift.String?
    ///
    /// This member is required.
    public var domainId: Swift.String?
    ///
    /// This member is required.
    public var revision: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.domainId = domainId
        self.revision = revision
    }
}

struct AcceptPredictionsOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let assetId: Swift.String?
    let revision: Swift.String?
}

extension AcceptPredictionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case domainId
        case revision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

enum AcceptPredictionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.AcceptRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = self.rule {
            try encodeContainer.encode(rule.rawValue, forKey: .rule)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AcceptRuleBehavior.self, forKey: .rule)
        rule = ruleDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension DataZoneClientTypes {
    /// Specifies the rule and the threshold under which a prediction can be accepted.
    public struct AcceptRule: Swift.Equatable {
        /// Specifies whether you want to accept the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.AcceptRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be accepted.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.AcceptRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }

}

extension DataZoneClientTypes {
    public enum AcceptRuleBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptRuleBehavior] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptRuleBehavior(rawValue: rawValue) ?? AcceptRuleBehavior.sdkUnknown(rawValue)
        }
    }
}

extension AcceptSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

extension AcceptSubscriptionRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decisionComment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decisionComment = self.decisionComment {
            try encodeContainer.encode(decisionComment, forKey: .decisionComment)
        }
    }
}

extension AcceptSubscriptionRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/accept"
    }
}

public struct AcceptSubscriptionRequestInput: Swift.Equatable {
    /// A description that specifies the reason for accepting the specified subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain where the specified subscription request is being accepted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription request that is to be accepted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct AcceptSubscriptionRequestInputBody: Swift.Equatable {
    let decisionComment: Swift.String?
}

extension AcceptSubscriptionRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decisionComment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

extension AcceptSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension AcceptSubscriptionRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptSubscriptionRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.decisionComment = output.decisionComment
            self.domainId = output.domainId
            self.id = output.id
            self.requestReason = output.requestReason
            self.reviewerId = output.reviewerId
            self.status = output.status
            self.subscribedListings = output.subscribedListings
            self.subscribedPrincipals = output.subscribedPrincipals
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.decisionComment = nil
            self.domainId = nil
            self.id = nil
            self.requestReason = nil
            self.reviewerId = nil
            self.status = nil
            self.subscribedListings = nil
            self.subscribedPrincipals = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct AcceptSubscriptionRequestOutput: Swift.Equatable {
    /// The timestamp that specifies when the subscription request was accepted.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user that accepted the specified subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Specifies the reason for accepting the subscription request.
    public var decisionComment: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the specified subscription request was accepted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the reason for requesting a subscription to the asset.
    /// This member is required.
    public var requestReason: Swift.String?
    /// Specifes the ID of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// Specifies the status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// Specifies the asset for which the subscription request was created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// Specifies the Amazon DataZone users who are subscribed to the asset specified in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// Specifies the timestamp when subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct AcceptSubscriptionRequestOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionRequestStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let requestReason: Swift.String?
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    let reviewerId: Swift.String?
    let decisionComment: Swift.String?
}

extension AcceptSubscriptionRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

enum AcceptSubscriptionRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes.AssetItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case createdAt
        case createdBy
        case description
        case domainId
        case externalIdentifier
        case firstRevisionCreatedAt
        case firstRevisionCreatedBy
        case glossaryTerms
        case identifier
        case name
        case owningProjectId
        case typeIdentifier
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = self.additionalAttributes {
            try encodeContainer.encode(additionalAttributes, forKey: .additionalAttributes)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let externalIdentifier = self.externalIdentifier {
            try encodeContainer.encode(externalIdentifier, forKey: .externalIdentifier)
        }
        if let firstRevisionCreatedAt = self.firstRevisionCreatedAt {
            try encodeContainer.encodeTimestamp(firstRevisionCreatedAt, format: .epochSeconds, forKey: .firstRevisionCreatedAt)
        }
        if let firstRevisionCreatedBy = self.firstRevisionCreatedBy {
            try encodeContainer.encode(firstRevisionCreatedBy, forKey: .firstRevisionCreatedBy)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
        if let typeIdentifier = self.typeIdentifier {
            try encodeContainer.encode(typeIdentifier, forKey: .typeIdentifier)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let externalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalIdentifier)
        externalIdentifier = externalIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let firstRevisionCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstRevisionCreatedAt)
        firstRevisionCreatedAt = firstRevisionCreatedAtDecoded
        let firstRevisionCreatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstRevisionCreatedBy)
        firstRevisionCreatedBy = firstRevisionCreatedByDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let additionalAttributesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AssetItemAdditionalAttributes.self, forKey: .additionalAttributes)
        additionalAttributes = additionalAttributesDecoded
    }
}

extension DataZoneClientTypes.AssetItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), owningProjectId: \(Swift.String(describing: owningProjectId)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// A Amazon DataZone inventory asset.
    public struct AssetItem: Swift.Equatable {
        /// The additional attributes of a Amazon DataZone inventory asset.
        public var additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes?
        /// The timestamp of when the Amazon DataZone inventory asset was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the inventory asset.
        public var createdBy: Swift.String?
        /// The description of an Amazon DataZone inventory asset.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the inventory asset exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The external identifier of the Amazon DataZone inventory asset.
        public var externalIdentifier: Swift.String?
        /// The timestamp of when the first revision of the inventory asset was created.
        public var firstRevisionCreatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the first revision of the inventory asset.
        public var firstRevisionCreatedBy: Swift.String?
        /// The glossary terms attached to the Amazon DataZone inventory asset.
        public var glossaryTerms: [Swift.String]?
        /// the identifier of the Amazon DataZone inventory asset.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the Amazon DataZone inventory asset.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the inventory asset.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The identifier of the asset type of the specified Amazon DataZone inventory asset.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision of the inventory asset type.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            externalIdentifier: Swift.String? = nil,
            firstRevisionCreatedAt: ClientRuntime.Date? = nil,
            firstRevisionCreatedBy: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.owningProjectId = owningProjectId
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.AssetItemAdditionalAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formsOutput
        case readOnlyFormsOutput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formsOutput = formsOutput {
            var formsOutputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formsOutput)
            for formoutput0 in formsOutput {
                try formsOutputContainer.encode(formoutput0)
            }
        }
        if let readOnlyFormsOutput = readOnlyFormsOutput {
            var readOnlyFormsOutputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readOnlyFormsOutput)
            for formoutput0 in readOnlyFormsOutput {
                try readOnlyFormsOutputContainer.encode(formoutput0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in formsOutputContainer {
                if let structure0 = structure0 {
                    formsOutputDecoded0?.append(structure0)
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let readOnlyFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .readOnlyFormsOutput)
        var readOnlyFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let readOnlyFormsOutputContainer = readOnlyFormsOutputContainer {
            readOnlyFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in readOnlyFormsOutputContainer {
                if let structure0 = structure0 {
                    readOnlyFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        readOnlyFormsOutput = readOnlyFormsOutputDecoded0
    }
}

extension DataZoneClientTypes {
    /// The additional attributes of an inventory asset.
    public struct AssetItemAdditionalAttributes: Swift.Equatable {
        /// The forms included in the additional attributes of an inventory asset.
        public var formsOutput: [DataZoneClientTypes.FormOutput]?
        /// The read-only forms included in the additional attributes of an inventory asset.
        public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?

        public init(
            formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
            readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil
        )
        {
            self.formsOutput = formsOutput
            self.readOnlyFormsOutput = readOnlyFormsOutput
        }
    }

}

extension DataZoneClientTypes.AssetListing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetRevision
        case assetType
        case createdAt
        case forms
        case glossaryTerms
        case owningProjectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let assetRevision = self.assetRevision {
            try encodeContainer.encode(assetRevision, forKey: .assetRevision)
        }
        if let assetType = self.assetType {
            try encodeContainer.encode(assetType, forKey: .assetType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let forms = self.forms {
            try encodeContainer.encode(forms, forKey: .forms)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for detailedglossaryterm0 in glossaryTerms {
                try glossaryTermsContainer.encode(detailedglossaryterm0)
            }
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetRevision)
        assetRevision = assetRevisionDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let formsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forms)
        forms = formsDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DetailedGlossaryTerm?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [DataZoneClientTypes.DetailedGlossaryTerm]()
            for structure0 in glossaryTermsContainer {
                if let structure0 = structure0 {
                    glossaryTermsDecoded0?.append(structure0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
    }
}

extension DataZoneClientTypes {
    /// An asset published in an Amazon DataZone catalog.
    public struct AssetListing: Swift.Equatable {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public var assetId: Swift.String?
        /// The revision of an asset published in an Amazon DataZone catalog.
        public var assetRevision: Swift.String?
        /// The type of an asset published in an Amazon DataZone catalog.
        public var assetType: Swift.String?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: ClientRuntime.Date?
        /// The metadata forms attached to an asset published in an Amazon DataZone catalog.
        public var forms: Swift.String?
        /// The glossary terms attached to an asset published in an Amazon DataZone catalog.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The identifier of the project where an asset published in an Amazon DataZone catalog exists.
        public var owningProjectId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            assetType: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetType = assetType
            self.createdAt = createdAt
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.owningProjectId = owningProjectId
        }
    }

}

extension DataZoneClientTypes.AssetListingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listingId
        case listingStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listingId = self.listingId {
            try encodeContainer.encode(listingId, forKey: .listingId)
        }
        if let listingStatus = self.listingStatus {
            try encodeContainer.encode(listingStatus.rawValue, forKey: .listingStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
        let listingStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ListingStatus.self, forKey: .listingStatus)
        listingStatus = listingStatusDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingDetails: Swift.Equatable {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingId: Swift.String?
        /// The status of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingStatus: DataZoneClientTypes.ListingStatus?

        public init(
            listingId: Swift.String? = nil,
            listingStatus: DataZoneClientTypes.ListingStatus? = nil
        )
        {
            self.listingId = listingId
            self.listingStatus = listingStatus
        }
    }

}

extension DataZoneClientTypes.AssetListingItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case createdAt
        case description
        case entityId
        case entityRevision
        case entityType
        case glossaryTerms
        case listingCreatedBy
        case listingId
        case listingRevision
        case listingUpdatedBy
        case name
        case owningProjectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = self.additionalAttributes {
            try encodeContainer.encode(additionalAttributes, forKey: .additionalAttributes)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityRevision = self.entityRevision {
            try encodeContainer.encode(entityRevision, forKey: .entityRevision)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for detailedglossaryterm0 in glossaryTerms {
                try glossaryTermsContainer.encode(detailedglossaryterm0)
            }
        }
        if let listingCreatedBy = self.listingCreatedBy {
            try encodeContainer.encode(listingCreatedBy, forKey: .listingCreatedBy)
        }
        if let listingId = self.listingId {
            try encodeContainer.encode(listingId, forKey: .listingId)
        }
        if let listingRevision = self.listingRevision {
            try encodeContainer.encode(listingRevision, forKey: .listingRevision)
        }
        if let listingUpdatedBy = self.listingUpdatedBy {
            try encodeContainer.encode(listingUpdatedBy, forKey: .listingUpdatedBy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
        let listingRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingRevision)
        listingRevision = listingRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityRevision)
        entityRevision = entityRevisionDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let listingCreatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingCreatedBy)
        listingCreatedBy = listingCreatedByDecoded
        let listingUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingUpdatedBy)
        listingUpdatedBy = listingUpdatedByDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DetailedGlossaryTerm?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [DataZoneClientTypes.DetailedGlossaryTerm]()
            for structure0 in glossaryTermsContainer {
                if let structure0 = structure0 {
                    glossaryTermsDecoded0?.append(structure0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let additionalAttributesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AssetListingItemAdditionalAttributes.self, forKey: .additionalAttributes)
        additionalAttributes = additionalAttributesDecoded
    }
}

extension DataZoneClientTypes.AssetListingItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetListingItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), entityId: \(Swift.String(describing: entityId)), entityRevision: \(Swift.String(describing: entityRevision)), entityType: \(Swift.String(describing: entityType)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), listingCreatedBy: \(Swift.String(describing: listingCreatedBy)), listingId: \(Swift.String(describing: listingId)), listingRevision: \(Swift.String(describing: listingRevision)), listingUpdatedBy: \(Swift.String(describing: listingUpdatedBy)), owningProjectId: \(Swift.String(describing: owningProjectId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingItem: Swift.Equatable {
        /// The additional attributes of an asset published in an Amazon DataZone catalog.
        public var additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of an asset published in an Amazon DataZone catalog.
        public var description: Swift.String?
        /// The identifier of the inventory asset.
        public var entityId: Swift.String?
        /// The revision of the inventory asset.
        public var entityRevision: Swift.String?
        /// The type of the inventory asset.
        public var entityType: Swift.String?
        /// Glossary terms attached to the inventory asset.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The Amazon DataZone user who created the listing.
        public var listingCreatedBy: Swift.String?
        /// The identifier of the listing (asset published in Amazon DataZone catalog).
        public var listingId: Swift.String?
        /// The revision of the listing (asset published in Amazon DataZone catalog).
        public var listingRevision: Swift.String?
        /// The Amazon DataZone user who updated the listing.
        public var listingUpdatedBy: Swift.String?
        /// The name of the inventory asset.
        public var name: Swift.String?
        /// The identifier of the project that owns the inventory asset.
        public var owningProjectId: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            listingCreatedBy: Swift.String? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil,
            listingUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.glossaryTerms = glossaryTerms
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }
    }

}

extension DataZoneClientTypes.AssetListingItemAdditionalAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forms
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forms = self.forms {
            try encodeContainer.encode(forms, forKey: .forms)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forms)
        forms = formsDecoded
    }
}

extension DataZoneClientTypes {
    /// Additional attributes of an inventory asset.
    public struct AssetListingItemAdditionalAttributes: Swift.Equatable {
        /// The metadata forms that form additional attributes of the metadata asset.
        public var forms: Swift.String?

        public init(
            forms: Swift.String? = nil
        )
        {
            self.forms = forms
        }
    }

}

extension DataZoneClientTypes.AssetRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case id
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DataZoneClientTypes {
    /// The revision of an inventory asset.
    public struct AssetRevision: Swift.Equatable {
        /// The timestamp of when an inventory asset revison was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the asset revision.
        public var createdBy: Swift.String?
        /// The Amazon DataZone user who created the inventory asset.
        public var domainId: Swift.String?
        /// The identifier of the inventory asset revision.
        public var id: Swift.String?
        /// The revision details of the inventory asset.
        public var revision: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.AssetTargetNameMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case targetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension DataZoneClientTypes {
    ///
    public struct AssetTargetNameMap: Swift.Equatable {
        /// The identifier of the inventory asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The target name in the asset target name map.
        /// This member is required.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.targetName = targetName
        }
    }

}

extension DataZoneClientTypes.AssetTypeItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case formsOutput
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let formsOutput = formsOutput {
            var formsOutputContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formsOutput)
            for (dictKey0, formsOutputMap0) in formsOutput {
                try formsOutputContainer.encode(formsOutputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let originDomainId = self.originDomainId {
            try encodeContainer.encode(originDomainId, forKey: .originDomainId)
        }
        if let originProjectId = self.originProjectId {
            try encodeContainer.encode(originProjectId, forKey: .originProjectId)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([Swift.String: DataZoneClientTypes.FormEntryOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [Swift.String:DataZoneClientTypes.FormEntryOutput]()
            for (key0, formentryoutput0) in formsOutputContainer {
                if let formentryoutput0 = formentryoutput0 {
                    formsOutputDecoded0?[key0] = formentryoutput0
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DataZoneClientTypes.AssetTypeItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetTypeItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the asset type.
    public struct AssetTypeItem: Swift.Equatable {
        /// The timestamp of when the asset type was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the asset type.
        public var createdBy: Swift.String?
        /// The description of the asset type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The forms included in the details of the asset type.
        /// This member is required.
        public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
        /// The name of the asset type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the Amazon DataZone project where the asset type exists.
        public var originProjectId: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the asset type.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The revision of the asset type.
        /// This member is required.
        public var revision: Swift.String?
        /// The timestamp of when the asset type was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the asset type.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case iamIdc
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .disabled,
                .iamIdc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .iamIdc: return "IAM_IDC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.BusinessNameGenerationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DataZoneClientTypes {
    /// The configuration of the business name generation.
    public struct BusinessNameGenerationConfiguration: Swift.Equatable {
        /// Specifies whether the business name generation is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension CancelSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/cancel"
    }
}

public struct CancelSubscriptionInput: Swift.Equatable {
    /// The unique identifier of the Amazon DataZone domain where the subscription request is being cancelled.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription that is being cancelled.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct CancelSubscriptionInputBody: Swift.Equatable {
}

extension CancelSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.id = output.id
            self.retainPermissions = output.retainPermissions
            self.status = output.status
            self.subscribedListing = output.subscribedListing
            self.subscribedPrincipal = output.subscribedPrincipal
            self.subscriptionRequestId = output.subscriptionRequestId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.id = nil
            self.retainPermissions = nil
            self.status = nil
            self.subscribedListing = nil
            self.subscribedPrincipal = nil
            self.subscriptionRequestId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct CancelSubscriptionOutput: Swift.Equatable {
    /// The timestamp that specifies when the request to cancel the subscription was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user who is cancelling the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the subscription is being cancelled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether the permissions to the asset are retained after the subscription is cancelled.
    public var retainPermissions: Swift.Bool?
    /// The status of the request to cancel the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The asset to which a subscription is being cancelled.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The Amazon DataZone user who is made a subscriber to the specified asset by the subscription that is being cancelled.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The unique ID of the subscripton request for the subscription that is being cancelled.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp that specifies when the subscription was cancelled.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that cancelled the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct CancelSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    let subscribedListing: DataZoneClientTypes.SubscribedListing?
    let subscriptionRequestId: Swift.String?
    let retainPermissions: Swift.Bool?
}

extension CancelSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case id
        case retainPermissions
        case status
        case subscribedListing
        case subscribedPrincipal
        case subscriptionRequestId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscribedPrincipalDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedPrincipal.self, forKey: .subscribedPrincipal)
        subscribedPrincipal = subscribedPrincipalDecoded
        let subscribedListingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedListing.self, forKey: .subscribedListing)
        subscribedListing = subscribedListingDecoded
        let subscriptionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionRequestId)
        subscriptionRequestId = subscriptionRequestIdDecoded
        let retainPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPermissions)
        retainPermissions = retainPermissionsDecoded
    }
}

enum CancelSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes {
    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publish
        case unpublish
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .publish,
                .unpublish,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .unpublish: return "UNPUBLISH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.CloudFormationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUrl = self.templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension DataZoneClientTypes {
    /// Part of the provisioning properties of the environment blueprint.
    public struct CloudFormationProperties: Swift.Equatable {
        /// The template URL of the cloud formation provisioning properties of the environment blueprint.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init(
            templateUrl: Swift.String? = nil
        )
        {
            self.templateUrl = templateUrl
        }
    }

}

extension DataZoneClientTypes.ConfigurableActionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the parameters for the configurable environment action.
    public struct ConfigurableActionParameter: Swift.Equatable {
        /// The key of the configurable action parameter.
        public var key: Swift.String?
        /// The value of the configurable action parameter.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension DataZoneClientTypes {
    public enum ConfigurableActionTypeAuthorization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurableActionTypeAuthorization] {
            return [
                .https,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurableActionTypeAuthorization(rawValue: rawValue) ?? ConfigurableActionTypeAuthorization.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.ConfigurableEnvironmentAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth
        case parameters
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auth = self.auth {
            try encodeContainer.encode(auth.rawValue, forKey: .auth)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for configurableactionparameter0 in parameters {
                try parametersContainer.encode(configurableactionparameter0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let authDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ConfigurableActionTypeAuthorization.self, forKey: .auth)
        auth = authDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ConfigurableActionParameter?].self, forKey: .parameters)
        var parametersDecoded0:[DataZoneClientTypes.ConfigurableActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DataZoneClientTypes.ConfigurableActionParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DataZoneClientTypes {
    /// The configurable action of a Amazon DataZone environment.
    public struct ConfigurableEnvironmentAction: Swift.Equatable {
        /// The authentication type of a configurable action of a Amazon DataZone environment.
        public var auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization?
        /// The parameters of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var parameters: [DataZoneClientTypes.ConfigurableActionParameter]?
        /// The type of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?

        public init(
            auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization? = nil,
            parameters: [DataZoneClientTypes.ConfigurableActionParameter]? = nil,
            type: Swift.String? = nil
        )
        {
            self.auth = auth
            self.parameters = parameters
            self.type = type
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a conflict while performing this action.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case externalIdentifier
        case formsInput
        case glossaryTerms
        case name
        case owningProjectIdentifier
        case predictionConfiguration
        case typeIdentifier
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let externalIdentifier = self.externalIdentifier {
            try encodeContainer.encode(externalIdentifier, forKey: .externalIdentifier)
        }
        if let formsInput = formsInput {
            var formsInputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formsInput)
            for forminput0 in formsInput {
                try formsInputContainer.encode(forminput0)
            }
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectIdentifier = self.owningProjectIdentifier {
            try encodeContainer.encode(owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }
        if let predictionConfiguration = self.predictionConfiguration {
            try encodeContainer.encode(predictionConfiguration, forKey: .predictionConfiguration)
        }
        if let typeIdentifier = self.typeIdentifier {
            try encodeContainer.encode(typeIdentifier, forKey: .typeIdentifier)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }
}

extension CreateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets"
    }
}

public struct CreateAssetInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Asset description.
    public var description: Swift.String?
    /// Amazon DataZone domain where the asset is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    ///
    public var externalIdentifier: Swift.String?
    /// Metadata forms attached to the asset.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// Glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// Asset name.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the project that owns this asset.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The unique identifier of this asset's type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of this asset's type.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.externalIdentifier = externalIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.predictionConfiguration = predictionConfiguration
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

struct CreateAssetInputBody: Swift.Equatable {
    let name: Swift.String?
    let externalIdentifier: Swift.String?
    let typeIdentifier: Swift.String?
    let typeRevision: Swift.String?
    let description: Swift.String?
    let glossaryTerms: [Swift.String]?
    let formsInput: [DataZoneClientTypes.FormInput]?
    let owningProjectIdentifier: Swift.String?
    let predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    let clientToken: Swift.String?
}

extension CreateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case externalIdentifier
        case formsInput
        case glossaryTerms
        case name
        case owningProjectIdentifier
        case predictionConfiguration
        case typeIdentifier
        case typeRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let externalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalIdentifier)
        externalIdentifier = externalIdentifierDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let formsInputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormInput?].self, forKey: .formsInput)
        var formsInputDecoded0:[DataZoneClientTypes.FormInput]? = nil
        if let formsInputContainer = formsInputContainer {
            formsInputDecoded0 = [DataZoneClientTypes.FormInput]()
            for structure0 in formsInputContainer {
                if let structure0 = structure0 {
                    formsInputDecoded0?.append(structure0)
                }
            }
        }
        formsInput = formsInputDecoded0
        let owningProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectIdentifier)
        owningProjectIdentifier = owningProjectIdentifierDecoded
        let predictionConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.PredictionConfiguration.self, forKey: .predictionConfiguration)
        predictionConfiguration = predictionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.externalIdentifier = output.externalIdentifier
            self.firstRevisionCreatedAt = output.firstRevisionCreatedAt
            self.firstRevisionCreatedBy = output.firstRevisionCreatedBy
            self.formsOutput = output.formsOutput
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.listing = output.listing
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.predictionConfiguration = output.predictionConfiguration
            self.readOnlyFormsOutput = output.readOnlyFormsOutput
            self.revision = output.revision
            self.typeIdentifier = output.typeIdentifier
            self.typeRevision = output.typeRevision
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.externalIdentifier = nil
            self.firstRevisionCreatedAt = nil
            self.firstRevisionCreatedBy = nil
            self.formsOutput = nil
            self.glossaryTerms = nil
            self.id = nil
            self.listing = nil
            self.name = nil
            self.owningProjectId = nil
            self.predictionConfiguration = nil
            self.readOnlyFormsOutput = nil
            self.revision = nil
            self.typeIdentifier = nil
            self.typeRevision = nil
        }
    }
}

public struct CreateAssetOutput: Swift.Equatable {
    /// The timestamp of when the asset was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user that created this asset in the catalog.
    public var createdBy: Swift.String?
    /// The description of the created asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset was created.
    /// This member is required.
    public var domainId: Swift.String?
    ///
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset took place.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that made the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that are attached to the created asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that are attached to the created asset.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the created asset.
    /// This member is required.
    public var id: Swift.String?
    ///
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the created asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns the created asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that are attached to the created asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the created asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

struct CreateAssetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let typeIdentifier: Swift.String?
    let typeRevision: Swift.String?
    let externalIdentifier: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let firstRevisionCreatedAt: ClientRuntime.Date?
    let firstRevisionCreatedBy: Swift.String?
    let glossaryTerms: [Swift.String]?
    let owningProjectId: Swift.String?
    let domainId: Swift.String?
    let listing: DataZoneClientTypes.AssetListingDetails?
    let formsOutput: [DataZoneClientTypes.FormOutput]?
    let readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    let predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
}

extension CreateAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case externalIdentifier
        case firstRevisionCreatedAt
        case firstRevisionCreatedBy
        case formsOutput
        case glossaryTerms
        case id
        case listing
        case name
        case owningProjectId
        case predictionConfiguration
        case readOnlyFormsOutput
        case revision
        case typeIdentifier
        case typeRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let externalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalIdentifier)
        externalIdentifier = externalIdentifierDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let firstRevisionCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstRevisionCreatedAt)
        firstRevisionCreatedAt = firstRevisionCreatedAtDecoded
        let firstRevisionCreatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstRevisionCreatedBy)
        firstRevisionCreatedBy = firstRevisionCreatedByDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let listingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AssetListingDetails.self, forKey: .listing)
        listing = listingDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in formsOutputContainer {
                if let structure0 = structure0 {
                    formsOutputDecoded0?.append(structure0)
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let readOnlyFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .readOnlyFormsOutput)
        var readOnlyFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let readOnlyFormsOutputContainer = readOnlyFormsOutputContainer {
            readOnlyFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in readOnlyFormsOutputContainer {
                if let structure0 = structure0 {
                    readOnlyFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        readOnlyFormsOutput = readOnlyFormsOutputDecoded0
        let predictionConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.PredictionConfiguration.self, forKey: .predictionConfiguration)
        predictionConfiguration = predictionConfigurationDecoded
    }
}

enum CreateAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetRevisionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case formsInput
        case glossaryTerms
        case name
        case predictionConfiguration
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let formsInput = formsInput {
            var formsInputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formsInput)
            for forminput0 in formsInput {
                try formsInputContainer.encode(forminput0)
            }
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionConfiguration = self.predictionConfiguration {
            try encodeContainer.encode(predictionConfiguration, forKey: .predictionConfiguration)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }
}

extension CreateAssetRevisionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

public struct CreateAssetRevisionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The revised description of the asset.
    public var description: Swift.String?
    /// The unique identifier of the domain where the asset is being revised.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms to be attached to the asset as part of asset revision.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// The glossary terms to be attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// Te revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The revision type of the asset.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
        self.predictionConfiguration = predictionConfiguration
        self.typeRevision = typeRevision
    }
}

struct CreateAssetRevisionInputBody: Swift.Equatable {
    let name: Swift.String?
    let typeRevision: Swift.String?
    let description: Swift.String?
    let glossaryTerms: [Swift.String]?
    let formsInput: [DataZoneClientTypes.FormInput]?
    let predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    let clientToken: Swift.String?
}

extension CreateAssetRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case formsInput
        case glossaryTerms
        case name
        case predictionConfiguration
        case typeRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let formsInputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormInput?].self, forKey: .formsInput)
        var formsInputDecoded0:[DataZoneClientTypes.FormInput]? = nil
        if let formsInputContainer = formsInputContainer {
            formsInputDecoded0 = [DataZoneClientTypes.FormInput]()
            for structure0 in formsInputContainer {
                if let structure0 = structure0 {
                    formsInputDecoded0?.append(structure0)
                }
            }
        }
        formsInput = formsInputDecoded0
        let predictionConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.PredictionConfiguration.self, forKey: .predictionConfiguration)
        predictionConfiguration = predictionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAssetRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssetRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.externalIdentifier = output.externalIdentifier
            self.firstRevisionCreatedAt = output.firstRevisionCreatedAt
            self.firstRevisionCreatedBy = output.firstRevisionCreatedBy
            self.formsOutput = output.formsOutput
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.listing = output.listing
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.predictionConfiguration = output.predictionConfiguration
            self.readOnlyFormsOutput = output.readOnlyFormsOutput
            self.revision = output.revision
            self.typeIdentifier = output.typeIdentifier
            self.typeRevision = output.typeRevision
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.externalIdentifier = nil
            self.firstRevisionCreatedAt = nil
            self.firstRevisionCreatedBy = nil
            self.formsOutput = nil
            self.glossaryTerms = nil
            self.id = nil
            self.listing = nil
            self.name = nil
            self.owningProjectId = nil
            self.predictionConfiguration = nil
            self.readOnlyFormsOutput = nil
            self.revision = nil
            self.typeIdentifier = nil
            self.typeRevision = nil
        }
    }
}

public struct CreateAssetRevisionOutput: Swift.Equatable {
    /// The timestamp of when the asset revision occured.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who performed the asset revision.
    public var createdBy: Swift.String?
    /// The revised asset description.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the asset was revised.
    /// This member is required.
    public var domainId: Swift.String?
    ///
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first asset revision occured.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who performed the first asset revision.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that were attached to the asset as part of the asset revision.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that were attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the asset revision.
    /// This member is required.
    public var id: Swift.String?
    ///
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the revised project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that were attached to the asset as part of the asset revision.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the revision type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

struct CreateAssetRevisionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let typeIdentifier: Swift.String?
    let typeRevision: Swift.String?
    let externalIdentifier: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let firstRevisionCreatedAt: ClientRuntime.Date?
    let firstRevisionCreatedBy: Swift.String?
    let glossaryTerms: [Swift.String]?
    let owningProjectId: Swift.String?
    let domainId: Swift.String?
    let listing: DataZoneClientTypes.AssetListingDetails?
    let formsOutput: [DataZoneClientTypes.FormOutput]?
    let readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    let predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
}

extension CreateAssetRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case externalIdentifier
        case firstRevisionCreatedAt
        case firstRevisionCreatedBy
        case formsOutput
        case glossaryTerms
        case id
        case listing
        case name
        case owningProjectId
        case predictionConfiguration
        case readOnlyFormsOutput
        case revision
        case typeIdentifier
        case typeRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let externalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalIdentifier)
        externalIdentifier = externalIdentifierDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let firstRevisionCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstRevisionCreatedAt)
        firstRevisionCreatedAt = firstRevisionCreatedAtDecoded
        let firstRevisionCreatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstRevisionCreatedBy)
        firstRevisionCreatedBy = firstRevisionCreatedByDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let listingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AssetListingDetails.self, forKey: .listing)
        listing = listingDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in formsOutputContainer {
                if let structure0 = structure0 {
                    formsOutputDecoded0?.append(structure0)
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let readOnlyFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .readOnlyFormsOutput)
        var readOnlyFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let readOnlyFormsOutputContainer = readOnlyFormsOutputContainer {
            readOnlyFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in readOnlyFormsOutputContainer {
                if let structure0 = structure0 {
                    readOnlyFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        readOnlyFormsOutput = readOnlyFormsOutputDecoded0
        let predictionConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.PredictionConfiguration.self, forKey: .predictionConfiguration)
        predictionConfiguration = predictionConfigurationDecoded
    }
}

enum CreateAssetRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssetTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), formsInput: \(Swift.String(describing: formsInput)), name: \(Swift.String(describing: name)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), description: \"CONTENT_REDACTED\")"}
}

extension CreateAssetTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case formsInput
        case name
        case owningProjectIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let formsInput = formsInput {
            var formsInputContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formsInput)
            for (dictKey0, formsInputMap0) in formsInput {
                try formsInputContainer.encode(formsInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectIdentifier = self.owningProjectIdentifier {
            try encodeContainer.encode(owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }
    }
}

extension CreateAssetTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types"
    }
}

public struct CreateAssetTypeInput: Swift.Equatable {
    /// The descripton of the custom asset type.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the custom asset type is being created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms that are to be attached to the custom asset type.
    /// This member is required.
    public var formsInput: [Swift.String:DataZoneClientTypes.FormEntryInput]?
    /// The name of the custom asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project that is to own the custom asset type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [Swift.String:DataZoneClientTypes.FormEntryInput]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
    }
}

struct CreateAssetTypeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let formsInput: [Swift.String:DataZoneClientTypes.FormEntryInput]?
    let owningProjectIdentifier: Swift.String?
}

extension CreateAssetTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case formsInput
        case name
        case owningProjectIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let formsInputContainer = try containerValues.decodeIfPresent([Swift.String: DataZoneClientTypes.FormEntryInput?].self, forKey: .formsInput)
        var formsInputDecoded0: [Swift.String:DataZoneClientTypes.FormEntryInput]? = nil
        if let formsInputContainer = formsInputContainer {
            formsInputDecoded0 = [Swift.String:DataZoneClientTypes.FormEntryInput]()
            for (key0, formentryinput0) in formsInputContainer {
                if let formentryinput0 = formentryinput0 {
                    formsInputDecoded0?[key0] = formentryinput0
                }
            }
        }
        formsInput = formsInputDecoded0
        let owningProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectIdentifier)
        owningProjectIdentifier = owningProjectIdentifierDecoded
    }
}

extension CreateAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension CreateAssetTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssetTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.formsOutput = output.formsOutput
            self.name = output.name
            self.originDomainId = output.originDomainId
            self.originProjectId = output.originProjectId
            self.owningProjectId = output.owningProjectId
            self.revision = output.revision
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.formsOutput = nil
            self.name = nil
            self.originDomainId = nil
            self.originProjectId = nil
            self.owningProjectId = nil
            self.revision = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct CreateAssetTypeOutput: Swift.Equatable {
    /// The timestamp of when the asset type is to be created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who creates this custom asset type.
    public var createdBy: Swift.String?
    /// The description of the custom asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms that are attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain where the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project where the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that currently owns this asset type.
    public var owningProjectId: Swift.String?
    /// The revision of the custom asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the custom type was created.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that created the custom asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct CreateAssetTypeOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    let owningProjectId: Swift.String?
    let originDomainId: Swift.String?
    let originProjectId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension CreateAssetTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case formsOutput
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([Swift.String: DataZoneClientTypes.FormEntryOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [Swift.String:DataZoneClientTypes.FormEntryOutput]()
            for (key0, formentryoutput0) in formsOutputContainer {
                if let formentryoutput0 = formentryoutput0 {
                    formsOutputDecoded0?[key0] = formentryoutput0
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum CreateAssetTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), type: \(Swift.String(describing: type)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsInput
        case clientToken
        case configuration
        case description
        case enableSetting
        case environmentIdentifier
        case name
        case projectIdentifier
        case publishOnImport
        case recommendation
        case schedule
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetFormsInput = assetFormsInput {
            var assetFormsInputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetFormsInput)
            for forminput0 in assetFormsInput {
                try assetFormsInputContainer.encode(forminput0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableSetting = self.enableSetting {
            try encodeContainer.encode(enableSetting.rawValue, forKey: .enableSetting)
        }
        if let environmentIdentifier = self.environmentIdentifier {
            try encodeContainer.encode(environmentIdentifier, forKey: .environmentIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectIdentifier = self.projectIdentifier {
            try encodeContainer.encode(projectIdentifier, forKey: .projectIdentifier)
        }
        if let publishOnImport = self.publishOnImport {
            try encodeContainer.encode(publishOnImport, forKey: .publishOnImport)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The metadata forms that are to be attached to the assets that this data source works with.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the data source is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which you want to add this data source.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The type of the data source.
    /// This member is required.
    public var type: Swift.String?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        clientToken: Swift.String? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.type = type
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let projectIdentifier: Swift.String?
    let environmentIdentifier: Swift.String?
    let type: Swift.String?
    let configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    let recommendation: DataZoneClientTypes.RecommendationConfiguration?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let publishOnImport: Swift.Bool?
    let assetFormsInput: [DataZoneClientTypes.FormInput]?
    let clientToken: Swift.String?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsInput
        case clientToken
        case configuration
        case description
        case enableSetting
        case environmentIdentifier
        case name
        case projectIdentifier
        case publishOnImport
        case recommendation
        case schedule
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let projectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectIdentifier)
        projectIdentifier = projectIdentifierDecoded
        let environmentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentIdentifier)
        environmentIdentifier = environmentIdentifierDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationInput.self, forKey: .configuration)
        configuration = configurationDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RecommendationConfiguration.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsInputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormInput?].self, forKey: .assetFormsInput)
        var assetFormsInputDecoded0:[DataZoneClientTypes.FormInput]? = nil
        if let assetFormsInputContainer = assetFormsInputContainer {
            assetFormsInputDecoded0 = [DataZoneClientTypes.FormInput]()
            for structure0 in assetFormsInputContainer {
                if let structure0 = structure0 {
                    assetFormsInputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsInput = assetFormsInputDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension CreateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetFormsOutput = output.assetFormsOutput
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.domainId = output.domainId
            self.enableSetting = output.enableSetting
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.lastRunAt = output.lastRunAt
            self.lastRunErrorMessage = output.lastRunErrorMessage
            self.lastRunStatus = output.lastRunStatus
            self.name = output.name
            self.projectId = output.projectId
            self.publishOnImport = output.publishOnImport
            self.recommendation = output.recommendation
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.assetFormsOutput = nil
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.domainId = nil
            self.enableSetting = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.id = nil
            self.lastRunAt = nil
            self.lastRunErrorMessage = nil
            self.lastRunStatus = nil
            self.name = nil
            self.projectId = nil
            self.publishOnImport = nil
            self.recommendation = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDataSourceOutput: Swift.Equatable {
    /// The metadata forms attached to the assets that this data source creates.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The unique identifier of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp that specifies when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project to which the data source is added.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct CreateDataSourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: DataZoneClientTypes.DataSourceStatus?
    let type: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    let recommendation: DataZoneClientTypes.RecommendationConfiguration?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let publishOnImport: Swift.Bool?
    let assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    let lastRunAt: ClientRuntime.Date?
    let lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension CreateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsOutput
        case configuration
        case createdAt
        case description
        case domainId
        case enableSetting
        case environmentId
        case errorMessage
        case id
        case lastRunAt
        case lastRunErrorMessage
        case lastRunStatus
        case name
        case projectId
        case publishOnImport
        case recommendation
        case schedule
        case status
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationOutput.self, forKey: .configuration)
        configuration = configurationDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RecommendationConfiguration.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .assetFormsOutput)
        var assetFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let assetFormsOutputContainer = assetFormsOutputContainer {
            assetFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in assetFormsOutputContainer {
                if let structure0 = structure0 {
                    assetFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsOutput = assetFormsOutputDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunAt)
        lastRunAt = lastRunAtDecoded
        let lastRunErrorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .lastRunErrorMessage)
        lastRunErrorMessage = lastRunErrorMessageDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case domainExecutionRole
        case kmsKeyIdentifier
        case name
        case singleSignOn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainExecutionRole = self.domainExecutionRole {
            try encodeContainer.encode(domainExecutionRole, forKey: .domainExecutionRole)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let singleSignOn = self.singleSignOn {
            try encodeContainer.encode(singleSignOn, forKey: .singleSignOn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domains"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    /// This member is required.
    public var name: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.singleSignOn = singleSignOn
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let singleSignOn: DataZoneClientTypes.SingleSignOn?
    let domainExecutionRole: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case domainExecutionRole
        case kmsKeyIdentifier
        case name
        case singleSignOn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let singleSignOnDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SingleSignOn.self, forKey: .singleSignOn)
        singleSignOn = singleSignOnDecoded
        let domainExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainExecutionRole)
        domainExecutionRole = domainExecutionRoleDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.domainExecutionRole = output.domainExecutionRole
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.portalUrl = output.portalUrl
            self.singleSignOn = output.singleSignOn
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.domainExecutionRole = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.portalUrl = nil
            self.singleSignOn = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainOutput: Swift.Equatable {
    /// The ARN of the Amazon DataZone domain.
    public var arn: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the Amazon DataZone domain.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.portalUrl = portalUrl
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

struct CreateDomainOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let singleSignOn: DataZoneClientTypes.SingleSignOn?
    let domainExecutionRole: Swift.String?
    let arn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let status: DataZoneClientTypes.DomainStatus?
    let portalUrl: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case domainExecutionRole
        case id
        case kmsKeyIdentifier
        case name
        case portalUrl
        case singleSignOn
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let singleSignOnDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SingleSignOn.self, forKey: .singleSignOn)
        singleSignOn = singleSignOnDecoded
        let domainExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainExecutionRole)
        domainExecutionRole = domainExecutionRoleDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let portalUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalUrl)
        portalUrl = portalUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentProfileIdentifier
        case glossaryTerms
        case name
        case projectIdentifier
        case userParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentProfileIdentifier = self.environmentProfileIdentifier {
            try encodeContainer.encode(environmentProfileIdentifier, forKey: .environmentProfileIdentifier)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectIdentifier = self.projectIdentifier {
            try encodeContainer.encode(projectIdentifier, forKey: .projectIdentifier)
        }
        if let userParameters = userParameters {
            var userParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userParameters)
            for environmentparameter0 in userParameters {
                try userParametersContainer.encode(environmentparameter0)
            }
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The description of the Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment profile that is used to create this Amazon DataZone environment.
    /// This member is required.
    public var environmentProfileIdentifier: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone environment.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let projectIdentifier: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let environmentProfileIdentifier: Swift.String?
    let userParameters: [DataZoneClientTypes.EnvironmentParameter]?
    let glossaryTerms: [Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentProfileIdentifier
        case glossaryTerms
        case name
        case projectIdentifier
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectIdentifier)
        projectIdentifier = projectIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentProfileIdentifier)
        environmentProfileIdentifier = environmentProfileIdentifierDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.EnvironmentParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.EnvironmentParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

extension CreateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.deploymentProperties = output.deploymentProperties
            self.description = output.description
            self.domainId = output.domainId
            self.environmentActions = output.environmentActions
            self.environmentBlueprintId = output.environmentBlueprintId
            self.environmentProfileId = output.environmentProfileId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastDeployment = output.lastDeployment
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.provisionedResources = output.provisionedResources
            self.provisioningProperties = output.provisioningProperties
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.deploymentProperties = nil
            self.description = nil
            self.domainId = nil
            self.environmentActions = nil
            self.environmentBlueprintId = nil
            self.environmentProfileId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastDeployment = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.provisionedResources = nil
            self.provisioningProperties = nil
            self.status = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which the Amazon DataZone environment is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of this Amazon DataZone environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The configurable actions of this Amazon DataZone environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The ID of the blueprint with which this Amazon DataZone environment was created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which this Amazon DataZone environment was created.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone environment.
    public var id: Swift.String?
    /// The details of the last deployment of this Amazon DataZone environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of this environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let projectId: Swift.String?
    let id: Swift.String?
    let domainId: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentProfileId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let provider: Swift.String?
    let provisionedResources: [DataZoneClientTypes.Resource]?
    let status: DataZoneClientTypes.EnvironmentStatus?
    let environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    let glossaryTerms: [Swift.String]?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
    let lastDeployment: DataZoneClientTypes.Deployment?
    let provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    let deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    let environmentBlueprintId: Swift.String?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case deploymentProperties
        case description
        case domainId
        case environmentActions
        case environmentBlueprintId
        case environmentProfileId
        case glossaryTerms
        case id
        case lastDeployment
        case name
        case projectId
        case provider
        case provisionedResources
        case provisioningProperties
        case status
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentProfileId)
        environmentProfileId = environmentProfileIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.Resource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[DataZoneClientTypes.Resource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [DataZoneClientTypes.Resource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentActionsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ConfigurableEnvironmentAction?].self, forKey: .environmentActions)
        var environmentActionsDecoded0:[DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil
        if let environmentActionsContainer = environmentActionsContainer {
            environmentActionsDecoded0 = [DataZoneClientTypes.ConfigurableEnvironmentAction]()
            for structure0 in environmentActionsContainer {
                if let structure0 = structure0 {
                    environmentActionsDecoded0?.append(structure0)
                }
            }
        }
        environmentActions = environmentActionsDecoded0
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let lastDeploymentDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Deployment.self, forKey: .lastDeployment)
        lastDeployment = lastDeploymentDecoded
        let provisioningPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ProvisioningProperties.self, forKey: .provisioningProperties)
        provisioningProperties = provisioningPropertiesDecoded
        let deploymentPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentProperties.self, forKey: .deploymentProperties)
        deploymentProperties = deploymentPropertiesDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case description
        case environmentBlueprintIdentifier
        case name
        case projectIdentifier
        case userParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsAccountRegion = self.awsAccountRegion {
            try encodeContainer.encode(awsAccountRegion, forKey: .awsAccountRegion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentBlueprintIdentifier = self.environmentBlueprintIdentifier {
            try encodeContainer.encode(environmentBlueprintIdentifier, forKey: .environmentBlueprintIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectIdentifier = self.projectIdentifier {
            try encodeContainer.encode(projectIdentifier, forKey: .projectIdentifier)
        }
        if let userParameters = userParameters {
            var userParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userParameters)
            for environmentparameter0 in userParameters {
                try userParametersContainer.encode(environmentparameter0)
            }
        }
    }
}

extension CreateEnvironmentProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

public struct CreateEnvironmentProfileInput: Swift.Equatable {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to create the environment profile.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

struct CreateEnvironmentProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let environmentBlueprintIdentifier: Swift.String?
    let projectIdentifier: Swift.String?
    let userParameters: [DataZoneClientTypes.EnvironmentParameter]?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
}

extension CreateEnvironmentProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case description
        case environmentBlueprintIdentifier
        case name
        case projectIdentifier
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentBlueprintIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintIdentifier)
        environmentBlueprintIdentifier = environmentBlueprintIdentifierDecoded
        let projectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectIdentifier)
        projectIdentifier = projectIdentifierDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.EnvironmentParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.EnvironmentParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
    }
}

extension CreateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.environmentBlueprintId = output.environmentBlueprintId
            self.id = output.id
            self.name = output.name
            self.projectId = output.projectId
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.environmentBlueprintId = nil
            self.id = nil
            self.name = nil
            self.projectId = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct CreateEnvironmentProfileOutput: Swift.Equatable {
    /// The Amazon Web Services account ID in which this Amazon DataZone environment profile is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this Amazon DataZone environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of this Amazon DataZone environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct CreateEnvironmentProfileOutputBody: Swift.Equatable {
    let id: Swift.String?
    let domainId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentBlueprintId: Swift.String?
    let projectId: Swift.String?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
}

extension CreateEnvironmentProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case description
        case domainId
        case environmentBlueprintId
        case id
        case name
        case projectId
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
    }
}

enum CreateEnvironmentProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFormTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateFormTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case model
        case name
        case owningProjectIdentifier
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectIdentifier = self.owningProjectIdentifier {
            try encodeContainer.encode(owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension CreateFormTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types"
    }
}

public struct CreateFormTypeInput: Swift.Equatable {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The model of this Amazon DataZone metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns this metadata form type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this Amazon DataZone metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.model = model
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

struct CreateFormTypeInputBody: Swift.Equatable {
    let name: Swift.String?
    let model: DataZoneClientTypes.Model?
    let owningProjectIdentifier: Swift.String?
    let status: DataZoneClientTypes.FormTypeStatus?
    let description: Swift.String?
}

extension CreateFormTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case model
        case name
        case owningProjectIdentifier
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modelDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Model.self, forKey: .model)
        model = modelDecoded
        let owningProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectIdentifier)
        owningProjectIdentifier = owningProjectIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FormTypeStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeOutput(domainId: \(Swift.String(describing: domainId)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateFormTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFormTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domainId = output.domainId
            self.name = output.name
            self.originDomainId = output.originDomainId
            self.originProjectId = output.originProjectId
            self.owningProjectId = output.owningProjectId
            self.revision = output.revision
        } else {
            self.description = nil
            self.domainId = nil
            self.name = nil
            self.originDomainId = nil
            self.originProjectId = nil
            self.owningProjectId = nil
            self.revision = nil
        }
    }
}

public struct CreateFormTypeOutput: Swift.Equatable {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this Amazon DataZone metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this Amazon DataZone metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of this Amazon DataZone metadata form type.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
    }
}

struct CreateFormTypeOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let owningProjectId: Swift.String?
    let originDomainId: Swift.String?
    let originProjectId: Swift.String?
}

extension CreateFormTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainId
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
    }
}

enum CreateFormTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case owningProjectIdentifier
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectIdentifier = self.owningProjectIdentifier {
            try encodeContainer.encode(owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension CreateGlossaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries"
    }
}

public struct CreateGlossaryInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns business glossary.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

struct CreateGlossaryInputBody: Swift.Equatable {
    let name: Swift.String?
    let owningProjectIdentifier: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.GlossaryStatus?
    let clientToken: Swift.String?
}

extension CreateGlossaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case owningProjectIdentifier
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectIdentifier)
        owningProjectIdentifier = owningProjectIdentifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGlossaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domainId = output.domainId
            self.id = output.id
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.status = output.status
        } else {
            self.description = nil
            self.domainId = nil
            self.id = nil
            self.name = nil
            self.owningProjectId = nil
            self.status = nil
        }
    }
}

public struct CreateGlossaryOutput: Swift.Equatable {
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of this business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

struct CreateGlossaryOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let owningProjectId: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.GlossaryStatus?
}

extension CreateGlossaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainId
        case id
        case name
        case owningProjectId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateGlossaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryTermInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case glossaryIdentifier
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let glossaryIdentifier = self.glossaryIdentifier {
            try encodeContainer.encode(glossaryIdentifier, forKey: .glossaryIdentifier)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let termRelations = self.termRelations {
            try encodeContainer.encode(termRelations, forKey: .termRelations)
        }
    }
}

extension CreateGlossaryTermInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms"
    }
}

public struct CreateGlossaryTermInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryIdentifier: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

struct CreateGlossaryTermInputBody: Swift.Equatable {
    let glossaryIdentifier: Swift.String?
    let name: Swift.String?
    let status: DataZoneClientTypes.GlossaryTermStatus?
    let shortDescription: Swift.String?
    let longDescription: Swift.String?
    let termRelations: DataZoneClientTypes.TermRelations?
    let clientToken: Swift.String?
}

extension CreateGlossaryTermInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case glossaryIdentifier
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glossaryIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryIdentifier)
        glossaryIdentifier = glossaryIdentifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryTermOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGlossaryTermOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainId = output.domainId
            self.glossaryId = output.glossaryId
            self.id = output.id
            self.longDescription = output.longDescription
            self.name = output.name
            self.shortDescription = output.shortDescription
            self.status = output.status
            self.termRelations = output.termRelations
        } else {
            self.domainId = nil
            self.glossaryId = nil
            self.id = nil
            self.longDescription = nil
            self.name = nil
            self.shortDescription = nil
            self.status = nil
            self.termRelations = nil
        }
    }
}

public struct CreateGlossaryTermOutput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of this business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

struct CreateGlossaryTermOutputBody: Swift.Equatable {
    let id: Swift.String?
    let domainId: Swift.String?
    let glossaryId: Swift.String?
    let name: Swift.String?
    let status: DataZoneClientTypes.GlossaryTermStatus?
    let shortDescription: Swift.String?
    let longDescription: Swift.String?
    let termRelations: DataZoneClientTypes.TermRelations?
}

extension CreateGlossaryTermOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case glossaryId
        case id
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let glossaryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryId)
        glossaryId = glossaryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
    }
}

enum CreateGlossaryTermOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case groupIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let groupIdentifier = self.groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
    }
}

extension CreateGroupProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles"
    }
}

public struct CreateGroupProfileInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group for which the group profile is created.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

struct CreateGroupProfileInputBody: Swift.Equatable {
    let groupIdentifier: Swift.String?
    let clientToken: Swift.String?
}

extension CreateGroupProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case groupIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension CreateGroupProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainId = output.domainId
            self.groupName = output.groupName
            self.id = output.id
            self.status = output.status
        } else {
            self.domainId = nil
            self.groupName = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct CreateGroupProfileOutput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    public var domainId: Swift.String?
    /// The name of the group for which group profile is created.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The status of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

struct CreateGroupProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let status: DataZoneClientTypes.GroupProfileStatus?
    let groupName: Swift.String?
}

extension CreateGroupProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case groupName
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupProfileStatus.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

enum CreateGroupProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateListingChangeSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case entityIdentifier
        case entityRevision
        case entityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let entityIdentifier = self.entityIdentifier {
            try encodeContainer.encode(entityIdentifier, forKey: .entityIdentifier)
        }
        if let entityRevision = self.entityRevision {
            try encodeContainer.encode(entityRevision, forKey: .entityRevision)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType.rawValue, forKey: .entityType)
        }
    }
}

extension CreateListingChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/change-set"
    }
}

public struct CreateListingChangeSetInput: Swift.Equatable {
    ///
    /// This member is required.
    public var action: DataZoneClientTypes.ChangeAction?
    ///
    public var clientToken: Swift.String?
    ///
    /// This member is required.
    public var domainIdentifier: Swift.String?
    ///
    /// This member is required.
    public var entityIdentifier: Swift.String?
    ///
    public var entityRevision: Swift.String?
    ///
    /// This member is required.
    public var entityType: DataZoneClientTypes.EntityType?

    public init(
        action: DataZoneClientTypes.ChangeAction? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityRevision: Swift.String? = nil,
        entityType: DataZoneClientTypes.EntityType? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityRevision = entityRevision
        self.entityType = entityType
    }
}

struct CreateListingChangeSetInputBody: Swift.Equatable {
    let entityIdentifier: Swift.String?
    let entityType: DataZoneClientTypes.EntityType?
    let entityRevision: Swift.String?
    let action: DataZoneClientTypes.ChangeAction?
    let clientToken: Swift.String?
}

extension CreateListingChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case entityIdentifier
        case entityRevision
        case entityType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdentifier)
        entityIdentifier = entityIdentifierDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityRevision)
        entityRevision = entityRevisionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateListingChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateListingChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.listingId = output.listingId
            self.listingRevision = output.listingRevision
            self.status = output.status
        } else {
            self.listingId = nil
            self.listingRevision = nil
            self.status = nil
        }
    }
}

public struct CreateListingChangeSetOutput: Swift.Equatable {
    ///
    /// This member is required.
    public var listingId: Swift.String?
    ///
    /// This member is required.
    public var listingRevision: Swift.String?
    ///
    /// This member is required.
    public var status: DataZoneClientTypes.ListingStatus?

    public init(
        listingId: Swift.String? = nil,
        listingRevision: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil
    )
    {
        self.listingId = listingId
        self.listingRevision = listingRevision
        self.status = status
    }
}

struct CreateListingChangeSetOutputBody: Swift.Equatable {
    let listingId: Swift.String?
    let listingRevision: Swift.String?
    let status: DataZoneClientTypes.ListingStatus?
}

extension CreateListingChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listingId
        case listingRevision
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
        let listingRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingRevision)
        listingRevision = listingRevisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ListingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateListingChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// The description of the Amazon DataZone project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this project is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone project.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone project.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.name = name
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let glossaryTerms: [Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

extension CreateProjectMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case designation
        case member
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let designation = self.designation {
            try encodeContainer.encode(designation.rawValue, forKey: .designation)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }
}

extension CreateProjectMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/createMembership"
    }
}

public struct CreateProjectMembershipInput: Swift.Equatable {
    /// The designation of the project membership.
    /// This member is required.
    public var designation: DataZoneClientTypes.UserDesignation?
    /// The ID of the Amazon DataZone domain in which project membership is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership was created.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the project for which this project membership was created.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        designation: DataZoneClientTypes.UserDesignation? = nil,
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.designation = designation
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

struct CreateProjectMembershipInputBody: Swift.Equatable {
    let member: DataZoneClientTypes.Member?
    let designation: DataZoneClientTypes.UserDesignation?
}

extension CreateProjectMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case designation
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Member.self, forKey: .member)
        member = memberDecoded
        let designationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserDesignation.self, forKey: .designation)
        designation = designationDecoded
    }
}

extension CreateProjectMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateProjectMembershipOutput: Swift.Equatable {

    public init() { }
}

enum CreateProjectMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the project was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the Amazon DataZone project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let glossaryTerms: [Swift.String]?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case glossaryTerms
        case id
        case lastUpdatedAt
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetTargetNames
        case clientToken
        case environmentIdentifier
        case grantedEntity
        case subscriptionTargetIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetTargetNames = assetTargetNames {
            var assetTargetNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetTargetNames)
            for assettargetnamemap0 in assetTargetNames {
                try assetTargetNamesContainer.encode(assettargetnamemap0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let environmentIdentifier = self.environmentIdentifier {
            try encodeContainer.encode(environmentIdentifier, forKey: .environmentIdentifier)
        }
        if let grantedEntity = self.grantedEntity {
            try encodeContainer.encode(grantedEntity, forKey: .grantedEntity)
        }
        if let subscriptionTargetIdentifier = self.subscriptionTargetIdentifier {
            try encodeContainer.encode(subscriptionTargetIdentifier, forKey: .subscriptionTargetIdentifier)
        }
    }
}

extension CreateSubscriptionGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

public struct CreateSubscriptionGrantInput: Swift.Equatable {
    /// The names of the assets for which the subscription grant is created.
    public var assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which the subscription grant is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The entity to which the subscription is to be granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntityInput?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetIdentifier: Swift.String?

    public init(
        assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntityInput? = nil,
        subscriptionTargetIdentifier: Swift.String? = nil
    )
    {
        self.assetTargetNames = assetTargetNames
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.grantedEntity = grantedEntity
        self.subscriptionTargetIdentifier = subscriptionTargetIdentifier
    }
}

struct CreateSubscriptionGrantInputBody: Swift.Equatable {
    let environmentIdentifier: Swift.String?
    let subscriptionTargetIdentifier: Swift.String?
    let grantedEntity: DataZoneClientTypes.GrantedEntityInput?
    let assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]?
    let clientToken: Swift.String?
}

extension CreateSubscriptionGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetTargetNames
        case clientToken
        case environmentIdentifier
        case grantedEntity
        case subscriptionTargetIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentIdentifier)
        environmentIdentifier = environmentIdentifierDecoded
        let subscriptionTargetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetIdentifier)
        subscriptionTargetIdentifier = subscriptionTargetIdentifierDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntityInput.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let assetTargetNamesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.AssetTargetNameMap?].self, forKey: .assetTargetNames)
        var assetTargetNamesDecoded0:[DataZoneClientTypes.AssetTargetNameMap]? = nil
        if let assetTargetNamesContainer = assetTargetNamesContainer {
            assetTargetNamesDecoded0 = [DataZoneClientTypes.AssetTargetNameMap]()
            for structure0 in assetTargetNamesContainer {
                if let structure0 = structure0 {
                    assetTargetNamesDecoded0?.append(structure0)
                }
            }
        }
        assetTargetNames = assetTargetNamesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSubscriptionGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriptionGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.grantedEntity = output.grantedEntity
            self.id = output.id
            self.status = output.status
            self.subscriptionId = output.subscriptionId
            self.subscriptionTargetId = output.subscriptionTargetId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.assets = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.grantedEntity = nil
            self.id = nil
            self.status = nil
            self.subscriptionId = nil
            self.subscriptionTargetId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct CreateSubscriptionGrantOutput: Swift.Equatable {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// A timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription grant.
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// A timestamp of when the subscription grant was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct CreateSubscriptionGrantOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscriptionTargetId: Swift.String?
    let grantedEntity: DataZoneClientTypes.GrantedEntity?
    let status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    let assets: [DataZoneClientTypes.SubscribedAsset]?
    let subscriptionId: Swift.String?
}

extension CreateSubscriptionGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case createdAt
        case createdBy
        case domainId
        case grantedEntity
        case id
        case status
        case subscriptionId
        case subscriptionTargetId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscriptionTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetId)
        subscriptionTargetId = subscriptionTargetIdDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntity.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantOverallStatus.self, forKey: .status)
        status = statusDecoded
        let assetsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedAsset?].self, forKey: .assets)
        var assetsDecoded0:[DataZoneClientTypes.SubscribedAsset]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataZoneClientTypes.SubscribedAsset]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
    }
}

enum CreateSubscriptionGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), requestReason: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case requestReason
        case subscribedListings
        case subscribedPrincipals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let requestReason = self.requestReason {
            try encodeContainer.encode(requestReason, forKey: .requestReason)
        }
        if let subscribedListings = subscribedListings {
            var subscribedListingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedListings)
            for subscribedlistinginput0 in subscribedListings {
                try subscribedListingsContainer.encode(subscribedlistinginput0)
            }
        }
        if let subscribedPrincipals = subscribedPrincipals {
            var subscribedPrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedPrincipals)
            for subscribedprincipalinput0 in subscribedPrincipals {
                try subscribedPrincipalsContainer.encode(subscribedprincipalinput0)
            }
        }
    }
}

extension CreateSubscriptionRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

public struct CreateSubscriptionRequestInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription request is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    ///
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListingInput]?
    /// The Amazon DataZone principals for whom the subscription request is created.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListingInput]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.requestReason = requestReason
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
    }
}

struct CreateSubscriptionRequestInputBody: Swift.Equatable {
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListingInput]?
    let requestReason: Swift.String?
    let clientToken: Swift.String?
}

extension CreateSubscriptionRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case requestReason
        case subscribedListings
        case subscribedPrincipals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipalInput?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipalInput]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipalInput]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListingInput?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListingInput]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListingInput]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriptionRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.decisionComment = output.decisionComment
            self.domainId = output.domainId
            self.id = output.id
            self.requestReason = output.requestReason
            self.reviewerId = output.reviewerId
            self.status = output.status
            self.subscribedListings = output.subscribedListings
            self.subscribedPrincipals = output.subscribedPrincipals
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.decisionComment = nil
            self.domainId = nil
            self.id = nil
            self.requestReason = nil
            self.reviewerId = nil
            self.status = nil
            self.subscribedListings = nil
            self.subscribedPrincipals = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct CreateSubscriptionRequestOutput: Swift.Equatable {
    /// A timestamp of when the subscription request is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The ID of the Amazon DataZone domain in whcih the subscription request is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The ID of the reviewer of the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    ///
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct CreateSubscriptionRequestOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionRequestStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let requestReason: Swift.String?
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    let reviewerId: Swift.String?
    let decisionComment: Swift.String?
}

extension CreateSubscriptionRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

enum CreateSubscriptionRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case clientToken
        case manageAccessRole
        case name
        case provider
        case subscriptionTargetConfig
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicableAssetTypes = applicableAssetTypes {
            var applicableAssetTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicableAssetTypes)
            for typename0 in applicableAssetTypes {
                try applicableAssetTypesContainer.encode(typename0)
            }
        }
        if let authorizedPrincipals = authorizedPrincipals {
            var authorizedPrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedPrincipals)
            for authorizedprincipalidentifier0 in authorizedPrincipals {
                try authorizedPrincipalsContainer.encode(authorizedprincipalidentifier0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let manageAccessRole = self.manageAccessRole {
            try encodeContainer.encode(manageAccessRole, forKey: .manageAccessRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let subscriptionTargetConfig = subscriptionTargetConfig {
            var subscriptionTargetConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionTargetConfig)
            for subscriptiontargetform0 in subscriptionTargetConfig {
                try subscriptionTargetConfigContainer.encode(subscriptiontargetform0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateSubscriptionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

public struct CreateSubscriptionTargetInput: Swift.Equatable {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which subscription target is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which subscription target is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The manage access role that is used to create the subscription target.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of the subscription target.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
    }
}

struct CreateSubscriptionTargetInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: Swift.String?
    let subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    let authorizedPrincipals: [Swift.String]?
    let manageAccessRole: Swift.String?
    let applicableAssetTypes: [Swift.String]?
    let provider: Swift.String?
    let clientToken: Swift.String?
}

extension CreateSubscriptionTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case clientToken
        case manageAccessRole
        case name
        case provider
        case subscriptionTargetConfig
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriptionTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicableAssetTypes = output.applicableAssetTypes
            self.authorizedPrincipals = output.authorizedPrincipals
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.environmentId = output.environmentId
            self.id = output.id
            self.manageAccessRole = output.manageAccessRole
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.subscriptionTargetConfig = output.subscriptionTargetConfig
            self.type = output.type
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.applicableAssetTypes = nil
            self.authorizedPrincipals = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.environmentId = nil
            self.id = nil
            self.manageAccessRole = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.subscriptionTargetConfig = nil
            self.type = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct CreateSubscriptionTargetOutput: Swift.Equatable {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorised principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment in which the subscription target was created.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// ???
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct CreateSubscriptionTargetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let authorizedPrincipals: [Swift.String]?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let name: Swift.String?
    let type: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let manageAccessRole: Swift.String?
    let applicableAssetTypes: [Swift.String]?
    let subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    let provider: Swift.String?
}

extension CreateSubscriptionTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case createdAt
        case createdBy
        case domainId
        case environmentId
        case id
        case manageAccessRole
        case name
        case projectId
        case provider
        case subscriptionTargetConfig
        case type
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

enum CreateSubscriptionTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case userIdentifier
        case userType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let userIdentifier = self.userIdentifier {
            try encodeContainer.encode(userIdentifier, forKey: .userIdentifier)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

extension CreateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles"
    }
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the user for which the user profile is created.
    /// This member is required.
    public var userIdentifier: Swift.String?
    /// The user type of the user for which the user profile is created.
    public var userType: DataZoneClientTypes.UserType?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        userIdentifier: Swift.String? = nil,
        userType: DataZoneClientTypes.UserType? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.userIdentifier = userIdentifier
        self.userType = userType
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    let userIdentifier: Swift.String?
    let userType: DataZoneClientTypes.UserType?
    let clientToken: Swift.String?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case userIdentifier
        case userType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userIdentifier)
        userIdentifier = userIdentifierDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.domainId = output.domainId
            self.id = output.id
            self.status = output.status
            self.type = output.type
        } else {
            self.details = nil
            self.domainId = nil
            self.id = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct CreateUserProfileOutput: Swift.Equatable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

struct CreateUserProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let type: DataZoneClientTypes.UserProfileType?
    let status: DataZoneClientTypes.UserProfileStatus?
    let details: DataZoneClientTypes.UserProfileDetails?
}

extension CreateUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case domainId
        case id
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum CreateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.CustomParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case fieldType
        case isEditable
        case isOptional
        case keyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fieldType = self.fieldType {
            try encodeContainer.encode(fieldType, forKey: .fieldType)
        }
        if let isEditable = self.isEditable {
            try encodeContainer.encode(isEditable, forKey: .isEditable)
        }
        if let isOptional = self.isOptional {
            try encodeContainer.encode(isOptional, forKey: .isOptional)
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fieldTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isEditableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEditable)
        isEditable = isEditableDecoded
        let isOptionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOptional)
        isOptional = isOptionalDecoded
    }
}

extension DataZoneClientTypes.CustomParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomParameter(defaultValue: \(Swift.String(describing: defaultValue)), fieldType: \(Swift.String(describing: fieldType)), isEditable: \(Swift.String(describing: isEditable)), isOptional: \(Swift.String(describing: isOptional)), keyName: \(Swift.String(describing: keyName)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of user parameters of an environment blueprint.
    public struct CustomParameter: Swift.Equatable {
        /// The default value of the parameter.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// The filed type of the parameter.
        /// This member is required.
        public var fieldType: Swift.String?
        /// Specifies whether the parameter is editable.
        public var isEditable: Swift.Bool?
        /// Specifies whether the custom parameter is optional.
        public var isOptional: Swift.Bool?
        /// The key name of the parameter.
        /// This member is required.
        public var keyName: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            fieldType: Swift.String? = nil,
            isEditable: Swift.Bool? = nil,
            isOptional: Swift.Bool? = nil,
            keyName: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.fieldType = fieldType
            self.isEditable = isEditable
            self.isOptional = isOptional
            self.keyName = keyName
        }
    }

}

extension DataZoneClientTypes {
    public enum DataAssetActivityStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case publishingFailed
        case skippedAlreadyImported
        case skippedArchived
        case skippedNoAccess
        case succeededCreated
        case succeededUpdated
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAssetActivityStatus] {
            return [
                .failed,
                .publishingFailed,
                .skippedAlreadyImported,
                .skippedArchived,
                .skippedNoAccess,
                .succeededCreated,
                .succeededUpdated,
                .unchanged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .publishingFailed: return "PUBLISHING_FAILED"
            case .skippedAlreadyImported: return "SKIPPED_ALREADY_IMPORTED"
            case .skippedArchived: return "SKIPPED_ARCHIVED"
            case .skippedNoAccess: return "SKIPPED_NO_ACCESS"
            case .succeededCreated: return "SUCCEEDED_CREATED"
            case .succeededUpdated: return "SUCCEEDED_UPDATED"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataAssetActivityStatus(rawValue: rawValue) ?? DataAssetActivityStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DataProductItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case itemId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
    }
}

extension DataZoneClientTypes {
    ///
    public struct DataProductItem: Swift.Equatable {
        ///
        public var domainId: Swift.String?
        ///
        public var itemId: Swift.String?

        public init(
            domainId: Swift.String? = nil,
            itemId: Swift.String? = nil
        )
        {
            self.domainId = domainId
            self.itemId = itemId
        }
    }

}

extension DataZoneClientTypes.DataProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case dataProductItems
        case description
        case domainId
        case glossaryTerms
        case id
        case name
        case owningProjectId
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let dataProductItems = dataProductItems {
            var dataProductItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataProductItems)
            for dataproductitem0 in dataProductItems {
                try dataProductItemsContainer.encode(dataproductitem0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let dataProductItemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DataProductItem?].self, forKey: .dataProductItems)
        var dataProductItemsDecoded0:[DataZoneClientTypes.DataProductItem]? = nil
        if let dataProductItemsContainer = dataProductItemsContainer {
            dataProductItemsDecoded0 = [DataZoneClientTypes.DataProductItem]()
            for structure0 in dataProductItemsContainer {
                if let structure0 = structure0 {
                    dataProductItemsDecoded0?.append(structure0)
                }
            }
        }
        dataProductItems = dataProductItemsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DataZoneClientTypes.DataProductSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataProductSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), dataProductItems: \(Swift.String(describing: dataProductItems)), domainId: \(Swift.String(describing: domainId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    ///
    public struct DataProductSummary: Swift.Equatable {
        ///
        public var createdAt: ClientRuntime.Date?
        ///
        public var createdBy: Swift.String?
        ///
        public var dataProductItems: [DataZoneClientTypes.DataProductItem]?
        ///
        public var description: Swift.String?
        ///
        /// This member is required.
        public var domainId: Swift.String?
        ///
        public var glossaryTerms: [Swift.String]?
        ///
        /// This member is required.
        public var id: Swift.String?
        ///
        /// This member is required.
        public var name: Swift.String?
        ///
        /// This member is required.
        public var owningProjectId: Swift.String?
        ///
        public var updatedAt: ClientRuntime.Date?
        ///
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            dataProductItems: [DataZoneClientTypes.DataProductItem]? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dataProductItems = dataProductItems
            self.description = description
            self.domainId = domainId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes.DataSourceConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gluerunconfiguration = "glueRunConfiguration"
        case redshiftrunconfiguration = "redshiftRunConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .gluerunconfiguration(gluerunconfiguration):
                try container.encode(gluerunconfiguration, forKey: .gluerunconfiguration)
            case let .redshiftrunconfiguration(redshiftrunconfiguration):
                try container.encode(redshiftrunconfiguration, forKey: .redshiftrunconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let gluerunconfigurationDecoded = try values.decodeIfPresent(DataZoneClientTypes.GlueRunConfigurationInput.self, forKey: .gluerunconfiguration)
        if let gluerunconfiguration = gluerunconfigurationDecoded {
            self = .gluerunconfiguration(gluerunconfiguration)
            return
        }
        let redshiftrunconfigurationDecoded = try values.decodeIfPresent(DataZoneClientTypes.RedshiftRunConfigurationInput.self, forKey: .redshiftrunconfiguration)
        if let redshiftrunconfiguration = redshiftrunconfigurationDecoded {
            self = .redshiftrunconfiguration(redshiftrunconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The configuration of the data source.
    public enum DataSourceConfigurationInput: Swift.Equatable {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationInput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.DataSourceConfigurationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gluerunconfiguration = "glueRunConfiguration"
        case redshiftrunconfiguration = "redshiftRunConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .gluerunconfiguration(gluerunconfiguration):
                try container.encode(gluerunconfiguration, forKey: .gluerunconfiguration)
            case let .redshiftrunconfiguration(redshiftrunconfiguration):
                try container.encode(redshiftrunconfiguration, forKey: .redshiftrunconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let gluerunconfigurationDecoded = try values.decodeIfPresent(DataZoneClientTypes.GlueRunConfigurationOutput.self, forKey: .gluerunconfiguration)
        if let gluerunconfiguration = gluerunconfigurationDecoded {
            self = .gluerunconfiguration(gluerunconfiguration)
            return
        }
        let redshiftrunconfigurationDecoded = try values.decodeIfPresent(DataZoneClientTypes.RedshiftRunConfigurationOutput.self, forKey: .redshiftrunconfiguration)
        if let redshiftrunconfiguration = redshiftrunconfigurationDecoded {
            self = .redshiftrunconfiguration(redshiftrunconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The configuration of the data source.
    public enum DataSourceConfigurationOutput: Swift.Equatable {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationOutput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.DataSourceErrorMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetail
        case errorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = self.errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorType.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the error message that is returned if the operation cannot be successfully completed.
    public struct DataSourceErrorMessage: Swift.Equatable {
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorDetail: Swift.String?
        /// The type of the error message that is returned if the operation cannot be successfully completed.
        /// This member is required.
        public var errorType: DataZoneClientTypes.DataSourceErrorType?

        public init(
            errorDetail: Swift.String? = nil,
            errorType: DataZoneClientTypes.DataSourceErrorType? = nil
        )
        {
            self.errorDetail = errorDetail
            self.errorType = errorType
        }
    }

}

extension DataZoneClientTypes {
    public enum DataSourceErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDeniedException
        case conflictException
        case internalServerException
        case resourceNotFoundException
        case serviceQuotaExceededException
        case throttlingException
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorType] {
            return [
                .accessDeniedException,
                .conflictException,
                .internalServerException,
                .resourceNotFoundException,
                .serviceQuotaExceededException,
                .throttlingException,
                .validationException,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
            case .conflictException: return "CONFLICT_EXCEPTION"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case .throttlingException: return "THROTTLING_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceErrorType(rawValue: rawValue) ?? DataSourceErrorType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DataSourceRunActivity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataAssetId
        case dataAssetStatus
        case dataSourceRunId
        case database
        case errorMessage
        case projectId
        case technicalDescription
        case technicalName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataAssetId = self.dataAssetId {
            try encodeContainer.encode(dataAssetId, forKey: .dataAssetId)
        }
        if let dataAssetStatus = self.dataAssetStatus {
            try encodeContainer.encode(dataAssetStatus.rawValue, forKey: .dataAssetStatus)
        }
        if let dataSourceRunId = self.dataSourceRunId {
            try encodeContainer.encode(dataSourceRunId, forKey: .dataSourceRunId)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let technicalDescription = self.technicalDescription {
            try encodeContainer.encode(technicalDescription, forKey: .technicalDescription)
        }
        if let technicalName = self.technicalName {
            try encodeContainer.encode(technicalName, forKey: .technicalName)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let dataSourceRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceRunId)
        dataSourceRunId = dataSourceRunIdDecoded
        let technicalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .technicalName)
        technicalName = technicalNameDecoded
        let dataAssetStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataAssetActivityStatus.self, forKey: .dataAssetStatus)
        dataAssetStatus = dataAssetStatusDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dataAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAssetId)
        dataAssetId = dataAssetIdDecoded
        let technicalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .technicalDescription)
        technicalDescription = technicalDescriptionDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataZoneClientTypes.DataSourceRunActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceRunActivity(createdAt: \(Swift.String(describing: createdAt)), dataAssetId: \(Swift.String(describing: dataAssetId)), dataAssetStatus: \(Swift.String(describing: dataAssetStatus)), dataSourceRunId: \(Swift.String(describing: dataSourceRunId)), errorMessage: \(Swift.String(describing: errorMessage)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), database: \"CONTENT_REDACTED\", technicalDescription: \"CONTENT_REDACTED\", technicalName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The activity details of the data source run.
    public struct DataSourceRunActivity: Swift.Equatable {
        /// The timestamp of when data source run activity was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the asset included in the data source run activity.
        public var dataAssetId: Swift.String?
        /// The status of the asset included in the data source run activity.
        /// This member is required.
        public var dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus?
        /// The identifier of the data source for the data source run activity.
        /// This member is required.
        public var dataSourceRunId: Swift.String?
        /// The database included in the data source run activity.
        /// This member is required.
        public var database: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The project ID included in the data source run activity.
        /// This member is required.
        public var projectId: Swift.String?
        /// The technical description included in the data source run activity.
        public var technicalDescription: Swift.String?
        /// The technical name included in the data source run activity.
        /// This member is required.
        public var technicalName: Swift.String?
        /// The timestamp of when data source run activity was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataAssetId: Swift.String? = nil,
            dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus? = nil,
            dataSourceRunId: Swift.String? = nil,
            database: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            projectId: Swift.String? = nil,
            technicalDescription: Swift.String? = nil,
            technicalName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAssetId = dataAssetId
            self.dataAssetStatus = dataAssetStatus
            self.dataSourceRunId = dataSourceRunId
            self.database = database
            self.errorMessage = errorMessage
            self.projectId = projectId
            self.technicalDescription = technicalDescription
            self.technicalName = technicalName
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {
    public enum DataSourceRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case partiallySucceeded
        case requested
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunStatus] {
            return [
                .failed,
                .partiallySucceeded,
                .requested,
                .running,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .partiallySucceeded: return "PARTIALLY_SUCCEEDED"
            case .requested: return "REQUESTED"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceRunStatus(rawValue: rawValue) ?? DataSourceRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DataSourceRunSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceId
        case errorMessage
        case id
        case projectId
        case runStatisticsForAssets
        case startedAt
        case status
        case stoppedAt
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let runStatisticsForAssets = self.runStatisticsForAssets {
            try encodeContainer.encode(runStatisticsForAssets, forKey: .runStatisticsForAssets)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stoppedAt = self.stoppedAt {
            try encodeContainer.encodeTimestamp(stoppedAt, format: .dateTime, forKey: .stoppedAt)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .status)
        status = statusDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let runStatisticsForAssetsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RunStatisticsForAssets.self, forKey: .runStatisticsForAssets)
        runStatisticsForAssets = runStatisticsForAssetsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let stoppedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of a data source run.
    public struct DataSourceRunSummary: Swift.Equatable {
        /// The timestamp of when a data source run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the data source of the data source run.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The identifier of the data source run.
        /// This member is required.
        public var id: Swift.String?
        /// The project ID of the data source run.
        /// This member is required.
        public var projectId: Swift.String?
        /// The asset statistics from the data source run.
        public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
        /// The timestamp of when a data source run was started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the data source run.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceRunStatus?
        /// The timestamp of when a data source run was stopped.
        public var stoppedAt: ClientRuntime.Date?
        /// The type of the data source run.
        /// This member is required.
        public var type: DataZoneClientTypes.DataSourceRunType?
        /// The timestamp of when a data source run was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            id: Swift.String? = nil,
            projectId: Swift.String? = nil,
            runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: DataZoneClientTypes.DataSourceRunStatus? = nil,
            stoppedAt: ClientRuntime.Date? = nil,
            type: DataZoneClientTypes.DataSourceRunType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {
    public enum DataSourceRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case prioritized
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunType] {
            return [
                .prioritized,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .prioritized: return "PRIORITIZED"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceRunType(rawValue: rawValue) ?? DataSourceRunType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failedCreation
        case failedDeletion
        case failedUpdate
        case ready
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .creating,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .failedUpdate,
                .ready,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdate: return "FAILED_UPDATE"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DataSourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceId
        case domainId
        case enableSetting
        case environmentId
        case lastRunAssetCount
        case lastRunAt
        case lastRunErrorMessage
        case lastRunStatus
        case name
        case schedule
        case status
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let enableSetting = self.enableSetting {
            try encodeContainer.encode(enableSetting.rawValue, forKey: .enableSetting)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastRunAssetCount = self.lastRunAssetCount {
            try encodeContainer.encode(lastRunAssetCount, forKey: .lastRunAssetCount)
        }
        if let lastRunAt = self.lastRunAt {
            try encodeContainer.encodeTimestamp(lastRunAt, format: .dateTime, forKey: .lastRunAt)
        }
        if let lastRunErrorMessage = self.lastRunErrorMessage {
            try encodeContainer.encode(lastRunErrorMessage, forKey: .lastRunErrorMessage)
        }
        if let lastRunStatus = self.lastRunStatus {
            try encodeContainer.encode(lastRunStatus.rawValue, forKey: .lastRunStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunAt)
        lastRunAt = lastRunAtDecoded
        let lastRunErrorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .lastRunErrorMessage)
        lastRunErrorMessage = lastRunErrorMessageDecoded
        let lastRunAssetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastRunAssetCount)
        lastRunAssetCount = lastRunAssetCountDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataZoneClientTypes.DataSourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSummary(createdAt: \(Swift.String(describing: createdAt)), dataSourceId: \(Swift.String(describing: dataSourceId)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the data source.
    public struct DataSourceSummary: Swift.Equatable {
        /// The timestamp of when the data source was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// Specifies whether the data source is enabled.
        public var enableSetting: DataZoneClientTypes.EnableSetting?
        /// The ID of the environment in which the data source exists.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The count of the assets created during the last data source run.
        public var lastRunAssetCount: Swift.Int?
        /// The timestamp of when the data source run was last performed.
        public var lastRunAt: ClientRuntime.Date?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The status of the last data source run.
        public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The details of the schedule of the data source runs.
        public var schedule: DataZoneClientTypes.ScheduleConfiguration?
        /// The status of the data source.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceStatus?
        /// The type of the data source.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the data source was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            enableSetting: DataZoneClientTypes.EnableSetting? = nil,
            environmentId: Swift.String? = nil,
            lastRunAssetCount: Swift.Int? = nil,
            lastRunAt: ClientRuntime.Date? = nil,
            lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
            name: Swift.String? = nil,
            schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
            status: DataZoneClientTypes.DataSourceStatus? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension DeleteAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the asset is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssetTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteAssetTypeInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the asset type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset type that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteAssetTypeInputBody: Swift.Equatable {
}

extension DeleteAssetTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssetTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssetTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DeleteDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetFormsOutput = output.assetFormsOutput
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.domainId = output.domainId
            self.enableSetting = output.enableSetting
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.lastRunAt = output.lastRunAt
            self.lastRunErrorMessage = output.lastRunErrorMessage
            self.lastRunStatus = output.lastRunStatus
            self.name = output.name
            self.projectId = output.projectId
            self.publishOnImport = output.publishOnImport
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.assetFormsOutput = nil
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.domainId = nil
            self.enableSetting = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.id = nil
            self.lastRunAt = nil
            self.lastRunErrorMessage = nil
            self.lastRunStatus = nil
            self.name = nil
            self.projectId = nil
            self.publishOnImport = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct DeleteDataSourceOutput: Swift.Equatable {
    /// The asset data forms associated with this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source that is deleted.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when this data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source that is deleted.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting of the data source that specifies whether the data source is enabled or disabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environemnt associated with this data source.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source that is deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project in which this data source exists and from which it's deleted.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// The schedule of runs for this data source.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of this data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of this data source.
    public var type: Swift.String?
    /// The timestamp of when this data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct DeleteDataSourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: DataZoneClientTypes.DataSourceStatus?
    let type: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let publishOnImport: Swift.Bool?
    let assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    let lastRunAt: ClientRuntime.Date?
    let lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension DeleteDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsOutput
        case configuration
        case createdAt
        case description
        case domainId
        case enableSetting
        case environmentId
        case errorMessage
        case id
        case lastRunAt
        case lastRunErrorMessage
        case lastRunStatus
        case name
        case projectId
        case publishOnImport
        case schedule
        case status
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationOutput.self, forKey: .configuration)
        configuration = configurationDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .assetFormsOutput)
        var assetFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let assetFormsOutputContainer = assetFormsOutputContainer {
            assetFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in assetFormsOutputContainer {
                if let structure0 = structure0 {
                    assetFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsOutput = assetFormsOutputDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunAt)
        lastRunAt = lastRunAtDecoded
        let lastRunErrorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .lastRunErrorMessage)
        lastRunErrorMessage = lastRunErrorMessageDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum DeleteDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Web Services domain that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identifier = identifier
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteDomainOutput: Swift.Equatable {
    /// The status of the domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteDomainOutputBody: Swift.Equatable {
    let status: DataZoneClientTypes.DomainStatus?
}

extension DeleteDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentBlueprintConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentBlueprintConfigurationInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the blueprint configuration is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint the configuration of which is deleted.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

struct DeleteEnvironmentBlueprintConfigurationInputBody: Swift.Equatable {
}

extension DeleteEnvironmentBlueprintConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentBlueprintConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentBlueprintConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentBlueprintConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the environment is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentProfileInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the environment profile is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteEnvironmentProfileInputBody: Swift.Equatable {
}

extension DeleteEnvironmentProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFormTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteFormTypeInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the metadata form type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type that is deleted.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
    }
}

struct DeleteFormTypeInputBody: Swift.Equatable {
}

extension DeleteFormTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFormTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFormTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFormTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGlossaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteGlossaryInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the business glossary is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteGlossaryInputBody: Swift.Equatable {
}

extension DeleteGlossaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGlossaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGlossaryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGlossaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGlossaryTermInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteGlossaryTermInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the business glossary term is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteGlossaryTermInputBody: Swift.Equatable {
}

extension DeleteGlossaryTermInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGlossaryTermOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGlossaryTermOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGlossaryTermOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteListingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteListingInput: Swift.Equatable {
    ///
    /// This member is required.
    public var domainIdentifier: Swift.String?
    ///
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteListingInputBody: Swift.Equatable {
}

extension DeleteListingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteListingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteListingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteListingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the project is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the project that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }
}

extension DeleteProjectMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/deleteMembership"
    }
}

public struct DeleteProjectMembershipInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain where project membership is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership is deleted.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the Amazon DataZone project the membership to which is deleted.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

struct DeleteProjectMembershipInputBody: Swift.Equatable {
    let member: DataZoneClientTypes.Member?
}

extension DeleteProjectMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Member.self, forKey: .member)
        member = memberDecoded
    }
}

extension DeleteProjectMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProjectMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProjectMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriptionGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionGrantInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain where the subscription grant is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteSubscriptionGrantInputBody: Swift.Equatable {
}

extension DeleteSubscriptionGrantInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSubscriptionGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.grantedEntity = output.grantedEntity
            self.id = output.id
            self.status = output.status
            self.subscriptionId = output.subscriptionId
            self.subscriptionTargetId = output.subscriptionTargetId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.assets = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.grantedEntity = nil
            self.id = nil
            self.status = nil
            self.subscriptionId = nil
            self.subscriptionTargetId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct DeleteSubscriptionGrantOutput: Swift.Equatable {
    /// The assets for which the subsctiption grant that is deleted gave access.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant that is deleted was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant that is deleted.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is deleted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant that is deleted.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subsctiption whose subscription grant is to be deleted.
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target associated with the subscription grant that is deleted.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant that is deleted was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant that is deleted.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct DeleteSubscriptionGrantOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscriptionTargetId: Swift.String?
    let grantedEntity: DataZoneClientTypes.GrantedEntity?
    let status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    let assets: [DataZoneClientTypes.SubscribedAsset]?
    let subscriptionId: Swift.String?
}

extension DeleteSubscriptionGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case createdAt
        case createdBy
        case domainId
        case grantedEntity
        case id
        case status
        case subscriptionId
        case subscriptionTargetId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscriptionTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetId)
        subscriptionTargetId = subscriptionTargetIdDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntity.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantOverallStatus.self, forKey: .status)
        status = statusDecoded
        let assetsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedAsset?].self, forKey: .assets)
        var assetsDecoded0:[DataZoneClientTypes.SubscribedAsset]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataZoneClientTypes.SubscribedAsset]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
    }
}

enum DeleteSubscriptionGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriptionRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionRequestInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the subscription request is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription request that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct DeleteSubscriptionRequestInputBody: Swift.Equatable {
}

extension DeleteSubscriptionRequestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSubscriptionRequestOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriptionRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriptionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionTargetInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the subscription target is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment in which the subscription target is deleted.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

struct DeleteSubscriptionTargetInputBody: Swift.Equatable {
}

extension DeleteSubscriptionTargetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSubscriptionTargetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriptionTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case deploymentStatus
        case deploymentType
        case failureReason
        case isDeploymentComplete
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let isDeploymentComplete = self.isDeploymentComplete {
            try encodeContainer.encode(isDeploymentComplete, forKey: .isDeploymentComplete)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for deploymentmessage0 in messages {
                try messagesContainer.encode(deploymentmessage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnvironmentError.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .messages)
        var messagesDecoded0:[Swift.String]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Swift.String]()
            for string0 in messagesContainer {
                if let string0 = string0 {
                    messagesDecoded0?.append(string0)
                }
            }
        }
        messages = messagesDecoded0
        let isDeploymentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDeploymentComplete)
        isDeploymentComplete = isDeploymentCompleteDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the last deployment of the environment.
    public struct Deployment: Swift.Equatable {
        /// The identifier of the last deployment of the environment.
        public var deploymentId: Swift.String?
        /// The status of the last deployment of the environment.
        public var deploymentStatus: DataZoneClientTypes.DeploymentStatus?
        /// The type of the last deployment of the environment.
        public var deploymentType: DataZoneClientTypes.DeploymentType?
        /// The failure reason of the last deployment of the environment.
        public var failureReason: DataZoneClientTypes.EnvironmentError?
        /// Specifies whether the last deployment of the environment is complete.
        public var isDeploymentComplete: Swift.Bool?
        /// The messages of the last deployment of the environment.
        public var messages: [Swift.String]?

        public init(
            deploymentId: Swift.String? = nil,
            deploymentStatus: DataZoneClientTypes.DeploymentStatus? = nil,
            deploymentType: DataZoneClientTypes.DeploymentType? = nil,
            failureReason: DataZoneClientTypes.EnvironmentError? = nil,
            isDeploymentComplete: Swift.Bool? = nil,
            messages: [Swift.String]? = nil
        )
        {
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.failureReason = failureReason
            self.isDeploymentComplete = isDeploymentComplete
            self.messages = messages
        }
    }

}

extension DataZoneClientTypes.DeploymentProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeoutMinutes
        case startTimeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeoutMinutes = self.endTimeoutMinutes {
            try encodeContainer.encode(endTimeoutMinutes, forKey: .endTimeoutMinutes)
        }
        if let startTimeoutMinutes = self.startTimeoutMinutes {
            try encodeContainer.encode(startTimeoutMinutes, forKey: .startTimeoutMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeoutMinutes)
        startTimeoutMinutes = startTimeoutMinutesDecoded
        let endTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTimeoutMinutes)
        endTimeoutMinutes = endTimeoutMinutesDecoded
    }
}

extension DataZoneClientTypes {
    /// The deployment properties of the Amazon DataZone blueprint.
    public struct DeploymentProperties: Swift.Equatable {
        /// The end timeout of the environment blueprint deployment.
        public var endTimeoutMinutes: Swift.Int?
        /// The start timeout of the environment blueprint deployment.
        public var startTimeoutMinutes: Swift.Int?

        public init(
            endTimeoutMinutes: Swift.Int? = nil,
            startTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.endTimeoutMinutes = endTimeoutMinutes
            self.startTimeoutMinutes = startTimeoutMinutes
        }
    }

}

extension DataZoneClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pendingDeployment
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .failed,
                .inProgress,
                .pendingDeployment,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DetailedGlossaryTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case shortDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
    }
}

extension DataZoneClientTypes.DetailedGlossaryTerm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetailedGlossaryTerm(name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// Details of a glossary term attached to the inventory asset.
    public struct DetailedGlossaryTerm: Swift.Equatable {
        /// The name of a glossary term attached to the inventory asset.
        public var name: Swift.String?
        /// The shoft description of a glossary term attached to the inventory asset.
        public var shortDescription: Swift.String?

        public init(
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil
        )
        {
            self.name = name
            self.shortDescription = shortDescription
        }
    }

}

extension DataZoneClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .available,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case id
        case lastUpdatedAt
        case managedAccountId
        case name
        case portalUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let managedAccountId = self.managedAccountId {
            try encodeContainer.encode(managedAccountId, forKey: .managedAccountId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portalUrl = self.portalUrl {
            try encodeContainer.encode(portalUrl, forKey: .portalUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedAccountId)
        managedAccountId = managedAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let portalUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalUrl)
        portalUrl = portalUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension DataZoneClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), managedAccountId: \(Swift.String(describing: managedAccountId)), portalUrl: \(Swift.String(describing: portalUrl)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// A summary of a Amazon DataZone domain.
    public struct DomainSummary: Swift.Equatable {
        /// The ARN of the Amazon DataZone domain.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of an Amazon DataZone domain.
        public var description: Swift.String?
        /// The ID of the Amazon DataZone domain.
        /// This member is required.
        public var id: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The identifier of the Amazon Web Services account that manages the domain.
        /// This member is required.
        public var managedAccountId: Swift.String?
        /// A name of an Amazon DataZone domain.
        /// This member is required.
        public var name: Swift.String?
        /// The data portal URL for the Amazon DataZone domain.
        public var portalUrl: Swift.String?
        /// The status of the Amazon DataZone domain.
        /// This member is required.
        public var status: DataZoneClientTypes.DomainStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            managedAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            portalUrl: Swift.String? = nil,
            status: DataZoneClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.managedAccountId = managedAccountId
            self.name = name
            self.portalUrl = portalUrl
            self.status = status
        }
    }

}

extension DataZoneClientTypes {
    public enum EnableSetting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableSetting] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnableSetting(rawValue: rawValue) ?? EnableSetting.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .asset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case domainId
        case enabledRegions
        case environmentBlueprintId
        case manageAccessRoleArn
        case provisioningRoleArn
        case regionalParameters
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let enabledRegions = enabledRegions {
            var enabledRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledRegions)
            for regionname0 in enabledRegions {
                try enabledRegionsContainer.encode(regionname0)
            }
        }
        if let environmentBlueprintId = self.environmentBlueprintId {
            try encodeContainer.encode(environmentBlueprintId, forKey: .environmentBlueprintId)
        }
        if let manageAccessRoleArn = self.manageAccessRoleArn {
            try encodeContainer.encode(manageAccessRoleArn, forKey: .manageAccessRoleArn)
        }
        if let provisioningRoleArn = self.provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let regionalParameters = regionalParameters {
            var regionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .regionalParameters)
            for (dictKey0, regionalParameterMap0) in regionalParameters {
                var regionalParameterMap0Container = regionalParametersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, regionalParameter1) in regionalParameterMap0 {
                    try regionalParameterMap0Container.encode(regionalParameter1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let manageAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRoleArn)
        manageAccessRoleArn = manageAccessRoleArnDecoded
        let enabledRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledRegions)
        var enabledRegionsDecoded0:[Swift.String]? = nil
        if let enabledRegionsContainer = enabledRegionsContainer {
            enabledRegionsDecoded0 = [Swift.String]()
            for string0 in enabledRegionsContainer {
                if let string0 = string0 {
                    enabledRegionsDecoded0?.append(string0)
                }
            }
        }
        enabledRegions = enabledRegionsDecoded0
        let regionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .regionalParameters)
        var regionalParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let regionalParametersContainer = regionalParametersContainer {
            regionalParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, regionalparameter0) in regionalParametersContainer {
                var regionalparameter0Decoded0: [Swift.String: Swift.String]? = nil
                if let regionalparameter0 = regionalparameter0 {
                    regionalparameter0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in regionalparameter0 {
                        if let string1 = string1 {
                            regionalparameter0Decoded0?[key1] = string1
                        }
                    }
                }
                regionalParametersDecoded0?[key0] = regionalparameter0Decoded0
            }
        }
        regionalParameters = regionalParametersDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataZoneClientTypes {
    /// The configuration details of an environment blueprint.
    public struct EnvironmentBlueprintConfigurationItem: Swift.Equatable {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the Amazon DataZone domain in which an environment blueprint exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The enabled Amazon Web Services Regions specified in a blueprint configuration.
        public var enabledRegions: [Swift.String]?
        /// The identifier of the environment blueprint.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The ARN of the manage access role specified in the environment blueprint configuration.
        public var manageAccessRoleArn: Swift.String?
        /// The ARN of the provisioning role specified in the environment blueprint configuration.
        public var provisioningRoleArn: Swift.String?
        /// The regional parameters of the environment blueprint.
        public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
        /// The timestamp of when the environment blueprint was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            enabledRegions: [Swift.String]? = nil,
            environmentBlueprintId: Swift.String? = nil,
            manageAccessRoleArn: Swift.String? = nil,
            provisioningRoleArn: Swift.String? = nil,
            regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.EnvironmentBlueprintSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case id
        case name
        case provider
        case provisioningProperties
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let provisioningProperties = self.provisioningProperties {
            try encodeContainer.encode(provisioningProperties, forKey: .provisioningProperties)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let provisioningPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ProvisioningProperties.self, forKey: .provisioningProperties)
        provisioningProperties = provisioningPropertiesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentBlueprintSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of an environment blueprint summary.
    public struct EnvironmentBlueprintSummary: Swift.Equatable {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a blueprint.
        public var description: Swift.String?
        /// The identifier of the blueprint.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the blueprint.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the blueprint.
        /// This member is required.
        public var provider: Swift.String?
        /// The provisioning properties of the blueprint.
        /// This member is required.
        public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
        /// The timestamp of when the blueprint was enabled.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.EnvironmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes {
    /// The failure reasons for the environment deployment.
    public struct EnvironmentError: Swift.Equatable {
        /// The error code for the failure reason for the environment deployment.
        public var code: Swift.String?
        /// The error message for the failure reason for the environment deployment.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension DataZoneClientTypes.EnvironmentParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataZoneClientTypes {
    /// The parameter details of an evironment profile.
    public struct EnvironmentParameter: Swift.Equatable {
        /// The name of an environment profile parameter.
        public var name: Swift.String?
        /// The value of an environment profile parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DataZoneClientTypes.EnvironmentProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case description
        case domainId
        case environmentBlueprintId
        case id
        case name
        case projectId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsAccountRegion = self.awsAccountRegion {
            try encodeContainer.encode(awsAccountRegion, forKey: .awsAccountRegion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let environmentBlueprintId = self.environmentBlueprintId {
            try encodeContainer.encode(environmentBlueprintId, forKey: .environmentBlueprintId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension DataZoneClientTypes.EnvironmentProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentProfileSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of an environment profile.
    public struct EnvironmentProfileSummary: Swift.Equatable {
        /// The identifier of an Amazon Web Services account in which an environment profile exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment profile exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when an environment profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the environment profile.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment profile.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment profile exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of a blueprint with which an environment profile is created.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The identifier of the environment profile.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the environment profile.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of a project in which an environment profile exists.
        public var projectId: Swift.String?
        /// The timestamp of when the environment profile was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentBlueprintId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {
    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case disabled
        case expired
        case inaccessible
        case suspended
        case updateFailed
        case updating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .disabled,
                .expired,
                .inaccessible,
                .suspended,
                .updateFailed,
                .updating,
                .validationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .expired: return "EXPIRED"
            case .inaccessible: return "INACCESSIBLE"
            case .suspended: return "SUSPENDED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case description
        case domainId
        case environmentProfileId
        case id
        case name
        case projectId
        case provider
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsAccountRegion = self.awsAccountRegion {
            try encodeContainer.encode(awsAccountRegion, forKey: .awsAccountRegion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let environmentProfileId = self.environmentProfileId {
            try encodeContainer.encode(environmentProfileId, forKey: .environmentProfileId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentProfileId)
        environmentProfileId = environmentProfileIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataZoneClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of an environment.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The identifier of the Amazon Web Services account in which an environment exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the environment.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment profile with which the environment was created.
        /// This member is required.
        public var environmentProfileId: Swift.String?
        /// The identifier of the environment.
        public var id: Swift.String?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project in which the environment exists.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the environment.
        /// This member is required.
        public var provider: Swift.String?
        /// The status of the environment.
        public var status: DataZoneClientTypes.EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentProfileId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            status: DataZoneClientTypes.EnvironmentStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentProfileId = environmentProfileId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.FailureCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes {
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public struct FailureCause: Swift.Equatable {
        /// The description of the error message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension DataZoneClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataZoneClientTypes {
    /// A search filter in Amazon DataZone.
    public struct Filter: Swift.Equatable {
        /// A search filter attribute in Amazon DataZone.
        /// This member is required.
        public var attribute: Swift.String?
        /// A search filter value in Amazon DataZone.
        /// This member is required.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.value = value
        }
    }

}

extension DataZoneClientTypes.FilterClause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and
        case filter
        case or
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .and(and):
                var andContainer = container.nestedUnkeyedContainer(forKey: .and)
                for filterclause0 in and {
                    try andContainer.encode(filterclause0)
                }
            case let .filter(filter):
                try container.encode(filter, forKey: .filter)
            case let .or(or):
                var orContainer = container.nestedUnkeyedContainer(forKey: .or)
                for filterclause0 in or {
                    try orContainer.encode(filterclause0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try values.decodeIfPresent(DataZoneClientTypes.Filter.self, forKey: .filter)
        if let filter = filterDecoded {
            self = .filter(filter)
            return
        }
        let andContainer = try values.decodeIfPresent([DataZoneClientTypes.FilterClause?].self, forKey: .and)
        var andDecoded0:[DataZoneClientTypes.FilterClause]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [DataZoneClientTypes.FilterClause]()
            for union0 in andContainer {
                if let union0 = union0 {
                    andDecoded0?.append(union0)
                }
            }
        }
        if let and = andDecoded0 {
            self = .and(and)
            return
        }
        let orContainer = try values.decodeIfPresent([DataZoneClientTypes.FilterClause?].self, forKey: .or)
        var orDecoded0:[DataZoneClientTypes.FilterClause]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [DataZoneClientTypes.FilterClause]()
            for union0 in orContainer {
                if let union0 = union0 {
                    orDecoded0?.append(union0)
                }
            }
        }
        if let or = orDecoded0 {
            self = .or(or)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// A search filter clause in Amazon DataZone.
    public indirect enum FilterClause: Swift.Equatable {
        /// A search filter in Amazon DataZone.
        case filter(DataZoneClientTypes.Filter)
        /// The 'and' search filter clause in Amazon DataZone.
        case and([DataZoneClientTypes.FilterClause])
        /// The 'or' search filter clause in Amazon DataZone.
        case or([DataZoneClientTypes.FilterClause])
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.FilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FilterExpressionType.self, forKey: .type)
        type = typeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension DataZoneClientTypes {
    /// A filter expression in Amazon DataZone.
    public struct FilterExpression: Swift.Equatable {
        /// The search filter expression.
        /// This member is required.
        public var expression: Swift.String?
        /// The search filter explresison type.
        /// This member is required.
        public var type: DataZoneClientTypes.FilterExpressionType?

        public init(
            expression: Swift.String? = nil,
            type: DataZoneClientTypes.FilterExpressionType? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension DataZoneClientTypes {
    public enum FilterExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterExpressionType] {
            return [
                .exclude,
                .include,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterExpressionType(rawValue: rawValue) ?? FilterExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.FormEntryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `required` = "required"
        case typeIdentifier
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let typeIdentifier = self.typeIdentifier {
            try encodeContainer.encode(typeIdentifier, forKey: .typeIdentifier)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the form entry.
    public struct FormEntryInput: Swift.Equatable {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The type ID of the form entry.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormEntryOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `required` = "required"
        case typeName
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension DataZoneClientTypes.FormEntryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormEntryOutput(required: \(Swift.String(describing: `required`)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the form entry.
    public struct FormEntryOutput: Swift.Equatable {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The name of the type of the form entry.
        /// This member is required.
        public var typeName: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case formName
        case typeIdentifier
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let formName = self.formName {
            try encodeContainer.encode(formName, forKey: .formName)
        }
        if let typeIdentifier = self.typeIdentifier {
            try encodeContainer.encode(typeIdentifier, forKey: .typeIdentifier)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formName)
        formName = formNameDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension DataZoneClientTypes.FormInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DataZoneClientTypes {
    /// The details of a metadata form.
    public struct FormInput: Swift.Equatable {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the metadata form type.
        public var typeIdentifier: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case formName
        case typeName
        case typeRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let formName = self.formName {
            try encodeContainer.encode(formName, forKey: .formName)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeRevision = self.typeRevision {
            try encodeContainer.encode(typeRevision, forKey: .typeRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formName)
        formName = formNameDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension DataZoneClientTypes.FormOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormOutput(content: \(Swift.String(describing: content)), formName: \(Swift.String(describing: formName)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a metadata form.
    public struct FormOutput: Swift.Equatable {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The name of the metadata form type.
        public var typeName: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormTypeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case imports
        case model
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let imports = imports {
            var importsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imports)
            for import0 in imports {
                try importsContainer.encode(import0)
            }
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let originDomainId = self.originDomainId {
            try encodeContainer.encode(originDomainId, forKey: .originDomainId)
        }
        if let originProjectId = self.originProjectId {
            try encodeContainer.encode(originProjectId, forKey: .originProjectId)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Model.self, forKey: .model)
        model = modelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FormTypeStatus.self, forKey: .status)
        status = statusDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let importsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.Import?].self, forKey: .imports)
        var importsDecoded0:[DataZoneClientTypes.Import]? = nil
        if let importsContainer = importsContainer {
            importsDecoded0 = [DataZoneClientTypes.Import]()
            for structure0 in importsContainer {
                if let structure0 = structure0 {
                    importsDecoded0?.append(structure0)
                }
            }
        }
        imports = importsDecoded0
    }
}

extension DataZoneClientTypes.FormTypeData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormTypeData(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the metadata form type.
    public struct FormTypeData: Swift.Equatable {
        /// The timestamp of when the metadata form type was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created teh metadata form type.
        public var createdBy: Swift.String?
        /// The description of the metadata form type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The imports specified in the form type.
        public var imports: [DataZoneClientTypes.Import]?
        /// The model of the form type.
        public var model: DataZoneClientTypes.Model?
        /// The name of the form type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the project in which the form type was originally created.
        public var originProjectId: Swift.String?
        /// The identifier of the project that owns the form type.
        public var owningProjectId: Swift.String?
        /// The revision of the form type.
        /// This member is required.
        public var revision: Swift.String?
        /// The status of the form type.
        public var status: DataZoneClientTypes.FormTypeStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            imports: [DataZoneClientTypes.Import]? = nil,
            model: DataZoneClientTypes.Model? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            status: DataZoneClientTypes.FormTypeStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }
    }

}

extension DataZoneClientTypes {
    public enum FormTypeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FormTypeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormTypeStatus(rawValue: rawValue) ?? FormTypeStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revision = revision {
                let revisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
                items.append(revisionQueryItem)
            }
            return items
        }
    }
}

extension GetAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

public struct GetAssetInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the Amazon DataZone asset.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

struct GetAssetInputBody: Swift.Equatable {
}

extension GetAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.externalIdentifier = output.externalIdentifier
            self.firstRevisionCreatedAt = output.firstRevisionCreatedAt
            self.firstRevisionCreatedBy = output.firstRevisionCreatedBy
            self.formsOutput = output.formsOutput
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.listing = output.listing
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.readOnlyFormsOutput = output.readOnlyFormsOutput
            self.revision = output.revision
            self.typeIdentifier = output.typeIdentifier
            self.typeRevision = output.typeRevision
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.externalIdentifier = nil
            self.firstRevisionCreatedAt = nil
            self.firstRevisionCreatedBy = nil
            self.formsOutput = nil
            self.glossaryTerms = nil
            self.id = nil
            self.listing = nil
            self.name = nil
            self.owningProjectId = nil
            self.readOnlyFormsOutput = nil
            self.revision = nil
            self.typeIdentifier = nil
            self.typeRevision = nil
        }
    }
}

public struct GetAssetOutput: Swift.Equatable {
    /// The timestamp of when the asset was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the asset.
    public var createdBy: Swift.String?
    /// The description of the Amazon DataZone asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainId: Swift.String?
    ///
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset was created.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms attached to the asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The business glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the asset.
    /// This member is required.
    public var id: Swift.String?
    ///
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The read-only metadata forms attached to the asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

struct GetAssetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let typeIdentifier: Swift.String?
    let typeRevision: Swift.String?
    let externalIdentifier: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let firstRevisionCreatedAt: ClientRuntime.Date?
    let firstRevisionCreatedBy: Swift.String?
    let glossaryTerms: [Swift.String]?
    let owningProjectId: Swift.String?
    let domainId: Swift.String?
    let listing: DataZoneClientTypes.AssetListingDetails?
    let formsOutput: [DataZoneClientTypes.FormOutput]?
    let readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
}

extension GetAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case externalIdentifier
        case firstRevisionCreatedAt
        case firstRevisionCreatedBy
        case formsOutput
        case glossaryTerms
        case id
        case listing
        case name
        case owningProjectId
        case readOnlyFormsOutput
        case revision
        case typeIdentifier
        case typeRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let typeRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeRevision)
        typeRevision = typeRevisionDecoded
        let externalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalIdentifier)
        externalIdentifier = externalIdentifierDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let firstRevisionCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstRevisionCreatedAt)
        firstRevisionCreatedAt = firstRevisionCreatedAtDecoded
        let firstRevisionCreatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstRevisionCreatedBy)
        firstRevisionCreatedBy = firstRevisionCreatedByDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let listingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AssetListingDetails.self, forKey: .listing)
        listing = listingDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in formsOutputContainer {
                if let structure0 = structure0 {
                    formsOutputDecoded0?.append(structure0)
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let readOnlyFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .readOnlyFormsOutput)
        var readOnlyFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let readOnlyFormsOutputContainer = readOnlyFormsOutputContainer {
            readOnlyFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in readOnlyFormsOutputContainer {
                if let structure0 = structure0 {
                    readOnlyFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        readOnlyFormsOutput = readOnlyFormsOutputDecoded0
    }
}

enum GetAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssetTypeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revision = revision {
                let revisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
                items.append(revisionQueryItem)
            }
            return items
        }
    }
}

extension GetAssetTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

public struct GetAssetTypeInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the asset type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

struct GetAssetTypeInputBody: Swift.Equatable {
}

extension GetAssetTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetAssetTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.formsOutput = output.formsOutput
            self.name = output.name
            self.originDomainId = output.originDomainId
            self.originProjectId = output.originProjectId
            self.owningProjectId = output.owningProjectId
            self.revision = output.revision
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.formsOutput = nil
            self.name = nil
            self.originDomainId = nil
            self.originProjectId = nil
            self.owningProjectId = nil
            self.revision = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetAssetTypeOutput: Swift.Equatable {
    /// The timestamp of when the asset type was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the asset type.
    public var createdBy: Swift.String?
    /// The description of the asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project in which the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that owns the asset type.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the asset type was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that updated the asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetAssetTypeOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let revision: Swift.String?
    let description: Swift.String?
    let formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    let owningProjectId: Swift.String?
    let originDomainId: Swift.String?
    let originProjectId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetAssetTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case formsOutput
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let formsOutputContainer = try containerValues.decodeIfPresent([Swift.String: DataZoneClientTypes.FormEntryOutput?].self, forKey: .formsOutput)
        var formsOutputDecoded0: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil
        if let formsOutputContainer = formsOutputContainer {
            formsOutputDecoded0 = [Swift.String:DataZoneClientTypes.FormEntryOutput]()
            for (key0, formentryoutput0) in formsOutputContainer {
                if let formentryoutput0 = formentryoutput0 {
                    formsOutputDecoded0?[key0] = formentryoutput0
                }
            }
        }
        formsOutput = formsOutputDecoded0
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetAssetTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone data source.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension GetDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetFormsOutput = output.assetFormsOutput
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.domainId = output.domainId
            self.enableSetting = output.enableSetting
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.lastRunAssetCount = output.lastRunAssetCount
            self.lastRunAt = output.lastRunAt
            self.lastRunErrorMessage = output.lastRunErrorMessage
            self.lastRunStatus = output.lastRunStatus
            self.name = output.name
            self.projectId = output.projectId
            self.publishOnImport = output.publishOnImport
            self.recommendation = output.recommendation
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.assetFormsOutput = nil
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.domainId = nil
            self.enableSetting = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.id = nil
            self.lastRunAssetCount = nil
            self.lastRunAt = nil
            self.lastRunErrorMessage = nil
            self.lastRunStatus = nil
            self.name = nil
            self.projectId = nil
            self.publishOnImport = nil
            self.recommendation = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDataSourceOutput: Swift.Equatable {
    /// The metadata forms attached to the assets created by this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether this data source is enabled or not.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environment where this data source creates and publishes assets,
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The number of assets created by the data source during its last run.
    public var lastRunAssetCount: Swift.Int?
    /// The timestamp of the last run of the data source.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project where the data source creates and publishes assets.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    ///
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAssetCount: Swift.Int? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAssetCount = lastRunAssetCount
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetDataSourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: DataZoneClientTypes.DataSourceStatus?
    let type: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    let recommendation: DataZoneClientTypes.RecommendationConfiguration?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let publishOnImport: Swift.Bool?
    let assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    let lastRunAt: ClientRuntime.Date?
    let lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let lastRunAssetCount: Swift.Int?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsOutput
        case configuration
        case createdAt
        case description
        case domainId
        case enableSetting
        case environmentId
        case errorMessage
        case id
        case lastRunAssetCount
        case lastRunAt
        case lastRunErrorMessage
        case lastRunStatus
        case name
        case projectId
        case publishOnImport
        case recommendation
        case schedule
        case status
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationOutput.self, forKey: .configuration)
        configuration = configurationDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RecommendationConfiguration.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .assetFormsOutput)
        var assetFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let assetFormsOutputContainer = assetFormsOutputContainer {
            assetFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in assetFormsOutputContainer {
                if let structure0 = structure0 {
                    assetFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsOutput = assetFormsOutputDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunAt)
        lastRunAt = lastRunAtDecoded
        let lastRunErrorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .lastRunErrorMessage)
        lastRunErrorMessage = lastRunErrorMessageDecoded
        let lastRunAssetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastRunAssetCount)
        lastRunAssetCount = lastRunAssetCountDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataSourceRunInput: Swift.Equatable {
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the data source run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetDataSourceRunInputBody: Swift.Equatable {
}

extension GetDataSourceRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSourceConfigurationSnapshot = output.dataSourceConfigurationSnapshot
            self.dataSourceId = output.dataSourceId
            self.domainId = output.domainId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.projectId = output.projectId
            self.runStatisticsForAssets = output.runStatisticsForAssets
            self.startedAt = output.startedAt
            self.status = output.status
            self.stoppedAt = output.stoppedAt
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSourceConfigurationSnapshot = nil
            self.dataSourceId = nil
            self.domainId = nil
            self.errorMessage = nil
            self.id = nil
            self.projectId = nil
            self.runStatisticsForAssets = nil
            self.startedAt = nil
            self.status = nil
            self.stoppedAt = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDataSourceRunOutput: Swift.Equatable {
    /// The timestamp of when the data source run was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The configuration snapshot of the data source run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The ID of the data source for this data source run.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project in which this data source run occured.
    /// This member is required.
    public var projectId: Swift.String?
    /// The asset statistics from this data source run.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when this data source run started.
    public var startedAt: ClientRuntime.Date?
    /// The status of this data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when this data source run stopped.
    public var stoppedAt: ClientRuntime.Date?
    /// The type of this data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when this data source run was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: ClientRuntime.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetDataSourceRunOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let dataSourceId: Swift.String?
    let id: Swift.String?
    let projectId: Swift.String?
    let status: DataZoneClientTypes.DataSourceRunStatus?
    let type: DataZoneClientTypes.DataSourceRunType?
    let dataSourceConfigurationSnapshot: Swift.String?
    let runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let startedAt: ClientRuntime.Date?
    let stoppedAt: ClientRuntime.Date?
}

extension GetDataSourceRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceConfigurationSnapshot
        case dataSourceId
        case domainId
        case errorMessage
        case id
        case projectId
        case runStatisticsForAssets
        case startedAt
        case status
        case stoppedAt
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunType.self, forKey: .type)
        type = typeDecoded
        let dataSourceConfigurationSnapshotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceConfigurationSnapshot)
        dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshotDecoded
        let runStatisticsForAssetsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RunStatisticsForAssets.self, forKey: .runStatisticsForAssets)
        runStatisticsForAssets = runStatisticsForAssetsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let stoppedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
    }
}

enum GetDataSourceRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDomainInput: Swift.Equatable {
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetDomainInputBody: Swift.Equatable {
}

extension GetDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.domainExecutionRole = output.domainExecutionRole
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.portalUrl = output.portalUrl
            self.singleSignOn = output.singleSignOn
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.domainExecutionRole = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.portalUrl = nil
            self.singleSignOn = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetDomainOutput: Swift.Equatable {
    /// The ARN of the specified Amazon DataZone domain.
    public var arn: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role with which the Amazon DataZone domain is created.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The single sing-on option of the specified Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the specified Amazon DataZone domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.portalUrl = portalUrl
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

struct GetDomainOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let singleSignOn: DataZoneClientTypes.SingleSignOn?
    let domainExecutionRole: Swift.String?
    let arn: Swift.String?
    let kmsKeyIdentifier: Swift.String?
    let status: DataZoneClientTypes.DomainStatus?
    let portalUrl: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case domainExecutionRole
        case id
        case kmsKeyIdentifier
        case lastUpdatedAt
        case name
        case portalUrl
        case singleSignOn
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let singleSignOnDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SingleSignOn.self, forKey: .singleSignOn)
        singleSignOn = singleSignOnDecoded
        let domainExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainExecutionRole)
        domainExecutionRole = domainExecutionRoleDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let portalUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalUrl)
        portalUrl = portalUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentBlueprintConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentBlueprintConfigurationInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// He ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

struct GetEnvironmentBlueprintConfigurationInputBody: Swift.Equatable {
}

extension GetEnvironmentBlueprintConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentBlueprintConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentBlueprintConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.domainId = output.domainId
            self.enabledRegions = output.enabledRegions
            self.environmentBlueprintId = output.environmentBlueprintId
            self.manageAccessRoleArn = output.manageAccessRoleArn
            self.provisioningRoleArn = output.provisioningRoleArn
            self.regionalParameters = output.regionalParameters
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.domainId = nil
            self.enabledRegions = nil
            self.environmentBlueprintId = nil
            self.manageAccessRoleArn = nil
            self.provisioningRoleArn = nil
            self.regionalParameters = nil
            self.updatedAt = nil
        }
    }
}

public struct GetEnvironmentBlueprintConfigurationOutput: Swift.Equatable {
    /// The timestamp of when this blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The Amazon Web Services regions in which this blueprint is enabled.
    public var enabledRegions: [Swift.String]?
    /// The ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role with which this blueprint is created.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role with which this blueprint is created.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters of the blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The timestamp of when this blueprint was upated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

struct GetEnvironmentBlueprintConfigurationOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let environmentBlueprintId: Swift.String?
    let provisioningRoleArn: Swift.String?
    let manageAccessRoleArn: Swift.String?
    let enabledRegions: [Swift.String]?
    let regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetEnvironmentBlueprintConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case domainId
        case enabledRegions
        case environmentBlueprintId
        case manageAccessRoleArn
        case provisioningRoleArn
        case regionalParameters
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let manageAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRoleArn)
        manageAccessRoleArn = manageAccessRoleArnDecoded
        let enabledRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledRegions)
        var enabledRegionsDecoded0:[Swift.String]? = nil
        if let enabledRegionsContainer = enabledRegionsContainer {
            enabledRegionsDecoded0 = [Swift.String]()
            for string0 in enabledRegionsContainer {
                if let string0 = string0 {
                    enabledRegionsDecoded0?.append(string0)
                }
            }
        }
        enabledRegions = enabledRegionsDecoded0
        let regionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .regionalParameters)
        var regionalParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let regionalParametersContainer = regionalParametersContainer {
            regionalParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, regionalparameter0) in regionalParametersContainer {
                var regionalparameter0Decoded0: [Swift.String: Swift.String]? = nil
                if let regionalparameter0 = regionalparameter0 {
                    regionalparameter0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in regionalparameter0 {
                        if let string1 = string1 {
                            regionalparameter0Decoded0?[key1] = string1
                        }
                    }
                }
                regionalParametersDecoded0?[key0] = regionalparameter0Decoded0
            }
        }
        regionalParameters = regionalParametersDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetEnvironmentBlueprintConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentBlueprintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentBlueprintInput: Swift.Equatable {
    /// The identifier of the domain in which this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetEnvironmentBlueprintInputBody: Swift.Equatable {
}

extension GetEnvironmentBlueprintInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentBlueprintOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentBlueprintOutput(createdAt: \(Swift.String(describing: createdAt)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentBlueprintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentBlueprintOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deploymentProperties = output.deploymentProperties
            self.description = output.description
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.name = output.name
            self.provider = output.provider
            self.provisioningProperties = output.provisioningProperties
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.createdAt = nil
            self.deploymentProperties = nil
            self.description = nil
            self.glossaryTerms = nil
            self.id = nil
            self.name = nil
            self.provider = nil
            self.provisioningProperties = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct GetEnvironmentBlueprintOutput: Swift.Equatable {
    /// A timestamp of when this blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment properties of this Amazon DataZone blueprint.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone blueprint.
    public var description: Swift.String?
    /// The glossary terms attached to this Amazon DataZone blueprint.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone blueprint.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of this Amazon DataZone blueprint.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioning properties of this Amazon DataZone blueprint.
    /// This member is required.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The timestamp of when this blueprint was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this blueprint.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.createdAt = createdAt
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.name = name
        self.provider = provider
        self.provisioningProperties = provisioningProperties
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct GetEnvironmentBlueprintOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let provider: Swift.String?
    let provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    let deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
    let glossaryTerms: [Swift.String]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetEnvironmentBlueprintOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deploymentProperties
        case description
        case glossaryTerms
        case id
        case name
        case provider
        case provisioningProperties
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let provisioningPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ProvisioningProperties.self, forKey: .provisioningProperties)
        provisioningProperties = provisioningPropertiesDecoded
        let deploymentPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentProperties.self, forKey: .deploymentProperties)
        deploymentProperties = deploymentPropertiesDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetEnvironmentBlueprintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.deploymentProperties = output.deploymentProperties
            self.description = output.description
            self.domainId = output.domainId
            self.environmentActions = output.environmentActions
            self.environmentBlueprintId = output.environmentBlueprintId
            self.environmentProfileId = output.environmentProfileId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastDeployment = output.lastDeployment
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.provisionedResources = output.provisionedResources
            self.provisioningProperties = output.provisioningProperties
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.deploymentProperties = nil
            self.description = nil
            self.domainId = nil
            self.environmentActions = nil
            self.environmentBlueprintId = nil
            self.environmentProfileId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastDeployment = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.provisionedResources = nil
            self.provisioningProperties = nil
            self.status = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where the environment exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where the environment exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of the environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of the environment.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The actions of the environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint with which the environment is created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which the environment is created.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The business glossary terms that can be used in this environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the environment.
    public var id: Swift.String?
    /// The details of the last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let projectId: Swift.String?
    let id: Swift.String?
    let domainId: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentProfileId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let provider: Swift.String?
    let provisionedResources: [DataZoneClientTypes.Resource]?
    let status: DataZoneClientTypes.EnvironmentStatus?
    let environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    let glossaryTerms: [Swift.String]?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
    let lastDeployment: DataZoneClientTypes.Deployment?
    let provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    let deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    let environmentBlueprintId: Swift.String?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case deploymentProperties
        case description
        case domainId
        case environmentActions
        case environmentBlueprintId
        case environmentProfileId
        case glossaryTerms
        case id
        case lastDeployment
        case name
        case projectId
        case provider
        case provisionedResources
        case provisioningProperties
        case status
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentProfileId)
        environmentProfileId = environmentProfileIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.Resource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[DataZoneClientTypes.Resource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [DataZoneClientTypes.Resource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentActionsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ConfigurableEnvironmentAction?].self, forKey: .environmentActions)
        var environmentActionsDecoded0:[DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil
        if let environmentActionsContainer = environmentActionsContainer {
            environmentActionsDecoded0 = [DataZoneClientTypes.ConfigurableEnvironmentAction]()
            for structure0 in environmentActionsContainer {
                if let structure0 = structure0 {
                    environmentActionsDecoded0?.append(structure0)
                }
            }
        }
        environmentActions = environmentActionsDecoded0
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let lastDeploymentDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Deployment.self, forKey: .lastDeployment)
        lastDeployment = lastDeploymentDecoded
        let provisioningPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ProvisioningProperties.self, forKey: .provisioningProperties)
        provisioningProperties = provisioningPropertiesDecoded
        let deploymentPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentProperties.self, forKey: .deploymentProperties)
        deploymentProperties = deploymentPropertiesDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentProfileInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetEnvironmentProfileInputBody: Swift.Equatable {
}

extension GetEnvironmentProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.environmentBlueprintId = output.environmentBlueprintId
            self.id = output.id
            self.name = output.name
            self.projectId = output.projectId
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.environmentBlueprintId = nil
            self.id = nil
            self.name = nil
            self.projectId = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct GetEnvironmentProfileOutput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where this environment profile exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where this environment profile exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was upated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of the environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct GetEnvironmentProfileOutputBody: Swift.Equatable {
    let id: Swift.String?
    let domainId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentBlueprintId: Swift.String?
    let projectId: Swift.String?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
}

extension GetEnvironmentProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case description
        case domainId
        case environmentBlueprintId
        case id
        case name
        case projectId
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
    }
}

enum GetEnvironmentProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFormTypeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revision = revision {
                let revisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
                items.append(revisionQueryItem)
            }
            return items
        }
    }
}

extension GetFormTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

public struct GetFormTypeInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?
    /// The revision of this metadata form type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
        self.revision = revision
    }
}

struct GetFormTypeInputBody: Swift.Equatable {
}

extension GetFormTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFormTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetFormTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFormTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.imports = output.imports
            self.model = output.model
            self.name = output.name
            self.originDomainId = output.originDomainId
            self.originProjectId = output.originProjectId
            self.owningProjectId = output.owningProjectId
            self.revision = output.revision
            self.status = output.status
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.imports = nil
            self.model = nil
            self.name = nil
            self.originDomainId = nil
            self.originProjectId = nil
            self.owningProjectId = nil
            self.revision = nil
            self.status = nil
        }
    }
}

public struct GetFormTypeOutput: Swift.Equatable {
    /// The timestamp of when this metadata form type was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this metadata form type.
    public var createdBy: Swift.String?
    /// The description of the metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The imports of the metadata form type.
    public var imports: [DataZoneClientTypes.Import]?
    /// The model of the metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of the metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of the metadata form type.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        imports: [DataZoneClientTypes.Import]? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.imports = imports
        self.model = model
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

struct GetFormTypeOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let revision: Swift.String?
    let model: DataZoneClientTypes.Model?
    let owningProjectId: Swift.String?
    let originDomainId: Swift.String?
    let originProjectId: Swift.String?
    let status: DataZoneClientTypes.FormTypeStatus?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let description: Swift.String?
    let imports: [DataZoneClientTypes.Import]?
}

extension GetFormTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case imports
        case model
        case name
        case originDomainId
        case originProjectId
        case owningProjectId
        case revision
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Model.self, forKey: .model)
        model = modelDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let originDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originDomainId)
        originDomainId = originDomainIdDecoded
        let originProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProjectId)
        originProjectId = originProjectIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FormTypeStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let importsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.Import?].self, forKey: .imports)
        var importsDecoded0:[DataZoneClientTypes.Import]? = nil
        if let importsContainer = importsContainer {
            importsDecoded0 = [DataZoneClientTypes.Import]()
            for structure0 in importsContainer {
                if let structure0 = structure0 {
                    importsDecoded0?.append(structure0)
                }
            }
        }
        imports = importsDecoded0
    }
}

enum GetFormTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGlossaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

public struct GetGlossaryInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetGlossaryInputBody: Swift.Equatable {
}

extension GetGlossaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetGlossaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlossaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.id = output.id
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.id = nil
            self.name = nil
            self.owningProjectId = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetGlossaryOutput: Swift.Equatable {
    /// The timestamp of when this business glossary was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this business glossary.
    public var createdBy: Swift.String?
    /// The description of the business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of the business glossary.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryStatus?
    /// The timestamp of when the business glossary was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the business glossary.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetGlossaryOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let owningProjectId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.GlossaryStatus?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetGlossaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case id
        case name
        case owningProjectId
        case status
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetGlossaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGlossaryTermInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

public struct GetGlossaryTermInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetGlossaryTermInputBody: Swift.Equatable {
}

extension GetGlossaryTermInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryTermOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension GetGlossaryTermOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlossaryTermOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.glossaryId = output.glossaryId
            self.id = output.id
            self.longDescription = output.longDescription
            self.name = output.name
            self.shortDescription = output.shortDescription
            self.status = output.status
            self.termRelations = output.termRelations
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.glossaryId = nil
            self.id = nil
            self.longDescription = nil
            self.name = nil
            self.shortDescription = nil
            self.status = nil
            self.termRelations = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetGlossaryTermOutput: Swift.Equatable {
    /// The timestamp of when the business glossary term was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the business glossary.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary to which this term belongs.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of the business glossary term.
    public var longDescription: Swift.String?
    /// The name of the business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short decription of the business glossary term.
    public var shortDescription: Swift.String?
    /// The status of the business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The relations of the business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?
    /// The timestamp of when the business glossary term was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the business glossary term.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetGlossaryTermOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let glossaryId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let shortDescription: Swift.String?
    let longDescription: Swift.String?
    let termRelations: DataZoneClientTypes.TermRelations?
    let status: DataZoneClientTypes.GlossaryTermStatus?
    let createdAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let updatedBy: Swift.String?
}

extension GetGlossaryTermOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case glossaryId
        case id
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let glossaryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryId)
        glossaryId = glossaryIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

enum GetGlossaryTermOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

public struct GetGroupProfileInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

struct GetGroupProfileInputBody: Swift.Equatable {
}

extension GetGroupProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension GetGroupProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainId = output.domainId
            self.groupName = output.groupName
            self.id = output.id
            self.status = output.status
        } else {
            self.domainId = nil
            self.groupName = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct GetGroupProfileOutput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    public var domainId: Swift.String?
    /// The name of the group for which the specified group profile exists.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The identifier of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

struct GetGroupProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let status: DataZoneClientTypes.GroupProfileStatus?
    let groupName: Swift.String?
}

extension GetGroupProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case groupName
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupProfileStatus.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

enum GetGroupProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIamPortalLoginUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/get-portal-login-url"
    }
}

public struct GetIamPortalLoginUrlInput: Swift.Equatable {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
    }
}

struct GetIamPortalLoginUrlInputBody: Swift.Equatable {
}

extension GetIamPortalLoginUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIamPortalLoginUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIamPortalLoginUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.authCodeUrl = output.authCodeUrl
            self.userProfileId = output.userProfileId
        } else {
            self.authCodeUrl = nil
            self.userProfileId = nil
        }
    }
}

public struct GetIamPortalLoginUrlOutput: Swift.Equatable {
    /// The data portal URL of the specified Amazon DataZone domain.
    public var authCodeUrl: Swift.String?
    /// The ID of the user profile.
    /// This member is required.
    public var userProfileId: Swift.String?

    public init(
        authCodeUrl: Swift.String? = nil,
        userProfileId: Swift.String? = nil
    )
    {
        self.authCodeUrl = authCodeUrl
        self.userProfileId = userProfileId
    }
}

struct GetIamPortalLoginUrlOutputBody: Swift.Equatable {
    let authCodeUrl: Swift.String?
    let userProfileId: Swift.String?
}

extension GetIamPortalLoginUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCodeUrl
        case userProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCodeUrl)
        authCodeUrl = authCodeUrlDecoded
        let userProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userProfileId)
        userProfileId = userProfileIdDecoded
    }
}

enum GetIamPortalLoginUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetListingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let listingRevision = listingRevision {
                let listingRevisionQueryItem = ClientRuntime.URLQueryItem(name: "listingRevision".urlPercentEncoding(), value: Swift.String(listingRevision).urlPercentEncoding())
                items.append(listingRevisionQueryItem)
            }
            return items
        }
    }
}

extension GetListingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

public struct GetListingInput: Swift.Equatable {
    ///
    /// This member is required.
    public var domainIdentifier: Swift.String?
    ///
    /// This member is required.
    public var identifier: Swift.String?
    ///
    public var listingRevision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        listingRevision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.listingRevision = listingRevision
    }
}

struct GetListingInputBody: Swift.Equatable {
}

extension GetListingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetListingOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetListingOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), listingRevision: \(Swift.String(describing: listingRevision)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetListingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetListingOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.id = output.id
            self.item = output.item
            self.listingRevision = output.listingRevision
            self.name = output.name
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.id = nil
            self.item = nil
            self.listingRevision = nil
            self.name = nil
            self.status = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetListingOutput: Swift.Equatable {
    ///
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the listing.
    public var createdBy: Swift.String?
    ///
    public var description: Swift.String?
    ///
    /// This member is required.
    public var domainId: Swift.String?
    ///
    /// This member is required.
    public var id: Swift.String?
    ///
    public var item: DataZoneClientTypes.ListingItem?
    ///
    /// This member is required.
    public var listingRevision: Swift.String?
    ///
    public var name: Swift.String?
    ///
    public var status: DataZoneClientTypes.ListingStatus?
    /// The timestamp of when the listing was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the listing.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        item: DataZoneClientTypes.ListingItem? = nil,
        listingRevision: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.item = item
        self.listingRevision = listingRevision
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetListingOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let listingRevision: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let item: DataZoneClientTypes.ListingItem?
    let name: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.ListingStatus?
}

extension GetListingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case id
        case item
        case listingRevision
        case name
        case status
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let listingRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingRevision)
        listingRevision = listingRevisionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let itemDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ListingItem.self, forKey: .item)
        item = itemDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ListingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetListingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

public struct GetProjectInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetProjectInputBody: Swift.Equatable {
}

extension GetProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct GetProjectOutput: Swift.Equatable {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The business glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// >The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct GetProjectOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let glossaryTerms: [Swift.String]?
}

extension GetProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case glossaryTerms
        case id
        case lastUpdatedAt
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

enum GetProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionGrantInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetSubscriptionGrantInputBody: Swift.Equatable {
}

extension GetSubscriptionGrantInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.grantedEntity = output.grantedEntity
            self.id = output.id
            self.status = output.status
            self.subscriptionId = output.subscriptionId
            self.subscriptionTargetId = output.subscriptionTargetId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.assets = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.grantedEntity = nil
            self.id = nil
            self.status = nil
            self.subscriptionId = nil
            self.subscriptionTargetId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetSubscriptionGrantOutput: Swift.Equatable {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The subscription target ID associated with the subscription grant.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant was upated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetSubscriptionGrantOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscriptionTargetId: Swift.String?
    let grantedEntity: DataZoneClientTypes.GrantedEntity?
    let status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    let assets: [DataZoneClientTypes.SubscribedAsset]?
    let subscriptionId: Swift.String?
}

extension GetSubscriptionGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case createdAt
        case createdBy
        case domainId
        case grantedEntity
        case id
        case status
        case subscriptionId
        case subscriptionTargetId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscriptionTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetId)
        subscriptionTargetId = subscriptionTargetIdDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntity.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantOverallStatus.self, forKey: .status)
        status = statusDecoded
        let assetsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedAsset?].self, forKey: .assets)
        var assetsDecoded0:[DataZoneClientTypes.SubscribedAsset]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataZoneClientTypes.SubscribedAsset]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
    }
}

enum GetSubscriptionGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetSubscriptionInputBody: Swift.Equatable {
}

extension GetSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.id = output.id
            self.retainPermissions = output.retainPermissions
            self.status = output.status
            self.subscribedListing = output.subscribedListing
            self.subscribedPrincipal = output.subscribedPrincipal
            self.subscriptionRequestId = output.subscriptionRequestId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.id = nil
            self.retainPermissions = nil
            self.status = nil
            self.subscribedListing = nil
            self.subscribedPrincipal = nil
            self.subscriptionRequestId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetSubscriptionOutput: Swift.Equatable {
    /// The timestamp of when the subscription was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The retain permissions of the subscription.
    public var retainPermissions: Swift.Bool?
    /// The status of the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    ///
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The principal that owns the subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The ID of the subscription request.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    let subscribedListing: DataZoneClientTypes.SubscribedListing?
    let subscriptionRequestId: Swift.String?
    let retainPermissions: Swift.Bool?
}

extension GetSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case id
        case retainPermissions
        case status
        case subscribedListing
        case subscribedPrincipal
        case subscriptionRequestId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscribedPrincipalDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedPrincipal.self, forKey: .subscribedPrincipal)
        subscribedPrincipal = subscribedPrincipalDecoded
        let subscribedListingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedListing.self, forKey: .subscribedListing)
        subscribedListing = subscribedListingDecoded
        let subscriptionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionRequestId)
        subscriptionRequestId = subscriptionRequestIdDecoded
        let retainPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPermissions)
        retainPermissions = retainPermissionsDecoded
    }
}

enum GetSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionRequestDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionRequestDetailsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which to get the subscription request details.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request the details of which to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct GetSubscriptionRequestDetailsInputBody: Swift.Equatable {
}

extension GetSubscriptionRequestDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionRequestDetailsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionRequestDetailsOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension GetSubscriptionRequestDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionRequestDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.decisionComment = output.decisionComment
            self.domainId = output.domainId
            self.id = output.id
            self.requestReason = output.requestReason
            self.reviewerId = output.reviewerId
            self.status = output.status
            self.subscribedListings = output.subscribedListings
            self.subscribedPrincipals = output.subscribedPrincipals
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.decisionComment = nil
            self.domainId = nil
            self.id = nil
            self.requestReason = nil
            self.reviewerId = nil
            self.status = nil
            self.subscribedListings = nil
            self.subscribedPrincipals = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetSubscriptionRequestDetailsOutput: Swift.Equatable {
    /// The timestamp of when the specified subscription request was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain of the subscription request.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings in the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetSubscriptionRequestDetailsOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionRequestStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let requestReason: Swift.String?
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    let reviewerId: Swift.String?
    let decisionComment: Swift.String?
}

extension GetSubscriptionRequestDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

enum GetSubscriptionRequestDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionTargetInput: Swift.Equatable {
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

struct GetSubscriptionTargetInputBody: Swift.Equatable {
}

extension GetSubscriptionTargetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension GetSubscriptionTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicableAssetTypes = output.applicableAssetTypes
            self.authorizedPrincipals = output.authorizedPrincipals
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.environmentId = output.environmentId
            self.id = output.id
            self.manageAccessRole = output.manageAccessRole
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.subscriptionTargetConfig = output.subscriptionTargetConfig
            self.type = output.type
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.applicableAssetTypes = nil
            self.authorizedPrincipals = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.environmentId = nil
            self.id = nil
            self.manageAccessRole = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.subscriptionTargetConfig = nil
            self.type = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct GetSubscriptionTargetOutput: Swift.Equatable {
    /// The asset types associated with the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project associated with the subscription target.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of teh subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct GetSubscriptionTargetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let authorizedPrincipals: [Swift.String]?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let name: Swift.String?
    let type: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let manageAccessRole: Swift.String?
    let applicableAssetTypes: [Swift.String]?
    let subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    let provider: Swift.String?
}

extension GetSubscriptionTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case createdAt
        case createdBy
        case domainId
        case environmentId
        case id
        case manageAccessRole
        case name
        case projectId
        case provider
        case subscriptionTargetConfig
        case type
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

enum GetSubscriptionTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension GetUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let userIdentifier = userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

public struct GetUserProfileInput: Swift.Equatable {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user for which you want to get the user profile.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

struct GetUserProfileInputBody: Swift.Equatable {
}

extension GetUserProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.domainId = output.domainId
            self.id = output.id
            self.status = output.status
            self.type = output.type
        } else {
            self.details = nil
            self.domainId = nil
            self.id = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct GetUserProfileOutput: Swift.Equatable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// the identifier of the Amazon DataZone domain of which you want to get the user profile.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

struct GetUserProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let type: DataZoneClientTypes.UserProfileType?
    let status: DataZoneClientTypes.UserProfileStatus?
    let details: DataZoneClientTypes.UserProfileDetails?
}

extension GetUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case domainId
        case id
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum GetUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.GlossaryItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case id
        case name
        case owningProjectId
        case status
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningProjectId = self.owningProjectId {
            try encodeContainer.encode(owningProjectId, forKey: .owningProjectId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DataZoneClientTypes.GlossaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a business glossary.
    public struct GlossaryItem: Swift.Equatable {
        /// The timestamp of when the glossary was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the glossary.
        public var createdBy: Swift.String?
        /// The business glossary description.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the glossary.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the glossary.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project that owns the business glosary.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The business glossary status.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryStatus?
        /// The timestamp of when the business glossary was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the business glossary.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {
    public enum GlossaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlossaryStatus(rawValue: rawValue) ?? GlossaryStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.GlossaryTermItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case glossaryId
        case id
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let glossaryId = self.glossaryId {
            try encodeContainer.encode(glossaryId, forKey: .glossaryId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let termRelations = self.termRelations {
            try encodeContainer.encode(termRelations, forKey: .termRelations)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let glossaryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryId)
        glossaryId = glossaryIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension DataZoneClientTypes.GlossaryTermItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryTermItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a business glossary term.
    public struct GlossaryTermItem: Swift.Equatable {
        /// The timestamp of when a business glossary term was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the business glossary.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the business glossary to which the term belongs.
        /// This member is required.
        public var glossaryId: Swift.String?
        /// The identifier of the business glossary term.
        /// This member is required.
        public var id: Swift.String?
        /// The long description of the business glossary term.
        public var longDescription: Swift.String?
        /// The name of the business glossary term.
        /// This member is required.
        public var name: Swift.String?
        /// The short description of the business glossary term.
        public var shortDescription: Swift.String?
        /// The status of the business glossary term.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryTermStatus?
        /// The relations of the business glossary term.
        public var termRelations: DataZoneClientTypes.TermRelations?
        /// The timestamp of when a business glossary term was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            glossaryId: Swift.String? = nil,
            id: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryTermStatus? = nil,
            termRelations: DataZoneClientTypes.TermRelations? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {
    public enum GlossaryTermStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryTermStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GlossaryTermStatus(rawValue: rawValue) ?? GlossaryTermStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.GlueRunConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRole
        case relationalFilterConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRole = self.dataAccessRole {
            try encodeContainer.encode(dataAccessRole, forKey: .dataAccessRole)
        }
        if let relationalFilterConfigurations = relationalFilterConfigurations {
            var relationalFilterConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationalFilterConfigurations)
            for relationalfilterconfiguration0 in relationalFilterConfigurations {
                try relationalFilterConfigurationsContainer.encode(relationalfilterconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRole)
        dataAccessRole = dataAccessRoleDecoded
        let relationalFilterConfigurationsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.RelationalFilterConfiguration?].self, forKey: .relationalFilterConfigurations)
        var relationalFilterConfigurationsDecoded0:[DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        if let relationalFilterConfigurationsContainer = relationalFilterConfigurationsContainer {
            relationalFilterConfigurationsDecoded0 = [DataZoneClientTypes.RelationalFilterConfiguration]()
            for structure0 in relationalFilterConfigurationsContainer {
                if let structure0 = structure0 {
                    relationalFilterConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        relationalFilterConfigurations = relationalFilterConfigurationsDecoded0
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationInput: Swift.Equatable {
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            dataAccessRole: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.dataAccessRole = dataAccessRole
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.GlueRunConfigurationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case dataAccessRole
        case region
        case relationalFilterConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataAccessRole = self.dataAccessRole {
            try encodeContainer.encode(dataAccessRole, forKey: .dataAccessRole)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let relationalFilterConfigurations = relationalFilterConfigurations {
            var relationalFilterConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationalFilterConfigurations)
            for relationalfilterconfiguration0 in relationalFilterConfigurations {
                try relationalFilterConfigurationsContainer.encode(relationalfilterconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRole)
        dataAccessRole = dataAccessRoleDecoded
        let relationalFilterConfigurationsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.RelationalFilterConfiguration?].self, forKey: .relationalFilterConfigurations)
        var relationalFilterConfigurationsDecoded0:[DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        if let relationalFilterConfigurationsContainer = relationalFilterConfigurationsContainer {
            relationalFilterConfigurationsDecoded0 = [DataZoneClientTypes.RelationalFilterConfiguration]()
            for structure0 in relationalFilterConfigurationsContainer {
                if let structure0 = structure0 {
                    relationalFilterConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        relationalFilterConfigurations = relationalFilterConfigurationsDecoded0
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationOutput: Swift.Equatable {
        /// The Amazon Web Services account ID included in the configuration details of the Amazon Web Services Glue data source.
        public var accountId: Swift.String?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The Amazon Web Services region included in the configuration details of the Amazon Web Services Glue data source.
        public var region: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            dataAccessRole: Swift.String? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.GrantedEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listing
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .listing(listing):
                try container.encode(listing, forKey: .listing)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let listingDecoded = try values.decodeIfPresent(DataZoneClientTypes.ListingRevision.self, forKey: .listing)
        if let listing = listingDecoded {
            self = .listing(listing)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of a listing for which a subscription is granted.
    public enum GrantedEntity: Swift.Equatable {
        /// The listing for which a subscription is granted.
        case listing(DataZoneClientTypes.ListingRevision)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.GrantedEntityInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listing
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .listing(listing):
                try container.encode(listing, forKey: .listing)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let listingDecoded = try values.decodeIfPresent(DataZoneClientTypes.ListingRevisionInput.self, forKey: .listing)
        if let listing = listingDecoded {
            self = .listing(listing)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of a listing for which a subscription is to be granted.
    public enum GrantedEntityInput: Swift.Equatable {
        /// The listing for which a subscription is to be granted.
        case listing(DataZoneClientTypes.ListingRevisionInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.GroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of a group in Amazon DataZone.
    public struct GroupDetails: Swift.Equatable {
        /// The identifier of the group in Amazon DataZone.
        /// This member is required.
        public var groupId: Swift.String?

        public init(
            groupId: Swift.String? = nil
        )
        {
            self.groupId = groupId
        }
    }

}

extension DataZoneClientTypes {
    public enum GroupProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assigned
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupProfileStatus] {
            return [
                .assigned,
                .notAssigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupProfileStatus(rawValue: rawValue) ?? GroupProfileStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.GroupProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case groupName
        case id
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupProfileStatus.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension DataZoneClientTypes.GroupProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupProfileSummary(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a group profile.
    public struct GroupProfileSummary: Swift.Equatable {
        /// The ID of the Amazon DataZone domain of a group profile.
        public var domainId: Swift.String?
        /// The group name of a group profile.
        public var groupName: Swift.String?
        /// The ID of a group profile.
        public var id: Swift.String?
        /// The status of a group profile.
        public var status: DataZoneClientTypes.GroupProfileStatus?

        public init(
            domainId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.GroupProfileStatus? = nil
        )
        {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }
    }

}

extension DataZoneClientTypes {
    public enum GroupSearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datazoneSsoGroup
        case ssoGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupSearchType] {
            return [
                .datazoneSsoGroup,
                .ssoGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datazoneSsoGroup: return "DATAZONE_SSO_GROUP"
            case .ssoGroup: return "SSO_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupSearchType(rawValue: rawValue) ?? GroupSearchType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.IamUserProfileDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of an IAM user profile in Amazon DataZone.
    public struct IamUserProfileDetails: Swift.Equatable {
        /// The ARN of an IAM user profile in Amazon DataZone.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DataZoneClientTypes.Import: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension DataZoneClientTypes.Import: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Import(revision: \(Swift.String(describing: revision)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the import of the metadata form type.
    public struct Import: Swift.Equatable {
        /// The name of the import.
        /// This member is required.
        public var name: Swift.String?
        /// The revision of the import.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            name: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.name = name
            self.revision = revision
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes {
    public enum InventorySearchScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case glossary
        case glossaryTerm
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySearchScope] {
            return [
                .asset,
                .glossary,
                .glossaryTerm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .glossary: return "GLOSSARY"
            case .glossaryTerm: return "GLOSSARY_TERM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventorySearchScope(rawValue: rawValue) ?? InventorySearchScope.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetRevisionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

public struct ListAssetRevisionsInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of revisions to return in a single call to ListAssetRevisions. When the number of revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var maxResults: Swift.Int?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetRevisionsInputBody: Swift.Equatable {
}

extension ListAssetRevisionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetRevisionsOutput: Swift.Equatable {
    /// The results of the ListAssetRevisions action.
    public var items: [DataZoneClientTypes.AssetRevision]?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.AssetRevision]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAssetRevisionsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.AssetRevision]?
    let nextToken: Swift.String?
}

extension ListAssetRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.AssetRevision?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.AssetRevision]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.AssetRevision]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourceRunActivitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourceRunActivitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())/activities"
    }
}

public struct ListDataSourceRunActivitiesInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which to list data source run activities.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source run.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of activities to return in a single call to ListDataSourceRunActivities. When the number of activities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var maxResults: Swift.Int?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?
    /// The status of the data source run.
    public var status: DataZoneClientTypes.DataAssetActivityStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataAssetActivityStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListDataSourceRunActivitiesInputBody: Swift.Equatable {
}

extension ListDataSourceRunActivitiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourceRunActivitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourceRunActivitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourceRunActivitiesOutput: Swift.Equatable {
    /// The results of the ListDataSourceRunActivities action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunActivity]?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunActivity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDataSourceRunActivitiesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.DataSourceRunActivity]?
    let nextToken: Swift.String?
}

extension ListDataSourceRunActivitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DataSourceRunActivity?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.DataSourceRunActivity]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.DataSourceRunActivity]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourceRunActivitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourceRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourceRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

public struct ListDataSourceRunsInput: Swift.Equatable {
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to invoke the ListDataSourceRuns action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of runs to return in a single call to ListDataSourceRuns. When the number of runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var maxResults: Swift.Int?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceRunStatus?

    public init(
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil
    )
    {
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListDataSourceRunsInputBody: Swift.Equatable {
}

extension ListDataSourceRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourceRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourceRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourceRunsOutput: Swift.Equatable {
    /// The results of the ListDataSourceRuns action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunSummary]?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDataSourceRunsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.DataSourceRunSummary]?
    let nextToken: Swift.String?
}

extension ListDataSourceRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DataSourceRunSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.DataSourceRunSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.DataSourceRunSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourceRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let environmentIdentifier = environmentIdentifier {
                let environmentIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "environmentIdentifier".urlPercentEncoding(), value: Swift.String(environmentIdentifier).urlPercentEncoding())
                items.append(environmentIdentifierQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            guard let projectIdentifier = projectIdentifier else {
                let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let projectIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
            items.append(projectIdentifierQueryItem)
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which to list the data sources.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which to list the data sources.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of data sources to return in a single call to ListDataSources. When the number of data sources to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSources to list the next set of data sources.
    public var maxResults: Swift.Int?
    /// The name of the data source.
    public var name: Swift.String?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?
    /// The identifier of the project in which to list data sources.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.status = status
        self.type = type
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutput: Swift.Equatable {
    /// The results of the ListDataSources action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceSummary]?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.DataSourceSummary]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DataSourceSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.DataSourceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.DataSourceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of domains to return in a single call to ListDomains. When the number of domains to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomains to list the next set of domains.
    public var maxResults: Swift.Int?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// The results of the ListDomains action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DomainSummary]?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DomainSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.DomainSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.DomainSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentBlueprintConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentBlueprintConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations"
    }
}

public struct ListEnvironmentBlueprintConfigurationsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of blueprint configurations to return in a single call to ListEnvironmentBlueprintConfigurations. When the number of configurations to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var maxResults: Swift.Int?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentBlueprintConfigurationsInputBody: Swift.Equatable {
}

extension ListEnvironmentBlueprintConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentBlueprintConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentBlueprintConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentBlueprintConfigurationsOutput: Swift.Equatable {
    /// The results of the ListEnvironmentBlueprintConfigurations action.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentBlueprintConfigurationsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]?
    let nextToken: Swift.String?
}

extension ListEnvironmentBlueprintConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentBlueprintConfigurationItem?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentBlueprintConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentBlueprintsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let managed = managed {
                let managedQueryItem = ClientRuntime.URLQueryItem(name: "managed".urlPercentEncoding(), value: Swift.String(managed).urlPercentEncoding())
                items.append(managedQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentBlueprintsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints"
    }
}

public struct ListEnvironmentBlueprintsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the environment blueprint is managed by Amazon DataZone.
    public var managed: Swift.Bool?
    /// The maximum number of blueprints to return in a single call to ListEnvironmentBlueprints. When the number of blueprints to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprints to list the next set of blueprints.
    public var maxResults: Swift.Int?
    /// The name of the Amazon DataZone environment.
    public var name: Swift.String?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.managed = managed
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListEnvironmentBlueprintsInputBody: Swift.Equatable {
}

extension ListEnvironmentBlueprintsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentBlueprintsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentBlueprintsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentBlueprintsOutput: Swift.Equatable {
    /// The results of the ListEnvironmentBlueprints action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintSummary]?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentBlueprintsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.EnvironmentBlueprintSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentBlueprintsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentBlueprintSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.EnvironmentBlueprintSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.EnvironmentBlueprintSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentBlueprintsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentProfilesInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension ListEnvironmentProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let environmentBlueprintIdentifier = environmentBlueprintIdentifier {
                let environmentBlueprintIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
                items.append(environmentBlueprintIdentifierQueryItem)
            }
            if let awsAccountId = awsAccountId {
                let awsAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
                items.append(awsAccountIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let awsAccountRegion = awsAccountRegion {
                let awsAccountRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
                items.append(awsAccountRegionQueryItem)
            }
            if let projectIdentifier = projectIdentifier {
                let projectIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
                items.append(projectIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

public struct ListEnvironmentProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account where you want to list environment profiles.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environment profiles.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the blueprint that was used to create the environment profiles that you want to list.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The maximum number of environment profiles to return in a single call to ListEnvironmentProfiles. When the number of environment profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var maxResults: Swift.Int?
    ///
    public var name: Swift.String?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    public var projectIdentifier: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
    }
}

struct ListEnvironmentProfilesInputBody: Swift.Equatable {
}

extension ListEnvironmentProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentProfilesOutput: Swift.Equatable {
    /// The results of the ListEnvironmentProfiles action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentProfileSummary]?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentProfilesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.EnvironmentProfileSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.EnvironmentProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.EnvironmentProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let environmentBlueprintIdentifier = environmentBlueprintIdentifier {
                let environmentBlueprintIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
                items.append(environmentBlueprintIdentifierQueryItem)
            }
            if let awsAccountId = awsAccountId {
                let awsAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
                items.append(awsAccountIdQueryItem)
            }
            if let environmentProfileIdentifier = environmentProfileIdentifier {
                let environmentProfileIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "environmentProfileIdentifier".urlPercentEncoding(), value: Swift.String(environmentProfileIdentifier).urlPercentEncoding())
                items.append(environmentProfileIdentifierQueryItem)
            }
            if let provider = provider {
                let providerQueryItem = ClientRuntime.URLQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
                items.append(providerQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let awsAccountRegion = awsAccountRegion {
                let awsAccountRegionQueryItem = ClientRuntime.URLQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
                items.append(awsAccountRegionQueryItem)
            }
            guard let projectIdentifier = projectIdentifier else {
                let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let projectIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
            items.append(projectIdentifierQueryItem)
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account where you want to list environments.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environments.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone blueprint.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The identifier of the environment profile.
    public var environmentProfileIdentifier: Swift.String?
    /// The maximum number of environments to return in a single call to ListEnvironments. When the number of environments to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironments to list the next set of environments.
    public var maxResults: Swift.Int?
    ///
    public var name: Swift.String?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The provider of the environment.
    public var provider: Swift.String?
    /// The status of the environments that you want to list.
    public var status: DataZoneClientTypes.EnvironmentStatus?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        provider: Swift.String? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.provider = provider
        self.status = status
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// The results of the ListEnvironments action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentSummary]?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.EnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.EnvironmentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.EnvironmentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotificationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let beforeTimestamp = beforeTimestamp {
                let beforeTimestampQueryItem = ClientRuntime.URLQueryItem(name: "beforeTimestamp".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeTimestamp)).urlPercentEncoding())
                items.append(beforeTimestampQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let subjects = subjects {
                subjects.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "subjects".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
            if let afterTimestamp = afterTimestamp {
                let afterTimestampQueryItem = ClientRuntime.URLQueryItem(name: "afterTimestamp".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterTimestamp)).urlPercentEncoding())
                items.append(afterTimestampQueryItem)
            }
            if let taskStatus = taskStatus {
                let taskStatusQueryItem = ClientRuntime.URLQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
                items.append(taskStatusQueryItem)
            }
            return items
        }
    }
}

extension ListNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/notifications"
    }
}

public struct ListNotificationsInput: Swift.Equatable {
    /// The time after which you want to list notifications.
    public var afterTimestamp: ClientRuntime.Date?
    /// The time before which you want to list notifications.
    public var beforeTimestamp: ClientRuntime.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of notifications to return in a single call to ListNotifications. When the number of notifications to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListNotifications to list the next set of notifications.
    public var maxResults: Swift.Int?
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The subjects of notifications.
    public var subjects: [Swift.String]?
    /// The task status of notifications.
    public var taskStatus: DataZoneClientTypes.TaskStatus?
    /// The type of notifications.
    /// This member is required.
    public var type: DataZoneClientTypes.NotificationType?

    public init(
        afterTimestamp: ClientRuntime.Date? = nil,
        beforeTimestamp: ClientRuntime.Date? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subjects: [Swift.String]? = nil,
        taskStatus: DataZoneClientTypes.TaskStatus? = nil,
        type: DataZoneClientTypes.NotificationType? = nil
    )
    {
        self.afterTimestamp = afterTimestamp
        self.beforeTimestamp = beforeTimestamp
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subjects = subjects
        self.taskStatus = taskStatus
        self.type = type
    }
}

struct ListNotificationsInputBody: Swift.Equatable {
}

extension ListNotificationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

public struct ListNotificationsOutput: Swift.Equatable {
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The results of the ListNotifications action.
    public var notifications: [DataZoneClientTypes.NotificationOutput]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [DataZoneClientTypes.NotificationOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct ListNotificationsOutputBody: Swift.Equatable {
    let notifications: [DataZoneClientTypes.NotificationOutput]?
    let nextToken: Swift.String?
}

extension ListNotificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case notifications
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.NotificationOutput?].self, forKey: .notifications)
        var notificationsDecoded0:[DataZoneClientTypes.NotificationOutput]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [DataZoneClientTypes.NotificationOutput]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            return items
        }
    }
}

extension ListProjectMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/memberships"
    }
}

public struct ListProjectMembershipsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which you want to list project memberships.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of memberships to return in a single call to ListProjectMemberships. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var maxResults: Swift.Int?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?
    /// The identifier of the project whose memberships you want to list.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The method by which you want to sort the project memberships.
    public var sortBy: DataZoneClientTypes.SortFieldProject?
    /// The sort order of the project memberships.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortFieldProject? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListProjectMembershipsInputBody: Swift.Equatable {
}

extension ListProjectMembershipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectMembershipsOutput: Swift.Equatable {
    /// The members of the project.
    /// This member is required.
    public var members: [DataZoneClientTypes.ProjectMember]?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?

    public init(
        members: [DataZoneClientTypes.ProjectMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListProjectMembershipsOutputBody: Swift.Equatable {
    let members: [DataZoneClientTypes.ProjectMember]?
    let nextToken: Swift.String?
}

extension ListProjectMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ProjectMember?].self, forKey: .members)
        var membersDecoded0:[DataZoneClientTypes.ProjectMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DataZoneClientTypes.ProjectMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupIdentifier: \(Swift.String(describing: groupIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userIdentifier: \(Swift.String(describing: userIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let userIdentifier = userIdentifier {
                let userIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "userIdentifier".urlPercentEncoding(), value: Swift.String(userIdentifier).urlPercentEncoding())
                items.append(userIdentifierQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let groupIdentifier = groupIdentifier {
                let groupIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "groupIdentifier".urlPercentEncoding(), value: Swift.String(groupIdentifier).urlPercentEncoding())
                items.append(groupIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of a group.
    public var groupIdentifier: Swift.String?
    /// The maximum number of projects to return in a single call to ListProjects. When the number of projects to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjects to list the next set of projects.
    public var maxResults: Swift.Int?
    ///
    public var name: Swift.String?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone user.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userIdentifier = userIdentifier
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// The results of the ListProjects action.
    public var items: [DataZoneClientTypes.ProjectSummary]?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.ProjectSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ProjectSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.ProjectSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.ProjectSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionGrantsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let environmentId = environmentId {
                let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
                items.append(environmentIdQueryItem)
            }
            if let subscribedListingId = subscribedListingId {
                let subscribedListingIdQueryItem = ClientRuntime.URLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
                items.append(subscribedListingIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let subscriptionTargetId = subscriptionTargetId {
                let subscriptionTargetIdQueryItem = ClientRuntime.URLQueryItem(name: "subscriptionTargetId".urlPercentEncoding(), value: Swift.String(subscriptionTargetId).urlPercentEncoding())
                items.append(subscriptionTargetIdQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let subscriptionId = subscriptionId {
                let subscriptionIdQueryItem = ClientRuntime.URLQueryItem(name: "subscriptionId".urlPercentEncoding(), value: Swift.String(subscriptionId).urlPercentEncoding())
                items.append(subscriptionIdQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionGrantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

public struct ListSubscriptionGrantsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone environment.
    public var environmentId: Swift.String?
    /// The maximum number of subscription grants to return in a single call to ListSubscriptionGrants. When the number of subscription grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var maxResults: Swift.Int?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?
    /// Specifies the way of sorting the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target.
    public var subscriptionTargetId: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.subscribedListingId = subscribedListingId
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
    }
}

struct ListSubscriptionGrantsInputBody: Swift.Equatable {
}

extension ListSubscriptionGrantsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionGrantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionGrantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionGrantsOutput: Swift.Equatable {
    /// The results of the ListSubscriptionGrants action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionGrantSummary]?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionGrantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSubscriptionGrantsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SubscriptionGrantSummary]?
    let nextToken: Swift.String?
}

extension ListSubscriptionGrantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionGrantSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SubscriptionGrantSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SubscriptionGrantSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscriptionGrantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionRequestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let approverProjectId = approverProjectId {
                let approverProjectIdQueryItem = ClientRuntime.URLQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
                items.append(approverProjectIdQueryItem)
            }
            if let subscribedListingId = subscribedListingId {
                let subscribedListingIdQueryItem = ClientRuntime.URLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
                items.append(subscribedListingIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let owningProjectId = owningProjectId {
                let owningProjectIdQueryItem = ClientRuntime.URLQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
                items.append(owningProjectIdQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

public struct ListSubscriptionRequestsInput: Swift.Equatable {
    /// The identifier of the subscription request approver's project.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscription requests to return in a single call to ListSubscriptionRequests. When the number of subscription requests to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var maxResults: Swift.Int?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?
    /// The identifier of the project for the subscription requests.
    public var owningProjectId: Swift.String?
    /// Specifies the way to sort the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// Specifies the status of the subscription requests.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListingId: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
    }
}

struct ListSubscriptionRequestsInputBody: Swift.Equatable {
}

extension ListSubscriptionRequestsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionRequestsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionRequestsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionRequestsOutput: Swift.Equatable {
    /// The results of the ListSubscriptionRequests action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionRequestSummary]?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionRequestSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSubscriptionRequestsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SubscriptionRequestSummary]?
    let nextToken: Swift.String?
}

extension ListSubscriptionRequestsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionRequestSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SubscriptionRequestSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SubscriptionRequestSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscriptionRequestsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionTargetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

public struct ListSubscriptionTargetsInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain where you want to list subscription targets.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment where you want to list subscription targets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of subscription targets to return in a single call to ListSubscriptionTargets. When the number of subscription targets to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var maxResults: Swift.Int?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListSubscriptionTargetsInputBody: Swift.Equatable {
}

extension ListSubscriptionTargetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionTargetsOutput: Swift.Equatable {
    /// The results of the ListSubscriptionTargets action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionTargetSummary]?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionTargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSubscriptionTargetsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SubscriptionTargetSummary]?
    let nextToken: Swift.String?
}

extension ListSubscriptionTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SubscriptionTargetSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SubscriptionTargetSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscriptionTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let approverProjectId = approverProjectId {
                let approverProjectIdQueryItem = ClientRuntime.URLQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
                items.append(approverProjectIdQueryItem)
            }
            if let subscribedListingId = subscribedListingId {
                let subscribedListingIdQueryItem = ClientRuntime.URLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
                items.append(subscribedListingIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let owningProjectId = owningProjectId {
                let owningProjectIdQueryItem = ClientRuntime.URLQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
                items.append(owningProjectIdQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let subscriptionRequestIdentifier = subscriptionRequestIdentifier {
                let subscriptionRequestIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "subscriptionRequestIdentifier".urlPercentEncoding(), value: Swift.String(subscriptionRequestIdentifier).urlPercentEncoding())
                items.append(subscriptionRequestIdentifierQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions"
    }
}

public struct ListSubscriptionsInput: Swift.Equatable {
    /// The identifier of the project for the subscription's approver.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscriptions to return in a single call to ListSubscriptions. When the number of subscriptions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptions to list the next set of Subscriptions.
    public var maxResults: Swift.Int?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?
    /// The identifier of the owning project.
    public var owningProjectId: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The status of the subscriptions that you want to list.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The identifier of the subscribed listing for the subscriptions that you want to list.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription request for the subscriptions that you want to list.
    public var subscriptionRequestIdentifier: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionRequestIdentifier: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
        self.subscriptionRequestIdentifier = subscriptionRequestIdentifier
    }
}

struct ListSubscriptionsInputBody: Swift.Equatable {
}

extension ListSubscriptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionsOutput: Swift.Equatable {
    /// The results of the ListSubscriptions action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionSummary]?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSubscriptionsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SubscriptionSummary]?
    let nextToken: Swift.String?
}

extension ListSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SubscriptionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SubscriptionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags of the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.ListingItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetlisting = "assetListing"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .assetlisting(assetlisting):
                try container.encode(assetlisting, forKey: .assetlisting)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let assetlistingDecoded = try values.decodeIfPresent(DataZoneClientTypes.AssetListing.self, forKey: .assetlisting)
        if let assetlisting = assetlistingDecoded {
            self = .assetlisting(assetlisting)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of a listing (aka asset published in a Amazon DataZone catalog).
    public enum ListingItem: Swift.Equatable {
        /// An asset published in an Amazon DataZone catalog.
        case assetlisting(DataZoneClientTypes.AssetListing)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.ListingRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension DataZoneClientTypes {
    /// A revision of an asset published in a Amazon DataZone catalog.
    public struct ListingRevision: Swift.Equatable {
        /// An identifier of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var id: Swift.String?
        /// The details of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.ListingRevisionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension DataZoneClientTypes {
    /// A revision to be made to an asset published in a Amazon DataZone catalog.
    public struct ListingRevisionInput: Swift.Equatable {
        /// An identifier of revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var identifier: Swift.String?
        /// The details of a revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes {
    public enum ListingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ListingStatus] {
            return [
                .active,
                .creating,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListingStatus(rawValue: rawValue) ?? ListingStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupidentifier = "groupIdentifier"
        case sdkUnknown
        case useridentifier = "userIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .groupidentifier(groupidentifier):
                try container.encode(groupidentifier, forKey: .groupidentifier)
            case let .useridentifier(useridentifier):
                try container.encode(useridentifier, forKey: .useridentifier)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let useridentifierDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .useridentifier)
        if let useridentifier = useridentifierDecoded {
            self = .useridentifier(useridentifier)
            return
        }
        let groupidentifierDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .groupidentifier)
        if let groupidentifier = groupidentifierDecoded {
            self = .groupidentifier(groupidentifier)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details about a project member.
    public enum Member: Swift.Equatable {
        /// The user ID of a project member.
        case useridentifier(Swift.String)
        /// The ID of the group of a project member.
        case groupidentifier(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.MemberDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case sdkUnknown
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .group(group):
                try container.encode(group, forKey: .group)
            case let .user(user):
                try container.encode(user, forKey: .user)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try values.decodeIfPresent(DataZoneClientTypes.UserDetails.self, forKey: .user)
        if let user = userDecoded {
            self = .user(user)
            return
        }
        let groupDecoded = try values.decodeIfPresent(DataZoneClientTypes.GroupDetails.self, forKey: .group)
        if let group = groupDecoded {
            self = .group(group)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details about a project member.
    public enum MemberDetails: Swift.Equatable {
        /// The user details of a project member.
        case user(DataZoneClientTypes.UserDetails)
        /// The group details of a project member.
        case group(DataZoneClientTypes.GroupDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case smithy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .smithy(smithy):
                try container.encode(smithy, forKey: .smithy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let smithyDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .smithy)
        if let smithy = smithyDecoded {
            self = .smithy(smithy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    ///
    public enum Model: Swift.Equatable {
        ///
        case smithy(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.NotificationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionLink
        case creationTimestamp
        case domainIdentifier
        case identifier
        case lastUpdatedTimestamp
        case message
        case metadata
        case status
        case title
        case topic
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionLink = self.actionLink {
            try encodeContainer.encode(actionLink, forKey: .actionLink)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let domainIdentifier = self.domainIdentifier {
            try encodeContainer.encode(domainIdentifier, forKey: .domainIdentifier)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadataMap0) in metadata {
                try metadataContainer.encode(metadataMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let domainIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIdentifier)
        domainIdentifier = domainIdentifierDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.NotificationType.self, forKey: .type)
        type = typeDecoded
        let topicDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Topic.self, forKey: .topic)
        topic = topicDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TaskStatus.self, forKey: .status)
        status = statusDecoded
        let actionLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionLink)
        actionLink = actionLinkDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension DataZoneClientTypes.NotificationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationOutput(creationTimestamp: \(Swift.String(describing: creationTimestamp)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), topic: \(Swift.String(describing: topic)), type: \(Swift.String(describing: type)), actionLink: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a notification generated in Amazon DataZone.
    public struct NotificationOutput: Swift.Equatable {
        /// The action link included in the notification.
        /// This member is required.
        public var actionLink: Swift.String?
        /// The timestamp of when a notification was created.
        /// This member is required.
        public var creationTimestamp: ClientRuntime.Date?
        /// The identifier of a Amazon DataZone domain in which the notification exists.
        /// This member is required.
        public var domainIdentifier: Swift.String?
        /// The identifier of the notification.
        /// This member is required.
        public var identifier: Swift.String?
        /// The timestamp of when the notification was last updated.
        /// This member is required.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The message included in the notification.
        /// This member is required.
        public var message: Swift.String?
        /// The metadata included in the notification.
        public var metadata: [Swift.String:Swift.String]?
        /// The status included in the notification.
        public var status: DataZoneClientTypes.TaskStatus?
        /// The title of the notification.
        /// This member is required.
        public var title: Swift.String?
        /// The topic of the notification.
        /// This member is required.
        public var topic: DataZoneClientTypes.Topic?
        /// The type of the notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationType?

        public init(
            actionLink: Swift.String? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            domainIdentifier: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            status: DataZoneClientTypes.TaskStatus? = nil,
            title: Swift.String? = nil,
            topic: DataZoneClientTypes.Topic? = nil,
            type: DataZoneClientTypes.NotificationType? = nil
        )
        {
            self.actionLink = actionLink
            self.creationTimestamp = creationTimestamp
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.message = message
            self.metadata = metadata
            self.status = status
            self.title = title
            self.topic = topic
            self.type = type
        }
    }

}

extension DataZoneClientTypes.NotificationResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.NotificationResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the resource mentioned in a notification.
    public struct NotificationResource: Swift.Equatable {
        /// The ID of the resource mentioned in a notification.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the resource mentioned in a notification.
        public var name: Swift.String?
        /// The type of the resource mentioned in a notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationResourceType?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DataZoneClientTypes.NotificationResourceType? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension DataZoneClientTypes {
    public enum NotificationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationResourceType] {
            return [
                .project,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationResourceType(rawValue: rawValue) ?? NotificationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum NotificationRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainOwner
        case projectContributor
        case projectOwner
        case projectSubscriber
        case projectViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationRole] {
            return [
                .domainOwner,
                .projectContributor,
                .projectOwner,
                .projectSubscriber,
                .projectViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainOwner: return "DOMAIN_OWNER"
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case .projectSubscriber: return "PROJECT_SUBSCRIBER"
            case .projectViewer: return "PROJECT_VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationRole(rawValue: rawValue) ?? NotificationRole.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .event,
                .task,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.PredictionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessNameGeneration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessNameGeneration = self.businessNameGeneration {
            try encodeContainer.encode(businessNameGeneration, forKey: .businessNameGeneration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessNameGenerationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.BusinessNameGenerationConfiguration.self, forKey: .businessNameGeneration)
        businessNameGeneration = businessNameGenerationDecoded
    }
}

extension DataZoneClientTypes {
    /// The configuration of the prediction.
    public struct PredictionConfiguration: Swift.Equatable {
        /// The business name generation mechanism.
        public var businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration?

        public init(
            businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration? = nil
        )
        {
            self.businessNameGeneration = businessNameGeneration
        }
    }

}

extension DataZoneClientTypes.ProjectMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case designation
        case memberDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let designation = self.designation {
            try encodeContainer.encode(designation.rawValue, forKey: .designation)
        }
        if let memberDetails = self.memberDetails {
            try encodeContainer.encode(memberDetails, forKey: .memberDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.MemberDetails.self, forKey: .memberDetails)
        memberDetails = memberDetailsDecoded
        let designationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserDesignation.self, forKey: .designation)
        designation = designationDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of a project member.
    public struct ProjectMember: Swift.Equatable {
        /// The designated role of a project member.
        /// This member is required.
        public var designation: DataZoneClientTypes.UserDesignation?
        /// The membership details of a project member.
        /// This member is required.
        public var memberDetails: DataZoneClientTypes.MemberDetails?

        public init(
            designation: DataZoneClientTypes.UserDesignation? = nil,
            memberDetails: DataZoneClientTypes.MemberDetails? = nil
        )
        {
            self.designation = designation
            self.memberDetails = memberDetails
        }
    }

}

extension DataZoneClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case id
        case name
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataZoneClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of a Amazon DataZone project.
    public struct ProjectSummary: Swift.Equatable {
        /// The timestamp of when a project was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the project.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of a project.
        public var description: Swift.String?
        /// The identifier of a Amazon DataZone domain where the project exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of a project.
        /// This member is required.
        public var id: Swift.String?
        /// The name of a project.
        /// This member is required.
        public var name: Swift.String?
        /// The timestamp of when the project was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.ProvisioningProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudformation = "cloudFormation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cloudformation(cloudformation):
                try container.encode(cloudformation, forKey: .cloudformation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cloudformationDecoded = try values.decodeIfPresent(DataZoneClientTypes.CloudFormationProperties.self, forKey: .cloudformation)
        if let cloudformation = cloudformationDecoded {
            self = .cloudformation(cloudformation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The provisioning properties of an environment blueprint.
    public enum ProvisioningProperties: Swift.Equatable {
        /// The cloud formation properties included as part of the provisioning properties of an environment blueprint.
        case cloudformation(DataZoneClientTypes.CloudFormationProperties)
        case sdkUnknown(Swift.String)
    }

}

extension PutEnvironmentBlueprintConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledRegions
        case manageAccessRoleArn
        case provisioningRoleArn
        case regionalParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledRegions = enabledRegions {
            var enabledRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledRegions)
            for regionname0 in enabledRegions {
                try enabledRegionsContainer.encode(regionname0)
            }
        }
        if let manageAccessRoleArn = self.manageAccessRoleArn {
            try encodeContainer.encode(manageAccessRoleArn, forKey: .manageAccessRoleArn)
        }
        if let provisioningRoleArn = self.provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let regionalParameters = regionalParameters {
            var regionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .regionalParameters)
            for (dictKey0, regionalParameterMap0) in regionalParameters {
                var regionalParameterMap0Container = regionalParametersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, regionalParameter1) in regionalParameterMap0 {
                    try regionalParameterMap0Container.encode(regionalParameter1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }
}

extension PutEnvironmentBlueprintConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

public struct PutEnvironmentBlueprintConfigurationInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    /// This member is required.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?

    public init(
        domainIdentifier: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.enabledRegions = enabledRegions
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
    }
}

struct PutEnvironmentBlueprintConfigurationInputBody: Swift.Equatable {
    let provisioningRoleArn: Swift.String?
    let manageAccessRoleArn: Swift.String?
    let enabledRegions: [Swift.String]?
    let regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
}

extension PutEnvironmentBlueprintConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledRegions
        case manageAccessRoleArn
        case provisioningRoleArn
        case regionalParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let manageAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRoleArn)
        manageAccessRoleArn = manageAccessRoleArnDecoded
        let enabledRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledRegions)
        var enabledRegionsDecoded0:[Swift.String]? = nil
        if let enabledRegionsContainer = enabledRegionsContainer {
            enabledRegionsDecoded0 = [Swift.String]()
            for string0 in enabledRegionsContainer {
                if let string0 = string0 {
                    enabledRegionsDecoded0?.append(string0)
                }
            }
        }
        enabledRegions = enabledRegionsDecoded0
        let regionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .regionalParameters)
        var regionalParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let regionalParametersContainer = regionalParametersContainer {
            regionalParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, regionalparameter0) in regionalParametersContainer {
                var regionalparameter0Decoded0: [Swift.String: Swift.String]? = nil
                if let regionalparameter0 = regionalparameter0 {
                    regionalparameter0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in regionalparameter0 {
                        if let string1 = string1 {
                            regionalparameter0Decoded0?[key1] = string1
                        }
                    }
                }
                regionalParametersDecoded0?[key0] = regionalparameter0Decoded0
            }
        }
        regionalParameters = regionalParametersDecoded0
    }
}

extension PutEnvironmentBlueprintConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutEnvironmentBlueprintConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.domainId = output.domainId
            self.enabledRegions = output.enabledRegions
            self.environmentBlueprintId = output.environmentBlueprintId
            self.manageAccessRoleArn = output.manageAccessRoleArn
            self.provisioningRoleArn = output.provisioningRoleArn
            self.regionalParameters = output.regionalParameters
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.domainId = nil
            self.enabledRegions = nil
            self.environmentBlueprintId = nil
            self.manageAccessRoleArn = nil
            self.provisioningRoleArn = nil
            self.regionalParameters = nil
            self.updatedAt = nil
        }
    }
}

public struct PutEnvironmentBlueprintConfigurationOutput: Swift.Equatable {
    /// The timestamp of when the environment blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The timestamp of when the environment blueprint was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

struct PutEnvironmentBlueprintConfigurationOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let environmentBlueprintId: Swift.String?
    let provisioningRoleArn: Swift.String?
    let manageAccessRoleArn: Swift.String?
    let enabledRegions: [Swift.String]?
    let regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension PutEnvironmentBlueprintConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case domainId
        case enabledRegions
        case environmentBlueprintId
        case manageAccessRoleArn
        case provisioningRoleArn
        case regionalParameters
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let manageAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRoleArn)
        manageAccessRoleArn = manageAccessRoleArnDecoded
        let enabledRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledRegions)
        var enabledRegionsDecoded0:[Swift.String]? = nil
        if let enabledRegionsContainer = enabledRegionsContainer {
            enabledRegionsDecoded0 = [Swift.String]()
            for string0 in enabledRegionsContainer {
                if let string0 = string0 {
                    enabledRegionsDecoded0?.append(string0)
                }
            }
        }
        enabledRegions = enabledRegionsDecoded0
        let regionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .regionalParameters)
        var regionalParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let regionalParametersContainer = regionalParametersContainer {
            regionalParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, regionalparameter0) in regionalParametersContainer {
                var regionalparameter0Decoded0: [Swift.String: Swift.String]? = nil
                if let regionalparameter0 = regionalparameter0 {
                    regionalparameter0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in regionalparameter0 {
                        if let string1 = string1 {
                            regionalparameter0Decoded0?[key1] = string1
                        }
                    }
                }
                regionalParametersDecoded0?[key0] = regionalparameter0Decoded0
            }
        }
        regionalParameters = regionalParametersDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum PutEnvironmentBlueprintConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.RecommendationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableBusinessNameGeneration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableBusinessNameGeneration = self.enableBusinessNameGeneration {
            try encodeContainer.encode(enableBusinessNameGeneration, forKey: .enableBusinessNameGeneration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableBusinessNameGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBusinessNameGeneration)
        enableBusinessNameGeneration = enableBusinessNameGenerationDecoded
    }
}

extension DataZoneClientTypes {
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public struct RecommendationConfiguration: Swift.Equatable {
        /// Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
        public var enableBusinessNameGeneration: Swift.Bool?

        public init(
            enableBusinessNameGeneration: Swift.Bool? = nil
        )
        {
            self.enableBusinessNameGeneration = enableBusinessNameGeneration
        }
    }

}

extension DataZoneClientTypes.RedshiftClusterStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift cluster storage.
    public struct RedshiftClusterStorage: Swift.Equatable {
        /// The name of an Amazon Redshift cluster.
        /// This member is required.
        public var clusterName: Swift.String?

        public init(
            clusterName: Swift.String? = nil
        )
        {
            self.clusterName = clusterName
        }
    }

}

extension DataZoneClientTypes.RedshiftCredentialConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretManagerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretManagerArn = self.secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the credentials required to access an Amazon Redshift cluster.
    public struct RedshiftCredentialConfiguration: Swift.Equatable {
        /// The ARN of a secret manager for an Amazon Redshift cluster.
        /// This member is required.
        public var secretManagerArn: Swift.String?

        public init(
            secretManagerArn: Swift.String? = nil
        )
        {
            self.secretManagerArn = secretManagerArn
        }
    }

}

extension DataZoneClientTypes.RedshiftRunConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRole
        case redshiftCredentialConfiguration
        case redshiftStorage
        case relationalFilterConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRole = self.dataAccessRole {
            try encodeContainer.encode(dataAccessRole, forKey: .dataAccessRole)
        }
        if let redshiftCredentialConfiguration = self.redshiftCredentialConfiguration {
            try encodeContainer.encode(redshiftCredentialConfiguration, forKey: .redshiftCredentialConfiguration)
        }
        if let redshiftStorage = self.redshiftStorage {
            try encodeContainer.encode(redshiftStorage, forKey: .redshiftStorage)
        }
        if let relationalFilterConfigurations = relationalFilterConfigurations {
            var relationalFilterConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationalFilterConfigurations)
            for relationalfilterconfiguration0 in relationalFilterConfigurations {
                try relationalFilterConfigurationsContainer.encode(relationalfilterconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRole)
        dataAccessRole = dataAccessRoleDecoded
        let relationalFilterConfigurationsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.RelationalFilterConfiguration?].self, forKey: .relationalFilterConfigurations)
        var relationalFilterConfigurationsDecoded0:[DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        if let relationalFilterConfigurationsContainer = relationalFilterConfigurationsContainer {
            relationalFilterConfigurationsDecoded0 = [DataZoneClientTypes.RelationalFilterConfiguration]()
            for structure0 in relationalFilterConfigurationsContainer {
                if let structure0 = structure0 {
                    relationalFilterConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        relationalFilterConfigurations = relationalFilterConfigurationsDecoded0
        let redshiftCredentialConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RedshiftCredentialConfiguration.self, forKey: .redshiftCredentialConfiguration)
        redshiftCredentialConfiguration = redshiftCredentialConfigurationDecoded
        let redshiftStorageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RedshiftStorage.self, forKey: .redshiftStorage)
        redshiftStorage = redshiftStorageDecoded
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationInput: Swift.Equatable {
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.RedshiftRunConfigurationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case dataAccessRole
        case redshiftCredentialConfiguration
        case redshiftStorage
        case region
        case relationalFilterConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataAccessRole = self.dataAccessRole {
            try encodeContainer.encode(dataAccessRole, forKey: .dataAccessRole)
        }
        if let redshiftCredentialConfiguration = self.redshiftCredentialConfiguration {
            try encodeContainer.encode(redshiftCredentialConfiguration, forKey: .redshiftCredentialConfiguration)
        }
        if let redshiftStorage = self.redshiftStorage {
            try encodeContainer.encode(redshiftStorage, forKey: .redshiftStorage)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let relationalFilterConfigurations = relationalFilterConfigurations {
            var relationalFilterConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationalFilterConfigurations)
            for relationalfilterconfiguration0 in relationalFilterConfigurations {
                try relationalFilterConfigurationsContainer.encode(relationalfilterconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRole)
        dataAccessRole = dataAccessRoleDecoded
        let relationalFilterConfigurationsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.RelationalFilterConfiguration?].self, forKey: .relationalFilterConfigurations)
        var relationalFilterConfigurationsDecoded0:[DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        if let relationalFilterConfigurationsContainer = relationalFilterConfigurationsContainer {
            relationalFilterConfigurationsDecoded0 = [DataZoneClientTypes.RelationalFilterConfiguration]()
            for structure0 in relationalFilterConfigurationsContainer {
                if let structure0 = structure0 {
                    relationalFilterConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        relationalFilterConfigurations = relationalFilterConfigurationsDecoded0
        let redshiftCredentialConfigurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RedshiftCredentialConfiguration.self, forKey: .redshiftCredentialConfiguration)
        redshiftCredentialConfiguration = redshiftCredentialConfigurationDecoded
        let redshiftStorageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RedshiftStorage.self, forKey: .redshiftStorage)
        redshiftStorage = redshiftStorageDecoded
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationOutput: Swift.Equatable {
        /// The ID of the Amazon Web Services account included in the configuration details of the Amazon Redshift data source.
        public var accountId: Swift.String?
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The Amazon Web Services region included in the configuration details of the Amazon Redshift data source.
        public var region: Swift.String?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.RedshiftServerlessStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift Serverless workgroup storage.
    public struct RedshiftServerlessStorage: Swift.Equatable {
        /// The name of the Amazon Redshift Serverless workgroup.
        /// This member is required.
        public var workgroupName: Swift.String?

        public init(
            workgroupName: Swift.String? = nil
        )
        {
            self.workgroupName = workgroupName
        }
    }

}

extension DataZoneClientTypes.RedshiftStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case redshiftclustersource = "redshiftClusterSource"
        case redshiftserverlesssource = "redshiftServerlessSource"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .redshiftclustersource(redshiftclustersource):
                try container.encode(redshiftclustersource, forKey: .redshiftclustersource)
            case let .redshiftserverlesssource(redshiftserverlesssource):
                try container.encode(redshiftserverlesssource, forKey: .redshiftserverlesssource)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftclustersourceDecoded = try values.decodeIfPresent(DataZoneClientTypes.RedshiftClusterStorage.self, forKey: .redshiftclustersource)
        if let redshiftclustersource = redshiftclustersourceDecoded {
            self = .redshiftclustersource(redshiftclustersource)
            return
        }
        let redshiftserverlesssourceDecoded = try values.decodeIfPresent(DataZoneClientTypes.RedshiftServerlessStorage.self, forKey: .redshiftserverlesssource)
        if let redshiftserverlesssource = redshiftserverlesssourceDecoded {
            self = .redshiftserverlesssource(redshiftserverlesssource)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
    public enum RedshiftStorage: Swift.Equatable {
        /// The details of the Amazon Redshift cluster source.
        case redshiftclustersource(DataZoneClientTypes.RedshiftClusterStorage)
        /// The details of the Amazon Redshift Serverless workgroup source.
        case redshiftserverlesssource(DataZoneClientTypes.RedshiftServerlessStorage)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.RejectChoice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictionChoices
        case predictionTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictionChoices = predictionChoices {
            var predictionChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictionChoices)
            for integer0 in predictionChoices {
                try predictionChoicesContainer.encode(integer0)
            }
        }
        if let predictionTarget = self.predictionTarget {
            try encodeContainer.encode(predictionTarget, forKey: .predictionTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictionTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionTarget)
        predictionTarget = predictionTargetDecoded
        let predictionChoicesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .predictionChoices)
        var predictionChoicesDecoded0:[Swift.Int]? = nil
        if let predictionChoicesContainer = predictionChoicesContainer {
            predictionChoicesDecoded0 = [Swift.Int]()
            for integer0 in predictionChoicesContainer {
                if let integer0 = integer0 {
                    predictionChoicesDecoded0?.append(integer0)
                }
            }
        }
        predictionChoices = predictionChoicesDecoded0
    }
}

extension DataZoneClientTypes {
    /// The details of the automatically generated business metadata that is rejected.
    public struct RejectChoice: Swift.Equatable {
        /// Specifies the the automatically generated business metadata that can be rejected.
        public var predictionChoices: [Swift.Int]?
        /// Specifies the target (for example, a column name) where a prediction can be rejected.
        public var predictionTarget: Swift.String?

        public init(
            predictionChoices: [Swift.Int]? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.predictionChoices = predictionChoices
            self.predictionTarget = predictionTarget
        }
    }

}

extension RejectPredictionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case rejectChoices
        case rejectRule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let rejectChoices = rejectChoices {
            var rejectChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectChoices)
            for rejectchoice0 in rejectChoices {
                try rejectChoicesContainer.encode(rejectchoice0)
            }
        }
        if let rejectRule = self.rejectRule {
            try encodeContainer.encode(rejectRule, forKey: .rejectRule)
        }
    }
}

extension RejectPredictionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revision = revision {
                let revisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
                items.append(revisionQueryItem)
            }
            return items
        }
    }
}

extension RejectPredictionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/reject-predictions"
    }
}

public struct RejectPredictionsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the prediction.
    /// This member is required.
    public var identifier: Swift.String?
    ///
    public var rejectChoices: [DataZoneClientTypes.RejectChoice]?
    ///
    public var rejectRule: DataZoneClientTypes.RejectRule?
    ///
    public var revision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        rejectChoices: [DataZoneClientTypes.RejectChoice]? = nil,
        rejectRule: DataZoneClientTypes.RejectRule? = nil,
        revision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.rejectChoices = rejectChoices
        self.rejectRule = rejectRule
        self.revision = revision
    }
}

struct RejectPredictionsInputBody: Swift.Equatable {
    let rejectRule: DataZoneClientTypes.RejectRule?
    let rejectChoices: [DataZoneClientTypes.RejectChoice]?
    let clientToken: Swift.String?
}

extension RejectPredictionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case rejectChoices
        case rejectRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rejectRuleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RejectRule.self, forKey: .rejectRule)
        rejectRule = rejectRuleDecoded
        let rejectChoicesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.RejectChoice?].self, forKey: .rejectChoices)
        var rejectChoicesDecoded0:[DataZoneClientTypes.RejectChoice]? = nil
        if let rejectChoicesContainer = rejectChoicesContainer {
            rejectChoicesDecoded0 = [DataZoneClientTypes.RejectChoice]()
            for structure0 in rejectChoicesContainer {
                if let structure0 = structure0 {
                    rejectChoicesDecoded0?.append(structure0)
                }
            }
        }
        rejectChoices = rejectChoicesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RejectPredictionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectPredictionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetId = output.assetId
            self.assetRevision = output.assetRevision
            self.domainId = output.domainId
        } else {
            self.assetId = nil
            self.assetRevision = nil
            self.domainId = nil
        }
    }
}

public struct RejectPredictionsOutput: Swift.Equatable {
    ///
    /// This member is required.
    public var assetId: Swift.String?
    ///
    /// This member is required.
    public var assetRevision: Swift.String?
    ///
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        assetRevision: Swift.String? = nil,
        domainId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.assetRevision = assetRevision
        self.domainId = domainId
    }
}

struct RejectPredictionsOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let assetId: Swift.String?
    let assetRevision: Swift.String?
}

extension RejectPredictionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetRevision
        case domainId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetRevision)
        assetRevision = assetRevisionDecoded
    }
}

enum RejectPredictionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.RejectRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = self.rule {
            try encodeContainer.encode(rule.rawValue, forKey: .rule)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RejectRuleBehavior.self, forKey: .rule)
        rule = ruleDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension DataZoneClientTypes {
    /// Specifies the rule and the threshold under which a prediction can be rejected.
    public struct RejectRule: Swift.Equatable {
        /// Specifies whether you want to reject the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.RejectRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be rejected.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.RejectRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }

}

extension DataZoneClientTypes {
    public enum RejectRuleBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RejectRuleBehavior] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RejectRuleBehavior(rawValue: rawValue) ?? RejectRuleBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RejectSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

extension RejectSubscriptionRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decisionComment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decisionComment = self.decisionComment {
            try encodeContainer.encode(decisionComment, forKey: .decisionComment)
        }
    }
}

extension RejectSubscriptionRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/reject"
    }
}

public struct RejectSubscriptionRequestInput: Swift.Equatable {
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

struct RejectSubscriptionRequestInputBody: Swift.Equatable {
    let decisionComment: Swift.String?
}

extension RejectSubscriptionRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decisionComment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

extension RejectSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension RejectSubscriptionRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectSubscriptionRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.decisionComment = output.decisionComment
            self.domainId = output.domainId
            self.id = output.id
            self.requestReason = output.requestReason
            self.reviewerId = output.reviewerId
            self.status = output.status
            self.subscribedListings = output.subscribedListings
            self.subscribedPrincipals = output.subscribedPrincipals
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.decisionComment = nil
            self.domainId = nil
            self.id = nil
            self.requestReason = nil
            self.reviewerId = nil
            self.status = nil
            self.subscribedListings = nil
            self.subscribedPrincipals = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct RejectSubscriptionRequestOutput: Swift.Equatable {
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the subscription request reviewer.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct RejectSubscriptionRequestOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionRequestStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let requestReason: Swift.String?
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    let reviewerId: Swift.String?
    let decisionComment: Swift.String?
}

extension RejectSubscriptionRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

enum RejectSubscriptionRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.RelationalFilterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case filterExpressions
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let filterExpressions = filterExpressions {
            var filterExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterExpressions)
            for filterexpression0 in filterExpressions {
                try filterExpressionsContainer.encode(filterexpression0)
            }
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let filterExpressionsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FilterExpression?].self, forKey: .filterExpressions)
        var filterExpressionsDecoded0:[DataZoneClientTypes.FilterExpression]? = nil
        if let filterExpressionsContainer = filterExpressionsContainer {
            filterExpressionsDecoded0 = [DataZoneClientTypes.FilterExpression]()
            for structure0 in filterExpressionsContainer {
                if let structure0 = structure0 {
                    filterExpressionsDecoded0?.append(structure0)
                }
            }
        }
        filterExpressions = filterExpressionsDecoded0
    }
}

extension DataZoneClientTypes {
    /// The relational filter configuration for the data source.
    public struct RelationalFilterConfiguration: Swift.Equatable {
        /// The database name specified in the relational filter configuration for the data source.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The filter expressions specified in the relational filter configuration for the data source.
        public var filterExpressions: [DataZoneClientTypes.FilterExpression]?
        /// The schema name specified in the relational filter configuration for the data source.
        public var schemaName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            filterExpressions: [DataZoneClientTypes.FilterExpression]? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.filterExpressions = filterExpressions
            self.schemaName = schemaName
        }
    }

}

extension DataZoneClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of a provisioned resource of this Amazon DataZone environment.
    public struct Resource: Swift.Equatable {
        /// The name of a provisioned resource of this Amazon DataZone environment.
        public var name: Swift.String?
        /// The provider of a provisioned resource of this Amazon DataZone environment.
        public var provider: Swift.String?
        /// The type of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?
        /// The value of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.provider = provider
            self.type = type
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevokeSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retainPermissions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retainPermissions = self.retainPermissions {
            try encodeContainer.encode(retainPermissions, forKey: .retainPermissions)
        }
    }
}

extension RevokeSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/revoke"
    }
}

public struct RevokeSubscriptionInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.retainPermissions = retainPermissions
    }
}

struct RevokeSubscriptionInputBody: Swift.Equatable {
    let retainPermissions: Swift.Bool?
}

extension RevokeSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retainPermissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPermissions)
        retainPermissions = retainPermissionsDecoded
    }
}

extension RevokeSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RevokeSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.id = output.id
            self.retainPermissions = output.retainPermissions
            self.status = output.status
            self.subscribedListing = output.subscribedListing
            self.subscribedPrincipal = output.subscribedPrincipal
            self.subscriptionRequestId = output.subscriptionRequestId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.id = nil
            self.retainPermissions = nil
            self.status = nil
            self.subscribedListing = nil
            self.subscribedPrincipal = nil
            self.subscriptionRequestId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct RevokeSubscriptionOutput: Swift.Equatable {
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The identifier of the user who revoked the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?
    /// The status of the revoked subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The subscribed listing of the revoked subscription.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The subscribed principal of the revoked subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The identifier of the subscription request for the revoked subscription.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who revoked the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct RevokeSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    let subscribedListing: DataZoneClientTypes.SubscribedListing?
    let subscriptionRequestId: Swift.String?
    let retainPermissions: Swift.Bool?
}

extension RevokeSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case id
        case retainPermissions
        case status
        case subscribedListing
        case subscribedPrincipal
        case subscriptionRequestId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscribedPrincipalDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedPrincipal.self, forKey: .subscribedPrincipal)
        subscribedPrincipal = subscribedPrincipalDecoded
        let subscribedListingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedListing.self, forKey: .subscribedListing)
        subscribedListing = subscribedListingDecoded
        let subscriptionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionRequestId)
        subscriptionRequestId = subscriptionRequestIdDecoded
        let retainPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPermissions)
        retainPermissions = retainPermissionsDecoded
    }
}

enum RevokeSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.RunStatisticsForAssets: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case added
        case failed
        case skipped
        case unchanged
        case updated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let added = self.added {
            try encodeContainer.encode(added, forKey: .added)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let skipped = self.skipped {
            try encodeContainer.encode(skipped, forKey: .skipped)
        }
        if let unchanged = self.unchanged {
            try encodeContainer.encode(unchanged, forKey: .unchanged)
        }
        if let updated = self.updated {
            try encodeContainer.encode(updated, forKey: .updated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .added)
        added = addedDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updated)
        updated = updatedDecoded
        let unchangedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unchanged)
        unchanged = unchangedDecoded
        let skippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skipped)
        skipped = skippedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension DataZoneClientTypes {
    /// The asset statistics from the data source run.
    public struct RunStatisticsForAssets: Swift.Equatable {
        /// The added statistic for the data source run.
        public var added: Swift.Int?
        /// The failed statistic for the data source run.
        public var failed: Swift.Int?
        /// The skipped statistic for the data source run.
        public var skipped: Swift.Int?
        /// The unchanged statistic for the data source run.
        public var unchanged: Swift.Int?
        /// The updated statistic for the data source run.
        public var updated: Swift.Int?

        public init(
            added: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            unchanged: Swift.Int? = nil,
            updated: Swift.Int? = nil
        )
        {
            self.added = added
            self.failed = failed
            self.skipped = skipped
            self.unchanged = unchanged
            self.updated = updated
        }
    }

}

extension DataZoneClientTypes.ScheduleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schedule
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone.rawValue, forKey: .timezone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Timezone.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension DataZoneClientTypes.ScheduleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DataZoneClientTypes {
    /// The details of the schedule of the data source runs.
    public struct ScheduleConfiguration: Swift.Equatable {
        /// The schedule of the data source runs.
        public var schedule: Swift.String?
        /// The timezone of the data source run.
        public var timezone: DataZoneClientTypes.Timezone?

        public init(
            schedule: Swift.String? = nil,
            timezone: DataZoneClientTypes.Timezone? = nil
        )
        {
            self.schedule = schedule
            self.timezone = timezone
        }
    }

}

extension SearchGroupProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchGroupProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupType: \(Swift.String(describing: groupType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchText: \"CONTENT_REDACTED\")"}
}

extension SearchGroupProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case maxResults
        case nextToken
        case searchText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchText = self.searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
    }
}

extension SearchGroupProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-group-profiles"
    }
}

public struct SearchGroupProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which you want to search group profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The group type for which to search.
    /// This member is required.
    public var groupType: DataZoneClientTypes.GroupSearchType?
    /// The maximum number of results to return in a single call to SearchGroupProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupType: DataZoneClientTypes.GroupSearchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupType = groupType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
    }
}

struct SearchGroupProfilesInputBody: Swift.Equatable {
    let groupType: DataZoneClientTypes.GroupSearchType?
    let searchText: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension SearchGroupProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case maxResults
        case nextToken
        case searchText
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupSearchType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let searchTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchGroupProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchGroupProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchGroupProfilesOutput: Swift.Equatable {
    /// The results of the SearchGroupProfiles action.
    public var items: [DataZoneClientTypes.GroupProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.GroupProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchGroupProfilesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.GroupProfileSummary]?
    let nextToken: Swift.String?
}

extension SearchGroupProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.GroupProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.GroupProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.GroupProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchGroupProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.SearchInItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the search.
    public struct SearchInItem: Swift.Equatable {
        /// The search attribute.
        /// This member is required.
        public var attribute: Swift.String?

        public init(
            attribute: Swift.String? = nil
        )
        {
            self.attribute = attribute
        }
    }

}

extension SearchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case filters
        case maxResults
        case nextToken
        case owningProjectIdentifier
        case searchIn
        case searchScope
        case searchText
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAttributes)
            for searchoutputadditionalattribute0 in additionalAttributes {
                try additionalAttributesContainer.encode(searchoutputadditionalattribute0.rawValue)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owningProjectIdentifier = self.owningProjectIdentifier {
            try encodeContainer.encode(owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }
        if let searchIn = searchIn {
            var searchInContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchIn)
            for searchinitem0 in searchIn {
                try searchInContainer.encode(searchinitem0)
            }
        }
        if let searchScope = self.searchScope {
            try encodeContainer.encode(searchScope.rawValue, forKey: .searchScope)
        }
        if let searchText = self.searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension SearchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search"
    }
}

public struct SearchInput: Swift.Equatable {
    /// Specifies additional attributes for the Search action.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the search filters.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to Search. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to Search to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the owning project specified for the search.
    public var owningProjectIdentifier: Swift.String?
    ///
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// The scope of the search.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.InventorySearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way in which the search results are to be sorted.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.InventorySearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectIdentifier = owningProjectIdentifier
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

struct SearchInputBody: Swift.Equatable {
    let owningProjectIdentifier: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let searchScope: DataZoneClientTypes.InventorySearchScope?
    let searchText: Swift.String?
    let searchIn: [DataZoneClientTypes.SearchInItem]?
    let filters: DataZoneClientTypes.FilterClause?
    let sort: DataZoneClientTypes.SearchSort?
    let additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
}

extension SearchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case filters
        case maxResults
        case nextToken
        case owningProjectIdentifier
        case searchIn
        case searchScope
        case searchText
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let owningProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectIdentifier)
        owningProjectIdentifier = owningProjectIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let searchScopeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.InventorySearchScope.self, forKey: .searchScope)
        searchScope = searchScopeDecoded
        let searchTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let searchInContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchInItem?].self, forKey: .searchIn)
        var searchInDecoded0:[DataZoneClientTypes.SearchInItem]? = nil
        if let searchInContainer = searchInContainer {
            searchInDecoded0 = [DataZoneClientTypes.SearchInItem]()
            for structure0 in searchInContainer {
                if let structure0 = structure0 {
                    searchInDecoded0?.append(structure0)
                }
            }
        }
        searchIn = searchInDecoded0
        let filtersDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FilterClause.self, forKey: .filters)
        filters = filtersDecoded
        let sortDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SearchSort.self, forKey: .sort)
        sort = sortDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchOutputAdditionalAttribute?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0:[DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [DataZoneClientTypes.SearchOutputAdditionalAttribute]()
            for enum0 in additionalAttributesContainer {
                if let enum0 = enum0 {
                    additionalAttributesDecoded0?.append(enum0)
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
    }
}

extension DataZoneClientTypes.SearchInventoryResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetitem = "assetItem"
        case dataproductitem = "dataProductItem"
        case glossaryitem = "glossaryItem"
        case glossarytermitem = "glossaryTermItem"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .assetitem(assetitem):
                try container.encode(assetitem, forKey: .assetitem)
            case let .dataproductitem(dataproductitem):
                try container.encode(dataproductitem, forKey: .dataproductitem)
            case let .glossaryitem(glossaryitem):
                try container.encode(glossaryitem, forKey: .glossaryitem)
            case let .glossarytermitem(glossarytermitem):
                try container.encode(glossarytermitem, forKey: .glossarytermitem)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let glossaryitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.GlossaryItem.self, forKey: .glossaryitem)
        if let glossaryitem = glossaryitemDecoded {
            self = .glossaryitem(glossaryitem)
            return
        }
        let glossarytermitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.GlossaryTermItem.self, forKey: .glossarytermitem)
        if let glossarytermitem = glossarytermitemDecoded {
            self = .glossarytermitem(glossarytermitem)
            return
        }
        let assetitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.AssetItem.self, forKey: .assetitem)
        if let assetitem = assetitemDecoded {
            self = .assetitem(assetitem)
            return
        }
        let dataproductitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.DataProductSummary.self, forKey: .dataproductitem)
        if let dataproductitem = dataproductitemDecoded {
            self = .dataproductitem(dataproductitem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of the search results.
    public enum SearchInventoryResultItem: Swift.Equatable {
        /// The glossary item included in the search results.
        case glossaryitem(DataZoneClientTypes.GlossaryItem)
        /// The glossary term item included in the search results.
        case glossarytermitem(DataZoneClientTypes.GlossaryTermItem)
        /// The asset item included in the search results.
        case assetitem(DataZoneClientTypes.AssetItem)
        /// The data product item included in the search results.
        case dataproductitem(DataZoneClientTypes.DataProductSummary)
        case sdkUnknown(Swift.String)
    }

}

extension SearchListingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case filters
        case maxResults
        case nextToken
        case searchIn
        case searchText
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAttributes)
            for searchoutputadditionalattribute0 in additionalAttributes {
                try additionalAttributesContainer.encode(searchoutputadditionalattribute0.rawValue)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchIn = searchIn {
            var searchInContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchIn)
            for searchinitem0 in searchIn {
                try searchInContainer.encode(searchinitem0)
            }
        }
        if let searchText = self.searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension SearchListingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/search"
    }
}

public struct SearchListingsInput: Swift.Equatable {
    /// Specifies additional attributes for the search.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the domain in which to search listings.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the filters for the search of listings.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to SearchListings. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchListings to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    ///
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way for sorting the search results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchText = searchText
        self.sort = sort
    }
}

struct SearchListingsInputBody: Swift.Equatable {
    let searchText: Swift.String?
    let searchIn: [DataZoneClientTypes.SearchInItem]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: DataZoneClientTypes.FilterClause?
    let sort: DataZoneClientTypes.SearchSort?
    let additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
}

extension SearchListingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes
        case filters
        case maxResults
        case nextToken
        case searchIn
        case searchText
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let searchInContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchInItem?].self, forKey: .searchIn)
        var searchInDecoded0:[DataZoneClientTypes.SearchInItem]? = nil
        if let searchInContainer = searchInContainer {
            searchInDecoded0 = [DataZoneClientTypes.SearchInItem]()
            for structure0 in searchInContainer {
                if let structure0 = structure0 {
                    searchInDecoded0?.append(structure0)
                }
            }
        }
        searchIn = searchInDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FilterClause.self, forKey: .filters)
        filters = filtersDecoded
        let sortDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SearchSort.self, forKey: .sort)
        sort = sortDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchOutputAdditionalAttribute?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0:[DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [DataZoneClientTypes.SearchOutputAdditionalAttribute]()
            for enum0 in additionalAttributesContainer {
                if let enum0 = enum0 {
                    additionalAttributesDecoded0?.append(enum0)
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
    }
}

extension SearchListingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchListingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
            self.totalMatchCount = output.totalMatchCount
        } else {
            self.items = nil
            self.nextToken = nil
            self.totalMatchCount = nil
        }
    }
}

public struct SearchListingsOutput: Swift.Equatable {
    /// The results of the SearchListings action.
    public var items: [DataZoneClientTypes.SearchResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

struct SearchListingsOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SearchResultItem]?
    let nextToken: Swift.String?
    let totalMatchCount: Swift.Int?
}

extension SearchListingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
        case totalMatchCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchResultItem?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SearchResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SearchResultItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalMatchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalMatchCount)
        totalMatchCount = totalMatchCountDecoded
    }
}

enum SearchListingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
            self.totalMatchCount = output.totalMatchCount
        } else {
            self.items = nil
            self.nextToken = nil
            self.totalMatchCount = nil
        }
    }
}

public struct SearchOutput: Swift.Equatable {
    /// The results of the Search action.
    public var items: [DataZoneClientTypes.SearchInventoryResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchInventoryResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

extension DataZoneClientTypes {
    public enum SearchOutputAdditionalAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forms
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchOutputAdditionalAttribute] {
            return [
                .forms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forms: return "FORMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchOutputAdditionalAttribute(rawValue: rawValue) ?? SearchOutputAdditionalAttribute.sdkUnknown(rawValue)
        }
    }
}

struct SearchOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SearchInventoryResultItem]?
    let nextToken: Swift.String?
    let totalMatchCount: Swift.Int?
}

extension SearchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
        case totalMatchCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchInventoryResultItem?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SearchInventoryResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SearchInventoryResultItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalMatchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalMatchCount)
        totalMatchCount = totalMatchCountDecoded
    }
}

enum SearchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.SearchResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetlisting = "assetListing"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .assetlisting(assetlisting):
                try container.encode(assetlisting, forKey: .assetlisting)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let assetlistingDecoded = try values.decodeIfPresent(DataZoneClientTypes.AssetListingItem.self, forKey: .assetlisting)
        if let assetlisting = assetlistingDecoded {
            self = .assetlisting(assetlisting)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of the results of the SearchListings action.
    public enum SearchResultItem: Swift.Equatable {
        /// The asset listing included in the results of the SearchListings action.
        case assetlisting(DataZoneClientTypes.AssetListingItem)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SearchSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the way to sort search results.
    public struct SearchSort: Swift.Equatable {
        /// The attribute detail of the way to sort search results.
        /// This member is required.
        public var attribute: Swift.String?
        /// The order detail of the wya to sort search results.
        public var order: DataZoneClientTypes.SortOrder?

        public init(
            attribute: Swift.String? = nil,
            order: DataZoneClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension SearchTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case managed
        case maxResults
        case nextToken
        case searchIn
        case searchScope
        case searchText
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let managed = self.managed {
            try encodeContainer.encode(managed, forKey: .managed)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchIn = searchIn {
            var searchInContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchIn)
            for searchinitem0 in searchIn {
                try searchInContainer.encode(searchinitem0)
            }
        }
        if let searchScope = self.searchScope {
            try encodeContainer.encode(searchScope.rawValue, forKey: .searchScope)
        }
        if let searchText = self.searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension SearchTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/types-search"
    }
}

public struct SearchTypesInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which to invoke the SearchTypes action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The filters for the SearchTypes action.
    public var filters: DataZoneClientTypes.FilterClause?
    ///
    /// This member is required.
    public var managed: Swift.Bool?
    /// The maximum number of results to return in a single call to SearchTypes. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchTypes to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    ///
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the scope of the search for types.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.TypesSearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// The specifies the way to sort the SearchTypes results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.TypesSearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.managed = managed
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

struct SearchTypesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let searchScope: DataZoneClientTypes.TypesSearchScope?
    let searchText: Swift.String?
    let searchIn: [DataZoneClientTypes.SearchInItem]?
    let filters: DataZoneClientTypes.FilterClause?
    let sort: DataZoneClientTypes.SearchSort?
    let managed: Swift.Bool?
}

extension SearchTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case managed
        case maxResults
        case nextToken
        case searchIn
        case searchScope
        case searchText
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let searchScopeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TypesSearchScope.self, forKey: .searchScope)
        searchScope = searchScopeDecoded
        let searchTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let searchInContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchInItem?].self, forKey: .searchIn)
        var searchInDecoded0:[DataZoneClientTypes.SearchInItem]? = nil
        if let searchInContainer = searchInContainer {
            searchInDecoded0 = [DataZoneClientTypes.SearchInItem]()
            for structure0 in searchInContainer {
                if let structure0 = structure0 {
                    searchInDecoded0?.append(structure0)
                }
            }
        }
        searchIn = searchInDecoded0
        let filtersDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FilterClause.self, forKey: .filters)
        filters = filtersDecoded
        let sortDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SearchSort.self, forKey: .sort)
        sort = sortDecoded
        let managedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .managed)
        managed = managedDecoded
    }
}

extension SearchTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
            self.totalMatchCount = output.totalMatchCount
        } else {
            self.items = nil
            self.nextToken = nil
            self.totalMatchCount = nil
        }
    }
}

public struct SearchTypesOutput: Swift.Equatable {
    /// The results of the SearchTypes action.
    public var items: [DataZoneClientTypes.SearchTypesResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchTypesResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

struct SearchTypesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.SearchTypesResultItem]?
    let nextToken: Swift.String?
    let totalMatchCount: Swift.Int?
}

extension SearchTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
        case totalMatchCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SearchTypesResultItem?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.SearchTypesResultItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.SearchTypesResultItem]()
            for union0 in itemsContainer {
                if let union0 = union0 {
                    itemsDecoded0?.append(union0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalMatchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalMatchCount)
        totalMatchCount = totalMatchCountDecoded
    }
}

enum SearchTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.SearchTypesResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assettypeitem = "assetTypeItem"
        case formtypeitem = "formTypeItem"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .assettypeitem(assettypeitem):
                try container.encode(assettypeitem, forKey: .assettypeitem)
            case let .formtypeitem(formtypeitem):
                try container.encode(formtypeitem, forKey: .formtypeitem)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let assettypeitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.AssetTypeItem.self, forKey: .assettypeitem)
        if let assettypeitem = assettypeitemDecoded {
            self = .assettypeitem(assettypeitem)
            return
        }
        let formtypeitemDecoded = try values.decodeIfPresent(DataZoneClientTypes.FormTypeData.self, forKey: .formtypeitem)
        if let formtypeitem = formtypeitemDecoded {
            self = .formtypeitem(formtypeitem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of the results of the SearchTypes action.
    public enum SearchTypesResultItem: Swift.Equatable {
        /// The asset type included in the results of the SearchTypes action.
        case assettypeitem(DataZoneClientTypes.AssetTypeItem)
        /// The form type included in the results of the SearchTypes action.
        case formtypeitem(DataZoneClientTypes.FormTypeData)
        case sdkUnknown(Swift.String)
    }

}

extension SearchUserProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchUserProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userType: \(Swift.String(describing: userType)), searchText: \"CONTENT_REDACTED\")"}
}

extension SearchUserProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case searchText
        case userType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchText = self.searchText {
            try encodeContainer.encode(searchText, forKey: .searchText)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

extension SearchUserProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-user-profiles"
    }
}

public struct SearchUserProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which you want to search user profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of results to return in a single call to SearchUserProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchUserProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the user type for the SearchUserProfiles action.
    /// This member is required.
    public var userType: DataZoneClientTypes.UserSearchType?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil,
        userType: DataZoneClientTypes.UserSearchType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
        self.userType = userType
    }
}

struct SearchUserProfilesInputBody: Swift.Equatable {
    let userType: DataZoneClientTypes.UserSearchType?
    let searchText: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension SearchUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case searchText
        case userType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userTypeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserSearchType.self, forKey: .userType)
        userType = userTypeDecoded
        let searchTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchText)
        searchText = searchTextDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchUserProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchUserProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchUserProfilesOutput: Swift.Equatable {
    /// The results of the SearchUserProfiles action.
    public var items: [DataZoneClientTypes.UserProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.UserProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchUserProfilesOutputBody: Swift.Equatable {
    let items: [DataZoneClientTypes.UserProfileSummary]?
    let nextToken: Swift.String?
}

extension SearchUserProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.UserProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[DataZoneClientTypes.UserProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DataZoneClientTypes.UserProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchUserProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has exceeded the specified service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes.SingleSignOn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case userAssignment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userAssignment = self.userAssignment {
            try encodeContainer.encode(userAssignment.rawValue, forKey: .userAssignment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.AuthType.self, forKey: .type)
        type = typeDecoded
        let userAssignmentDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserAssignment.self, forKey: .userAssignment)
        userAssignment = userAssignmentDecoded
    }
}

extension DataZoneClientTypes {
    /// The single sign-on details in Amazon DataZone.
    public struct SingleSignOn: Swift.Equatable {
        /// The type of single sign-on in Amazon DataZone.
        public var type: DataZoneClientTypes.AuthType?
        /// The single sign-on user assignment in Amazon DataZone.
        public var userAssignment: DataZoneClientTypes.UserAssignment?

        public init(
            type: DataZoneClientTypes.AuthType? = nil,
            userAssignment: DataZoneClientTypes.UserAssignment? = nil
        )
        {
            self.type = type
            self.userAssignment = userAssignment
        }
    }

}

extension DataZoneClientTypes {
    public enum SortFieldProject: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [SortFieldProject] {
            return [
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortFieldProject(rawValue: rawValue) ?? SortFieldProject.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum SortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdAt
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .createdAt,
                .updatedAt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdAt: return "CREATED_AT"
            case .updatedAt: return "UPDATED_AT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKey(rawValue: rawValue) ?? SortKey.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.SsoUserProfileDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstName
        case lastName
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
    }
}

extension DataZoneClientTypes.SsoUserProfileDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SsoUserProfileDetails(firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The single sign-on details of the user profile.
    public struct SsoUserProfileDetails: Swift.Equatable {
        /// The first name included in the single sign-on details of the user profile.
        public var firstName: Swift.String?
        /// The last name included in the single sign-on details of the user profile.
        public var lastName: Swift.String?
        /// The username included in the single sign-on details of the user profile.
        public var username: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.firstName = firstName
            self.lastName = lastName
            self.username = username
        }
    }

}

extension StartDataSourceRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension StartDataSourceRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

public struct StartDataSourceRunInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
    }
}

struct StartDataSourceRunInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension StartDataSourceRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartDataSourceRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDataSourceRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSourceConfigurationSnapshot = output.dataSourceConfigurationSnapshot
            self.dataSourceId = output.dataSourceId
            self.domainId = output.domainId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.projectId = output.projectId
            self.runStatisticsForAssets = output.runStatisticsForAssets
            self.startedAt = output.startedAt
            self.status = output.status
            self.stoppedAt = output.stoppedAt
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSourceConfigurationSnapshot = nil
            self.dataSourceId = nil
            self.domainId = nil
            self.errorMessage = nil
            self.id = nil
            self.projectId = nil
            self.runStatisticsForAssets = nil
            self.startedAt = nil
            self.status = nil
            self.stoppedAt = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct StartDataSourceRunOutput: Swift.Equatable {
    /// The timestamp of when data source run was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The configuration snapshot of the data source that is being run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies run statistics for assets.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when the data source run was started.
    public var startedAt: ClientRuntime.Date?
    /// The status of the data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when the data source run was stopped.
    public var stoppedAt: ClientRuntime.Date?
    /// The type of the data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when the data source run was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: ClientRuntime.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct StartDataSourceRunOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let dataSourceId: Swift.String?
    let id: Swift.String?
    let projectId: Swift.String?
    let status: DataZoneClientTypes.DataSourceRunStatus?
    let type: DataZoneClientTypes.DataSourceRunType?
    let dataSourceConfigurationSnapshot: Swift.String?
    let runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let startedAt: ClientRuntime.Date?
    let stoppedAt: ClientRuntime.Date?
}

extension StartDataSourceRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceConfigurationSnapshot
        case dataSourceId
        case domainId
        case errorMessage
        case id
        case projectId
        case runStatisticsForAssets
        case startedAt
        case status
        case stoppedAt
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunType.self, forKey: .type)
        type = typeDecoded
        let dataSourceConfigurationSnapshotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceConfigurationSnapshot)
        dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshotDecoded
        let runStatisticsForAssetsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RunStatisticsForAssets.self, forKey: .runStatisticsForAssets)
        runStatisticsForAssets = runStatisticsForAssetsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let stoppedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
    }
}

enum StartDataSourceRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes.SubscribedAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetRevision
        case failureCause
        case failureTimestamp
        case grantedTimestamp
        case status
        case targetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let assetRevision = self.assetRevision {
            try encodeContainer.encode(assetRevision, forKey: .assetRevision)
        }
        if let failureCause = self.failureCause {
            try encodeContainer.encode(failureCause, forKey: .failureCause)
        }
        if let failureTimestamp = self.failureTimestamp {
            try encodeContainer.encodeTimestamp(failureTimestamp, format: .epochSeconds, forKey: .failureTimestamp)
        }
        if let grantedTimestamp = self.grantedTimestamp {
            try encodeContainer.encodeTimestamp(grantedTimestamp, format: .epochSeconds, forKey: .grantedTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetRevision)
        assetRevision = assetRevisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantStatus.self, forKey: .status)
        status = statusDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let grantedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .grantedTimestamp)
        grantedTimestamp = grantedTimestampDecoded
        let failureTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .failureTimestamp)
        failureTimestamp = failureTimestampDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the asset for which the subscription grant is created.
    public struct SubscribedAsset: Swift.Equatable {
        /// The identifier of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetId: Swift.String?
        /// The revision of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetRevision: Swift.String?
        /// The failure cause included in the details of the asset for which the subscription grant is created.
        public var failureCause: DataZoneClientTypes.FailureCause?
        /// The failure timestamp included in the details of the asset for which the subscription grant is created.
        public var failureTimestamp: ClientRuntime.Date?
        /// The timestamp of when the subscription grant to the asset is created.
        public var grantedTimestamp: ClientRuntime.Date?
        /// The status of the asset for which the subscription grant is created.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantStatus?
        /// The target name of the asset for which the subscription grant is created.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            failureCause: DataZoneClientTypes.FailureCause? = nil,
            failureTimestamp: ClientRuntime.Date? = nil,
            grantedTimestamp: ClientRuntime.Date? = nil,
            status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.failureCause = failureCause
            self.failureTimestamp = failureTimestamp
            self.grantedTimestamp = grantedTimestamp
            self.status = status
            self.targetName = targetName
        }
    }

}

extension DataZoneClientTypes.SubscribedAssetListing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case entityRevision
        case entityType
        case forms
        case glossaryTerms
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityRevision = self.entityRevision {
            try encodeContainer.encode(entityRevision, forKey: .entityRevision)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let forms = self.forms {
            try encodeContainer.encode(forms, forKey: .forms)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for detailedglossaryterm0 in glossaryTerms {
                try glossaryTermsContainer.encode(detailedglossaryterm0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityRevision)
        entityRevision = entityRevisionDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let formsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forms)
        forms = formsDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.DetailedGlossaryTerm?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [DataZoneClientTypes.DetailedGlossaryTerm]()
            for structure0 in glossaryTermsContainer {
                if let structure0 = structure0 {
                    glossaryTermsDecoded0?.append(structure0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

extension DataZoneClientTypes {
    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedAssetListing: Swift.Equatable {
        /// The identifier of the published asset for which the subscription grant is created.
        public var entityId: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var entityRevision: Swift.String?
        /// The type of the published asset for which the subscription grant is created.
        public var entityType: Swift.String?
        /// The forms attached to the published asset for which the subscription grant is created.
        public var forms: Swift.String?
        /// The glossary terms attached to the published asset for which the subscription grant is created.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?

        public init(
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        )
        {
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.forms = forms
            self.glossaryTerms = glossaryTerms
        }
    }

}

extension DataZoneClientTypes.SubscribedListing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case item
        case name
        case ownerProjectId
        case ownerProjectName
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let item = self.item {
            try encodeContainer.encode(item, forKey: .item)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerProjectId = self.ownerProjectId {
            try encodeContainer.encode(ownerProjectId, forKey: .ownerProjectId)
        }
        if let ownerProjectName = self.ownerProjectName {
            try encodeContainer.encode(ownerProjectName, forKey: .ownerProjectName)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedListingItem.self, forKey: .item)
        item = itemDecoded
        let ownerProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerProjectId)
        ownerProjectId = ownerProjectIdDecoded
        let ownerProjectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerProjectName)
        ownerProjectName = ownerProjectNameDecoded
    }
}

extension DataZoneClientTypes.SubscribedListing: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedListing(id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), name: \(Swift.String(describing: name)), ownerProjectId: \(Swift.String(describing: ownerProjectId)), ownerProjectName: \(Swift.String(describing: ownerProjectName)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedListing: Swift.Equatable {
        /// The description of the published asset for which the subscription grant is created.
        /// This member is required.
        public var description: Swift.String?
        /// The identifier of the published asset for which the subscription grant is created.
        /// This member is required.
        public var id: Swift.String?
        /// The published asset for which the subscription grant is created.
        /// This member is required.
        public var item: DataZoneClientTypes.SubscribedListingItem?
        /// The name of the published asset for which the subscription grant is created.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project of the published asset for which the subscription grant is created.
        /// This member is required.
        public var ownerProjectId: Swift.String?
        /// The name of the project that owns the published asset for which the subscription grant is created.
        public var ownerProjectName: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var revision: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            item: DataZoneClientTypes.SubscribedListingItem? = nil,
            name: Swift.String? = nil,
            ownerProjectId: Swift.String? = nil,
            ownerProjectName: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.item = item
            self.name = name
            self.ownerProjectId = ownerProjectId
            self.ownerProjectName = ownerProjectName
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.SubscribedListingInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DataZoneClientTypes {
    /// The published asset for which the subscription grant is to be created.
    public struct SubscribedListingInput: Swift.Equatable {
        /// The identifier of the published asset for which the subscription grant is to be created.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension DataZoneClientTypes.SubscribedListingItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetlisting = "assetListing"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .assetlisting(assetlisting):
                try container.encode(assetlisting, forKey: .assetlisting)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let assetlistingDecoded = try values.decodeIfPresent(DataZoneClientTypes.SubscribedAssetListing.self, forKey: .assetlisting)
        if let assetlisting = assetlistingDecoded {
            self = .assetlisting(assetlisting)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The published asset for which the subscription grant is created.
    public enum SubscribedListingItem: Swift.Equatable {
        /// The asset for which the subscription grant is created.
        case assetlisting(DataZoneClientTypes.SubscribedAssetListing)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedPrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .project(project):
                try container.encode(project, forKey: .project)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try values.decodeIfPresent(DataZoneClientTypes.SubscribedProject.self, forKey: .project)
        if let project = projectDecoded {
            self = .project(project)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The principal that has the subscription grant for the asset.
    public enum SubscribedPrincipal: Swift.Equatable {
        /// The project that has the subscription grant.
        case project(DataZoneClientTypes.SubscribedProject)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedPrincipalInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .project(project):
                try container.encode(project, forKey: .project)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try values.decodeIfPresent(DataZoneClientTypes.SubscribedProjectInput.self, forKey: .project)
        if let project = projectDecoded {
            self = .project(project)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The principal that is to be given a subscriptiong grant.
    public enum SubscribedPrincipalInput: Swift.Equatable {
        /// The project that is to be given a subscription grant.
        case project(DataZoneClientTypes.SubscribedProjectInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedProject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DataZoneClientTypes.SubscribedProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedProject(id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The project that has the subscription grant.
    public struct SubscribedProject: Swift.Equatable {
        /// The identifier of the project that has the subscription grant.
        public var id: Swift.String?
        /// The name of the project that has the subscription grant.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension DataZoneClientTypes.SubscribedProjectInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DataZoneClientTypes {
    /// The project that is to be given a subscription grant.
    public struct SubscribedProjectInput: Swift.Equatable {
        /// The identifier of the project that is to be given a subscription grant.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension DataZoneClientTypes {
    public enum SubscriptionGrantOverallStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case grantAndRevokeFailed
        case grantFailed
        case inaccessible
        case inProgress
        case pending
        case revokeFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantOverallStatus] {
            return [
                .completed,
                .grantAndRevokeFailed,
                .grantFailed,
                .inaccessible,
                .inProgress,
                .pending,
                .revokeFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .grantAndRevokeFailed: return "GRANT_AND_REVOKE_FAILED"
            case .grantFailed: return "GRANT_FAILED"
            case .inaccessible: return "INACCESSIBLE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .revokeFailed: return "REVOKE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionGrantOverallStatus(rawValue: rawValue) ?? SubscriptionGrantOverallStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum SubscriptionGrantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case granted
        case grantFailed
        case grantInProgress
        case grantPending
        case revoked
        case revokeFailed
        case revokeInProgress
        case revokePending
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantStatus] {
            return [
                .granted,
                .grantFailed,
                .grantInProgress,
                .grantPending,
                .revoked,
                .revokeFailed,
                .revokeInProgress,
                .revokePending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .granted: return "GRANTED"
            case .grantFailed: return "GRANT_FAILED"
            case .grantInProgress: return "GRANT_IN_PROGRESS"
            case .grantPending: return "GRANT_PENDING"
            case .revoked: return "REVOKED"
            case .revokeFailed: return "REVOKE_FAILED"
            case .revokeInProgress: return "REVOKE_IN_PROGRESS"
            case .revokePending: return "REVOKE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionGrantStatus(rawValue: rawValue) ?? SubscriptionGrantStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.SubscriptionGrantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case createdAt
        case createdBy
        case domainId
        case grantedEntity
        case id
        case status
        case subscriptionId
        case subscriptionTargetId
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assets = assets {
            var assetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assets)
            for subscribedasset0 in assets {
                try assetsContainer.encode(subscribedasset0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let grantedEntity = self.grantedEntity {
            try encodeContainer.encode(grantedEntity, forKey: .grantedEntity)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscriptionId = self.subscriptionId {
            try encodeContainer.encode(subscriptionId, forKey: .subscriptionId)
        }
        if let subscriptionTargetId = self.subscriptionTargetId {
            try encodeContainer.encode(subscriptionTargetId, forKey: .subscriptionTargetId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscriptionTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetId)
        subscriptionTargetId = subscriptionTargetIdDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntity.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantOverallStatus.self, forKey: .status)
        status = statusDecoded
        let assetsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedAsset?].self, forKey: .assets)
        var assetsDecoded0:[DataZoneClientTypes.SubscribedAsset]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataZoneClientTypes.SubscribedAsset]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription grant.
    public struct SubscriptionGrantSummary: Swift.Equatable {
        /// The assets included in the subscription grant.
        public var assets: [DataZoneClientTypes.SubscribedAsset]?
        /// The timestamp of when a subscription grant was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The datazone user who created the subscription grant.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription grant exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The entity to which the subscription is granted.
        /// This member is required.
        public var grantedEntity: DataZoneClientTypes.GrantedEntity?
        /// The identifier of the subscription grant.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the subscription grant.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
        /// The ID of the subscription grant.
        public var subscriptionId: Swift.String?
        /// The identifier of the target of the subscription grant.
        /// This member is required.
        public var subscriptionTargetId: Swift.String?
        /// The timestampf of when the subscription grant was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription grant.
        public var updatedBy: Swift.String?

        public init(
            assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
            subscriptionId: Swift.String? = nil,
            subscriptionTargetId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {
    public enum SubscriptionRequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionRequestStatus] {
            return [
                .accepted,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionRequestStatus(rawValue: rawValue) ?? SubscriptionRequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.SubscriptionRequestSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let decisionComment = self.decisionComment {
            try encodeContainer.encode(decisionComment, forKey: .decisionComment)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let requestReason = self.requestReason {
            try encodeContainer.encode(requestReason, forKey: .requestReason)
        }
        if let reviewerId = self.reviewerId {
            try encodeContainer.encode(reviewerId, forKey: .reviewerId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribedListings = subscribedListings {
            var subscribedListingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedListings)
            for subscribedlisting0 in subscribedListings {
                try subscribedListingsContainer.encode(subscribedlisting0)
            }
        }
        if let subscribedPrincipals = subscribedPrincipals {
            var subscribedPrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribedPrincipals)
            for subscribedprincipal0 in subscribedPrincipals {
                try subscribedPrincipalsContainer.encode(subscribedprincipal0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

extension DataZoneClientTypes.SubscriptionRequestSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionRequestSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the subscription request.
    public struct SubscriptionRequestSummary: Swift.Equatable {
        /// The timestamp of when a subscription request was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription request.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The decision comment of the subscription request.
        public var decisionComment: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription request exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription request.
        /// This member is required.
        public var id: Swift.String?
        /// The reason for the subscription request.
        /// This member is required.
        public var requestReason: Swift.String?
        /// The identifier of the subscription request reviewer.
        public var reviewerId: Swift.String?
        /// The status of the subscription request.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionRequestStatus?
        /// The listings included in the subscription request.
        /// This member is required.
        public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
        /// The principals included in the subscription request.
        /// This member is required.
        public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
        /// The timestamp of when the subscription request was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The identifier of the Amazon DataZone user who updated the subscription request.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            decisionComment: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            requestReason: Swift.String? = nil,
            reviewerId: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
            subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
            subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {
    public enum SubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case cancelled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionStatus] {
            return [
                .approved,
                .cancelled,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .cancelled: return "CANCELLED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionStatus(rawValue: rawValue) ?? SubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.SubscriptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case domainId
        case id
        case retainPermissions
        case status
        case subscribedListing
        case subscribedPrincipal
        case subscriptionRequestId
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let retainPermissions = self.retainPermissions {
            try encodeContainer.encode(retainPermissions, forKey: .retainPermissions)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribedListing = self.subscribedListing {
            try encodeContainer.encode(subscribedListing, forKey: .subscribedListing)
        }
        if let subscribedPrincipal = self.subscribedPrincipal {
            try encodeContainer.encode(subscribedPrincipal, forKey: .subscribedPrincipal)
        }
        if let subscriptionRequestId = self.subscriptionRequestId {
            try encodeContainer.encode(subscriptionRequestId, forKey: .subscriptionRequestId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscribedPrincipalDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedPrincipal.self, forKey: .subscribedPrincipal)
        subscribedPrincipal = subscribedPrincipalDecoded
        let subscribedListingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscribedListing.self, forKey: .subscribedListing)
        subscribedListing = subscribedListingDecoded
        let subscriptionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionRequestId)
        subscriptionRequestId = subscriptionRequestIdDecoded
        let retainPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPermissions)
        retainPermissions = retainPermissionsDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription.
    public struct SubscriptionSummary: Swift.Equatable {
        /// The timestamp of when the subscription was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The retain permissions included in the subscription.
        public var retainPermissions: Swift.Bool?
        /// The status of the subscription.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionStatus?
        /// The listing included in the subscription.
        /// This member is required.
        public var subscribedListing: DataZoneClientTypes.SubscribedListing?
        /// The principal included in the subscription.
        /// This member is required.
        public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
        /// The identifier of the subscription request for the subscription.
        public var subscriptionRequestId: Swift.String?
        /// The timestamp of when the subscription was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            retainPermissions: Swift.Bool? = nil,
            status: DataZoneClientTypes.SubscriptionStatus? = nil,
            subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
            subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
            subscriptionRequestId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes.SubscriptionTargetForm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case formName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let formName = self.formName {
            try encodeContainer.encode(formName, forKey: .formName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formName)
        formName = formNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription target configuration.
    public struct SubscriptionTargetForm: Swift.Equatable {
        /// The content of the subscription target configuration.
        /// This member is required.
        public var content: Swift.String?
        /// The form name included in the subscription target configuration.
        /// This member is required.
        public var formName: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
        }
    }

}

extension DataZoneClientTypes.SubscriptionTargetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case createdAt
        case createdBy
        case domainId
        case environmentId
        case id
        case manageAccessRole
        case name
        case projectId
        case provider
        case subscriptionTargetConfig
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicableAssetTypes = applicableAssetTypes {
            var applicableAssetTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicableAssetTypes)
            for typename0 in applicableAssetTypes {
                try applicableAssetTypesContainer.encode(typename0)
            }
        }
        if let authorizedPrincipals = authorizedPrincipals {
            var authorizedPrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedPrincipals)
            for authorizedprincipalidentifier0 in authorizedPrincipals {
                try authorizedPrincipalsContainer.encode(authorizedprincipalidentifier0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manageAccessRole = self.manageAccessRole {
            try encodeContainer.encode(manageAccessRole, forKey: .manageAccessRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let subscriptionTargetConfig = subscriptionTargetConfig {
            var subscriptionTargetConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionTargetConfig)
            for subscriptiontargetform0 in subscriptionTargetConfig {
                try subscriptionTargetConfigContainer.encode(subscriptiontargetform0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension DataZoneClientTypes.SubscriptionTargetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionTargetSummary(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {
    /// The details of the subscription target.
    public struct SubscriptionTargetSummary: Swift.Equatable {
        /// The asset types included in the subscription target.
        /// This member is required.
        public var applicableAssetTypes: [Swift.String]?
        /// The authorized principals included in the subscription target.
        /// This member is required.
        public var authorizedPrincipals: [Swift.String]?
        /// The timestamp of when the subscription target was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription target.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the subscription target exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment of the subscription target.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The identifier of the subscription target.
        /// This member is required.
        public var id: Swift.String?
        /// The manage access role specified in the subscription target.
        /// This member is required.
        public var manageAccessRole: Swift.String?
        /// The name of the subscription target.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project specified in the subscription target.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the subscription target.
        /// This member is required.
        public var provider: Swift.String?
        /// The configuration of the subscription target.
        /// This member is required.
        public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
        /// The type of the subscription target.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the subscription target was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription target.
        public var updatedBy: Swift.String?

        public init(
            applicableAssetTypes: [Swift.String]? = nil,
            authorizedPrincipals: [Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            manageAccessRole: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tags for the TagResource action.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.TermRelations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classifies
        case isa = "isA"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classifies = classifies {
            var classifiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classifies)
            for glossarytermid0 in classifies {
                try classifiesContainer.encode(glossarytermid0)
            }
        }
        if let isa = isa {
            var isaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .isa)
            for glossarytermid0 in isa {
                try isaContainer.encode(glossarytermid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isaContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .isa)
        var isaDecoded0:[Swift.String]? = nil
        if let isaContainer = isaContainer {
            isaDecoded0 = [Swift.String]()
            for string0 in isaContainer {
                if let string0 = string0 {
                    isaDecoded0?.append(string0)
                }
            }
        }
        isa = isaDecoded0
        let classifiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .classifies)
        var classifiesDecoded0:[Swift.String]? = nil
        if let classifiesContainer = classifiesContainer {
            classifiesDecoded0 = [Swift.String]()
            for string0 in classifiesContainer {
                if let string0 = string0 {
                    classifiesDecoded0?.append(string0)
                }
            }
        }
        classifies = classifiesDecoded0
    }
}

extension DataZoneClientTypes {
    /// The details of the term relations.
    public struct TermRelations: Swift.Equatable {
        /// The classifies of the term relations.
        public var classifies: [Swift.String]?
        /// The isA property of the term relations.
        public var isa: [Swift.String]?

        public init(
            classifies: [Swift.String]? = nil,
            isa: [Swift.String]? = nil
        )
        {
            self.classifies = classifies
            self.isa = isa
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataZoneClientTypes {
    public enum Timezone: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case africaJohannesburg
        case americaMontreal
        case americaSaoPaulo
        case asiaBahrain
        case asiaBangkok
        case asiaCalcutta
        case asiaDubai
        case asiaHongKong
        case asiaJakarta
        case asiaKualaLumpur
        case asiaSeoul
        case asiaShanghai
        case asiaSingapore
        case asiaTaipei
        case asiaTokyo
        case australiaMelbourne
        case australiaSydney
        case canadaCentral
        case cet
        case cst6cdt
        case etcGmt
        case etcGmt0
        case etcGmtAdd0
        case etcGmtAdd1
        case etcGmtAdd10
        case etcGmtAdd11
        case etcGmtAdd12
        case etcGmtAdd2
        case etcGmtAdd3
        case etcGmtAdd4
        case etcGmtAdd5
        case etcGmtAdd6
        case etcGmtAdd7
        case etcGmtAdd8
        case etcGmtAdd9
        case etcGmtNeg0
        case etcGmtNeg1
        case etcGmtNeg10
        case etcGmtNeg11
        case etcGmtNeg12
        case etcGmtNeg13
        case etcGmtNeg14
        case etcGmtNeg2
        case etcGmtNeg3
        case etcGmtNeg4
        case etcGmtNeg5
        case etcGmtNeg6
        case etcGmtNeg7
        case etcGmtNeg8
        case etcGmtNeg9
        case europeDublin
        case europeLondon
        case europeParis
        case europeStockholm
        case europeZurich
        case israel
        case mexicoGeneral
        case mst7mdt
        case pacificAuckland
        case usCentral
        case usEastern
        case usMountain
        case usPacific
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [Timezone] {
            return [
                .africaJohannesburg,
                .americaMontreal,
                .americaSaoPaulo,
                .asiaBahrain,
                .asiaBangkok,
                .asiaCalcutta,
                .asiaDubai,
                .asiaHongKong,
                .asiaJakarta,
                .asiaKualaLumpur,
                .asiaSeoul,
                .asiaShanghai,
                .asiaSingapore,
                .asiaTaipei,
                .asiaTokyo,
                .australiaMelbourne,
                .australiaSydney,
                .canadaCentral,
                .cet,
                .cst6cdt,
                .etcGmt,
                .etcGmt0,
                .etcGmtAdd0,
                .etcGmtAdd1,
                .etcGmtAdd10,
                .etcGmtAdd11,
                .etcGmtAdd12,
                .etcGmtAdd2,
                .etcGmtAdd3,
                .etcGmtAdd4,
                .etcGmtAdd5,
                .etcGmtAdd6,
                .etcGmtAdd7,
                .etcGmtAdd8,
                .etcGmtAdd9,
                .etcGmtNeg0,
                .etcGmtNeg1,
                .etcGmtNeg10,
                .etcGmtNeg11,
                .etcGmtNeg12,
                .etcGmtNeg13,
                .etcGmtNeg14,
                .etcGmtNeg2,
                .etcGmtNeg3,
                .etcGmtNeg4,
                .etcGmtNeg5,
                .etcGmtNeg6,
                .etcGmtNeg7,
                .etcGmtNeg8,
                .etcGmtNeg9,
                .europeDublin,
                .europeLondon,
                .europeParis,
                .europeStockholm,
                .europeZurich,
                .israel,
                .mexicoGeneral,
                .mst7mdt,
                .pacificAuckland,
                .usCentral,
                .usEastern,
                .usMountain,
                .usPacific,
                .utc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .africaJohannesburg: return "AFRICA_JOHANNESBURG"
            case .americaMontreal: return "AMERICA_MONTREAL"
            case .americaSaoPaulo: return "AMERICA_SAO_PAULO"
            case .asiaBahrain: return "ASIA_BAHRAIN"
            case .asiaBangkok: return "ASIA_BANGKOK"
            case .asiaCalcutta: return "ASIA_CALCUTTA"
            case .asiaDubai: return "ASIA_DUBAI"
            case .asiaHongKong: return "ASIA_HONG_KONG"
            case .asiaJakarta: return "ASIA_JAKARTA"
            case .asiaKualaLumpur: return "ASIA_KUALA_LUMPUR"
            case .asiaSeoul: return "ASIA_SEOUL"
            case .asiaShanghai: return "ASIA_SHANGHAI"
            case .asiaSingapore: return "ASIA_SINGAPORE"
            case .asiaTaipei: return "ASIA_TAIPEI"
            case .asiaTokyo: return "ASIA_TOKYO"
            case .australiaMelbourne: return "AUSTRALIA_MELBOURNE"
            case .australiaSydney: return "AUSTRALIA_SYDNEY"
            case .canadaCentral: return "CANADA_CENTRAL"
            case .cet: return "CET"
            case .cst6cdt: return "CST6CDT"
            case .etcGmt: return "ETC_GMT"
            case .etcGmt0: return "ETC_GMT0"
            case .etcGmtAdd0: return "ETC_GMT_ADD_0"
            case .etcGmtAdd1: return "ETC_GMT_ADD_1"
            case .etcGmtAdd10: return "ETC_GMT_ADD_10"
            case .etcGmtAdd11: return "ETC_GMT_ADD_11"
            case .etcGmtAdd12: return "ETC_GMT_ADD_12"
            case .etcGmtAdd2: return "ETC_GMT_ADD_2"
            case .etcGmtAdd3: return "ETC_GMT_ADD_3"
            case .etcGmtAdd4: return "ETC_GMT_ADD_4"
            case .etcGmtAdd5: return "ETC_GMT_ADD_5"
            case .etcGmtAdd6: return "ETC_GMT_ADD_6"
            case .etcGmtAdd7: return "ETC_GMT_ADD_7"
            case .etcGmtAdd8: return "ETC_GMT_ADD_8"
            case .etcGmtAdd9: return "ETC_GMT_ADD_9"
            case .etcGmtNeg0: return "ETC_GMT_NEG_0"
            case .etcGmtNeg1: return "ETC_GMT_NEG_1"
            case .etcGmtNeg10: return "ETC_GMT_NEG_10"
            case .etcGmtNeg11: return "ETC_GMT_NEG_11"
            case .etcGmtNeg12: return "ETC_GMT_NEG_12"
            case .etcGmtNeg13: return "ETC_GMT_NEG_13"
            case .etcGmtNeg14: return "ETC_GMT_NEG_14"
            case .etcGmtNeg2: return "ETC_GMT_NEG_2"
            case .etcGmtNeg3: return "ETC_GMT_NEG_3"
            case .etcGmtNeg4: return "ETC_GMT_NEG_4"
            case .etcGmtNeg5: return "ETC_GMT_NEG_5"
            case .etcGmtNeg6: return "ETC_GMT_NEG_6"
            case .etcGmtNeg7: return "ETC_GMT_NEG_7"
            case .etcGmtNeg8: return "ETC_GMT_NEG_8"
            case .etcGmtNeg9: return "ETC_GMT_NEG_9"
            case .europeDublin: return "EUROPE_DUBLIN"
            case .europeLondon: return "EUROPE_LONDON"
            case .europeParis: return "EUROPE_PARIS"
            case .europeStockholm: return "EUROPE_STOCKHOLM"
            case .europeZurich: return "EUROPE_ZURICH"
            case .israel: return "ISRAEL"
            case .mexicoGeneral: return "MEXICO_GENERAL"
            case .mst7mdt: return "MST7MDT"
            case .pacificAuckland: return "PACIFIC_AUCKLAND"
            case .usCentral: return "US_CENTRAL"
            case .usEastern: return "US_EASTERN"
            case .usMountain: return "US_MOUNTAIN"
            case .usPacific: return "US_PACIFIC"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Timezone(rawValue: rawValue) ?? Timezone.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.Topic: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
        case role
        case subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.NotificationResource.self, forKey: .resource)
        resource = resourceDecoded
        let roleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.NotificationRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension DataZoneClientTypes {
    /// The topic of the notification.
    public struct Topic: Swift.Equatable {
        /// The details of the resource mentioned in a notification.
        /// This member is required.
        public var resource: DataZoneClientTypes.NotificationResource?
        /// The role of the resource mentioned in a notification.
        /// This member is required.
        public var role: DataZoneClientTypes.NotificationRole?
        /// The subject of the resource mentioned in a notification.
        /// This member is required.
        public var subject: Swift.String?

        public init(
            resource: DataZoneClientTypes.NotificationResource? = nil,
            role: DataZoneClientTypes.NotificationRole? = nil,
            subject: Swift.String? = nil
        )
        {
            self.resource = resource
            self.role = role
            self.subject = subject
        }
    }

}

extension DataZoneClientTypes {
    public enum TypesSearchScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assetType
        case formType
        case sdkUnknown(Swift.String)

        public static var allCases: [TypesSearchScope] {
            return [
                .assetType,
                .formType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assetType: return "ASSET_TYPE"
            case .formType: return "FORM_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypesSearchScope(rawValue: rawValue) ?? TypesSearchScope.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have permission to perform this action.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be untagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tag keys for the UntagResource action.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), identifier: \(Swift.String(describing: identifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsInput
        case configuration
        case description
        case enableSetting
        case name
        case publishOnImport
        case recommendation
        case schedule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetFormsInput = assetFormsInput {
            var assetFormsInputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetFormsInput)
            for forminput0 in assetFormsInput {
                try assetFormsInputContainer.encode(forminput0)
            }
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableSetting = self.enableSetting {
            try encodeContainer.encode(enableSetting.rawValue, forKey: .enableSetting)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishOnImport = self.publishOnImport {
            try encodeContainer.encode(publishOnImport, forKey: .publishOnImport)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the domain in which to update a data source.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDataSource action.
    public var name: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.identifier = identifier
        self.name = name
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let publishOnImport: Swift.Bool?
    let assetFormsInput: [DataZoneClientTypes.FormInput]?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    let recommendation: DataZoneClientTypes.RecommendationConfiguration?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsInput
        case configuration
        case description
        case enableSetting
        case name
        case publishOnImport
        case recommendation
        case schedule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsInputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormInput?].self, forKey: .assetFormsInput)
        var assetFormsInputDecoded0:[DataZoneClientTypes.FormInput]? = nil
        if let assetFormsInputContainer = assetFormsInputContainer {
            assetFormsInputDecoded0 = [DataZoneClientTypes.FormInput]()
            for structure0 in assetFormsInputContainer {
                if let structure0 = structure0 {
                    assetFormsInputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsInput = assetFormsInputDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationInput.self, forKey: .configuration)
        configuration = configurationDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RecommendationConfiguration.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension UpdateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension UpdateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetFormsOutput = output.assetFormsOutput
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.description = output.description
            self.domainId = output.domainId
            self.enableSetting = output.enableSetting
            self.environmentId = output.environmentId
            self.errorMessage = output.errorMessage
            self.id = output.id
            self.lastRunAt = output.lastRunAt
            self.lastRunErrorMessage = output.lastRunErrorMessage
            self.lastRunStatus = output.lastRunStatus
            self.name = output.name
            self.projectId = output.projectId
            self.publishOnImport = output.publishOnImport
            self.recommendation = output.recommendation
            self.schedule = output.schedule
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.assetFormsOutput = nil
            self.configuration = nil
            self.createdAt = nil
            self.description = nil
            self.domainId = nil
            self.enableSetting = nil
            self.environmentId = nil
            self.errorMessage = nil
            self.id = nil
            self.lastRunAt = nil
            self.lastRunErrorMessage = nil
            self.lastRunStatus = nil
            self.name = nil
            self.projectId = nil
            self.publishOnImport = nil
            self.recommendation = nil
            self.schedule = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDataSourceOutput: Swift.Equatable {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was updated.
    public var createdAt: ClientRuntime.Date?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a data source is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the environment in which a data source is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// The last run error message of the data source.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The last run status of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name to be updated as part of the UpdateDataSource action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project where data source is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status to be updated as part of the UpdateDataSource action.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type to be updated as part of the UpdateDataSource action.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct UpdateDataSourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: DataZoneClientTypes.DataSourceStatus?
    let type: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    let recommendation: DataZoneClientTypes.RecommendationConfiguration?
    let enableSetting: DataZoneClientTypes.EnableSetting?
    let publishOnImport: Swift.Bool?
    let assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    let schedule: DataZoneClientTypes.ScheduleConfiguration?
    let lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    let lastRunAt: ClientRuntime.Date?
    let lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetFormsOutput
        case configuration
        case createdAt
        case description
        case domainId
        case enableSetting
        case environmentId
        case errorMessage
        case id
        case lastRunAt
        case lastRunErrorMessage
        case lastRunStatus
        case name
        case projectId
        case publishOnImport
        case recommendation
        case schedule
        case status
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceConfigurationOutput.self, forKey: .configuration)
        configuration = configurationDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.RecommendationConfiguration.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let enableSettingDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnableSetting.self, forKey: .enableSetting)
        enableSetting = enableSettingDecoded
        let publishOnImportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishOnImport)
        publishOnImport = publishOnImportDecoded
        let assetFormsOutputContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.FormOutput?].self, forKey: .assetFormsOutput)
        var assetFormsOutputDecoded0:[DataZoneClientTypes.FormOutput]? = nil
        if let assetFormsOutputContainer = assetFormsOutputContainer {
            assetFormsOutputDecoded0 = [DataZoneClientTypes.FormOutput]()
            for structure0 in assetFormsOutputContainer {
                if let structure0 = structure0 {
                    assetFormsOutputDecoded0?.append(structure0)
                }
            }
        }
        assetFormsOutput = assetFormsOutputDecoded0
        let scheduleDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ScheduleConfiguration.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceRunStatus.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastRunAt)
        lastRunAt = lastRunAtDecoded
        let lastRunErrorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .lastRunErrorMessage)
        lastRunErrorMessage = lastRunErrorMessageDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DataSourceErrorMessage.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainExecutionRole
        case name
        case singleSignOn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainExecutionRole = self.domainExecutionRole {
            try encodeContainer.encode(domainExecutionRole, forKey: .domainExecutionRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let singleSignOn = self.singleSignOn {
            try encodeContainer.encode(singleSignOn, forKey: .singleSignOn)
        }
    }
}

extension UpdateDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateDomainInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The ID of the Amazon Web Services domain that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The single sign-on option to be updated as part of the UpdateDomain action.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.identifier = identifier
        self.name = name
        self.singleSignOn = singleSignOn
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    let description: Swift.String?
    let singleSignOn: DataZoneClientTypes.SingleSignOn?
    let domainExecutionRole: Swift.String?
    let name: Swift.String?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainExecutionRole
        case name
        case singleSignOn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let singleSignOnDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SingleSignOn.self, forKey: .singleSignOn)
        singleSignOn = singleSignOnDecoded
        let domainExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainExecutionRole)
        domainExecutionRole = domainExecutionRoleDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domainExecutionRole = output.domainExecutionRole
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.singleSignOn = output.singleSignOn
        } else {
            self.description = nil
            self.domainExecutionRole = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.singleSignOn = nil
        }
    }
}

public struct UpdateDomainOutput: Swift.Equatable {
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the timestamp of when the domain was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The single sign-on option of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.singleSignOn = singleSignOn
    }
}

struct UpdateDomainOutputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let singleSignOn: DataZoneClientTypes.SingleSignOn?
    let domainExecutionRole: Swift.String?
    let name: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainExecutionRole
        case id
        case lastUpdatedAt
        case name
        case singleSignOn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let singleSignOnDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SingleSignOn.self, forKey: .singleSignOn)
        singleSignOn = singleSignOnDecoded
        let domainExecutionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainExecutionRole)
        domainExecutionRole = domainExecutionRoleDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum UpdateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironment action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let glossaryTerms: [Swift.String]?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

extension UpdateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.deploymentProperties = output.deploymentProperties
            self.description = output.description
            self.domainId = output.domainId
            self.environmentActions = output.environmentActions
            self.environmentBlueprintId = output.environmentBlueprintId
            self.environmentProfileId = output.environmentProfileId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastDeployment = output.lastDeployment
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.provisionedResources = output.provisionedResources
            self.provisioningProperties = output.provisioningProperties
            self.status = output.status
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.deploymentProperties = nil
            self.description = nil
            self.domainId = nil
            self.environmentActions = nil
            self.environmentBlueprintId = nil
            self.environmentProfileId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastDeployment = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.provisionedResources = nil
            self.provisioningProperties = nil
            self.status = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account in which the environment is to be updated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which the environment is updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties to be updated as part of the UpdateEnvironment action.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The environment actions to be updated as part of the UpdateEnvironment action.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint identifier of the environment.
    public var environmentBlueprintId: Swift.String?
    /// The profile identifier of the environment.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    public var id: Swift.String?
    /// The last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name to be updated as part of the UpdateEnvironment action.
    /// This member is required.
    public var name: Swift.String?
    /// The project identifier of the environment.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider identifier of the environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources to be updated as part of the UpdateEnvironment action.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties to be updated as part of the UpdateEnvironment action.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status to be updated as part of the UpdateEnvironment action.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when the environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters to be updated as part of the UpdateEnvironment action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let projectId: Swift.String?
    let id: Swift.String?
    let domainId: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentProfileId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let provider: Swift.String?
    let provisionedResources: [DataZoneClientTypes.Resource]?
    let status: DataZoneClientTypes.EnvironmentStatus?
    let environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    let glossaryTerms: [Swift.String]?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
    let lastDeployment: DataZoneClientTypes.Deployment?
    let provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    let deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    let environmentBlueprintId: Swift.String?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case deploymentProperties
        case description
        case domainId
        case environmentActions
        case environmentBlueprintId
        case environmentProfileId
        case glossaryTerms
        case id
        case lastDeployment
        case name
        case projectId
        case provider
        case provisionedResources
        case provisioningProperties
        case status
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentProfileId)
        environmentProfileId = environmentProfileIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.Resource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[DataZoneClientTypes.Resource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [DataZoneClientTypes.Resource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentActionsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.ConfigurableEnvironmentAction?].self, forKey: .environmentActions)
        var environmentActionsDecoded0:[DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil
        if let environmentActionsContainer = environmentActionsContainer {
            environmentActionsDecoded0 = [DataZoneClientTypes.ConfigurableEnvironmentAction]()
            for structure0 in environmentActionsContainer {
                if let structure0 = structure0 {
                    environmentActionsDecoded0?.append(structure0)
                }
            }
        }
        environmentActions = environmentActionsDecoded0
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let lastDeploymentDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.Deployment.self, forKey: .lastDeployment)
        lastDeployment = lastDeploymentDecoded
        let provisioningPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.ProvisioningProperties.self, forKey: .provisioningProperties)
        provisioningProperties = provisioningPropertiesDecoded
        let deploymentPropertiesDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.DeploymentProperties.self, forKey: .deploymentProperties)
        deploymentProperties = deploymentPropertiesDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), description: \(Swift.String(describing: description)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), userParameters: \(Swift.String(describing: userParameters)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case description
        case name
        case userParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsAccountRegion = self.awsAccountRegion {
            try encodeContainer.encode(awsAccountRegion, forKey: .awsAccountRegion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let userParameters = userParameters {
            var userParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userParameters)
            for environmentparameter0 in userParameters {
                try userParametersContainer.encode(environmentparameter0)
            }
        }
    }
}

extension UpdateEnvironmentProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentProfileInput: Swift.Equatable {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which an environment profile is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment profile that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    public var name: Swift.String?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.userParameters = userParameters
    }
}

struct UpdateEnvironmentProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let userParameters: [DataZoneClientTypes.EnvironmentParameter]?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
}

extension UpdateEnvironmentProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case description
        case name
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.EnvironmentParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.EnvironmentParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.EnvironmentParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
    }
}

extension UpdateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.awsAccountRegion = output.awsAccountRegion
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.environmentBlueprintId = output.environmentBlueprintId
            self.id = output.id
            self.name = output.name
            self.projectId = output.projectId
            self.updatedAt = output.updatedAt
            self.userParameters = output.userParameters
        } else {
            self.awsAccountId = nil
            self.awsAccountRegion = nil
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.environmentBlueprintId = nil
            self.id = nil
            self.name = nil
            self.projectId = nil
            self.updatedAt = nil
            self.userParameters = nil
        }
    }
}

public struct UpdateEnvironmentProfileOutput: Swift.Equatable {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment profile is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the blueprint of the environment profile that is to be updated.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The identifier of the environment profile that is to be udpated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project of the environment profile that is to be updated.
    public var projectId: Swift.String?
    /// The timestamp of when the environment profile was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

struct UpdateEnvironmentProfileOutputBody: Swift.Equatable {
    let id: Swift.String?
    let domainId: Swift.String?
    let awsAccountId: Swift.String?
    let awsAccountRegion: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let description: Swift.String?
    let environmentBlueprintId: Swift.String?
    let projectId: Swift.String?
    let userParameters: [DataZoneClientTypes.CustomParameter]?
}

extension UpdateEnvironmentProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsAccountRegion
        case createdAt
        case createdBy
        case description
        case domainId
        case environmentBlueprintId
        case id
        case name
        case projectId
        case updatedAt
        case userParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let awsAccountRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountRegion)
        awsAccountRegion = awsAccountRegionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentBlueprintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentBlueprintId)
        environmentBlueprintId = environmentBlueprintIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userParametersContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.CustomParameter?].self, forKey: .userParameters)
        var userParametersDecoded0:[DataZoneClientTypes.CustomParameter]? = nil
        if let userParametersContainer = userParametersContainer {
            userParametersDecoded0 = [DataZoneClientTypes.CustomParameter]()
            for structure0 in userParametersContainer {
                if let structure0 = structure0 {
                    userParametersDecoded0?.append(structure0)
                }
            }
        }
        userParameters = userParametersDecoded0
    }
}

enum UpdateEnvironmentProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateGlossaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateGlossaryInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    public var name: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.status = status
    }
}

struct UpdateGlossaryInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.GlossaryStatus?
    let clientToken: Swift.String?
}

extension UpdateGlossaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGlossaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domainId = output.domainId
            self.id = output.id
            self.name = output.name
            self.owningProjectId = output.owningProjectId
            self.status = output.status
        } else {
            self.description = nil
            self.domainId = nil
            self.id = nil
            self.name = nil
            self.owningProjectId = nil
            self.status = nil
        }
    }
}

public struct UpdateGlossaryOutput: Swift.Equatable {
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to update a business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

struct UpdateGlossaryOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let owningProjectId: Swift.String?
    let description: Swift.String?
    let status: DataZoneClientTypes.GlossaryStatus?
}

extension UpdateGlossaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case domainId
        case id
        case name
        case owningProjectId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningProjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningProjectId)
        owningProjectId = owningProjectIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateGlossaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryTermInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glossaryIdentifier
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glossaryIdentifier = self.glossaryIdentifier {
            try encodeContainer.encode(glossaryIdentifier, forKey: .glossaryIdentifier)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let termRelations = self.termRelations {
            try encodeContainer.encode(termRelations, forKey: .termRelations)
        }
    }
}

extension UpdateGlossaryTermInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateGlossaryTermInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    public var glossaryIdentifier: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.identifier = identifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

struct UpdateGlossaryTermInputBody: Swift.Equatable {
    let glossaryIdentifier: Swift.String?
    let name: Swift.String?
    let shortDescription: Swift.String?
    let longDescription: Swift.String?
    let termRelations: DataZoneClientTypes.TermRelations?
    let status: DataZoneClientTypes.GlossaryTermStatus?
}

extension UpdateGlossaryTermInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glossaryIdentifier
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glossaryIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryIdentifier)
        glossaryIdentifier = glossaryIdentifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryTermOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGlossaryTermOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainId = output.domainId
            self.glossaryId = output.glossaryId
            self.id = output.id
            self.longDescription = output.longDescription
            self.name = output.name
            self.shortDescription = output.shortDescription
            self.status = output.status
            self.termRelations = output.termRelations
        } else {
            self.domainId = nil
            self.glossaryId = nil
            self.id = nil
            self.longDescription = nil
            self.name = nil
            self.shortDescription = nil
            self.status = nil
            self.termRelations = nil
        }
    }
}

public struct UpdateGlossaryTermOutput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

struct UpdateGlossaryTermOutputBody: Swift.Equatable {
    let id: Swift.String?
    let domainId: Swift.String?
    let glossaryId: Swift.String?
    let name: Swift.String?
    let status: DataZoneClientTypes.GlossaryTermStatus?
    let shortDescription: Swift.String?
    let longDescription: Swift.String?
    let termRelations: DataZoneClientTypes.TermRelations?
}

extension UpdateGlossaryTermOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case glossaryId
        case id
        case longDescription
        case name
        case shortDescription
        case status
        case termRelations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let glossaryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glossaryId)
        glossaryId = glossaryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GlossaryTermStatus.self, forKey: .status)
        status = statusDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let termRelationsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.TermRelations.self, forKey: .termRelations)
        termRelations = termRelationsDecoded
    }
}

enum UpdateGlossaryTermOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGroupProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateGroupProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateGroupProfileInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile that is updated.
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The status of the group profile that is updated.
    /// This member is required.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.status = status
    }
}

struct UpdateGroupProfileInputBody: Swift.Equatable {
    let status: DataZoneClientTypes.GroupProfileStatus?
}

extension UpdateGroupProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupProfileStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension UpdateGroupProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGroupProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainId = output.domainId
            self.groupName = output.groupName
            self.id = output.id
            self.status = output.status
        } else {
            self.domainId = nil
            self.groupName = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct UpdateGroupProfileOutput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    public var domainId: Swift.String?
    /// The name of the group profile that is updated.
    public var groupName: Swift.String?
    /// The identifier of the group profile that is updated.
    public var id: Swift.String?
    /// The status of the group profile that is updated.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

struct UpdateGroupProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let status: DataZoneClientTypes.GroupProfileStatus?
    let groupName: Swift.String?
}

extension UpdateGroupProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId
        case groupName
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GroupProfileStatus.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

enum UpdateGroupProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let glossaryTerms = glossaryTerms {
            var glossaryTermsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glossaryTerms)
            for glossarytermid0 in glossaryTerms {
                try glossaryTermsContainer.encode(glossarytermid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The description to be updated as part of the UpdateProject action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a project is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateProject action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateProject action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let glossaryTerms: [Swift.String]?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case glossaryTerms
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

extension UpdateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.domainId = output.domainId
            self.glossaryTerms = output.glossaryTerms
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.domainId = nil
            self.glossaryTerms = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct UpdateProjectOutput: Swift.Equatable {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project that is to be updated.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a project is updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The glossary terms of the project that are to be updated.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project that is to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct UpdateProjectOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let glossaryTerms: [Swift.String]?
}

extension UpdateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case domainId
        case glossaryTerms
        case id
        case lastUpdatedAt
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let glossaryTermsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glossaryTerms)
        var glossaryTermsDecoded0:[Swift.String]? = nil
        if let glossaryTermsContainer = glossaryTermsContainer {
            glossaryTermsDecoded0 = [Swift.String]()
            for string0 in glossaryTermsContainer {
                if let string0 = string0 {
                    glossaryTermsDecoded0?.append(string0)
                }
            }
        }
        glossaryTerms = glossaryTermsDecoded0
    }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriptionGrantStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCause
        case status
        case targetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCause = self.failureCause {
            try encodeContainer.encode(failureCause, forKey: .failureCause)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }
}

extension UpdateSubscriptionGrantStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        guard let assetIdentifier = assetIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())/status/\(assetIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionGrantStatusInput: Swift.Equatable {
    /// The identifier of the asset the subscription grant status of which is to be updated.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureCause: DataZoneClientTypes.FailureCause?
    /// The identifier of the subscription grant the status of which is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantStatus?
    /// The target name to be updated as part of the UpdateSubscriptionGrantStatus action.
    public var targetName: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        failureCause: DataZoneClientTypes.FailureCause? = nil,
        identifier: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.failureCause = failureCause
        self.identifier = identifier
        self.status = status
        self.targetName = targetName
    }
}

struct UpdateSubscriptionGrantStatusInputBody: Swift.Equatable {
    let status: DataZoneClientTypes.SubscriptionGrantStatus?
    let failureCause: DataZoneClientTypes.FailureCause?
    let targetName: Swift.String?
}

extension UpdateSubscriptionGrantStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCause
        case status
        case targetName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantStatus.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.FailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension UpdateSubscriptionGrantStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriptionGrantStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.grantedEntity = output.grantedEntity
            self.id = output.id
            self.status = output.status
            self.subscriptionId = output.subscriptionId
            self.subscriptionTargetId = output.subscriptionTargetId
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.assets = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.grantedEntity = nil
            self.id = nil
            self.status = nil
            self.subscriptionId = nil
            self.subscriptionTargetId = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct UpdateSubscriptionGrantStatusOutput: Swift.Equatable {
    ///
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant status was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone domain user who created the subscription grant status.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The granted entity to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The identifier of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target whose subscription grant status is to be updated.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant status is to be updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant status.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct UpdateSubscriptionGrantStatusOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let subscriptionTargetId: Swift.String?
    let grantedEntity: DataZoneClientTypes.GrantedEntity?
    let status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    let assets: [DataZoneClientTypes.SubscribedAsset]?
    let subscriptionId: Swift.String?
}

extension UpdateSubscriptionGrantStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case createdAt
        case createdBy
        case domainId
        case grantedEntity
        case id
        case status
        case subscriptionId
        case subscriptionTargetId
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let subscriptionTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionTargetId)
        subscriptionTargetId = subscriptionTargetIdDecoded
        let grantedEntityDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.GrantedEntity.self, forKey: .grantedEntity)
        grantedEntity = grantedEntityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionGrantOverallStatus.self, forKey: .status)
        status = statusDecoded
        let assetsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedAsset?].self, forKey: .assets)
        var assetsDecoded0:[DataZoneClientTypes.SubscribedAsset]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataZoneClientTypes.SubscribedAsset]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
    }
}

enum UpdateSubscriptionGrantStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), requestReason: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestReason = self.requestReason {
            try encodeContainer.encode(requestReason, forKey: .requestReason)
        }
    }
}

extension UpdateSubscriptionRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionRequestInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestReason: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.requestReason = requestReason
    }
}

struct UpdateSubscriptionRequestInputBody: Swift.Equatable {
    let requestReason: Swift.String?
}

extension UpdateSubscriptionRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
    }
}

extension UpdateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionRequestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriptionRequestOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.decisionComment = output.decisionComment
            self.domainId = output.domainId
            self.id = output.id
            self.requestReason = output.requestReason
            self.reviewerId = output.reviewerId
            self.status = output.status
            self.subscribedListings = output.subscribedListings
            self.subscribedPrincipals = output.subscribedPrincipals
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.decisionComment = nil
            self.domainId = nil
            self.id = nil
            self.requestReason = nil
            self.reviewerId = nil
            self.status = nil
            self.subscribedListings = nil
            self.subscribedPrincipals = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct UpdateSubscriptionRequestOutput: Swift.Equatable {
    /// The timestamp of when the subscription request was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the UpdateSubscriptionRequest action.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviews the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct UpdateSubscriptionRequestOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let domainId: Swift.String?
    let status: DataZoneClientTypes.SubscriptionRequestStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let requestReason: Swift.String?
    let subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    let subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    let reviewerId: Swift.String?
    let decisionComment: Swift.String?
}

extension UpdateSubscriptionRequestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case decisionComment
        case domainId
        case id
        case requestReason
        case reviewerId
        case status
        case subscribedListings
        case subscribedPrincipals
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.SubscriptionRequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let requestReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestReason)
        requestReason = requestReasonDecoded
        let subscribedPrincipalsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedPrincipal?].self, forKey: .subscribedPrincipals)
        var subscribedPrincipalsDecoded0:[DataZoneClientTypes.SubscribedPrincipal]? = nil
        if let subscribedPrincipalsContainer = subscribedPrincipalsContainer {
            subscribedPrincipalsDecoded0 = [DataZoneClientTypes.SubscribedPrincipal]()
            for union0 in subscribedPrincipalsContainer {
                if let union0 = union0 {
                    subscribedPrincipalsDecoded0?.append(union0)
                }
            }
        }
        subscribedPrincipals = subscribedPrincipalsDecoded0
        let subscribedListingsContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscribedListing?].self, forKey: .subscribedListings)
        var subscribedListingsDecoded0:[DataZoneClientTypes.SubscribedListing]? = nil
        if let subscribedListingsContainer = subscribedListingsContainer {
            subscribedListingsDecoded0 = [DataZoneClientTypes.SubscribedListing]()
            for structure0 in subscribedListingsContainer {
                if let structure0 = structure0 {
                    subscribedListingsDecoded0?.append(structure0)
                }
            }
        }
        subscribedListings = subscribedListingsDecoded0
        let reviewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewerId)
        reviewerId = reviewerIdDecoded
        let decisionCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decisionComment)
        decisionComment = decisionCommentDecoded
    }
}

enum UpdateSubscriptionRequestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), identifier: \(Swift.String(describing: identifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case manageAccessRole
        case name
        case provider
        case subscriptionTargetConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicableAssetTypes = applicableAssetTypes {
            var applicableAssetTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicableAssetTypes)
            for typename0 in applicableAssetTypes {
                try applicableAssetTypesContainer.encode(typename0)
            }
        }
        if let authorizedPrincipals = authorizedPrincipals {
            var authorizedPrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedPrincipals)
            for authorizedprincipalidentifier0 in authorizedPrincipals {
                try authorizedPrincipalsContainer.encode(authorizedprincipalidentifier0)
            }
        }
        if let manageAccessRole = self.manageAccessRole {
            try encodeContainer.encode(manageAccessRole, forKey: .manageAccessRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let subscriptionTargetConfig = subscriptionTargetConfig {
            var subscriptionTargetConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionTargetConfig)
            for subscriptiontargetform0 in subscriptionTargetConfig {
                try subscriptionTargetConfigContainer.encode(subscriptiontargetform0)
            }
        }
    }
}

extension UpdateSubscriptionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let identifier = identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionTargetInput: Swift.Equatable {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    public var authorizedPrincipals: [Swift.String]?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    public var name: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
    }
}

struct UpdateSubscriptionTargetInputBody: Swift.Equatable {
    let name: Swift.String?
    let authorizedPrincipals: [Swift.String]?
    let applicableAssetTypes: [Swift.String]?
    let subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    let manageAccessRole: Swift.String?
    let provider: Swift.String?
}

extension UpdateSubscriptionTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case manageAccessRole
        case name
        case provider
        case subscriptionTargetConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension UpdateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriptionTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicableAssetTypes = output.applicableAssetTypes
            self.authorizedPrincipals = output.authorizedPrincipals
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.domainId = output.domainId
            self.environmentId = output.environmentId
            self.id = output.id
            self.manageAccessRole = output.manageAccessRole
            self.name = output.name
            self.projectId = output.projectId
            self.provider = output.provider
            self.subscriptionTargetConfig = output.subscriptionTargetConfig
            self.type = output.type
            self.updatedAt = output.updatedAt
            self.updatedBy = output.updatedBy
        } else {
            self.applicableAssetTypes = nil
            self.authorizedPrincipals = nil
            self.createdAt = nil
            self.createdBy = nil
            self.domainId = nil
            self.environmentId = nil
            self.id = nil
            self.manageAccessRole = nil
            self.name = nil
            self.projectId = nil
            self.provider = nil
            self.subscriptionTargetConfig = nil
            self.type = nil
            self.updatedAt = nil
            self.updatedBy = nil
        }
    }
}

public struct UpdateSubscriptionTargetOutput: Swift.Equatable {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when a subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which a subscription target is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

struct UpdateSubscriptionTargetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let authorizedPrincipals: [Swift.String]?
    let domainId: Swift.String?
    let projectId: Swift.String?
    let environmentId: Swift.String?
    let name: Swift.String?
    let type: Swift.String?
    let createdBy: Swift.String?
    let updatedBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let manageAccessRole: Swift.String?
    let applicableAssetTypes: [Swift.String]?
    let subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    let provider: Swift.String?
}

extension UpdateSubscriptionTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicableAssetTypes
        case authorizedPrincipals
        case createdAt
        case createdBy
        case domainId
        case environmentId
        case id
        case manageAccessRole
        case name
        case projectId
        case provider
        case subscriptionTargetConfig
        case type
        case updatedAt
        case updatedBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let authorizedPrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedPrincipals)
        var authorizedPrincipalsDecoded0:[Swift.String]? = nil
        if let authorizedPrincipalsContainer = authorizedPrincipalsContainer {
            authorizedPrincipalsDecoded0 = [Swift.String]()
            for string0 in authorizedPrincipalsContainer {
                if let string0 = string0 {
                    authorizedPrincipalsDecoded0?.append(string0)
                }
            }
        }
        authorizedPrincipals = authorizedPrincipalsDecoded0
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let manageAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manageAccessRole)
        manageAccessRole = manageAccessRoleDecoded
        let applicableAssetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicableAssetTypes)
        var applicableAssetTypesDecoded0:[Swift.String]? = nil
        if let applicableAssetTypesContainer = applicableAssetTypesContainer {
            applicableAssetTypesDecoded0 = [Swift.String]()
            for string0 in applicableAssetTypesContainer {
                if let string0 = string0 {
                    applicableAssetTypesDecoded0?.append(string0)
                }
            }
        }
        applicableAssetTypes = applicableAssetTypesDecoded0
        let subscriptionTargetConfigContainer = try containerValues.decodeIfPresent([DataZoneClientTypes.SubscriptionTargetForm?].self, forKey: .subscriptionTargetConfig)
        var subscriptionTargetConfigDecoded0:[DataZoneClientTypes.SubscriptionTargetForm]? = nil
        if let subscriptionTargetConfigContainer = subscriptionTargetConfigContainer {
            subscriptionTargetConfigDecoded0 = [DataZoneClientTypes.SubscriptionTargetForm]()
            for structure0 in subscriptionTargetConfigContainer {
                if let structure0 = structure0 {
                    subscriptionTargetConfigDecoded0?.append(structure0)
                }
            }
        }
        subscriptionTargetConfig = subscriptionTargetConfigDecoded0
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
    }
}

enum UpdateSubscriptionTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainIdentifier = domainIdentifier else {
            return nil
        }
        guard let userIdentifier = userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The status of the user profile that are to be updated.
    /// This member is required.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile that are to be updated.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user whose user profile is to be updated.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.status = status
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    let type: DataZoneClientTypes.UserProfileType?
    let status: DataZoneClientTypes.UserProfileStatus?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.domainId = output.domainId
            self.id = output.id
            self.status = output.status
            self.type = output.type
        } else {
            self.details = nil
            self.domainId = nil
            self.id = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct UpdateUserProfileOutput: Swift.Equatable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

struct UpdateUserProfileOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let id: Swift.String?
    let type: DataZoneClientTypes.UserProfileType?
    let status: DataZoneClientTypes.UserProfileStatus?
    let details: DataZoneClientTypes.UserProfileDetails?
}

extension UpdateUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case domainId
        case id
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum UpdateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await DataZoneClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataZoneClientTypes {
    public enum UserAssignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UserAssignment] {
            return [
                .automatic,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserAssignment(rawValue: rawValue) ?? UserAssignment.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum UserDesignation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case projectContributor
        case projectOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [UserDesignation] {
            return [
                .projectContributor,
                .projectOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserDesignation(rawValue: rawValue) ?? UserDesignation.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.UserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DataZoneClientTypes {
    /// The user details of a project member.
    public struct UserDetails: Swift.Equatable {
        /// The identifier of the Amazon DataZone user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }

}

extension DataZoneClientTypes.UserProfileDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam
        case sdkUnknown
        case sso
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .iam(iam):
                try container.encode(iam, forKey: .iam)
            case let .sso(sso):
                try container.encode(sso, forKey: .sso)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let iamDecoded = try values.decodeIfPresent(DataZoneClientTypes.IamUserProfileDetails.self, forKey: .iam)
        if let iam = iamDecoded {
            self = .iam(iam)
            return
        }
        let ssoDecoded = try values.decodeIfPresent(DataZoneClientTypes.SsoUserProfileDetails.self, forKey: .sso)
        if let sso = ssoDecoded {
            self = .sso(sso)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DataZoneClientTypes {
    /// The details of the user profile in Amazon DataZone.
    public enum UserProfileDetails: Swift.Equatable {
        /// The IAM details included in the user profile details.
        case iam(DataZoneClientTypes.IamUserProfileDetails)
        /// The single sign-on details included in the user profile details.
        case sso(DataZoneClientTypes.SsoUserProfileDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes {
    public enum UserProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case assigned
        case deactivated
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileStatus] {
            return [
                .activated,
                .assigned,
                .deactivated,
                .notAssigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .assigned: return "ASSIGNED"
            case .deactivated: return "DEACTIVATED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserProfileStatus(rawValue: rawValue) ?? UserProfileStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes.UserProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case domainId
        case id
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataZoneClientTypes.UserProfileDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DataZoneClientTypes {
    /// The details of the user profile.
    public struct UserProfileSummary: Swift.Equatable {
        /// The details of the user profile.
        public var details: DataZoneClientTypes.UserProfileDetails?
        /// The ID of the Amazon DataZone domain of the user profile.
        public var domainId: Swift.String?
        /// The ID of the user profile.
        public var id: Swift.String?
        /// The status of the user profile.
        public var status: DataZoneClientTypes.UserProfileStatus?
        /// The type of the user profile.
        public var type: DataZoneClientTypes.UserProfileType?

        public init(
            details: DataZoneClientTypes.UserProfileDetails? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.UserProfileStatus? = nil,
            type: DataZoneClientTypes.UserProfileType? = nil
        )
        {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }
    }

}

extension DataZoneClientTypes {
    public enum UserProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileType] {
            return [
                .iam,
                .sso,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserProfileType(rawValue: rawValue) ?? UserProfileType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum UserSearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datazoneIamUser
        case datazoneSsoUser
        case datazoneUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSearchType] {
            return [
                .datazoneIamUser,
                .datazoneSsoUser,
                .datazoneUser,
                .ssoUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datazoneIamUser: return "DATAZONE_IAM_USER"
            case .datazoneSsoUser: return "DATAZONE_SSO_USER"
            case .datazoneUser: return "DATAZONE_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserSearchType(rawValue: rawValue) ?? UserSearchType.sdkUnknown(rawValue)
        }
    }
}

extension DataZoneClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iamRole
        case iamUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .iamRole,
                .iamUser,
                .ssoUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iamRole: return "IAM_ROLE"
            case .iamUser: return "IAM_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by the Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
