// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension DataZoneClientTypes.AcceptChoice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptChoice(predictionChoice: \(Swift.String(describing: predictionChoice)), predictionTarget: \(Swift.String(describing: predictionTarget)), editedValue: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.AcceptChoice {

    static func write(value: DataZoneClientTypes.AcceptChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["editedValue"].write(value.editedValue)
        try writer["predictionChoice"].write(value.predictionChoice)
        try writer["predictionTarget"].write(value.predictionTarget)
    }
}

extension DataZoneClientTypes {
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
    public struct AcceptChoice {
        /// The edit of the prediction.
        public var editedValue: Swift.String?
        /// Specifies the prediction (aka, the automatically generated piece of metadata) that can be accepted.
        public var predictionChoice: Swift.Int?
        /// Specifies the target (for example, a column name) where a prediction can be accepted.
        /// This member is required.
        public var predictionTarget: Swift.String?

        public init(
            editedValue: Swift.String? = nil,
            predictionChoice: Swift.Int? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.editedValue = editedValue
            self.predictionChoice = predictionChoice
            self.predictionTarget = predictionTarget
        }
    }

}

extension AcceptPredictionsInput {

    static func queryItemProvider(_ value: AcceptPredictionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension AcceptPredictionsInput {

    static func urlPathProvider(_ value: AcceptPredictionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/accept-predictions"
    }
}

extension AcceptPredictionsInput {

    static func write(value: AcceptPredictionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceptChoices"].writeList(value.acceptChoices, memberWritingClosure: DataZoneClientTypes.AcceptChoice.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["acceptRule"].write(value.acceptRule, with: DataZoneClientTypes.AcceptRule.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
    }
}

public struct AcceptPredictionsInput {
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
    public var acceptChoices: [DataZoneClientTypes.AcceptChoice]?
    /// Specifies the rule (or the conditions) under which a prediction can be accepted.
    public var acceptRule: DataZoneClientTypes.AcceptRule?
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision that is to be made to the asset.
    public var revision: Swift.String?

    public init(
        acceptChoices: [DataZoneClientTypes.AcceptChoice]? = nil,
        acceptRule: DataZoneClientTypes.AcceptRule? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.acceptChoices = acceptChoices
        self.acceptRule = acceptRule
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

extension AcceptPredictionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AcceptPredictionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptPredictionsOutput()
        value.assetId = try reader["assetId"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

public struct AcceptPredictionsOutput {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The revision that is to be made to the asset.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.domainId = domainId
        self.revision = revision
    }
}

enum AcceptPredictionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.AcceptRule {

    static func write(value: DataZoneClientTypes.AcceptRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rule"].write(value.rule)
        try writer["threshold"].write(value.threshold)
    }
}

extension DataZoneClientTypes {
    /// Specifies the rule and the threshold under which a prediction can be accepted.
    public struct AcceptRule {
        /// Specifies whether you want to accept the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.AcceptRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be accepted.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.AcceptRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }

}

extension DataZoneClientTypes {

    public enum AcceptRuleBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptRuleBehavior] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AcceptSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

extension AcceptSubscriptionRequestInput {

    static func urlPathProvider(_ value: AcceptSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/accept"
    }
}

extension AcceptSubscriptionRequestInput {

    static func write(value: AcceptSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decisionComment"].write(value.decisionComment)
    }
}

public struct AcceptSubscriptionRequestInput {
    /// A description that specifies the reason for accepting the specified subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain where the specified subscription request is being accepted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription request that is to be accepted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension AcceptSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension AcceptSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AcceptSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct AcceptSubscriptionRequestOutput {
    /// The timestamp that specifies when the subscription request was accepted.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user that accepted the specified subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Specifies the reason for accepting the subscription request.
    public var decisionComment: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the specified subscription request was accepted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the reason for requesting a subscription to the asset.
    /// This member is required.
    public var requestReason: Swift.String?
    /// Specifes the ID of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// Specifies the status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// Specifies the asset for which the subscription request was created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// Specifies the Amazon DataZone users who are subscribed to the asset specified in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// Specifies the timestamp when subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum AcceptSubscriptionRequestOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes.AssetItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), owningProjectId: \(Swift.String(describing: owningProjectId)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.AssetItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.identifier = try reader["identifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.additionalAttributes = try reader["additionalAttributes"].readIfPresent(with: DataZoneClientTypes.AssetItemAdditionalAttributes.read(from:))
        return value
    }
}

extension DataZoneClientTypes {
    /// A Amazon DataZone inventory asset.
    public struct AssetItem {
        /// The additional attributes of a Amazon DataZone inventory asset.
        public var additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes?
        /// The timestamp of when the Amazon DataZone inventory asset was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the inventory asset.
        public var createdBy: Swift.String?
        /// The description of an Amazon DataZone inventory asset.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the inventory asset exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The external identifier of the Amazon DataZone inventory asset.
        public var externalIdentifier: Swift.String?
        /// The timestamp of when the first revision of the inventory asset was created.
        public var firstRevisionCreatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the first revision of the inventory asset.
        public var firstRevisionCreatedBy: Swift.String?
        /// The glossary terms attached to the Amazon DataZone inventory asset.
        public var glossaryTerms: [Swift.String]?
        /// the identifier of the Amazon DataZone inventory asset.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the Amazon DataZone inventory asset.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the inventory asset.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The identifier of the asset type of the specified Amazon DataZone inventory asset.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision of the inventory asset type.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            externalIdentifier: Swift.String? = nil,
            firstRevisionCreatedAt: ClientRuntime.Date? = nil,
            firstRevisionCreatedBy: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.owningProjectId = owningProjectId
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.AssetItemAdditionalAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetItemAdditionalAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetItemAdditionalAttributes()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The additional attributes of an inventory asset.
    public struct AssetItemAdditionalAttributes {
        /// The forms included in the additional attributes of an inventory asset.
        public var formsOutput: [DataZoneClientTypes.FormOutput]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
        /// The read-only forms included in the additional attributes of an inventory asset.
        public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?

        public init(
            formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
            latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
            readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil
        )
        {
            self.formsOutput = formsOutput
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.readOnlyFormsOutput = readOnlyFormsOutput
        }
    }

}

extension DataZoneClientTypes.AssetListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListing()
        value.assetId = try reader["assetId"].readIfPresent()
        value.assetRevision = try reader["assetRevision"].readIfPresent()
        value.assetType = try reader["assetType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.forms = try reader["forms"].readIfPresent()
        value.latestTimeSeriesDataPointForms = try reader["latestTimeSeriesDataPointForms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// An asset published in an Amazon DataZone catalog.
    public struct AssetListing {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public var assetId: Swift.String?
        /// The revision of an asset published in an Amazon DataZone catalog.
        public var assetRevision: Swift.String?
        /// The type of an asset published in an Amazon DataZone catalog.
        public var assetType: Swift.String?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: ClientRuntime.Date?
        /// The metadata forms attached to an asset published in an Amazon DataZone catalog.
        public var forms: Swift.String?
        /// The glossary terms attached to an asset published in an Amazon DataZone catalog.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
        /// The identifier of the project where an asset published in an Amazon DataZone catalog exists.
        public var owningProjectId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            assetType: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetType = assetType
            self.createdAt = createdAt
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
            self.owningProjectId = owningProjectId
        }
    }

}

extension DataZoneClientTypes.AssetListingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingDetails()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingStatus = try reader["listingStatus"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingDetails {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingId: Swift.String?
        /// The status of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingStatus: DataZoneClientTypes.ListingStatus?

        public init(
            listingId: Swift.String? = nil,
            listingStatus: DataZoneClientTypes.ListingStatus? = nil
        )
        {
            self.listingId = listingId
            self.listingStatus = listingStatus
        }
    }

}

extension DataZoneClientTypes.AssetListingItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetListingItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), entityId: \(Swift.String(describing: entityId)), entityRevision: \(Swift.String(describing: entityRevision)), entityType: \(Swift.String(describing: entityType)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), listingCreatedBy: \(Swift.String(describing: listingCreatedBy)), listingId: \(Swift.String(describing: listingId)), listingRevision: \(Swift.String(describing: listingRevision)), listingUpdatedBy: \(Swift.String(describing: listingUpdatedBy)), owningProjectId: \(Swift.String(describing: owningProjectId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.AssetListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingItem()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.listingCreatedBy = try reader["listingCreatedBy"].readIfPresent()
        value.listingUpdatedBy = try reader["listingUpdatedBy"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.additionalAttributes = try reader["additionalAttributes"].readIfPresent(with: DataZoneClientTypes.AssetListingItemAdditionalAttributes.read(from:))
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingItem {
        /// The additional attributes of an asset published in an Amazon DataZone catalog.
        public var additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of an asset published in an Amazon DataZone catalog.
        public var description: Swift.String?
        /// The identifier of the inventory asset.
        public var entityId: Swift.String?
        /// The revision of the inventory asset.
        public var entityRevision: Swift.String?
        /// The type of the inventory asset.
        public var entityType: Swift.String?
        /// Glossary terms attached to the inventory asset.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The Amazon DataZone user who created the listing.
        public var listingCreatedBy: Swift.String?
        /// The identifier of the listing (asset published in Amazon DataZone catalog).
        public var listingId: Swift.String?
        /// The revision of the listing (asset published in Amazon DataZone catalog).
        public var listingRevision: Swift.String?
        /// The Amazon DataZone user who updated the listing.
        public var listingUpdatedBy: Swift.String?
        /// The name of the inventory asset.
        public var name: Swift.String?
        /// The identifier of the project that owns the inventory asset.
        public var owningProjectId: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            listingCreatedBy: Swift.String? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil,
            listingUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.glossaryTerms = glossaryTerms
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }
    }

}

extension DataZoneClientTypes.AssetListingItemAdditionalAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingItemAdditionalAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingItemAdditionalAttributes()
        value.forms = try reader["forms"].readIfPresent()
        value.latestTimeSeriesDataPointForms = try reader["latestTimeSeriesDataPointForms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// Additional attributes of an inventory asset.
    public struct AssetListingItemAdditionalAttributes {
        /// The metadata forms that form additional attributes of the metadata asset.
        public var forms: Swift.String?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?

        public init(
            forms: Swift.String? = nil,
            latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil
        )
        {
            self.forms = forms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
        }
    }

}

extension DataZoneClientTypes.AssetRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetRevision()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension DataZoneClientTypes {
    /// The revision of an inventory asset.
    public struct AssetRevision {
        /// The timestamp of when an inventory asset revison was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the asset revision.
        public var createdBy: Swift.String?
        /// The Amazon DataZone user who created the inventory asset.
        public var domainId: Swift.String?
        /// The identifier of the inventory asset revision.
        public var id: Swift.String?
        /// The revision details of the inventory asset.
        public var revision: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.AssetTargetNameMap {

    static func write(value: DataZoneClientTypes.AssetTargetNameMap?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["targetName"].write(value.targetName)
    }
}

extension DataZoneClientTypes {
    /// The name map for assets.
    public struct AssetTargetNameMap {
        /// The identifier of the inventory asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The target name in the asset target name map.
        /// This member is required.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.targetName = targetName
        }
    }

}

extension DataZoneClientTypes.AssetTypeItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetTypeItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.AssetTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetTypeItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the asset type.
    public struct AssetTypeItem {
        /// The timestamp of when the asset type was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the asset type.
        public var createdBy: Swift.String?
        /// The description of the asset type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The forms included in the details of the asset type.
        /// This member is required.
        public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
        /// The name of the asset type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the Amazon DataZone project where the asset type exists.
        public var originProjectId: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the asset type.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The revision of the asset type.
        /// This member is required.
        public var revision: Swift.String?
        /// The timestamp of when the asset type was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the asset type.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {

    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case iamIdc
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .disabled,
                .iamIdc,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .iamIdc: return "IAM_IDC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.BusinessNameGenerationConfiguration {

    static func write(value: DataZoneClientTypes.BusinessNameGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.BusinessNameGenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.BusinessNameGenerationConfiguration()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The configuration of the business name generation.
    public struct BusinessNameGenerationConfiguration {
        /// Specifies whether the business name generation is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension CancelMetadataGenerationRunInput {

    static func urlPathProvider(_ value: CancelMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs/\(identifier.urlPercentEncoding())/cancel"
    }
}

public struct CancelMetadataGenerationRunInput {
    /// The ID of the Amazon DataZone domain in which the metadata generation run is to be cancelled.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension CancelMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelMetadataGenerationRunOutput {
        return CancelMetadataGenerationRunOutput()
    }
}

public struct CancelMetadataGenerationRunOutput {

    public init() { }
}

enum CancelMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CancelSubscriptionInput {

    static func urlPathProvider(_ value: CancelSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/cancel"
    }
}

public struct CancelSubscriptionInput {
    /// The unique identifier of the Amazon DataZone domain where the subscription request is being cancelled.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription that is being cancelled.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension CancelSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct CancelSubscriptionOutput {
    /// The timestamp that specifies when the request to cancel the subscription was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Specifies the Amazon DataZone user who is cancelling the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the subscription is being cancelled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether the permissions to the asset are retained after the subscription is cancelled.
    public var retainPermissions: Swift.Bool?
    /// The status of the request to cancel the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The asset to which a subscription is being cancelled.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The Amazon DataZone user who is made a subscriber to the specified asset by the subscription that is being cancelled.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The unique ID of the subscripton request for the subscription that is being cancelled.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp that specifies when the subscription was cancelled.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that cancelled the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum CancelSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes {

    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case publish
        case unpublish
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .publish,
                .unpublish,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .unpublish: return "UNPUBLISH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.CloudFormationProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CloudFormationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CloudFormationProperties()
        value.templateUrl = try reader["templateUrl"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// Part of the provisioning properties of the environment blueprint.
    public struct CloudFormationProperties {
        /// The template URL of the cloud formation provisioning properties of the environment blueprint.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init(
            templateUrl: Swift.String? = nil
        )
        {
            self.templateUrl = templateUrl
        }
    }

}

extension DataZoneClientTypes.ConfigurableActionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ConfigurableActionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ConfigurableActionParameter()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the parameters for the configurable environment action.
    public struct ConfigurableActionParameter {
        /// The key of the configurable action parameter.
        public var key: Swift.String?
        /// The value of the configurable action parameter.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension DataZoneClientTypes {

    public enum ConfigurableActionTypeAuthorization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case https
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurableActionTypeAuthorization] {
            return [
                .https,
                .iam,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.ConfigurableEnvironmentAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ConfigurableEnvironmentAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ConfigurableEnvironmentAction()
        value.type = try reader["type"].readIfPresent()
        value.auth = try reader["auth"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableActionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The configurable action of a Amazon DataZone environment.
    public struct ConfigurableEnvironmentAction {
        /// The authentication type of a configurable action of a Amazon DataZone environment.
        public var auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization?
        /// The parameters of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var parameters: [DataZoneClientTypes.ConfigurableActionParameter]?
        /// The type of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?

        public init(
            auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization? = nil,
            parameters: [DataZoneClientTypes.ConfigurableActionParameter]? = nil,
            type: Swift.String? = nil
        )
        {
            self.auth = auth
            self.parameters = parameters
            self.type = type
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// There is a conflict while performing this action.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetInput {

    static func urlPathProvider(_ value: CreateAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets"
    }
}

extension CreateAssetInput {

    static func write(value: CreateAssetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["externalIdentifier"].write(value.externalIdentifier)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["predictionConfiguration"].write(value.predictionConfiguration, with: DataZoneClientTypes.PredictionConfiguration.write(value:to:))
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

public struct CreateAssetInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Asset description.
    public var description: Swift.String?
    /// Amazon DataZone domain where the asset is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// Metadata forms attached to the asset.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// Glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// Asset name.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the project that owns this asset.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The unique identifier of this asset's type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of this asset's type.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.externalIdentifier = externalIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.predictionConfiguration = predictionConfiguration
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

extension CreateAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.predictionConfiguration = try reader["predictionConfiguration"].readIfPresent(with: DataZoneClientTypes.PredictionConfiguration.read(from:))
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        return value
    }
}

public struct CreateAssetOutput {
    /// The timestamp of when the asset was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user that created this asset in the catalog.
    public var createdBy: Swift.String?
    /// The description of the created asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset took place.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that made the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that are attached to the created asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that are attached to the created asset.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the created asset.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The details of an asset published in an Amazon DataZone catalog.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the created asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns the created asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that are attached to the created asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the created asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

enum CreateAssetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAssetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetRevisionInput {

    static func urlPathProvider(_ value: CreateAssetRevisionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

extension CreateAssetRevisionInput {

    static func write(value: CreateAssetRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["predictionConfiguration"].write(value.predictionConfiguration, with: DataZoneClientTypes.PredictionConfiguration.write(value:to:))
        try writer["typeRevision"].write(value.typeRevision)
    }
}

public struct CreateAssetRevisionInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The revised description of the asset.
    public var description: Swift.String?
    /// The unique identifier of the domain where the asset is being revised.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms to be attached to the asset as part of asset revision.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// The glossary terms to be attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// Te revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The revision type of the asset.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
        self.predictionConfiguration = predictionConfiguration
        self.typeRevision = typeRevision
    }
}

extension CreateAssetRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAssetRevisionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAssetRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetRevisionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.predictionConfiguration = try reader["predictionConfiguration"].readIfPresent(with: DataZoneClientTypes.PredictionConfiguration.read(from:))
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        return value
    }
}

public struct CreateAssetRevisionOutput {
    /// The timestamp of when the asset revision occured.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who performed the asset revision.
    public var createdBy: Swift.String?
    /// The revised asset description.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the asset was revised.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first asset revision occured.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who performed the first asset revision.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that were attached to the asset as part of the asset revision.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that were attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the asset revision.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The details of an asset published in an Amazon DataZone catalog.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the revised project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that were attached to the asset as part of the asset revision.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the revision type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

enum CreateAssetRevisionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAssetTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), formsInput: \(Swift.String(describing: formsInput)), name: \(Swift.String(describing: name)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), description: \"CONTENT_REDACTED\")"}
}

extension CreateAssetTypeInput {

    static func urlPathProvider(_ value: CreateAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types"
    }
}

extension CreateAssetTypeInput {

    static func write(value: CreateAssetTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["formsInput"].writeMap(value.formsInput, valueWritingClosure: DataZoneClientTypes.FormEntryInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
    }
}

public struct CreateAssetTypeInput {
    /// The descripton of the custom asset type.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the custom asset type is being created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms that are to be attached to the custom asset type.
    /// This member is required.
    public var formsInput: [Swift.String:DataZoneClientTypes.FormEntryInput]?
    /// The name of the custom asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project that is to own the custom asset type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [Swift.String:DataZoneClientTypes.FormEntryInput]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
    }
}

extension CreateAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension CreateAssetTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAssetTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct CreateAssetTypeOutput {
    /// The timestamp of when the asset type is to be created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who creates this custom asset type.
    public var createdBy: Swift.String?
    /// The description of the custom asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms that are attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain where the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project where the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that currently owns this asset type.
    public var owningProjectId: Swift.String?
    /// The revision of the custom asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the custom type was created.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that created the custom asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum CreateAssetTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), type: \(Swift.String(describing: type)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetFormsInput"].writeList(value.assetFormsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.DataSourceConfigurationInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["enableSetting"].write(value.enableSetting)
        try writer["environmentIdentifier"].write(value.environmentIdentifier)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["publishOnImport"].write(value.publishOnImport)
        try writer["recommendation"].write(value.recommendation, with: DataZoneClientTypes.RecommendationConfiguration.write(value:to:))
        try writer["schedule"].write(value.schedule, with: DataZoneClientTypes.ScheduleConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

public struct CreateDataSourceInput {
    /// The metadata forms that are to be attached to the assets that this data source works with.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the data source is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which you want to add this data source.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The type of the data source.
    /// This member is required.
    public var type: Swift.String?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        clientToken: Swift.String? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.type = type
    }
}

extension CreateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: .dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct CreateDataSourceOutput {
    /// The metadata forms attached to the assets that this data source creates.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The unique identifier of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp that specifies when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project to which the data source is added.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/v2/domains"
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["domainExecutionRole"].write(value.domainExecutionRole)
        try writer["kmsKeyIdentifier"].write(value.kmsKeyIdentifier)
        try writer["name"].write(value.name)
        try writer["singleSignOn"].write(value.singleSignOn, with: DataZoneClientTypes.SingleSignOn.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateDomainInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    /// This member is required.
    public var name: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.singleSignOn = singleSignOn
        self.tags = tags
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct CreateDomainOutput {
    /// The ARN of the Amazon DataZone domain.
    public var arn: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the Amazon DataZone domain.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.portalUrl = portalUrl
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["environmentProfileIdentifier"].write(value.environmentProfileIdentifier)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateEnvironmentInput {
    /// The description of the Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment profile that is used to create this Amazon DataZone environment.
    /// This member is required.
    public var environmentProfileIdentifier: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone environment.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

extension CreateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct CreateEnvironmentOutput {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which the Amazon DataZone environment is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of this Amazon DataZone environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The configurable actions of this Amazon DataZone environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The ID of the blueprint with which this Amazon DataZone environment was created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which this Amazon DataZone environment was created.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone environment.
    public var id: Swift.String?
    /// The details of the last deployment of this Amazon DataZone environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of this environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentProfileInput {

    static func urlPathProvider(_ value: CreateEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

extension CreateEnvironmentProfileInput {

    static func write(value: CreateEnvironmentProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["awsAccountRegion"].write(value.awsAccountRegion)
        try writer["description"].write(value.description)
        try writer["environmentBlueprintIdentifier"].write(value.environmentBlueprintIdentifier)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateEnvironmentProfileInput {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to create the environment profile.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

extension CreateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct CreateEnvironmentProfileOutput {
    /// The Amazon Web Services account ID in which this Amazon DataZone environment profile is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this Amazon DataZone environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of this Amazon DataZone environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum CreateEnvironmentProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateFormTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateFormTypeInput {

    static func urlPathProvider(_ value: CreateFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types"
    }
}

extension CreateFormTypeInput {

    static func write(value: CreateFormTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["model"].write(value.model, with: DataZoneClientTypes.Model.write(value:to:))
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["status"].write(value.status)
    }
}

public struct CreateFormTypeInput {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The model of this Amazon DataZone metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns this metadata form type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this Amazon DataZone metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.model = model
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

extension CreateFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeOutput(domainId: \(Swift.String(describing: domainId)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateFormTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateFormTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFormTypeOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

public struct CreateFormTypeOutput {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this Amazon DataZone metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this Amazon DataZone metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of this Amazon DataZone metadata form type.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
    }
}

enum CreateFormTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryInput {

    static func urlPathProvider(_ value: CreateGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries"
    }
}

extension CreateGlossaryInput {

    static func write(value: CreateGlossaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["status"].write(value.status)
    }
}

public struct CreateGlossaryInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns business glossary.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

extension CreateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlossaryOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateGlossaryOutput {
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of this business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

enum CreateGlossaryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryTermInput {

    static func urlPathProvider(_ value: CreateGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms"
    }
}

extension CreateGlossaryTermInput {

    static func write(value: CreateGlossaryTermInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["glossaryIdentifier"].write(value.glossaryIdentifier)
        try writer["longDescription"].write(value.longDescription)
        try writer["name"].write(value.name)
        try writer["shortDescription"].write(value.shortDescription)
        try writer["status"].write(value.status)
        try writer["termRelations"].write(value.termRelations, with: DataZoneClientTypes.TermRelations.write(value:to:))
    }
}

public struct CreateGlossaryTermInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryIdentifier: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension CreateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension CreateGlossaryTermOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlossaryTermOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.glossaryId = try reader["glossaryId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        return value
    }
}

public struct CreateGlossaryTermOutput {
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of this business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

enum CreateGlossaryTermOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGroupProfileInput {

    static func urlPathProvider(_ value: CreateGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles"
    }
}

extension CreateGroupProfileInput {

    static func write(value: CreateGroupProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["groupIdentifier"].write(value.groupIdentifier)
    }
}

public struct CreateGroupProfileInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group for which the group profile is created.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

extension CreateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension CreateGroupProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateGroupProfileOutput {
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    public var domainId: Swift.String?
    /// The name of the group for which group profile is created.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The status of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

enum CreateGroupProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateListingChangeSetInput {

    static func urlPathProvider(_ value: CreateListingChangeSetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/change-set"
    }
}

extension CreateListingChangeSetInput {

    static func write(value: CreateListingChangeSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["clientToken"].write(value.clientToken)
        try writer["entityIdentifier"].write(value.entityIdentifier)
        try writer["entityRevision"].write(value.entityRevision)
        try writer["entityType"].write(value.entityType)
    }
}

public struct CreateListingChangeSetInput {
    /// Specifies whether to publish or unpublish a listing.
    /// This member is required.
    public var action: DataZoneClientTypes.ChangeAction?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The revision of an asset.
    public var entityRevision: Swift.String?
    /// The type of an entity.
    /// This member is required.
    public var entityType: DataZoneClientTypes.EntityType?

    public init(
        action: DataZoneClientTypes.ChangeAction? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityRevision: Swift.String? = nil,
        entityType: DataZoneClientTypes.EntityType? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityRevision = entityRevision
        self.entityType = entityType
    }
}

extension CreateListingChangeSetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateListingChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListingChangeSetOutput()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateListingChangeSetOutput {
    /// The ID of the listing (a record of an asset at a given time).
    /// This member is required.
    public var listingId: Swift.String?
    /// The revision of a listing.
    /// This member is required.
    public var listingRevision: Swift.String?
    /// Specifies the status of the listing.
    /// This member is required.
    public var status: DataZoneClientTypes.ListingStatus?

    public init(
        listingId: Swift.String? = nil,
        listingRevision: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil
    )
    {
        self.listingId = listingId
        self.listingRevision = listingRevision
        self.status = status
    }
}

enum CreateListingChangeSetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

public struct CreateProjectInput {
    /// The description of the Amazon DataZone project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this project is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone project.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone project.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.name = name
    }
}

extension CreateProjectMembershipInput {

    static func urlPathProvider(_ value: CreateProjectMembershipInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/createMembership"
    }
}

extension CreateProjectMembershipInput {

    static func write(value: CreateProjectMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["designation"].write(value.designation)
        try writer["member"].write(value.member, with: DataZoneClientTypes.Member.write(value:to:))
    }
}

public struct CreateProjectMembershipInput {
    /// The designation of the project membership.
    /// This member is required.
    public var designation: DataZoneClientTypes.UserDesignation?
    /// The ID of the Amazon DataZone domain in which project membership is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership was created.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the project for which this project membership was created.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        designation: DataZoneClientTypes.UserDesignation? = nil,
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.designation = designation
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

extension CreateProjectMembershipOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProjectMembershipOutput {
        return CreateProjectMembershipOutput()
    }
}

public struct CreateProjectMembershipOutput {

    public init() { }
}

enum CreateProjectMembershipOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

public struct CreateProjectOutput {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the project was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the Amazon DataZone project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Amazon DataZone project that was created.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSubscriptionGrantInput {

    static func urlPathProvider(_ value: CreateSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

extension CreateSubscriptionGrantInput {

    static func write(value: CreateSubscriptionGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetTargetNames"].writeList(value.assetTargetNames, memberWritingClosure: DataZoneClientTypes.AssetTargetNameMap.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentIdentifier"].write(value.environmentIdentifier)
        try writer["grantedEntity"].write(value.grantedEntity, with: DataZoneClientTypes.GrantedEntityInput.write(value:to:))
        try writer["subscriptionTargetIdentifier"].write(value.subscriptionTargetIdentifier)
    }
}

public struct CreateSubscriptionGrantInput {
    /// The names of the assets for which the subscription grant is created.
    public var assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which the subscription grant is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The entity to which the subscription is to be granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntityInput?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetIdentifier: Swift.String?

    public init(
        assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntityInput? = nil,
        subscriptionTargetIdentifier: Swift.String? = nil
    )
    {
        self.assetTargetNames = assetTargetNames
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.grantedEntity = grantedEntity
        self.subscriptionTargetIdentifier = subscriptionTargetIdentifier
    }
}

extension CreateSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct CreateSubscriptionGrantOutput {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// A timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription grant.
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// A timestamp of when the subscription grant was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum CreateSubscriptionGrantOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), requestReason: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionRequestInput {

    static func urlPathProvider(_ value: CreateSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

extension CreateSubscriptionRequestInput {

    static func write(value: CreateSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["requestReason"].write(value.requestReason)
        try writer["subscribedListings"].writeList(value.subscribedListings, memberWritingClosure: DataZoneClientTypes.SubscribedListingInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subscribedPrincipals"].writeList(value.subscribedPrincipals, memberWritingClosure: DataZoneClientTypes.SubscribedPrincipalInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateSubscriptionRequestInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription request is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The published asset for which the subscription grant is to be created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListingInput]?
    /// The Amazon DataZone principals for whom the subscription request is created.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListingInput]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.requestReason = requestReason
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
    }
}

extension CreateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct CreateSubscriptionRequestOutput {
    /// A timestamp of when the subscription request is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The ID of the Amazon DataZone domain in whcih the subscription request is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The ID of the reviewer of the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The published asset for which the subscription grant is to be created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum CreateSubscriptionRequestOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionTargetInput {

    static func urlPathProvider(_ value: CreateSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

extension CreateSubscriptionTargetInput {

    static func write(value: CreateSubscriptionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicableAssetTypes"].writeList(value.applicableAssetTypes, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizedPrincipals"].writeList(value.authorizedPrincipals, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["manageAccessRole"].write(value.manageAccessRole)
        try writer["name"].write(value.name)
        try writer["provider"].write(value.provider)
        try writer["subscriptionTargetConfig"].writeList(value.subscriptionTargetConfig, memberWritingClosure: DataZoneClientTypes.SubscriptionTargetForm.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

public struct CreateSubscriptionTargetInput {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which subscription target is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which subscription target is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The manage access role that is used to create the subscription target.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of the subscription target.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
    }
}

extension CreateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension CreateSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct CreateSubscriptionTargetOutput {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorised principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment in which the subscription target was created.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// ???
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum CreateSubscriptionTargetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateUserProfileInput {

    static func urlPathProvider(_ value: CreateUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles"
    }
}

extension CreateUserProfileInput {

    static func write(value: CreateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["userIdentifier"].write(value.userIdentifier)
        try writer["userType"].write(value.userType)
    }
}

public struct CreateUserProfileInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the user for which the user profile is created.
    /// This member is required.
    public var userIdentifier: Swift.String?
    /// The user type of the user for which the user profile is created.
    public var userType: DataZoneClientTypes.UserType?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        userIdentifier: Swift.String? = nil,
        userType: DataZoneClientTypes.UserType? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.userIdentifier = userIdentifier
        self.userType = userType
    }
}

extension CreateUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct CreateUserProfileOutput {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

enum CreateUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.CustomParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomParameter(defaultValue: \(Swift.String(describing: defaultValue)), fieldType: \(Swift.String(describing: fieldType)), isEditable: \(Swift.String(describing: isEditable)), isOptional: \(Swift.String(describing: isOptional)), keyName: \(Swift.String(describing: keyName)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.CustomParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CustomParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CustomParameter()
        value.keyName = try reader["keyName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.fieldType = try reader["fieldType"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.isEditable = try reader["isEditable"].readIfPresent()
        value.isOptional = try reader["isOptional"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of user parameters of an environment blueprint.
    public struct CustomParameter {
        /// The default value of the parameter.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// The filed type of the parameter.
        /// This member is required.
        public var fieldType: Swift.String?
        /// Specifies whether the parameter is editable.
        public var isEditable: Swift.Bool?
        /// Specifies whether the custom parameter is optional.
        public var isOptional: Swift.Bool?
        /// The key name of the parameter.
        /// This member is required.
        public var keyName: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            fieldType: Swift.String? = nil,
            isEditable: Swift.Bool? = nil,
            isOptional: Swift.Bool? = nil,
            keyName: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.fieldType = fieldType
            self.isEditable = isEditable
            self.isOptional = isOptional
            self.keyName = keyName
        }
    }

}

extension DataZoneClientTypes {

    public enum DataAssetActivityStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case publishingFailed
        case skippedAlreadyImported
        case skippedArchived
        case skippedNoAccess
        case succeededCreated
        case succeededUpdated
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAssetActivityStatus] {
            return [
                .failed,
                .publishingFailed,
                .skippedAlreadyImported,
                .skippedArchived,
                .skippedNoAccess,
                .succeededCreated,
                .succeededUpdated,
                .unchanged,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .publishingFailed: return "PUBLISHING_FAILED"
            case .skippedAlreadyImported: return "SKIPPED_ALREADY_IMPORTED"
            case .skippedArchived: return "SKIPPED_ARCHIVED"
            case .skippedNoAccess: return "SKIPPED_NO_ACCESS"
            case .succeededCreated: return "SUCCEEDED_CREATED"
            case .succeededUpdated: return "SUCCEEDED_UPDATED"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DataProductItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductItem()
        value.itemId = try reader["itemId"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    ///
    public struct DataProductItem {
        ///
        public var domainId: Swift.String?
        ///
        public var itemId: Swift.String?

        public init(
            domainId: Swift.String? = nil,
            itemId: Swift.String? = nil
        )
        {
            self.domainId = domainId
            self.itemId = itemId
        }
    }

}

extension DataZoneClientTypes.DataProductSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataProductSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), dataProductItems: \(Swift.String(describing: dataProductItems)), domainId: \(Swift.String(describing: domainId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.DataProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataProductItems = try reader["dataProductItems"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataProductItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    ///
    public struct DataProductSummary {
        ///
        public var createdAt: ClientRuntime.Date?
        ///
        public var createdBy: Swift.String?
        ///
        public var dataProductItems: [DataZoneClientTypes.DataProductItem]?
        ///
        public var description: Swift.String?
        ///
        /// This member is required.
        public var domainId: Swift.String?
        ///
        public var glossaryTerms: [Swift.String]?
        ///
        /// This member is required.
        public var id: Swift.String?
        ///
        /// This member is required.
        public var name: Swift.String?
        ///
        /// This member is required.
        public var owningProjectId: Swift.String?
        ///
        public var updatedAt: ClientRuntime.Date?
        ///
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            dataProductItems: [DataZoneClientTypes.DataProductItem]? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dataProductItems = dataProductItems
            self.description = description
            self.domainId = domainId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes.DataSourceConfigurationInput {

    static func write(value: DataZoneClientTypes.DataSourceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .gluerunconfiguration(gluerunconfiguration):
                try writer["glueRunConfiguration"].write(gluerunconfiguration, with: DataZoneClientTypes.GlueRunConfigurationInput.write(value:to:))
            case let .redshiftrunconfiguration(redshiftrunconfiguration):
                try writer["redshiftRunConfiguration"].write(redshiftrunconfiguration, with: DataZoneClientTypes.RedshiftRunConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes {
    /// The configuration of the data source.
    public enum DataSourceConfigurationInput {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationInput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.DataSourceConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glueRunConfiguration":
                return .gluerunconfiguration(try reader["glueRunConfiguration"].read(with: DataZoneClientTypes.GlueRunConfigurationOutput.read(from:)))
            case "redshiftRunConfiguration":
                return .redshiftrunconfiguration(try reader["redshiftRunConfiguration"].read(with: DataZoneClientTypes.RedshiftRunConfigurationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The configuration of the data source.
    public enum DataSourceConfigurationOutput {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationOutput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.DataSourceErrorMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceErrorMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceErrorMessage()
        value.errorType = try reader["errorType"].readIfPresent()
        value.errorDetail = try reader["errorDetail"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the error message that is returned if the operation cannot be successfully completed.
    public struct DataSourceErrorMessage {
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorDetail: Swift.String?
        /// The type of the error message that is returned if the operation cannot be successfully completed.
        /// This member is required.
        public var errorType: DataZoneClientTypes.DataSourceErrorType?

        public init(
            errorDetail: Swift.String? = nil,
            errorType: DataZoneClientTypes.DataSourceErrorType? = nil
        )
        {
            self.errorDetail = errorDetail
            self.errorType = errorType
        }
    }

}

extension DataZoneClientTypes {

    public enum DataSourceErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDeniedException
        case conflictException
        case internalServerException
        case resourceNotFoundException
        case serviceQuotaExceededException
        case throttlingException
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorType] {
            return [
                .accessDeniedException,
                .conflictException,
                .internalServerException,
                .resourceNotFoundException,
                .serviceQuotaExceededException,
                .throttlingException,
                .validationException,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
            case .conflictException: return "CONFLICT_EXCEPTION"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case .throttlingException: return "THROTTLING_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DataSourceRunActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceRunActivity(createdAt: \(Swift.String(describing: createdAt)), dataAssetId: \(Swift.String(describing: dataAssetId)), dataAssetStatus: \(Swift.String(describing: dataAssetStatus)), dataSourceRunId: \(Swift.String(describing: dataSourceRunId)), errorMessage: \(Swift.String(describing: errorMessage)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), database: \"CONTENT_REDACTED\", technicalDescription: \"CONTENT_REDACTED\", technicalName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.DataSourceRunActivity {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceRunActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceRunActivity()
        value.database = try reader["database"].readIfPresent()
        value.dataSourceRunId = try reader["dataSourceRunId"].readIfPresent()
        value.technicalName = try reader["technicalName"].readIfPresent()
        value.dataAssetStatus = try reader["dataAssetStatus"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.dataAssetId = try reader["dataAssetId"].readIfPresent()
        value.technicalDescription = try reader["technicalDescription"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The activity details of the data source run.
    public struct DataSourceRunActivity {
        /// The timestamp of when data source run activity was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the asset included in the data source run activity.
        public var dataAssetId: Swift.String?
        /// The status of the asset included in the data source run activity.
        /// This member is required.
        public var dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus?
        /// The identifier of the data source for the data source run activity.
        /// This member is required.
        public var dataSourceRunId: Swift.String?
        /// The database included in the data source run activity.
        /// This member is required.
        public var database: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The project ID included in the data source run activity.
        /// This member is required.
        public var projectId: Swift.String?
        /// The technical description included in the data source run activity.
        public var technicalDescription: Swift.String?
        /// The technical name included in the data source run activity.
        /// This member is required.
        public var technicalName: Swift.String?
        /// The timestamp of when data source run activity was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataAssetId: Swift.String? = nil,
            dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus? = nil,
            dataSourceRunId: Swift.String? = nil,
            database: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            projectId: Swift.String? = nil,
            technicalDescription: Swift.String? = nil,
            technicalName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAssetId = dataAssetId
            self.dataAssetStatus = dataAssetStatus
            self.dataSourceRunId = dataSourceRunId
            self.database = database
            self.errorMessage = errorMessage
            self.projectId = projectId
            self.technicalDescription = technicalDescription
            self.technicalName = technicalName
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {

    public enum DataSourceRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case partiallySucceeded
        case requested
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunStatus] {
            return [
                .failed,
                .partiallySucceeded,
                .requested,
                .running,
                .success,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .partiallySucceeded: return "PARTIALLY_SUCCEEDED"
            case .requested: return "REQUESTED"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DataSourceRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceRunSummary()
        value.id = try reader["id"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: .dateTime)
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a data source run.
    public struct DataSourceRunSummary {
        /// The timestamp of when a data source run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the data source of the data source run.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The identifier of the data source run.
        /// This member is required.
        public var id: Swift.String?
        /// The project ID of the data source run.
        /// This member is required.
        public var projectId: Swift.String?
        /// The asset statistics from the data source run.
        public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
        /// The timestamp of when a data source run was started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the data source run.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceRunStatus?
        /// The timestamp of when a data source run was stopped.
        public var stoppedAt: ClientRuntime.Date?
        /// The type of the data source run.
        /// This member is required.
        public var type: DataZoneClientTypes.DataSourceRunType?
        /// The timestamp of when a data source run was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            id: Swift.String? = nil,
            projectId: Swift.String? = nil,
            runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: DataZoneClientTypes.DataSourceRunStatus? = nil,
            stoppedAt: ClientRuntime.Date? = nil,
            type: DataZoneClientTypes.DataSourceRunType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {

    public enum DataSourceRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case prioritized
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunType] {
            return [
                .prioritized,
                .scheduled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .prioritized: return "PRIORITIZED"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failedCreation
        case failedDeletion
        case failedUpdate
        case ready
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .creating,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .failedUpdate,
                .ready,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdate: return "FAILED_UPDATE"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DataSourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSummary(createdAt: \(Swift.String(describing: createdAt)), dataSourceId: \(Swift.String(describing: dataSourceId)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.DataSourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: .dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunAssetCount = try reader["lastRunAssetCount"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the data source.
    public struct DataSourceSummary {
        /// The timestamp of when the data source was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// Specifies whether the data source is enabled.
        public var enableSetting: DataZoneClientTypes.EnableSetting?
        /// The ID of the environment in which the data source exists.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The count of the assets created during the last data source run.
        public var lastRunAssetCount: Swift.Int?
        /// The timestamp of when the data source run was last performed.
        public var lastRunAt: ClientRuntime.Date?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The status of the last data source run.
        public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The details of the schedule of the data source runs.
        public var schedule: DataZoneClientTypes.ScheduleConfiguration?
        /// The status of the data source.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceStatus?
        /// The type of the data source.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the data source was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            enableSetting: DataZoneClientTypes.EnableSetting? = nil,
            environmentId: Swift.String? = nil,
            lastRunAssetCount: Swift.Int? = nil,
            lastRunAt: ClientRuntime.Date? = nil,
            lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
            name: Swift.String? = nil,
            schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
            status: DataZoneClientTypes.DataSourceStatus? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
        default: return nil
    }
}

public enum DataZoneClientTypes {}

extension DeleteAssetInput {

    static func urlPathProvider(_ value: DeleteAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput {
    /// The ID of the Amazon DataZone domain in which the asset is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteAssetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAssetOutput {
        return DeleteAssetOutput()
    }
}

public struct DeleteAssetOutput {

    public init() { }
}

enum DeleteAssetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAssetTypeInput {

    static func urlPathProvider(_ value: DeleteAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteAssetTypeInput {
    /// The ID of the Amazon DataZone domain in which the asset type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset type that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteAssetTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAssetTypeOutput {
        return DeleteAssetTypeOutput()
    }
}

public struct DeleteAssetTypeOutput {

    public init() { }
}

enum DeleteAssetTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDataSourceInput {

    static func queryItemProvider(_ value: DeleteDataSourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: .dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct DeleteDataSourceOutput {
    /// The asset data forms associated with this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source that is deleted.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when this data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source that is deleted.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting of the data source that specifies whether the data source is enabled or disabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environemnt associated with this data source.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source that is deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project in which this data source exists and from which it's deleted.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// The schedule of runs for this data source.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of this data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of this data source.
    public var type: Swift.String?
    /// The timestamp of when this data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDomainInput {

    static func queryItemProvider(_ value: DeleteDomainInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        if let skipDeletionCheck = value.skipDeletionCheck {
            let skipDeletionCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipDeletionCheck".urlPercentEncoding(), value: Swift.String(skipDeletionCheck).urlPercentEncoding())
            items.append(skipDeletionCheckQueryItem)
        }
        return items
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteDomainInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Web Services domain that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the optional flag to delete all child entities within the domain.
    public var skipDeletionCheck: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        skipDeletionCheck: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.identifier = identifier
        self.skipDeletionCheck = skipDeletionCheck
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteDomainOutput {
    /// The status of the domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.status = status
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: DeleteEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentBlueprintConfigurationInput {
    /// The ID of the Amazon DataZone domain in which the blueprint configuration is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint the configuration of which is deleted.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

extension DeleteEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteEnvironmentBlueprintConfigurationOutput {
        return DeleteEnvironmentBlueprintConfigurationOutput()
    }
}

public struct DeleteEnvironmentBlueprintConfigurationOutput {

    public init() { }
}

enum DeleteEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput {
    /// The ID of the Amazon DataZone domain in which the environment is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteEnvironmentOutput {
        return DeleteEnvironmentOutput()
    }
}

public struct DeleteEnvironmentOutput {

    public init() { }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteEnvironmentProfileInput {

    static func urlPathProvider(_ value: DeleteEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentProfileInput {
    /// The ID of the Amazon DataZone domain in which the environment profile is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteEnvironmentProfileOutput {
        return DeleteEnvironmentProfileOutput()
    }
}

public struct DeleteEnvironmentProfileOutput {

    public init() { }
}

enum DeleteEnvironmentProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteFormTypeInput {

    static func urlPathProvider(_ value: DeleteFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = value.formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteFormTypeInput {
    /// The ID of the Amazon DataZone domain in which the metadata form type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type that is deleted.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
    }
}

extension DeleteFormTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteFormTypeOutput {
        return DeleteFormTypeOutput()
    }
}

public struct DeleteFormTypeOutput {

    public init() { }
}

enum DeleteFormTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGlossaryInput {

    static func urlPathProvider(_ value: DeleteGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteGlossaryInput {
    /// The ID of the Amazon DataZone domain in which the business glossary is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteGlossaryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGlossaryOutput {
        return DeleteGlossaryOutput()
    }
}

public struct DeleteGlossaryOutput {

    public init() { }
}

enum DeleteGlossaryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGlossaryTermInput {

    static func urlPathProvider(_ value: DeleteGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteGlossaryTermInput {
    /// The ID of the Amazon DataZone domain in which the business glossary term is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteGlossaryTermOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGlossaryTermOutput {
        return DeleteGlossaryTermOutput()
    }
}

public struct DeleteGlossaryTermOutput {

    public init() { }
}

enum DeleteGlossaryTermOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteListingInput {

    static func urlPathProvider(_ value: DeleteListingInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteListingInput {
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the listing to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteListingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteListingOutput {
        return DeleteListingOutput()
    }
}

public struct DeleteListingOutput {

    public init() { }
}

enum DeleteListingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProjectInput {

    static func queryItemProvider(_ value: DeleteProjectInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipDeletionCheck = value.skipDeletionCheck {
            let skipDeletionCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipDeletionCheck".urlPercentEncoding(), value: Swift.String(skipDeletionCheck).urlPercentEncoding())
            items.append(skipDeletionCheckQueryItem)
        }
        return items
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput {
    /// The ID of the Amazon DataZone domain in which the project is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the project that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the optional flag to delete all child entities within the project.
    public var skipDeletionCheck: Swift.Bool?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        skipDeletionCheck: Swift.Bool? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.skipDeletionCheck = skipDeletionCheck
    }
}

extension DeleteProjectMembershipInput {

    static func urlPathProvider(_ value: DeleteProjectMembershipInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/deleteMembership"
    }
}

extension DeleteProjectMembershipInput {

    static func write(value: DeleteProjectMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["member"].write(value.member, with: DataZoneClientTypes.Member.write(value:to:))
    }
}

public struct DeleteProjectMembershipInput {
    /// The ID of the Amazon DataZone domain where project membership is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership is deleted.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the Amazon DataZone project the membership to which is deleted.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

extension DeleteProjectMembershipOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProjectMembershipOutput {
        return DeleteProjectMembershipOutput()
    }
}

public struct DeleteProjectMembershipOutput {

    public init() { }
}

enum DeleteProjectMembershipOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

public struct DeleteProjectOutput {

    public init() { }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSubscriptionGrantInput {

    static func urlPathProvider(_ value: DeleteSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionGrantInput {
    /// The ID of the Amazon DataZone domain where the subscription grant is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct DeleteSubscriptionGrantOutput {
    /// The assets for which the subsctiption grant that is deleted gave access.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant that is deleted was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant that is deleted.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is deleted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant that is deleted.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subsctiption whose subscription grant is to be deleted.
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target associated with the subscription grant that is deleted.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant that is deleted was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant that is deleted.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum DeleteSubscriptionGrantOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSubscriptionRequestInput {

    static func urlPathProvider(_ value: DeleteSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionRequestInput {
    /// The ID of the Amazon DataZone domain in which the subscription request is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription request that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DeleteSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSubscriptionRequestOutput {
        return DeleteSubscriptionRequestOutput()
    }
}

public struct DeleteSubscriptionRequestOutput {

    public init() { }
}

enum DeleteSubscriptionRequestOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSubscriptionTargetInput {

    static func urlPathProvider(_ value: DeleteSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionTargetInput {
    /// The ID of the Amazon DataZone domain in which the subscription target is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment in which the subscription target is deleted.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

extension DeleteSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSubscriptionTargetOutput {
        return DeleteSubscriptionTargetOutput()
    }
}

public struct DeleteSubscriptionTargetOutput {

    public init() { }
}

enum DeleteSubscriptionTargetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTimeSeriesDataPointsInput {

    static func queryItemProvider(_ value: DeleteTimeSeriesDataPointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let formNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        return items
    }
}

extension DeleteTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: DeleteTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

public struct DeleteTimeSeriesDataPointsInput {
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain that houses the asset for which you want to delete a time series form.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to delete a time series form.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to delete a time series form.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series form that you want to delete.
    /// This member is required.
    public var formName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
    }
}

extension DeleteTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteTimeSeriesDataPointsOutput {
        return DeleteTimeSeriesDataPointsOutput()
    }
}

public struct DeleteTimeSeriesDataPointsOutput {

    public init() { }
}

enum DeleteTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Deployment()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentType = try reader["deploymentType"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent(with: DataZoneClientTypes.EnvironmentError.read(from:))
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isDeploymentComplete = try reader["isDeploymentComplete"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the last deployment of the environment.
    public struct Deployment {
        /// The identifier of the last deployment of the environment.
        public var deploymentId: Swift.String?
        /// The status of the last deployment of the environment.
        public var deploymentStatus: DataZoneClientTypes.DeploymentStatus?
        /// The type of the last deployment of the environment.
        public var deploymentType: DataZoneClientTypes.DeploymentType?
        /// The failure reason of the last deployment of the environment.
        public var failureReason: DataZoneClientTypes.EnvironmentError?
        /// Specifies whether the last deployment of the environment is complete.
        public var isDeploymentComplete: Swift.Bool?
        /// The messages of the last deployment of the environment.
        public var messages: [Swift.String]?

        public init(
            deploymentId: Swift.String? = nil,
            deploymentStatus: DataZoneClientTypes.DeploymentStatus? = nil,
            deploymentType: DataZoneClientTypes.DeploymentType? = nil,
            failureReason: DataZoneClientTypes.EnvironmentError? = nil,
            isDeploymentComplete: Swift.Bool? = nil,
            messages: [Swift.String]? = nil
        )
        {
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.failureReason = failureReason
            self.isDeploymentComplete = isDeploymentComplete
            self.messages = messages
        }
    }

}

extension DataZoneClientTypes.DeploymentProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DeploymentProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DeploymentProperties()
        value.startTimeoutMinutes = try reader["startTimeoutMinutes"].readIfPresent()
        value.endTimeoutMinutes = try reader["endTimeoutMinutes"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The deployment properties of the Amazon DataZone blueprint.
    public struct DeploymentProperties {
        /// The end timeout of the environment blueprint deployment.
        public var endTimeoutMinutes: Swift.Int?
        /// The start timeout of the environment blueprint deployment.
        public var startTimeoutMinutes: Swift.Int?

        public init(
            endTimeoutMinutes: Swift.Int? = nil,
            startTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.endTimeoutMinutes = endTimeoutMinutes
            self.startTimeoutMinutes = startTimeoutMinutes
        }
    }

}

extension DataZoneClientTypes {

    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case pendingDeployment
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .failed,
                .inProgress,
                .pendingDeployment,
                .successful,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DetailedGlossaryTerm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetailedGlossaryTerm(name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.DetailedGlossaryTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DetailedGlossaryTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DetailedGlossaryTerm()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// Details of a glossary term attached to the inventory asset.
    public struct DetailedGlossaryTerm {
        /// The name of a glossary term attached to the inventory asset.
        public var name: Swift.String?
        /// The shoft description of a glossary term attached to the inventory asset.
        public var shortDescription: Swift.String?

        public init(
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil
        )
        {
            self.name = name
            self.shortDescription = shortDescription
        }
    }

}

extension DataZoneClientTypes {

    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .available,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), managedAccountId: \(Swift.String(describing: managedAccountId)), portalUrl: \(Swift.String(describing: portalUrl)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.managedAccountId = try reader["managedAccountId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension DataZoneClientTypes {
    /// A summary of a Amazon DataZone domain.
    public struct DomainSummary {
        /// The ARN of the Amazon DataZone domain.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of an Amazon DataZone domain.
        public var description: Swift.String?
        /// The ID of the Amazon DataZone domain.
        /// This member is required.
        public var id: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The identifier of the Amazon Web Services account that manages the domain.
        /// This member is required.
        public var managedAccountId: Swift.String?
        /// A name of an Amazon DataZone domain.
        /// This member is required.
        public var name: Swift.String?
        /// The data portal URL for the Amazon DataZone domain.
        public var portalUrl: Swift.String?
        /// The status of the Amazon DataZone domain.
        /// This member is required.
        public var status: DataZoneClientTypes.DomainStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            managedAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            portalUrl: Swift.String? = nil,
            status: DataZoneClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.managedAccountId = managedAccountId
            self.name = name
            self.portalUrl = portalUrl
            self.status = status
        }
    }

}

extension DataZoneClientTypes {

    public enum EnableSetting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableSetting] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .asset,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentBlueprintConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentBlueprintConfigurationItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: mapReadingClosure(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The configuration details of an environment blueprint.
    public struct EnvironmentBlueprintConfigurationItem {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the Amazon DataZone domain in which an environment blueprint exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The enabled Amazon Web Services Regions specified in a blueprint configuration.
        public var enabledRegions: [Swift.String]?
        /// The identifier of the environment blueprint.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The ARN of the manage access role specified in the environment blueprint configuration.
        public var manageAccessRoleArn: Swift.String?
        /// The ARN of the provisioning role specified in the environment blueprint configuration.
        public var provisioningRoleArn: Swift.String?
        /// The regional parameters of the environment blueprint.
        public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
        /// The timestamp of when the environment blueprint was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            enabledRegions: [Swift.String]? = nil,
            environmentBlueprintId: Swift.String? = nil,
            manageAccessRoleArn: Swift.String? = nil,
            provisioningRoleArn: Swift.String? = nil,
            regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.EnvironmentBlueprintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentBlueprintSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.EnvironmentBlueprintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentBlueprintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentBlueprintSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an environment blueprint summary.
    public struct EnvironmentBlueprintSummary {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of a blueprint.
        public var description: Swift.String?
        /// The identifier of the blueprint.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the blueprint.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the blueprint.
        /// This member is required.
        public var provider: Swift.String?
        /// The provisioning properties of the blueprint.
        /// This member is required.
        public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
        /// The timestamp of when the blueprint was enabled.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.EnvironmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The failure reasons for the environment deployment.
    public struct EnvironmentError {
        /// The error code for the failure reason for the environment deployment.
        public var code: Swift.String?
        /// The error message for the failure reason for the environment deployment.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension DataZoneClientTypes.EnvironmentParameter {

    static func write(value: DataZoneClientTypes.EnvironmentParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension DataZoneClientTypes {
    /// The parameter details of an evironment profile.
    public struct EnvironmentParameter {
        /// The name of an environment profile parameter.
        public var name: Swift.String?
        /// The value of an environment profile parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DataZoneClientTypes.EnvironmentProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentProfileSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.EnvironmentProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentProfileSummary()
        value.id = try reader["id"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an environment profile.
    public struct EnvironmentProfileSummary {
        /// The identifier of an Amazon Web Services account in which an environment profile exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment profile exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when an environment profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the environment profile.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment profile.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment profile exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of a blueprint with which an environment profile is created.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The identifier of the environment profile.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the environment profile.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of a project in which an environment profile exists.
        public var projectId: Swift.String?
        /// The timestamp of when the environment profile was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentBlueprintId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes {

    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case disabled
        case expired
        case inaccessible
        case suspended
        case updateFailed
        case updating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .disabled,
                .expired,
                .inaccessible,
                .suspended,
                .updateFailed,
                .updating,
                .validationFailed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .expired: return "EXPIRED"
            case .inaccessible: return "INACCESSIBLE"
            case .suspended: return "SUSPENDED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentSummary()
        value.projectId = try reader["projectId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an environment.
    public struct EnvironmentSummary {
        /// The identifier of the Amazon Web Services account in which an environment exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the environment.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment profile with which the environment was created.
        /// This member is required.
        public var environmentProfileId: Swift.String?
        /// The identifier of the environment.
        public var id: Swift.String?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project in which the environment exists.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the environment.
        /// This member is required.
        public var provider: Swift.String?
        /// The status of the environment.
        public var status: DataZoneClientTypes.EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentProfileId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            status: DataZoneClientTypes.EnvironmentStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentProfileId = environmentProfileId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.FailureCause {

    static func write(value: DataZoneClientTypes.FailureCause?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FailureCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FailureCause()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public struct FailureCause {
        /// The description of the error message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension DataZoneClientTypes.Filter {

    static func write(value: DataZoneClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["value"].write(value.value)
    }
}

extension DataZoneClientTypes {
    /// A search filter in Amazon DataZone.
    public struct Filter {
        /// A search filter attribute in Amazon DataZone.
        /// This member is required.
        public var attribute: Swift.String?
        /// A search filter value in Amazon DataZone.
        /// This member is required.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.value = value
        }
    }

}

extension DataZoneClientTypes.FilterClause {

    static func write(value: DataZoneClientTypes.FilterClause?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .and(and):
                try writer["and"].writeList(and, memberWritingClosure: DataZoneClientTypes.FilterClause.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .filter(filter):
                try writer["filter"].write(filter, with: DataZoneClientTypes.Filter.write(value:to:))
            case let .or(or):
                try writer["or"].writeList(or, memberWritingClosure: DataZoneClientTypes.FilterClause.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes {
    /// A search filter clause in Amazon DataZone.
    public indirect enum FilterClause {
        /// A search filter in Amazon DataZone.
        case filter(DataZoneClientTypes.Filter)
        /// The 'and' search filter clause in Amazon DataZone.
        case and([DataZoneClientTypes.FilterClause])
        /// The 'or' search filter clause in Amazon DataZone.
        case or([DataZoneClientTypes.FilterClause])
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.FilterExpression {

    static func write(value: DataZoneClientTypes.FilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FilterExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FilterExpression()
        value.type = try reader["type"].readIfPresent()
        value.expression = try reader["expression"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// A filter expression in Amazon DataZone.
    public struct FilterExpression {
        /// The search filter expression.
        /// This member is required.
        public var expression: Swift.String?
        /// The search filter explresison type.
        /// This member is required.
        public var type: DataZoneClientTypes.FilterExpressionType?

        public init(
            expression: Swift.String? = nil,
            type: DataZoneClientTypes.FilterExpressionType? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension DataZoneClientTypes {

    public enum FilterExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterExpressionType] {
            return [
                .exclude,
                .include,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.FormEntryInput {

    static func write(value: DataZoneClientTypes.FormEntryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["required"].write(value.`required`)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes {
    /// The details of the form entry.
    public struct FormEntryInput {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The type ID of the form entry.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormEntryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormEntryOutput(required: \(Swift.String(describing: `required`)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.FormEntryOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormEntryOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormEntryOutput()
        value.typeName = try reader["typeName"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the form entry.
    public struct FormEntryOutput {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The name of the type of the form entry.
        /// This member is required.
        public var typeName: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DataZoneClientTypes.FormInput {

    static func write(value: DataZoneClientTypes.FormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes {
    /// The details of a metadata form.
    public struct FormInput {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the metadata form type.
        public var typeIdentifier: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormOutput(content: \(Swift.String(describing: content)), formName: \(Swift.String(describing: formName)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.FormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormOutput()
        value.formName = try reader["formName"].readIfPresent()
        value.typeName = try reader["typeName"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a metadata form.
    public struct FormOutput {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The name of the metadata form type.
        public var typeName: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.FormTypeData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormTypeData(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.FormTypeData {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormTypeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormTypeData()
        value.domainId = try reader["domainId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.model = try reader["model"].readIfPresent(with: DataZoneClientTypes.Model.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.imports = try reader["imports"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Import.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the metadata form type.
    public struct FormTypeData {
        /// The timestamp of when the metadata form type was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created teh metadata form type.
        public var createdBy: Swift.String?
        /// The description of the metadata form type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The imports specified in the form type.
        public var imports: [DataZoneClientTypes.Import]?
        /// The model of the form type.
        public var model: DataZoneClientTypes.Model?
        /// The name of the form type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the project in which the form type was originally created.
        public var originProjectId: Swift.String?
        /// The identifier of the project that owns the form type.
        public var owningProjectId: Swift.String?
        /// The revision of the form type.
        /// This member is required.
        public var revision: Swift.String?
        /// The status of the form type.
        public var status: DataZoneClientTypes.FormTypeStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            imports: [DataZoneClientTypes.Import]? = nil,
            model: DataZoneClientTypes.Model? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            status: DataZoneClientTypes.FormTypeStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }
    }

}

extension DataZoneClientTypes {

    public enum FormTypeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FormTypeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetAssetInput {

    static func queryItemProvider(_ value: GetAssetInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetAssetInput {

    static func urlPathProvider(_ value: GetAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

public struct GetAssetInput {
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the Amazon DataZone asset.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

extension GetAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetAssetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        return value
    }
}

public struct GetAssetOutput {
    /// The timestamp of when the asset was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the asset.
    public var createdBy: Swift.String?
    /// The description of the Amazon DataZone asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external ID of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset was created.
    public var firstRevisionCreatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms attached to the asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The business glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the asset.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The listing of the asset.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The read-only metadata forms attached to the asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: ClientRuntime.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

enum GetAssetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAssetTypeInput {

    static func queryItemProvider(_ value: GetAssetTypeInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetAssetTypeInput {

    static func urlPathProvider(_ value: GetAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

public struct GetAssetTypeInput {
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the asset type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

extension GetAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetAssetTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAssetTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetAssetTypeOutput {
    /// The timestamp of when the asset type was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the asset type.
    public var createdBy: Swift.String?
    /// The description of the asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project in which the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that owns the asset type.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the asset type was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user that updated the asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String:DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetAssetTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput {
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone data source.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastRunAssetCount = try reader["lastRunAssetCount"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: .dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetDataSourceOutput {
    /// The metadata forms attached to the assets created by this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether this data source is enabled or not.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environment where this data source creates and publishes assets,
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The number of assets created by the data source during its last run.
    public var lastRunAssetCount: Swift.Int?
    /// The timestamp of the last run of the data source.
    public var lastRunAt: ClientRuntime.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project where the data source creates and publishes assets.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// The recommendation configuration of the data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAssetCount: Swift.Int? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAssetCount = lastRunAssetCount
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDataSourceRunInput {

    static func urlPathProvider(_ value: GetDataSourceRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDataSourceRunInput {
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the data source run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetDataSourceRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDataSourceRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.dataSourceConfigurationSnapshot = try reader["dataSourceConfigurationSnapshot"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: .dateTime)
        value.status = try reader["status"].readIfPresent()
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: .dateTime)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetDataSourceRunOutput {
    /// The timestamp of when the data source run was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The configuration snapshot of the data source run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The ID of the data source for this data source run.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project in which this data source run occured.
    /// This member is required.
    public var projectId: Swift.String?
    /// The asset statistics from this data source run.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when this data source run started.
    public var startedAt: ClientRuntime.Date?
    /// The status of this data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when this data source run stopped.
    public var stoppedAt: ClientRuntime.Date?
    /// The type of this data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when this data source run was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: ClientRuntime.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum GetDataSourceRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDomainInput {

    static func urlPathProvider(_ value: GetDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

public struct GetDomainInput {
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

extension GetDomainOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetDomainOutput {
    /// The ARN of the specified Amazon DataZone domain.
    public var arn: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was created.
    public var createdAt: ClientRuntime.Date?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role with which the Amazon DataZone domain is created.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The single sing-on option of the specified Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the specified Amazon DataZone domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.portalUrl = portalUrl
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

enum GetDomainOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: GetEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentBlueprintConfigurationInput {
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// He ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

extension GetEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEnvironmentBlueprintConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentBlueprintConfigurationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.domainId = try reader["domainId"].readIfPresent()
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: mapReadingClosure(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct GetEnvironmentBlueprintConfigurationOutput {
    /// The timestamp of when this blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The Amazon Web Services regions in which this blueprint is enabled.
    public var enabledRegions: [Swift.String]?
    /// The ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role with which this blueprint is created.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role with which this blueprint is created.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters of the blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The timestamp of when this blueprint was upated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

enum GetEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEnvironmentBlueprintInput {

    static func urlPathProvider(_ value: GetEnvironmentBlueprintInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentBlueprintInput {
    /// The identifier of the domain in which this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetEnvironmentBlueprintOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentBlueprintOutput(createdAt: \(Swift.String(describing: createdAt)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentBlueprintOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEnvironmentBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentBlueprintOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetEnvironmentBlueprintOutput {
    /// A timestamp of when this blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment properties of this Amazon DataZone blueprint.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone blueprint.
    public var description: Swift.String?
    /// The glossary terms attached to this Amazon DataZone blueprint.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone blueprint.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of this Amazon DataZone blueprint.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioning properties of this Amazon DataZone blueprint.
    /// This member is required.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The timestamp of when this blueprint was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this blueprint.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.createdAt = createdAt
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.name = name
        self.provider = provider
        self.provisioningProperties = provisioningProperties
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum GetEnvironmentBlueprintOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput {
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetEnvironmentOutput {
    /// The ID of the Amazon Web Services account where the environment exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where the environment exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of the environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of the environment.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The actions of the environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint with which the environment is created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which the environment is created.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The business glossary terms that can be used in this environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the environment.
    public var id: Swift.String?
    /// The details of the last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEnvironmentProfileInput {

    static func urlPathProvider(_ value: GetEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentProfileInput {
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetEnvironmentProfileOutput {
    /// The ID of the Amazon Web Services account where this environment profile exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where this environment profile exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was upated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters of the environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum GetEnvironmentProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetFormTypeInput {

    static func queryItemProvider(_ value: GetFormTypeInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetFormTypeInput {

    static func urlPathProvider(_ value: GetFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = value.formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

public struct GetFormTypeInput {
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?
    /// The revision of this metadata form type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
        self.revision = revision
    }
}

extension GetFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFormTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetFormTypeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetFormTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFormTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.imports = try reader["imports"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Import.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.model = try reader["model"].readIfPresent(with: DataZoneClientTypes.Model.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetFormTypeOutput {
    /// The timestamp of when this metadata form type was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this metadata form type.
    public var createdBy: Swift.String?
    /// The description of the metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The imports of the metadata form type.
    public var imports: [DataZoneClientTypes.Import]?
    /// The model of the metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of the metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of the metadata form type.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        imports: [DataZoneClientTypes.Import]? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.imports = imports
        self.model = model
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

enum GetFormTypeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGlossaryInput {

    static func urlPathProvider(_ value: GetGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

public struct GetGlossaryInput {
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetGlossaryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlossaryOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetGlossaryOutput {
    /// The timestamp of when this business glossary was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created this business glossary.
    public var createdBy: Swift.String?
    /// The description of the business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of the business glossary.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryStatus?
    /// The timestamp of when the business glossary was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the business glossary.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetGlossaryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGlossaryTermInput {

    static func urlPathProvider(_ value: GetGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

public struct GetGlossaryTermInput {
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryTermOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension GetGlossaryTermOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlossaryTermOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.glossaryId = try reader["glossaryId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetGlossaryTermOutput {
    /// The timestamp of when the business glossary term was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the business glossary.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary to which this term belongs.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of the business glossary term.
    public var longDescription: Swift.String?
    /// The name of the business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short decription of the business glossary term.
    public var shortDescription: Swift.String?
    /// The status of the business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The relations of the business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?
    /// The timestamp of when the business glossary term was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the business glossary term.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetGlossaryTermOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGroupProfileInput {

    static func urlPathProvider(_ value: GetGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = value.groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

public struct GetGroupProfileInput {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

extension GetGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension GetGroupProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetGroupProfileOutput {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    public var domainId: Swift.String?
    /// The name of the group for which the specified group profile exists.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The identifier of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

enum GetGroupProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetIamPortalLoginUrlInput {

    static func urlPathProvider(_ value: GetIamPortalLoginUrlInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/get-portal-login-url"
    }
}

public struct GetIamPortalLoginUrlInput {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
    }
}

extension GetIamPortalLoginUrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetIamPortalLoginUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIamPortalLoginUrlOutput()
        value.authCodeUrl = try reader["authCodeUrl"].readIfPresent()
        value.userProfileId = try reader["userProfileId"].readIfPresent()
        return value
    }
}

public struct GetIamPortalLoginUrlOutput {
    /// The data portal URL of the specified Amazon DataZone domain.
    public var authCodeUrl: Swift.String?
    /// The ID of the user profile.
    /// This member is required.
    public var userProfileId: Swift.String?

    public init(
        authCodeUrl: Swift.String? = nil,
        userProfileId: Swift.String? = nil
    )
    {
        self.authCodeUrl = authCodeUrl
        self.userProfileId = userProfileId
    }
}

enum GetIamPortalLoginUrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetListingInput {

    static func queryItemProvider(_ value: GetListingInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let listingRevision = value.listingRevision {
            let listingRevisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "listingRevision".urlPercentEncoding(), value: Swift.String(listingRevision).urlPercentEncoding())
            items.append(listingRevisionQueryItem)
        }
        return items
    }
}

extension GetListingInput {

    static func urlPathProvider(_ value: GetListingInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

public struct GetListingInput {
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the listing.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the listing.
    public var listingRevision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        listingRevision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.listingRevision = listingRevision
    }
}

extension GetListingOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetListingOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), listingRevision: \(Swift.String(describing: listingRevision)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension GetListingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetListingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListingOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.item = try reader["item"].readIfPresent(with: DataZoneClientTypes.ListingItem.read(from:))
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetListingOutput {
    /// The timestamp of when the listing was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the listing.
    public var createdBy: Swift.String?
    /// The description of the listing.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the listing.
    /// This member is required.
    public var id: Swift.String?
    /// The details of a listing.
    public var item: DataZoneClientTypes.ListingItem?
    /// The revision of a listing.
    /// This member is required.
    public var listingRevision: Swift.String?
    /// The name of the listing.
    public var name: Swift.String?
    /// The status of the listing.
    public var status: DataZoneClientTypes.ListingStatus?
    /// The timestamp of when the listing was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the listing.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        item: DataZoneClientTypes.ListingItem? = nil,
        listingRevision: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.item = item
        self.listingRevision = listingRevision
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetListingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetMetadataGenerationRunInput {

    static func urlPathProvider(_ value: GetMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs/\(identifier.urlPercentEncoding())"
    }
}

public struct GetMetadataGenerationRunInput {
    /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the metadata generation run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetMetadataGenerationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetadataGenerationRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.target = try reader["target"].readIfPresent(with: DataZoneClientTypes.MetadataGenerationRunTarget.read(from:))
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct GetMetadataGenerationRunOutput {
    /// The timestamp of when the metadata generation run was start.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who started the metadata generation run.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project that owns the assets for which you're running metadata generation.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of the metadata generation run.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The asset for which you're generating metadata.
    public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
    /// The type of metadata generation run.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.owningProjectId = owningProjectId
        self.status = status
        self.target = target
        self.type = type
    }
}

enum GetMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetProjectInput {

    static func urlPathProvider(_ value: GetProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

public struct GetProjectInput {
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

public struct GetProjectOutput {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The business glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// >The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the project.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

enum GetProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionGrantInput {

    static func urlPathProvider(_ value: GetSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionGrantInput {
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetSubscriptionGrantOutput {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The subscription target ID associated with the subscription grant.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant was upated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetSubscriptionGrantOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionInput {

    static func urlPathProvider(_ value: GetSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionInput {
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetSubscriptionOutput {
    /// The timestamp of when the subscription was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The retain permissions of the subscription.
    public var retainPermissions: Swift.Bool?
    /// The status of the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The details of the published asset for which the subscription grant is created.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The principal that owns the subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The ID of the subscription request.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionRequestDetailsInput {

    static func urlPathProvider(_ value: GetSubscriptionRequestDetailsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionRequestDetailsInput {
    /// The identifier of the Amazon DataZone domain in which to get the subscription request details.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request the details of which to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension GetSubscriptionRequestDetailsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionRequestDetailsOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension GetSubscriptionRequestDetailsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionRequestDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionRequestDetailsOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetSubscriptionRequestDetailsOutput {
    /// The timestamp of when the specified subscription request was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain of the subscription request.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings in the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetSubscriptionRequestDetailsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionTargetInput {

    static func urlPathProvider(_ value: GetSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

public struct GetSubscriptionTargetInput {
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

extension GetSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension GetSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct GetSubscriptionTargetOutput {
    /// The asset types associated with the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project associated with the subscription target.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of teh subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum GetSubscriptionTargetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTimeSeriesDataPointInput {

    static func queryItemProvider(_ value: GetTimeSeriesDataPointInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let formNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        return items
    }
}

extension GetTimeSeriesDataPointInput {

    static func urlPathProvider(_ value: GetTimeSeriesDataPointInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points/\(identifier.urlPercentEncoding())"
    }
}

public struct GetTimeSeriesDataPointInput {
    /// The ID of the Amazon DataZone domain that houses the asset for which you want to get the data point.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to get the data point.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to get the data point.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series form that houses the data point that you want to get.
    /// This member is required.
    public var formName: Swift.String?
    /// The ID of the data point that you want to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
        self.identifier = identifier
    }
}

extension GetTimeSeriesDataPointOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTimeSeriesDataPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTimeSeriesDataPointOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.form = try reader["form"].readIfPresent(with: DataZoneClientTypes.TimeSeriesDataPointFormOutput.read(from:))
        value.formName = try reader["formName"].readIfPresent()
        return value
    }
}

public struct GetTimeSeriesDataPointOutput {
    /// The ID of the Amazon DataZone domain that houses the asset data point that you want to get.
    public var domainId: Swift.String?
    /// The ID of the asset for which you want to get the data point.
    public var entityId: Swift.String?
    /// The type of the asset for which you want to get the data point.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The time series form that houses the data point that you want to get.
    public var form: DataZoneClientTypes.TimeSeriesDataPointFormOutput?
    /// The name of the time series form that houses the data point that you want to get.
    public var formName: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        form: DataZoneClientTypes.TimeSeriesDataPointFormOutput? = nil,
        formName: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.entityId = entityId
        self.entityType = entityType
        self.form = form
        self.formName = formName
    }
}

enum GetTimeSeriesDataPointOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetUserProfileInput {

    static func queryItemProvider(_ value: GetUserProfileInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension GetUserProfileInput {

    static func urlPathProvider(_ value: GetUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let userIdentifier = value.userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

public struct GetUserProfileInput {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user for which you want to get the user profile.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

extension GetUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct GetUserProfileOutput {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// the identifier of the Amazon DataZone domain of which you want to get the user profile.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

enum GetUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.GlossaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.GlossaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlossaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlossaryItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a business glossary.
    public struct GlossaryItem {
        /// The timestamp of when the glossary was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the glossary.
        public var createdBy: Swift.String?
        /// The business glossary description.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the glossary.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the glossary.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project that owns the business glosary.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The business glossary status.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryStatus?
        /// The timestamp of when the business glossary was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the business glossary.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {

    public enum GlossaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.GlossaryTermItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryTermItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.GlossaryTermItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlossaryTermItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlossaryTermItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.glossaryId = try reader["glossaryId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a business glossary term.
    public struct GlossaryTermItem {
        /// The timestamp of when a business glossary term was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the business glossary.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the business glossary to which the term belongs.
        /// This member is required.
        public var glossaryId: Swift.String?
        /// The identifier of the business glossary term.
        /// This member is required.
        public var id: Swift.String?
        /// The long description of the business glossary term.
        public var longDescription: Swift.String?
        /// The name of the business glossary term.
        /// This member is required.
        public var name: Swift.String?
        /// The short description of the business glossary term.
        public var shortDescription: Swift.String?
        /// The status of the business glossary term.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryTermStatus?
        /// The relations of the business glossary term.
        public var termRelations: DataZoneClientTypes.TermRelations?
        /// The timestamp of when a business glossary term was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            glossaryId: Swift.String? = nil,
            id: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryTermStatus? = nil,
            termRelations: DataZoneClientTypes.TermRelations? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {

    public enum GlossaryTermStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryTermStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.GlueRunConfigurationInput {

    static func write(value: DataZoneClientTypes.GlueRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoImportDataQualityResult"].write(value.autoImportDataQualityResult)
        try writer["dataAccessRole"].write(value.dataAccessRole)
        try writer["relationalFilterConfigurations"].writeList(value.relationalFilterConfigurations, memberWritingClosure: DataZoneClientTypes.RelationalFilterConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationInput {
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public var autoImportDataQualityResult: Swift.Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            autoImportDataQualityResult: Swift.Bool? = nil,
            dataAccessRole: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.GlueRunConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlueRunConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlueRunConfigurationOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.dataAccessRole = try reader["dataAccessRole"].readIfPresent()
        value.relationalFilterConfigurations = try reader["relationalFilterConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.RelationalFilterConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoImportDataQualityResult = try reader["autoImportDataQualityResult"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationOutput {
        /// The Amazon Web Services account ID included in the configuration details of the Amazon Web Services Glue data source.
        public var accountId: Swift.String?
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public var autoImportDataQualityResult: Swift.Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The Amazon Web Services region included in the configuration details of the Amazon Web Services Glue data source.
        public var region: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            autoImportDataQualityResult: Swift.Bool? = nil,
            dataAccessRole: Swift.String? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.GrantedEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GrantedEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "listing":
                return .listing(try reader["listing"].read(with: DataZoneClientTypes.ListingRevision.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of a listing for which a subscription is granted.
    public enum GrantedEntity {
        /// The listing for which a subscription is granted.
        case listing(DataZoneClientTypes.ListingRevision)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.GrantedEntityInput {

    static func write(value: DataZoneClientTypes.GrantedEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .listing(listing):
                try writer["listing"].write(listing, with: DataZoneClientTypes.ListingRevisionInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes {
    /// The details of a listing for which a subscription is to be granted.
    public enum GrantedEntityInput {
        /// The listing for which a subscription is to be granted.
        case listing(DataZoneClientTypes.ListingRevisionInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.GroupDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GroupDetails()
        value.groupId = try reader["groupId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a group in Amazon DataZone.
    public struct GroupDetails {
        /// The identifier of the group in Amazon DataZone.
        /// This member is required.
        public var groupId: Swift.String?

        public init(
            groupId: Swift.String? = nil
        )
        {
            self.groupId = groupId
        }
    }

}

extension DataZoneClientTypes {

    public enum GroupProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assigned
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupProfileStatus] {
            return [
                .assigned,
                .notAssigned,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.GroupProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupProfileSummary(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.GroupProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GroupProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GroupProfileSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a group profile.
    public struct GroupProfileSummary {
        /// The ID of the Amazon DataZone domain of a group profile.
        public var domainId: Swift.String?
        /// The group name of a group profile.
        public var groupName: Swift.String?
        /// The ID of a group profile.
        public var id: Swift.String?
        /// The status of a group profile.
        public var status: DataZoneClientTypes.GroupProfileStatus?

        public init(
            domainId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.GroupProfileStatus? = nil
        )
        {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }
    }

}

extension DataZoneClientTypes {

    public enum GroupSearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datazoneSsoGroup
        case ssoGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupSearchType] {
            return [
                .datazoneSsoGroup,
                .ssoGroup,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datazoneSsoGroup: return "DATAZONE_SSO_GROUP"
            case .ssoGroup: return "SSO_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.IamUserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.IamUserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.IamUserProfileDetails()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of an IAM user profile in Amazon DataZone.
    public struct IamUserProfileDetails {
        /// The ARN of an IAM user profile in Amazon DataZone.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DataZoneClientTypes.Import: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Import(revision: \(Swift.String(describing: revision)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.Import {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Import {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Import()
        value.name = try reader["name"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the import of the metadata form type.
    public struct Import {
        /// The name of the import.
        /// This member is required.
        public var name: Swift.String?
        /// The revision of the import.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            name: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.name = name
            self.revision = revision
        }
    }

}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes {

    public enum InventorySearchScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case glossary
        case glossaryTerm
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySearchScope] {
            return [
                .asset,
                .glossary,
                .glossaryTerm,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .glossary: return "GLOSSARY"
            case .glossaryTerm: return "GLOSSARY_TERM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListAssetRevisionsInput {

    static func queryItemProvider(_ value: ListAssetRevisionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssetRevisionsInput {

    static func urlPathProvider(_ value: ListAssetRevisionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

public struct ListAssetRevisionsInput {
    /// The identifier of the domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of revisions to return in a single call to ListAssetRevisions. When the number of revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var maxResults: Swift.Int?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAssetRevisionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAssetRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetRevisionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.AssetRevision.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAssetRevisionsOutput {
    /// The results of the ListAssetRevisions action.
    public var items: [DataZoneClientTypes.AssetRevision]?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.AssetRevision]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListAssetRevisionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataSourceRunActivitiesInput {

    static func queryItemProvider(_ value: ListDataSourceRunActivitiesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDataSourceRunActivitiesInput {

    static func urlPathProvider(_ value: ListDataSourceRunActivitiesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())/activities"
    }
}

public struct ListDataSourceRunActivitiesInput {
    /// The identifier of the Amazon DataZone domain in which to list data source run activities.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source run.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of activities to return in a single call to ListDataSourceRunActivities. When the number of activities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var maxResults: Swift.Int?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?
    /// The status of the data source run.
    public var status: DataZoneClientTypes.DataAssetActivityStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataAssetActivityStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ListDataSourceRunActivitiesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataSourceRunActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourceRunActivitiesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceRunActivity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDataSourceRunActivitiesOutput {
    /// The results of the ListDataSourceRunActivities action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunActivity]?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunActivity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListDataSourceRunActivitiesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataSourceRunsInput {

    static func queryItemProvider(_ value: ListDataSourceRunsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDataSourceRunsInput {

    static func urlPathProvider(_ value: ListDataSourceRunsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = value.dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

public struct ListDataSourceRunsInput {
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to invoke the ListDataSourceRuns action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of runs to return in a single call to ListDataSourceRuns. When the number of runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var maxResults: Swift.Int?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceRunStatus?

    public init(
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil
    )
    {
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ListDataSourceRunsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataSourceRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourceRunsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDataSourceRunsOutput {
    /// The results of the ListDataSourceRuns action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunSummary]?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListDataSourceRunsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension ListDataSourcesInput {

    static func queryItemProvider(_ value: ListDataSourcesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let environmentIdentifier = value.environmentIdentifier {
            let environmentIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "environmentIdentifier".urlPercentEncoding(), value: Swift.String(environmentIdentifier).urlPercentEncoding())
            items.append(environmentIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        guard let projectIdentifier = value.projectIdentifier else {
            let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let projectIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
        items.append(projectIdentifierQueryItem)
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

public struct ListDataSourcesInput {
    /// The identifier of the Amazon DataZone domain in which to list the data sources.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which to list the data sources.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of data sources to return in a single call to ListDataSources. When the number of data sources to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSources to list the next set of data sources.
    public var maxResults: Swift.Int?
    /// The name of the data source.
    public var name: Swift.String?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?
    /// The identifier of the project in which to list data sources.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.status = status
        self.type = type
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDataSourcesOutput {
    /// The results of the ListDataSources action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceSummary]?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/v2/domains"
    }
}

public struct ListDomainsInput {
    /// The maximum number of domains to return in a single call to ListDomains. When the number of domains to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomains to list the next set of domains.
    public var maxResults: Swift.Int?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDomainsOutput {
    /// The results of the ListDomains action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DomainSummary]?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEnvironmentBlueprintConfigurationsInput {

    static func queryItemProvider(_ value: ListEnvironmentBlueprintConfigurationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEnvironmentBlueprintConfigurationsInput {

    static func urlPathProvider(_ value: ListEnvironmentBlueprintConfigurationsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations"
    }
}

public struct ListEnvironmentBlueprintConfigurationsInput {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of blueprint configurations to return in a single call to ListEnvironmentBlueprintConfigurations. When the number of configurations to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var maxResults: Swift.Int?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEnvironmentBlueprintConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEnvironmentBlueprintConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentBlueprintConfigurationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentBlueprintConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEnvironmentBlueprintConfigurationsOutput {
    /// The results of the ListEnvironmentBlueprintConfigurations action.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListEnvironmentBlueprintConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEnvironmentBlueprintsInput {

    static func queryItemProvider(_ value: ListEnvironmentBlueprintsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let managed = value.managed {
            let managedQueryItem = ClientRuntime.SDKURLQueryItem(name: "managed".urlPercentEncoding(), value: Swift.String(managed).urlPercentEncoding())
            items.append(managedQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListEnvironmentBlueprintsInput {

    static func urlPathProvider(_ value: ListEnvironmentBlueprintsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints"
    }
}

public struct ListEnvironmentBlueprintsInput {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the environment blueprint is managed by Amazon DataZone.
    public var managed: Swift.Bool?
    /// The maximum number of blueprints to return in a single call to ListEnvironmentBlueprints. When the number of blueprints to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprints to list the next set of blueprints.
    public var maxResults: Swift.Int?
    /// The name of the Amazon DataZone environment.
    public var name: Swift.String?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.managed = managed
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension ListEnvironmentBlueprintsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEnvironmentBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentBlueprintsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentBlueprintSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEnvironmentBlueprintsOutput {
    /// The results of the ListEnvironmentBlueprints action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintSummary]?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListEnvironmentBlueprintsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEnvironmentProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentProfilesInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension ListEnvironmentProfilesInput {

    static func queryItemProvider(_ value: ListEnvironmentProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier {
            let environmentBlueprintIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
            items.append(environmentBlueprintIdentifierQueryItem)
        }
        if let awsAccountId = value.awsAccountId {
            let awsAccountIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
            items.append(awsAccountIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let awsAccountRegion = value.awsAccountRegion {
            let awsAccountRegionQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
            items.append(awsAccountRegionQueryItem)
        }
        if let projectIdentifier = value.projectIdentifier {
            let projectIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
            items.append(projectIdentifierQueryItem)
        }
        return items
    }
}

extension ListEnvironmentProfilesInput {

    static func urlPathProvider(_ value: ListEnvironmentProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

public struct ListEnvironmentProfilesInput {
    /// The identifier of the Amazon Web Services account where you want to list environment profiles.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environment profiles.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the blueprint that was used to create the environment profiles that you want to list.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The maximum number of environment profiles to return in a single call to ListEnvironmentProfiles. When the number of environment profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var maxResults: Swift.Int?
    ///
    public var name: Swift.String?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    public var projectIdentifier: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
    }
}

extension ListEnvironmentProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEnvironmentProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEnvironmentProfilesOutput {
    /// The results of the ListEnvironmentProfiles action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentProfileSummary]?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListEnvironmentProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier {
            let environmentBlueprintIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
            items.append(environmentBlueprintIdentifierQueryItem)
        }
        if let awsAccountId = value.awsAccountId {
            let awsAccountIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
            items.append(awsAccountIdQueryItem)
        }
        if let environmentProfileIdentifier = value.environmentProfileIdentifier {
            let environmentProfileIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "environmentProfileIdentifier".urlPercentEncoding(), value: Swift.String(environmentProfileIdentifier).urlPercentEncoding())
            items.append(environmentProfileIdentifierQueryItem)
        }
        if let provider = value.provider {
            let providerQueryItem = ClientRuntime.SDKURLQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
            items.append(providerQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let awsAccountRegion = value.awsAccountRegion {
            let awsAccountRegionQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
            items.append(awsAccountRegionQueryItem)
        }
        guard let projectIdentifier = value.projectIdentifier else {
            let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let projectIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
        items.append(projectIdentifierQueryItem)
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

public struct ListEnvironmentsInput {
    /// The identifier of the Amazon Web Services account where you want to list environments.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environments.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone blueprint.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The identifier of the environment profile.
    public var environmentProfileIdentifier: Swift.String?
    /// The maximum number of environments to return in a single call to ListEnvironments. When the number of environments to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironments to list the next set of environments.
    public var maxResults: Swift.Int?
    /// The name of the environment.
    public var name: Swift.String?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The provider of the environment.
    public var provider: Swift.String?
    /// The status of the environments that you want to list.
    public var status: DataZoneClientTypes.EnvironmentStatus?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        provider: Swift.String? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.provider = provider
        self.status = status
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEnvironmentsOutput {
    /// The results of the ListEnvironments action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentSummary]?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListMetadataGenerationRunsInput {

    static func queryItemProvider(_ value: ListMetadataGenerationRunsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListMetadataGenerationRunsInput {

    static func urlPathProvider(_ value: ListMetadataGenerationRunsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs"
    }
}

public struct ListMetadataGenerationRunsInput {
    /// The ID of the Amazon DataZone domain where you want to list metadata generation runs.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of metadata generation runs to return in a single call to ListMetadataGenerationRuns. When the number of metadata generation runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var maxResults: Swift.Int?
    /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var nextToken: Swift.String?
    /// The status of the metadata generation runs.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The type of the metadata generation runs.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.type = type
    }
}

extension ListMetadataGenerationRunsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListMetadataGenerationRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetadataGenerationRunsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.MetadataGenerationRunItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListMetadataGenerationRunsOutput {
    /// The results of the ListMetadataGenerationRuns action.
    public var items: [DataZoneClientTypes.MetadataGenerationRunItem]?
    /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.MetadataGenerationRunItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListMetadataGenerationRunsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListNotificationsInput {

    static func queryItemProvider(_ value: ListNotificationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let beforeTimestamp = value.beforeTimestamp {
            let beforeTimestampQueryItem = ClientRuntime.SDKURLQueryItem(name: "beforeTimestamp".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeTimestamp)).urlPercentEncoding())
            items.append(beforeTimestampQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let subjects = value.subjects {
            subjects.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "subjects".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
        items.append(typeQueryItem)
        if let afterTimestamp = value.afterTimestamp {
            let afterTimestampQueryItem = ClientRuntime.SDKURLQueryItem(name: "afterTimestamp".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterTimestamp)).urlPercentEncoding())
            items.append(afterTimestampQueryItem)
        }
        if let taskStatus = value.taskStatus {
            let taskStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
            items.append(taskStatusQueryItem)
        }
        return items
    }
}

extension ListNotificationsInput {

    static func urlPathProvider(_ value: ListNotificationsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/notifications"
    }
}

public struct ListNotificationsInput {
    /// The time after which you want to list notifications.
    public var afterTimestamp: ClientRuntime.Date?
    /// The time before which you want to list notifications.
    public var beforeTimestamp: ClientRuntime.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of notifications to return in a single call to ListNotifications. When the number of notifications to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListNotifications to list the next set of notifications.
    public var maxResults: Swift.Int?
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The subjects of notifications.
    public var subjects: [Swift.String]?
    /// The task status of notifications.
    public var taskStatus: DataZoneClientTypes.TaskStatus?
    /// The type of notifications.
    /// This member is required.
    public var type: DataZoneClientTypes.NotificationType?

    public init(
        afterTimestamp: ClientRuntime.Date? = nil,
        beforeTimestamp: ClientRuntime.Date? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subjects: [Swift.String]? = nil,
        taskStatus: DataZoneClientTypes.TaskStatus? = nil,
        type: DataZoneClientTypes.NotificationType? = nil
    )
    {
        self.afterTimestamp = afterTimestamp
        self.beforeTimestamp = beforeTimestamp
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subjects = subjects
        self.taskStatus = taskStatus
        self.type = type
    }
}

extension ListNotificationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notifications = try reader["notifications"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.NotificationOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListNotificationsOutput {
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The results of the ListNotifications action.
    public var notifications: [DataZoneClientTypes.NotificationOutput]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [DataZoneClientTypes.NotificationOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

enum ListNotificationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListProjectMembershipsInput {

    static func queryItemProvider(_ value: ListProjectMembershipsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListProjectMembershipsInput {

    static func urlPathProvider(_ value: ListProjectMembershipsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/memberships"
    }
}

public struct ListProjectMembershipsInput {
    /// The identifier of the Amazon DataZone domain in which you want to list project memberships.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of memberships to return in a single call to ListProjectMemberships. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var maxResults: Swift.Int?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?
    /// The identifier of the project whose memberships you want to list.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The method by which you want to sort the project memberships.
    public var sortBy: DataZoneClientTypes.SortFieldProject?
    /// The sort order of the project memberships.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortFieldProject? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension ListProjectMembershipsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListProjectMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectMembershipsOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListProjectMembershipsOutput {
    /// The members of the project.
    /// This member is required.
    public var members: [DataZoneClientTypes.ProjectMember]?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?

    public init(
        members: [DataZoneClientTypes.ProjectMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

enum ListProjectMembershipsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupIdentifier: \(Swift.String(describing: groupIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userIdentifier: \(Swift.String(describing: userIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let userIdentifier = value.userIdentifier {
            let userIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "userIdentifier".urlPercentEncoding(), value: Swift.String(userIdentifier).urlPercentEncoding())
            items.append(userIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let groupIdentifier = value.groupIdentifier {
            let groupIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "groupIdentifier".urlPercentEncoding(), value: Swift.String(groupIdentifier).urlPercentEncoding())
            items.append(groupIdentifierQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

public struct ListProjectsInput {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of a group.
    public var groupIdentifier: Swift.String?
    /// The maximum number of projects to return in a single call to ListProjects. When the number of projects to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjects to list the next set of projects.
    public var maxResults: Swift.Int?
    /// The name of the project.
    public var name: Swift.String?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone user.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userIdentifier = userIdentifier
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListProjectsOutput {
    /// The results of the ListProjects action.
    public var items: [DataZoneClientTypes.ProjectSummary]?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.ProjectSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionGrantsInput {

    static func queryItemProvider(_ value: ListSubscriptionGrantsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let environmentId = value.environmentId {
            let environmentIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            items.append(environmentIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let subscriptionTargetId = value.subscriptionTargetId {
            let subscriptionTargetIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscriptionTargetId".urlPercentEncoding(), value: Swift.String(subscriptionTargetId).urlPercentEncoding())
            items.append(subscriptionTargetIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let subscriptionId = value.subscriptionId {
            let subscriptionIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscriptionId".urlPercentEncoding(), value: Swift.String(subscriptionId).urlPercentEncoding())
            items.append(subscriptionIdQueryItem)
        }
        return items
    }
}

extension ListSubscriptionGrantsInput {

    static func urlPathProvider(_ value: ListSubscriptionGrantsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

public struct ListSubscriptionGrantsInput {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone environment.
    public var environmentId: Swift.String?
    /// The maximum number of subscription grants to return in a single call to ListSubscriptionGrants. When the number of subscription grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var maxResults: Swift.Int?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?
    /// Specifies the way of sorting the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target.
    public var subscriptionTargetId: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.subscribedListingId = subscribedListingId
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
    }
}

extension ListSubscriptionGrantsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionGrantsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionGrantSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListSubscriptionGrantsOutput {
    /// The results of the ListSubscriptionGrants action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionGrantSummary]?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionGrantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListSubscriptionGrantsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionRequestsInput {

    static func queryItemProvider(_ value: ListSubscriptionRequestsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let approverProjectId = value.approverProjectId {
            let approverProjectIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
            items.append(approverProjectIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let owningProjectId = value.owningProjectId {
            let owningProjectIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
            items.append(owningProjectIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSubscriptionRequestsInput {

    static func urlPathProvider(_ value: ListSubscriptionRequestsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

public struct ListSubscriptionRequestsInput {
    /// The identifier of the subscription request approver's project.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscription requests to return in a single call to ListSubscriptionRequests. When the number of subscription requests to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var maxResults: Swift.Int?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?
    /// The identifier of the project for the subscription requests.
    public var owningProjectId: Swift.String?
    /// Specifies the way to sort the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// Specifies the status of the subscription requests.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListingId: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
    }
}

extension ListSubscriptionRequestsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionRequestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionRequestsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionRequestSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListSubscriptionRequestsOutput {
    /// The results of the ListSubscriptionRequests action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionRequestSummary]?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionRequestSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListSubscriptionRequestsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionTargetsInput {

    static func queryItemProvider(_ value: ListSubscriptionTargetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListSubscriptionTargetsInput {

    static func urlPathProvider(_ value: ListSubscriptionTargetsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

public struct ListSubscriptionTargetsInput {
    /// The identifier of the Amazon DataZone domain where you want to list subscription targets.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment where you want to list subscription targets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of subscription targets to return in a single call to ListSubscriptionTargets. When the number of subscription targets to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var maxResults: Swift.Int?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension ListSubscriptionTargetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListSubscriptionTargetsOutput {
    /// The results of the ListSubscriptionTargets action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionTargetSummary]?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionTargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListSubscriptionTargetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionsInput {

    static func queryItemProvider(_ value: ListSubscriptionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let approverProjectId = value.approverProjectId {
            let approverProjectIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
            items.append(approverProjectIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let owningProjectId = value.owningProjectId {
            let owningProjectIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
            items.append(owningProjectIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let subscriptionRequestIdentifier = value.subscriptionRequestIdentifier {
            let subscriptionRequestIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "subscriptionRequestIdentifier".urlPercentEncoding(), value: Swift.String(subscriptionRequestIdentifier).urlPercentEncoding())
            items.append(subscriptionRequestIdentifierQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSubscriptionsInput {

    static func urlPathProvider(_ value: ListSubscriptionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions"
    }
}

public struct ListSubscriptionsInput {
    /// The identifier of the project for the subscription's approver.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscriptions to return in a single call to ListSubscriptions. When the number of subscriptions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptions to list the next set of Subscriptions.
    public var maxResults: Swift.Int?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?
    /// The identifier of the owning project.
    public var owningProjectId: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The status of the subscriptions that you want to list.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The identifier of the subscribed listing for the subscriptions that you want to list.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription request for the subscriptions that you want to list.
    public var subscriptionRequestIdentifier: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionRequestIdentifier: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
        self.subscriptionRequestIdentifier = subscriptionRequestIdentifier
    }
}

extension ListSubscriptionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListSubscriptionsOutput {
    /// The results of the ListSubscriptions action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionSummary]?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListSubscriptionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags of the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTimeSeriesDataPointsInput {

    static func queryItemProvider(_ value: ListTimeSeriesDataPointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let endedAt = value.endedAt {
            let endedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "endedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endedAt)).urlPercentEncoding())
            items.append(endedAtQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let formNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        if let startedAt = value.startedAt {
            let startedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "startedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startedAt)).urlPercentEncoding())
            items.append(startedAtQueryItem)
        }
        return items
    }
}

extension ListTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: ListTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

public struct ListTimeSeriesDataPointsInput {
    /// The ID of the Amazon DataZone domain that houses the assets for which you want to list time series data points.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The timestamp at which the data points that you wanted to list ended.
    public var endedAt: ClientRuntime.Date?
    /// The ID of the asset for which you want to list data points.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to list data points.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series data points form.
    /// This member is required.
    public var formName: Swift.String?
    /// The maximum number of data points to return in a single call to ListTimeSeriesDataPoints. When the number of data points to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var maxResults: Swift.Int?
    /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var nextToken: Swift.String?
    /// The timestamp at which the data points that you want to list started.
    public var startedAt: ClientRuntime.Date?

    public init(
        domainIdentifier: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.endedAt = endedAt
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startedAt = startedAt
    }
}

extension ListTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTimeSeriesDataPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTimeSeriesDataPointsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListTimeSeriesDataPointsOutput {
    /// The results of the ListTimeSeriesDataPoints action.
    public var items: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.ListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.AssetListing.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of a listing (aka asset published in a Amazon DataZone catalog).
    public enum ListingItem {
        /// An asset published in an Amazon DataZone catalog.
        case assetlisting(DataZoneClientTypes.AssetListing)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.ListingRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ListingRevision()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// A revision of an asset published in a Amazon DataZone catalog.
    public struct ListingRevision {
        /// An identifier of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var id: Swift.String?
        /// The details of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.ListingRevisionInput {

    static func write(value: DataZoneClientTypes.ListingRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["revision"].write(value.revision)
    }
}

extension DataZoneClientTypes {
    /// A revision to be made to an asset published in a Amazon DataZone catalog.
    public struct ListingRevisionInput {
        /// An identifier of revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var identifier: Swift.String?
        /// The details of a revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes {

    public enum ListingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ListingStatus] {
            return [
                .active,
                .creating,
                .inactive,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.Member {

    static func write(value: DataZoneClientTypes.Member?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .groupidentifier(groupidentifier):
                try writer["groupIdentifier"].write(groupidentifier)
            case let .useridentifier(useridentifier):
                try writer["userIdentifier"].write(useridentifier)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes {
    /// The details about a project member.
    public enum Member {
        /// The user ID of a project member.
        case useridentifier(Swift.String)
        /// The ID of the group of a project member.
        case groupidentifier(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.MemberDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MemberDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "user":
                return .user(try reader["user"].read(with: DataZoneClientTypes.UserDetails.read(from:)))
            case "group":
                return .group(try reader["group"].read(with: DataZoneClientTypes.GroupDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details about a project member.
    public enum MemberDetails {
        /// The user details of a project member.
        case user(DataZoneClientTypes.UserDetails)
        /// The group details of a project member.
        case group(DataZoneClientTypes.GroupDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.MetadataGenerationRunItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MetadataGenerationRunItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.MetadataGenerationRunItem()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.target = try reader["target"].readIfPresent(with: DataZoneClientTypes.MetadataGenerationRunTarget.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The metadata generation run.
    public struct MetadataGenerationRunItem {
        /// The timestamp at which the metadata generation run was created.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the metadata generation run.
        public var createdBy: Swift.String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was created.
        /// This member is required.
        public var domainId: Swift.String?
        /// The ID of the metadata generation run.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the project that owns the asset for which the metadata generation was ran.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The status of the metadata generation run.
        public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
        /// The asset for which metadata was generated.
        public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
        /// The type of the metadata generation run.
        public var type: DataZoneClientTypes.MetadataGenerationRunType?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
            target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
            type: DataZoneClientTypes.MetadataGenerationRunType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }
    }

}

extension DataZoneClientTypes {

    public enum MetadataGenerationRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case submitted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationRunStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .submitted,
                .succeeded,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.MetadataGenerationRunTarget {

    static func write(value: DataZoneClientTypes.MetadataGenerationRunTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["revision"].write(value.revision)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MetadataGenerationRunTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.MetadataGenerationRunTarget()
        value.type = try reader["type"].readIfPresent()
        value.identifier = try reader["identifier"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The asset for which metadata was generated.
    public struct MetadataGenerationRunTarget {
        /// The ID of the metadata generation run's target.
        /// This member is required.
        public var identifier: Swift.String?
        /// The revision of the asset for which metadata was generated.
        public var revision: Swift.String?
        /// The type of the asset for which metadata was generated.
        /// This member is required.
        public var type: DataZoneClientTypes.MetadataGenerationTargetType?

        public init(
            identifier: Swift.String? = nil,
            revision: Swift.String? = nil,
            type: DataZoneClientTypes.MetadataGenerationTargetType? = nil
        )
        {
            self.identifier = identifier
            self.revision = revision
            self.type = type
        }
    }

}

extension DataZoneClientTypes {

    public enum MetadataGenerationRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessDescriptions
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationRunType] {
            return [
                .businessDescriptions,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessDescriptions: return "BUSINESS_DESCRIPTIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum MetadataGenerationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationTargetType] {
            return [
                .asset,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.Model {

    static func write(value: DataZoneClientTypes.Model?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .smithy(smithy):
                try writer["smithy"].write(smithy)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "smithy":
                return .smithy(try reader["smithy"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The model of the API.
    public enum Model {
        /// Indicates the smithy model of the API.
        case smithy(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.NotificationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationOutput(creationTimestamp: \(Swift.String(describing: creationTimestamp)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), topic: \(Swift.String(describing: topic)), type: \(Swift.String(describing: type)), actionLink: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.NotificationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotificationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotificationOutput()
        value.identifier = try reader["identifier"].readIfPresent()
        value.domainIdentifier = try reader["domainIdentifier"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.topic = try reader["topic"].readIfPresent(with: DataZoneClientTypes.Topic.read(from:))
        value.title = try reader["title"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.actionLink = try reader["actionLink"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a notification generated in Amazon DataZone.
    public struct NotificationOutput {
        /// The action link included in the notification.
        /// This member is required.
        public var actionLink: Swift.String?
        /// The timestamp of when a notification was created.
        /// This member is required.
        public var creationTimestamp: ClientRuntime.Date?
        /// The identifier of a Amazon DataZone domain in which the notification exists.
        /// This member is required.
        public var domainIdentifier: Swift.String?
        /// The identifier of the notification.
        /// This member is required.
        public var identifier: Swift.String?
        /// The timestamp of when the notification was last updated.
        /// This member is required.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The message included in the notification.
        /// This member is required.
        public var message: Swift.String?
        /// The metadata included in the notification.
        public var metadata: [Swift.String:Swift.String]?
        /// The status included in the notification.
        public var status: DataZoneClientTypes.TaskStatus?
        /// The title of the notification.
        /// This member is required.
        public var title: Swift.String?
        /// The topic of the notification.
        /// This member is required.
        public var topic: DataZoneClientTypes.Topic?
        /// The type of the notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationType?

        public init(
            actionLink: Swift.String? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            domainIdentifier: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            status: DataZoneClientTypes.TaskStatus? = nil,
            title: Swift.String? = nil,
            topic: DataZoneClientTypes.Topic? = nil,
            type: DataZoneClientTypes.NotificationType? = nil
        )
        {
            self.actionLink = actionLink
            self.creationTimestamp = creationTimestamp
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.message = message
            self.metadata = metadata
            self.status = status
            self.title = title
            self.topic = topic
            self.type = type
        }
    }

}

extension DataZoneClientTypes.NotificationResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotificationResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotificationResource()
        value.type = try reader["type"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the resource mentioned in a notification.
    public struct NotificationResource {
        /// The ID of the resource mentioned in a notification.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the resource mentioned in a notification.
        public var name: Swift.String?
        /// The type of the resource mentioned in a notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationResourceType?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DataZoneClientTypes.NotificationResourceType? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension DataZoneClientTypes {

    public enum NotificationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationResourceType] {
            return [
                .project,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum NotificationRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainOwner
        case projectContributor
        case projectOwner
        case projectSubscriber
        case projectViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationRole] {
            return [
                .domainOwner,
                .projectContributor,
                .projectOwner,
                .projectSubscriber,
                .projectViewer,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainOwner: return "DOMAIN_OWNER"
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case .projectSubscriber: return "PROJECT_SUBSCRIBER"
            case .projectViewer: return "PROJECT_VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .event,
                .task,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PostTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: PostTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

extension PostTimeSeriesDataPointsInput {

    static func write(value: PostTimeSeriesDataPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["forms"].writeList(value.forms, memberWritingClosure: DataZoneClientTypes.TimeSeriesDataPointFormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct PostTimeSeriesDataPointsInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which you want to post time series data points.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to post time series data points.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to post data points.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The forms that contain the data points that you want to post.
    /// This member is required.
    public var forms: [DataZoneClientTypes.TimeSeriesDataPointFormInput]?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        forms: [DataZoneClientTypes.TimeSeriesDataPointFormInput]? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.forms = forms
    }
}

extension PostTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PostTimeSeriesDataPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostTimeSeriesDataPointsOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.forms = try reader["forms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct PostTimeSeriesDataPointsOutput {
    /// The ID of the Amazon DataZone domain in which you want to post time series data points.
    public var domainId: Swift.String?
    /// The ID of the asset for which you want to post time series data points.
    public var entityId: Swift.String?
    /// The type of the asset for which you want to post data points.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The forms that contain the data points that you have posted.
    public var forms: [DataZoneClientTypes.TimeSeriesDataPointFormOutput]?

    public init(
        domainId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        forms: [DataZoneClientTypes.TimeSeriesDataPointFormOutput]? = nil
    )
    {
        self.domainId = domainId
        self.entityId = entityId
        self.entityType = entityType
        self.forms = forms
    }
}

enum PostTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.PredictionConfiguration {

    static func write(value: DataZoneClientTypes.PredictionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessNameGeneration"].write(value.businessNameGeneration, with: DataZoneClientTypes.BusinessNameGenerationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.PredictionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.PredictionConfiguration()
        value.businessNameGeneration = try reader["businessNameGeneration"].readIfPresent(with: DataZoneClientTypes.BusinessNameGenerationConfiguration.read(from:))
        return value
    }
}

extension DataZoneClientTypes {
    /// The configuration of the prediction.
    public struct PredictionConfiguration {
        /// The business name generation mechanism.
        public var businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration?

        public init(
            businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration? = nil
        )
        {
            self.businessNameGeneration = businessNameGeneration
        }
    }

}

extension DataZoneClientTypes.ProjectDeletionError {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectDeletionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectDeletionError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public struct ProjectDeletionError {
        /// The code of the project deletion error.
        public var code: Swift.String?
        /// The message of the project deletion error.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension DataZoneClientTypes.ProjectMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectMember()
        value.memberDetails = try reader["memberDetails"].readIfPresent(with: DataZoneClientTypes.MemberDetails.read(from:))
        value.designation = try reader["designation"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a project member.
    public struct ProjectMember {
        /// The designated role of a project member.
        /// This member is required.
        public var designation: DataZoneClientTypes.UserDesignation?
        /// The membership details of a project member.
        /// This member is required.
        public var memberDetails: DataZoneClientTypes.MemberDetails?

        public init(
            designation: DataZoneClientTypes.UserDesignation? = nil,
            memberDetails: DataZoneClientTypes.MemberDetails? = nil
        )
        {
            self.designation = designation
            self.memberDetails = memberDetails
        }
    }

}

extension DataZoneClientTypes {

    public enum ProjectStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectStatus] {
            return [
                .active,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), failureReasons: \(Swift.String(describing: failureReasons)), id: \(Swift.String(describing: id)), projectStatus: \(Swift.String(describing: projectStatus)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a Amazon DataZone project.
    public struct ProjectSummary {
        /// The timestamp of when a project was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the project.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of a project.
        public var description: Swift.String?
        /// The identifier of a Amazon DataZone domain where the project exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
        /// The identifier of a project.
        /// This member is required.
        public var id: Swift.String?
        /// The name of a project.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the project.
        public var projectStatus: DataZoneClientTypes.ProjectStatus?
        /// The timestamp of when the project was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectStatus: DataZoneClientTypes.ProjectStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.failureReasons = failureReasons
            self.id = id
            self.name = name
            self.projectStatus = projectStatus
            self.updatedAt = updatedAt
        }
    }

}

extension DataZoneClientTypes.ProvisioningProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProvisioningProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cloudFormation":
                return .cloudformation(try reader["cloudFormation"].read(with: DataZoneClientTypes.CloudFormationProperties.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The provisioning properties of an environment blueprint.
    public enum ProvisioningProperties {
        /// The cloud formation properties included as part of the provisioning properties of an environment blueprint.
        case cloudformation(DataZoneClientTypes.CloudFormationProperties)
        case sdkUnknown(Swift.String)
    }

}

extension PutEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: PutEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

extension PutEnvironmentBlueprintConfigurationInput {

    static func write(value: PutEnvironmentBlueprintConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabledRegions"].writeList(value.enabledRegions, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAccessRoleArn"].write(value.manageAccessRoleArn)
        try writer["provisioningRoleArn"].write(value.provisioningRoleArn)
        try writer["regionalParameters"].writeMap(value.regionalParameters, valueWritingClosure: mapWritingClosure(valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct PutEnvironmentBlueprintConfigurationInput {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    /// This member is required.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?

    public init(
        domainIdentifier: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.enabledRegions = enabledRegions
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
    }
}

extension PutEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutEnvironmentBlueprintConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEnvironmentBlueprintConfigurationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.domainId = try reader["domainId"].readIfPresent()
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: mapReadingClosure(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct PutEnvironmentBlueprintConfigurationOutput {
    /// The timestamp of when the environment blueprint was created.
    public var createdAt: ClientRuntime.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The timestamp of when the environment blueprint was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

enum PutEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.RecommendationConfiguration {

    static func write(value: DataZoneClientTypes.RecommendationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableBusinessNameGeneration"].write(value.enableBusinessNameGeneration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RecommendationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RecommendationConfiguration()
        value.enableBusinessNameGeneration = try reader["enableBusinessNameGeneration"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public struct RecommendationConfiguration {
        /// Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
        public var enableBusinessNameGeneration: Swift.Bool?

        public init(
            enableBusinessNameGeneration: Swift.Bool? = nil
        )
        {
            self.enableBusinessNameGeneration = enableBusinessNameGeneration
        }
    }

}

extension DataZoneClientTypes.RedshiftClusterStorage {

    static func write(value: DataZoneClientTypes.RedshiftClusterStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusterName"].write(value.clusterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftClusterStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftClusterStorage()
        value.clusterName = try reader["clusterName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift cluster storage.
    public struct RedshiftClusterStorage {
        /// The name of an Amazon Redshift cluster.
        /// This member is required.
        public var clusterName: Swift.String?

        public init(
            clusterName: Swift.String? = nil
        )
        {
            self.clusterName = clusterName
        }
    }

}

extension DataZoneClientTypes.RedshiftCredentialConfiguration {

    static func write(value: DataZoneClientTypes.RedshiftCredentialConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretManagerArn"].write(value.secretManagerArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftCredentialConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftCredentialConfiguration()
        value.secretManagerArn = try reader["secretManagerArn"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the credentials required to access an Amazon Redshift cluster.
    public struct RedshiftCredentialConfiguration {
        /// The ARN of a secret manager for an Amazon Redshift cluster.
        /// This member is required.
        public var secretManagerArn: Swift.String?

        public init(
            secretManagerArn: Swift.String? = nil
        )
        {
            self.secretManagerArn = secretManagerArn
        }
    }

}

extension DataZoneClientTypes.RedshiftRunConfigurationInput {

    static func write(value: DataZoneClientTypes.RedshiftRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataAccessRole"].write(value.dataAccessRole)
        try writer["redshiftCredentialConfiguration"].write(value.redshiftCredentialConfiguration, with: DataZoneClientTypes.RedshiftCredentialConfiguration.write(value:to:))
        try writer["redshiftStorage"].write(value.redshiftStorage, with: DataZoneClientTypes.RedshiftStorage.write(value:to:))
        try writer["relationalFilterConfigurations"].writeList(value.relationalFilterConfigurations, memberWritingClosure: DataZoneClientTypes.RelationalFilterConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationInput {
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.RedshiftRunConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftRunConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftRunConfigurationOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.dataAccessRole = try reader["dataAccessRole"].readIfPresent()
        value.relationalFilterConfigurations = try reader["relationalFilterConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.RelationalFilterConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.redshiftCredentialConfiguration = try reader["redshiftCredentialConfiguration"].readIfPresent(with: DataZoneClientTypes.RedshiftCredentialConfiguration.read(from:))
        value.redshiftStorage = try reader["redshiftStorage"].readIfPresent(with: DataZoneClientTypes.RedshiftStorage.read(from:))
        return value
    }
}

extension DataZoneClientTypes {
    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationOutput {
        /// The ID of the Amazon Web Services account included in the configuration details of the Amazon Redshift data source.
        public var accountId: Swift.String?
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The Amazon Web Services region included in the configuration details of the Amazon Redshift data source.
        public var region: Swift.String?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }

}

extension DataZoneClientTypes.RedshiftServerlessStorage {

    static func write(value: DataZoneClientTypes.RedshiftServerlessStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workgroupName"].write(value.workgroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftServerlessStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftServerlessStorage()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift Serverless workgroup storage.
    public struct RedshiftServerlessStorage {
        /// The name of the Amazon Redshift Serverless workgroup.
        /// This member is required.
        public var workgroupName: Swift.String?

        public init(
            workgroupName: Swift.String? = nil
        )
        {
            self.workgroupName = workgroupName
        }
    }

}

extension DataZoneClientTypes.RedshiftStorage {

    static func write(value: DataZoneClientTypes.RedshiftStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .redshiftclustersource(redshiftclustersource):
                try writer["redshiftClusterSource"].write(redshiftclustersource, with: DataZoneClientTypes.RedshiftClusterStorage.write(value:to:))
            case let .redshiftserverlesssource(redshiftserverlesssource):
                try writer["redshiftServerlessSource"].write(redshiftserverlesssource, with: DataZoneClientTypes.RedshiftServerlessStorage.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "redshiftClusterSource":
                return .redshiftclustersource(try reader["redshiftClusterSource"].read(with: DataZoneClientTypes.RedshiftClusterStorage.read(from:)))
            case "redshiftServerlessSource":
                return .redshiftserverlesssource(try reader["redshiftServerlessSource"].read(with: DataZoneClientTypes.RedshiftServerlessStorage.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
    public enum RedshiftStorage {
        /// The details of the Amazon Redshift cluster source.
        case redshiftclustersource(DataZoneClientTypes.RedshiftClusterStorage)
        /// The details of the Amazon Redshift Serverless workgroup source.
        case redshiftserverlesssource(DataZoneClientTypes.RedshiftServerlessStorage)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.RejectChoice {

    static func write(value: DataZoneClientTypes.RejectChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["predictionChoices"].writeList(value.predictionChoices, memberWritingClosure: Swift.Int.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["predictionTarget"].write(value.predictionTarget)
    }
}

extension DataZoneClientTypes {
    /// The details of the automatically generated business metadata that is rejected.
    public struct RejectChoice {
        /// Specifies the the automatically generated business metadata that can be rejected.
        public var predictionChoices: [Swift.Int]?
        /// Specifies the target (for example, a column name) where a prediction can be rejected.
        /// This member is required.
        public var predictionTarget: Swift.String?

        public init(
            predictionChoices: [Swift.Int]? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.predictionChoices = predictionChoices
            self.predictionTarget = predictionTarget
        }
    }

}

extension RejectPredictionsInput {

    static func queryItemProvider(_ value: RejectPredictionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = ClientRuntime.SDKURLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension RejectPredictionsInput {

    static func urlPathProvider(_ value: RejectPredictionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/reject-predictions"
    }
}

extension RejectPredictionsInput {

    static func write(value: RejectPredictionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["rejectChoices"].writeList(value.rejectChoices, memberWritingClosure: DataZoneClientTypes.RejectChoice.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rejectRule"].write(value.rejectRule, with: DataZoneClientTypes.RejectRule.write(value:to:))
    }
}

public struct RejectPredictionsInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the prediction.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be rejected.
    public var rejectChoices: [DataZoneClientTypes.RejectChoice]?
    /// Specifies the rule (or the conditions) under which a prediction can be rejected.
    public var rejectRule: DataZoneClientTypes.RejectRule?
    /// The revision that is to be made to the asset.
    public var revision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        rejectChoices: [DataZoneClientTypes.RejectChoice]? = nil,
        rejectRule: DataZoneClientTypes.RejectRule? = nil,
        revision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.rejectChoices = rejectChoices
        self.rejectRule = rejectRule
        self.revision = revision
    }
}

extension RejectPredictionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RejectPredictionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectPredictionsOutput()
        value.assetId = try reader["assetId"].readIfPresent()
        value.assetRevision = try reader["assetRevision"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        return value
    }
}

public struct RejectPredictionsOutput {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The revision that is to be made to the asset.
    /// This member is required.
    public var assetRevision: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        assetRevision: Swift.String? = nil,
        domainId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.assetRevision = assetRevision
        self.domainId = domainId
    }
}

enum RejectPredictionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.RejectRule {

    static func write(value: DataZoneClientTypes.RejectRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rule"].write(value.rule)
        try writer["threshold"].write(value.threshold)
    }
}

extension DataZoneClientTypes {
    /// Specifies the rule and the threshold under which a prediction can be rejected.
    public struct RejectRule {
        /// Specifies whether you want to reject the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.RejectRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be rejected.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.RejectRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }

}

extension DataZoneClientTypes {

    public enum RejectRuleBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RejectRuleBehavior] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RejectSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

extension RejectSubscriptionRequestInput {

    static func urlPathProvider(_ value: RejectSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/reject"
    }
}

extension RejectSubscriptionRequestInput {

    static func write(value: RejectSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decisionComment"].write(value.decisionComment)
    }
}

public struct RejectSubscriptionRequestInput {
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension RejectSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension RejectSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RejectSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct RejectSubscriptionRequestOutput {
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the subscription request reviewer.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum RejectSubscriptionRequestOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.RelationalFilterConfiguration {

    static func write(value: DataZoneClientTypes.RelationalFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["filterExpressions"].writeList(value.filterExpressions, memberWritingClosure: DataZoneClientTypes.FilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["schemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RelationalFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RelationalFilterConfiguration()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.filterExpressions = try reader["filterExpressions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FilterExpression.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The relational filter configuration for the data source.
    public struct RelationalFilterConfiguration {
        /// The database name specified in the relational filter configuration for the data source.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The filter expressions specified in the relational filter configuration for the data source.
        public var filterExpressions: [DataZoneClientTypes.FilterExpression]?
        /// The schema name specified in the relational filter configuration for the data source.
        public var schemaName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            filterExpressions: [DataZoneClientTypes.FilterExpression]? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.filterExpressions = filterExpressions
            self.schemaName = schemaName
        }
    }

}

extension DataZoneClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Resource()
        value.provider = try reader["provider"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of a provisioned resource of this Amazon DataZone environment.
    public struct Resource {
        /// The name of a provisioned resource of this Amazon DataZone environment.
        public var name: Swift.String?
        /// The provider of a provisioned resource of this Amazon DataZone environment.
        public var provider: Swift.String?
        /// The type of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?
        /// The value of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.provider = provider
            self.type = type
            self.value = value
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RevokeSubscriptionInput {

    static func urlPathProvider(_ value: RevokeSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/revoke"
    }
}

extension RevokeSubscriptionInput {

    static func write(value: RevokeSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["retainPermissions"].write(value.retainPermissions)
    }
}

public struct RevokeSubscriptionInput {
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.retainPermissions = retainPermissions
    }
}

extension RevokeSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RevokeSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RevokeSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct RevokeSubscriptionOutput {
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The identifier of the user who revoked the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?
    /// The status of the revoked subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The subscribed listing of the revoked subscription.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The subscribed principal of the revoked subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The identifier of the subscription request for the revoked subscription.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who revoked the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum RevokeSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.RunStatisticsForAssets {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RunStatisticsForAssets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RunStatisticsForAssets()
        value.added = try reader["added"].readIfPresent()
        value.updated = try reader["updated"].readIfPresent()
        value.unchanged = try reader["unchanged"].readIfPresent()
        value.skipped = try reader["skipped"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The asset statistics from the data source run.
    public struct RunStatisticsForAssets {
        /// The added statistic for the data source run.
        public var added: Swift.Int?
        /// The failed statistic for the data source run.
        public var failed: Swift.Int?
        /// The skipped statistic for the data source run.
        public var skipped: Swift.Int?
        /// The unchanged statistic for the data source run.
        public var unchanged: Swift.Int?
        /// The updated statistic for the data source run.
        public var updated: Swift.Int?

        public init(
            added: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            unchanged: Swift.Int? = nil,
            updated: Swift.Int? = nil
        )
        {
            self.added = added
            self.failed = failed
            self.skipped = skipped
            self.unchanged = unchanged
            self.updated = updated
        }
    }

}

extension DataZoneClientTypes.ScheduleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DataZoneClientTypes.ScheduleConfiguration {

    static func write(value: DataZoneClientTypes.ScheduleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schedule"].write(value.schedule)
        try writer["timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ScheduleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ScheduleConfiguration()
        value.timezone = try reader["timezone"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the schedule of the data source runs.
    public struct ScheduleConfiguration {
        /// The schedule of the data source runs.
        public var schedule: Swift.String?
        /// The timezone of the data source run.
        public var timezone: DataZoneClientTypes.Timezone?

        public init(
            schedule: Swift.String? = nil,
            timezone: DataZoneClientTypes.Timezone? = nil
        )
        {
            self.schedule = schedule
            self.timezone = timezone
        }
    }

}

extension SearchGroupProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchGroupProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupType: \(Swift.String(describing: groupType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchText: \"CONTENT_REDACTED\")"}
}

extension SearchGroupProfilesInput {

    static func urlPathProvider(_ value: SearchGroupProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-group-profiles"
    }
}

extension SearchGroupProfilesInput {

    static func write(value: SearchGroupProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupType"].write(value.groupType)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchText"].write(value.searchText)
    }
}

public struct SearchGroupProfilesInput {
    /// The identifier of the Amazon DataZone domain in which you want to search group profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The group type for which to search.
    /// This member is required.
    public var groupType: DataZoneClientTypes.GroupSearchType?
    /// The maximum number of results to return in a single call to SearchGroupProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupType: DataZoneClientTypes.GroupSearchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupType = groupType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
    }
}

extension SearchGroupProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchGroupProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchGroupProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.GroupProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct SearchGroupProfilesOutput {
    /// The results of the SearchGroupProfiles action.
    public var items: [DataZoneClientTypes.GroupProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.GroupProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum SearchGroupProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.SearchInItem {

    static func write(value: DataZoneClientTypes.SearchInItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
    }
}

extension DataZoneClientTypes {
    /// The details of the search.
    public struct SearchInItem {
        /// The search attribute.
        /// This member is required.
        public var attribute: Swift.String?

        public init(
            attribute: Swift.String? = nil
        )
        {
            self.attribute = attribute
        }
    }

}

extension SearchInput {

    static func urlPathProvider(_ value: SearchInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search"
    }
}

extension SearchInput {

    static func write(value: SearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: DataZoneClientTypes.SearchOutputAdditionalAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchScope"].write(value.searchScope)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

public struct SearchInput {
    /// Specifies additional attributes for the Search action.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the search filters.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to Search. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to Search to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the owning project specified for the search.
    public var owningProjectIdentifier: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// The scope of the search.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.InventorySearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way in which the search results are to be sorted.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.InventorySearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectIdentifier = owningProjectIdentifier
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

extension DataZoneClientTypes.SearchInventoryResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchInventoryResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glossaryItem":
                return .glossaryitem(try reader["glossaryItem"].read(with: DataZoneClientTypes.GlossaryItem.read(from:)))
            case "glossaryTermItem":
                return .glossarytermitem(try reader["glossaryTermItem"].read(with: DataZoneClientTypes.GlossaryTermItem.read(from:)))
            case "assetItem":
                return .assetitem(try reader["assetItem"].read(with: DataZoneClientTypes.AssetItem.read(from:)))
            case "dataProductItem":
                return .dataproductitem(try reader["dataProductItem"].read(with: DataZoneClientTypes.DataProductSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of the search results.
    public enum SearchInventoryResultItem {
        /// The glossary item included in the search results.
        case glossaryitem(DataZoneClientTypes.GlossaryItem)
        /// The glossary term item included in the search results.
        case glossarytermitem(DataZoneClientTypes.GlossaryTermItem)
        /// The asset item included in the search results.
        case assetitem(DataZoneClientTypes.AssetItem)
        /// The data product item included in the search results.
        case dataproductitem(DataZoneClientTypes.DataProductSummary)
        case sdkUnknown(Swift.String)
    }

}

extension SearchListingsInput {

    static func urlPathProvider(_ value: SearchListingsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/search"
    }
}

extension SearchListingsInput {

    static func write(value: SearchListingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: DataZoneClientTypes.SearchOutputAdditionalAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

public struct SearchListingsInput {
    /// Specifies additional attributes for the search.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the domain in which to search listings.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the filters for the search of listings.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to SearchListings. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchListings to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way for sorting the search results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchText = searchText
        self.sort = sort
    }
}

extension SearchListingsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchListingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchListingsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

public struct SearchListingsOutput {
    /// The results of the SearchListings action.
    public var items: [DataZoneClientTypes.SearchResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

enum SearchListingsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchInventoryResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

public struct SearchOutput {
    /// The results of the Search action.
    public var items: [DataZoneClientTypes.SearchInventoryResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchInventoryResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

extension DataZoneClientTypes {

    public enum SearchOutputAdditionalAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forms
        case timeSeriesDataPointForms
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchOutputAdditionalAttribute] {
            return [
                .forms,
                .timeSeriesDataPointForms,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forms: return "FORMS"
            case .timeSeriesDataPointForms: return "TIME_SERIES_DATA_POINT_FORMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

enum SearchOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.SearchResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.AssetListingItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of the results of the SearchListings action.
    public enum SearchResultItem {
        /// The asset listing included in the results of the SearchListings action.
        case assetlisting(DataZoneClientTypes.AssetListingItem)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SearchSort {

    static func write(value: DataZoneClientTypes.SearchSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["order"].write(value.order)
    }
}

extension DataZoneClientTypes {
    /// The details of the way to sort search results.
    public struct SearchSort {
        /// The attribute detail of the way to sort search results.
        /// This member is required.
        public var attribute: Swift.String?
        /// The order detail of the wya to sort search results.
        public var order: DataZoneClientTypes.SortOrder?

        public init(
            attribute: Swift.String? = nil,
            order: DataZoneClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension SearchTypesInput {

    static func urlPathProvider(_ value: SearchTypesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/types-search"
    }
}

extension SearchTypesInput {

    static func write(value: SearchTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["managed"].write(value.managed)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchScope"].write(value.searchScope)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

public struct SearchTypesInput {
    /// The identifier of the Amazon DataZone domain in which to invoke the SearchTypes action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The filters for the SearchTypes action.
    public var filters: DataZoneClientTypes.FilterClause?
    /// Specifies whether the search is managed.
    /// This member is required.
    public var managed: Swift.Bool?
    /// The maximum number of results to return in a single call to SearchTypes. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchTypes to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the scope of the search for types.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.TypesSearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// The specifies the way to sort the SearchTypes results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.TypesSearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.managed = managed
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

extension SearchTypesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTypesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchTypesResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

public struct SearchTypesOutput {
    /// The results of the SearchTypes action.
    public var items: [DataZoneClientTypes.SearchTypesResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchTypesResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

enum SearchTypesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.SearchTypesResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchTypesResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetTypeItem":
                return .assettypeitem(try reader["assetTypeItem"].read(with: DataZoneClientTypes.AssetTypeItem.read(from:)))
            case "formTypeItem":
                return .formtypeitem(try reader["formTypeItem"].read(with: DataZoneClientTypes.FormTypeData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of the results of the SearchTypes action.
    public enum SearchTypesResultItem {
        /// The asset type included in the results of the SearchTypes action.
        case assettypeitem(DataZoneClientTypes.AssetTypeItem)
        /// The form type included in the results of the SearchTypes action.
        case formtypeitem(DataZoneClientTypes.FormTypeData)
        case sdkUnknown(Swift.String)
    }

}

extension SearchUserProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchUserProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userType: \(Swift.String(describing: userType)), searchText: \"CONTENT_REDACTED\")"}
}

extension SearchUserProfilesInput {

    static func urlPathProvider(_ value: SearchUserProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-user-profiles"
    }
}

extension SearchUserProfilesInput {

    static func write(value: SearchUserProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchText"].write(value.searchText)
        try writer["userType"].write(value.userType)
    }
}

public struct SearchUserProfilesInput {
    /// The identifier of the Amazon DataZone domain in which you want to search user profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of results to return in a single call to SearchUserProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchUserProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the user type for the SearchUserProfiles action.
    /// This member is required.
    public var userType: DataZoneClientTypes.UserSearchType?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil,
        userType: DataZoneClientTypes.UserSearchType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
        self.userType = userType
    }
}

extension SearchUserProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchUserProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchUserProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.UserProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct SearchUserProfilesOutput {
    /// The results of the SearchUserProfiles action.
    public var items: [DataZoneClientTypes.UserProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.UserProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum SearchUserProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request has exceeded the specified service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes.SingleSignOn {

    static func write(value: DataZoneClientTypes.SingleSignOn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["userAssignment"].write(value.userAssignment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SingleSignOn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SingleSignOn()
        value.type = try reader["type"].readIfPresent()
        value.userAssignment = try reader["userAssignment"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The single sign-on details in Amazon DataZone.
    public struct SingleSignOn {
        /// The type of single sign-on in Amazon DataZone.
        public var type: DataZoneClientTypes.AuthType?
        /// The single sign-on user assignment in Amazon DataZone.
        public var userAssignment: DataZoneClientTypes.UserAssignment?

        public init(
            type: DataZoneClientTypes.AuthType? = nil,
            userAssignment: DataZoneClientTypes.UserAssignment? = nil
        )
        {
            self.type = type
            self.userAssignment = userAssignment
        }
    }

}

extension DataZoneClientTypes {

    public enum SortFieldProject: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [SortFieldProject] {
            return [
                .name,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum SortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdAt
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .createdAt,
                .updatedAt,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdAt: return "CREATED_AT"
            case .updatedAt: return "UPDATED_AT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.SsoUserProfileDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SsoUserProfileDetails(firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.SsoUserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SsoUserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SsoUserProfileDetails()
        value.username = try reader["username"].readIfPresent()
        value.firstName = try reader["firstName"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The single sign-on details of the user profile.
    public struct SsoUserProfileDetails {
        /// The first name included in the single sign-on details of the user profile.
        public var firstName: Swift.String?
        /// The last name included in the single sign-on details of the user profile.
        public var lastName: Swift.String?
        /// The username included in the single sign-on details of the user profile.
        public var username: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.firstName = firstName
            self.lastName = lastName
            self.username = username
        }
    }

}

extension StartDataSourceRunInput {

    static func urlPathProvider(_ value: StartDataSourceRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = value.dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

extension StartDataSourceRunInput {

    static func write(value: StartDataSourceRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

public struct StartDataSourceRunInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
    }
}

extension StartDataSourceRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartDataSourceRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataSourceRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.dataSourceConfigurationSnapshot = try reader["dataSourceConfigurationSnapshot"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: .dateTime)
        value.status = try reader["status"].readIfPresent()
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: .dateTime)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct StartDataSourceRunOutput {
    /// The timestamp of when data source run was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The configuration snapshot of the data source that is being run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies run statistics for assets.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when the data source run was started.
    public var startedAt: ClientRuntime.Date?
    /// The status of the data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when the data source run was stopped.
    public var stoppedAt: ClientRuntime.Date?
    /// The type of the data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when the data source run was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: ClientRuntime.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum StartDataSourceRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartMetadataGenerationRunInput {

    static func urlPathProvider(_ value: StartMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs"
    }
}

extension StartMetadataGenerationRunInput {

    static func write(value: StartMetadataGenerationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["target"].write(value.target, with: DataZoneClientTypes.MetadataGenerationRunTarget.write(value:to:))
        try writer["type"].write(value.type)
    }
}

public struct StartMetadataGenerationRunInput {
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain where you want to start a metadata generation run.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the project that owns the asset for which you want to start a metadata generation run.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The asset for which you want to start a metadata generation run.
    /// This member is required.
    public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
    /// The type of the metadata generation run.
    /// This member is required.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.owningProjectIdentifier = owningProjectIdentifier
        self.target = target
        self.type = type
    }
}

extension StartMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartMetadataGenerationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataGenerationRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct StartMetadataGenerationRunOutput {
    /// The timestamp at which the metadata generation run was started.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the user who started the metadata generation run.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the metadata generation run was started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project that owns the asset for which the metadata generation run was started.
    public var owningProjectId: Swift.String?
    /// The status of the metadata generation run.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The type of the metadata generation run.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.owningProjectId = owningProjectId
        self.status = status
        self.type = type
    }
}

enum StartMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes.SubscribedAsset {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedAsset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedAsset()
        value.assetId = try reader["assetId"].readIfPresent()
        value.assetRevision = try reader["assetRevision"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.targetName = try reader["targetName"].readIfPresent()
        value.failureCause = try reader["failureCause"].readIfPresent(with: DataZoneClientTypes.FailureCause.read(from:))
        value.grantedTimestamp = try reader["grantedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.failureTimestamp = try reader["failureTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the asset for which the subscription grant is created.
    public struct SubscribedAsset {
        /// The identifier of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetId: Swift.String?
        /// The revision of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetRevision: Swift.String?
        /// The failure cause included in the details of the asset for which the subscription grant is created.
        public var failureCause: DataZoneClientTypes.FailureCause?
        /// The failure timestamp included in the details of the asset for which the subscription grant is created.
        public var failureTimestamp: ClientRuntime.Date?
        /// The timestamp of when the subscription grant to the asset is created.
        public var grantedTimestamp: ClientRuntime.Date?
        /// The status of the asset for which the subscription grant is created.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantStatus?
        /// The target name of the asset for which the subscription grant is created.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            failureCause: DataZoneClientTypes.FailureCause? = nil,
            failureTimestamp: ClientRuntime.Date? = nil,
            grantedTimestamp: ClientRuntime.Date? = nil,
            status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.failureCause = failureCause
            self.failureTimestamp = failureTimestamp
            self.grantedTimestamp = grantedTimestamp
            self.status = status
            self.targetName = targetName
        }
    }

}

extension DataZoneClientTypes.SubscribedAssetListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedAssetListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedAssetListing()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.forms = try reader["forms"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedAssetListing {
        /// The identifier of the published asset for which the subscription grant is created.
        public var entityId: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var entityRevision: Swift.String?
        /// The type of the published asset for which the subscription grant is created.
        public var entityType: Swift.String?
        /// The forms attached to the published asset for which the subscription grant is created.
        public var forms: Swift.String?
        /// The glossary terms attached to the published asset for which the subscription grant is created.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?

        public init(
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        )
        {
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.forms = forms
            self.glossaryTerms = glossaryTerms
        }
    }

}

extension DataZoneClientTypes.SubscribedListing: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedListing(id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), name: \(Swift.String(describing: name)), ownerProjectId: \(Swift.String(describing: ownerProjectId)), ownerProjectName: \(Swift.String(describing: ownerProjectName)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.SubscribedListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedListing()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.item = try reader["item"].readIfPresent(with: DataZoneClientTypes.SubscribedListingItem.read(from:))
        value.ownerProjectId = try reader["ownerProjectId"].readIfPresent()
        value.ownerProjectName = try reader["ownerProjectName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedListing {
        /// The description of the published asset for which the subscription grant is created.
        /// This member is required.
        public var description: Swift.String?
        /// The identifier of the published asset for which the subscription grant is created.
        /// This member is required.
        public var id: Swift.String?
        /// The published asset for which the subscription grant is created.
        /// This member is required.
        public var item: DataZoneClientTypes.SubscribedListingItem?
        /// The name of the published asset for which the subscription grant is created.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project of the published asset for which the subscription grant is created.
        /// This member is required.
        public var ownerProjectId: Swift.String?
        /// The name of the project that owns the published asset for which the subscription grant is created.
        public var ownerProjectName: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var revision: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            item: DataZoneClientTypes.SubscribedListingItem? = nil,
            name: Swift.String? = nil,
            ownerProjectId: Swift.String? = nil,
            ownerProjectName: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.item = item
            self.name = name
            self.ownerProjectId = ownerProjectId
            self.ownerProjectName = ownerProjectName
            self.revision = revision
        }
    }

}

extension DataZoneClientTypes.SubscribedListingInput {

    static func write(value: DataZoneClientTypes.SubscribedListingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DataZoneClientTypes {
    /// The published asset for which the subscription grant is to be created.
    public struct SubscribedListingInput {
        /// The identifier of the published asset for which the subscription grant is to be created.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension DataZoneClientTypes.SubscribedListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.SubscribedAssetListing.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The published asset for which the subscription grant is created.
    public enum SubscribedListingItem {
        /// The asset for which the subscription grant is created.
        case assetlisting(DataZoneClientTypes.SubscribedAssetListing)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedPrincipal {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "project":
                return .project(try reader["project"].read(with: DataZoneClientTypes.SubscribedProject.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The principal that has the subscription grant for the asset.
    public enum SubscribedPrincipal {
        /// The project that has the subscription grant.
        case project(DataZoneClientTypes.SubscribedProject)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedPrincipalInput {

    static func write(value: DataZoneClientTypes.SubscribedPrincipalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .project(project):
                try writer["project"].write(project, with: DataZoneClientTypes.SubscribedProjectInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes {
    /// The principal that is to be given a subscriptiong grant.
    public enum SubscribedPrincipalInput {
        /// The project that is to be given a subscription grant.
        case project(DataZoneClientTypes.SubscribedProjectInput)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes.SubscribedProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedProject(id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.SubscribedProject {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedProject()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The project that has the subscription grant.
    public struct SubscribedProject {
        /// The identifier of the project that has the subscription grant.
        public var id: Swift.String?
        /// The name of the project that has the subscription grant.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension DataZoneClientTypes.SubscribedProjectInput {

    static func write(value: DataZoneClientTypes.SubscribedProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DataZoneClientTypes {
    /// The project that is to be given a subscription grant.
    public struct SubscribedProjectInput {
        /// The identifier of the project that is to be given a subscription grant.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension DataZoneClientTypes {

    public enum SubscriptionGrantOverallStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case grantAndRevokeFailed
        case grantFailed
        case inaccessible
        case inProgress
        case pending
        case revokeFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantOverallStatus] {
            return [
                .completed,
                .grantAndRevokeFailed,
                .grantFailed,
                .inaccessible,
                .inProgress,
                .pending,
                .revokeFailed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .grantAndRevokeFailed: return "GRANT_AND_REVOKE_FAILED"
            case .grantFailed: return "GRANT_FAILED"
            case .inaccessible: return "INACCESSIBLE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .revokeFailed: return "REVOKE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum SubscriptionGrantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case granted
        case grantFailed
        case grantInProgress
        case grantPending
        case revoked
        case revokeFailed
        case revokeInProgress
        case revokePending
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantStatus] {
            return [
                .granted,
                .grantFailed,
                .grantInProgress,
                .grantPending,
                .revoked,
                .revokeFailed,
                .revokeInProgress,
                .revokePending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .granted: return "GRANTED"
            case .grantFailed: return "GRANT_FAILED"
            case .grantInProgress: return "GRANT_IN_PROGRESS"
            case .grantPending: return "GRANT_PENDING"
            case .revoked: return "REVOKED"
            case .revokeFailed: return "REVOKE_FAILED"
            case .revokeInProgress: return "REVOKE_IN_PROGRESS"
            case .revokePending: return "REVOKE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.SubscriptionGrantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionGrantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionGrantSummary()
        value.id = try reader["id"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent()
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription grant.
    public struct SubscriptionGrantSummary {
        /// The assets included in the subscription grant.
        public var assets: [DataZoneClientTypes.SubscribedAsset]?
        /// The timestamp of when a subscription grant was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The datazone user who created the subscription grant.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription grant exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The entity to which the subscription is granted.
        /// This member is required.
        public var grantedEntity: DataZoneClientTypes.GrantedEntity?
        /// The identifier of the subscription grant.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the subscription grant.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
        /// The ID of the subscription grant.
        public var subscriptionId: Swift.String?
        /// The identifier of the target of the subscription grant.
        /// This member is required.
        public var subscriptionTargetId: Swift.String?
        /// The timestampf of when the subscription grant was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription grant.
        public var updatedBy: Swift.String?

        public init(
            assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
            subscriptionId: Swift.String? = nil,
            subscriptionTargetId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {

    public enum SubscriptionRequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionRequestStatus] {
            return [
                .accepted,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.SubscriptionRequestSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionRequestSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.SubscriptionRequestSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionRequestSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionRequestSummary()
        value.id = try reader["id"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription request.
    public struct SubscriptionRequestSummary {
        /// The timestamp of when a subscription request was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription request.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The decision comment of the subscription request.
        public var decisionComment: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription request exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription request.
        /// This member is required.
        public var id: Swift.String?
        /// The reason for the subscription request.
        /// This member is required.
        public var requestReason: Swift.String?
        /// The identifier of the subscription request reviewer.
        public var reviewerId: Swift.String?
        /// The status of the subscription request.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionRequestStatus?
        /// The listings included in the subscription request.
        /// This member is required.
        public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
        /// The principals included in the subscription request.
        /// This member is required.
        public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
        /// The timestamp of when the subscription request was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The identifier of the Amazon DataZone user who updated the subscription request.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            decisionComment: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            requestReason: Swift.String? = nil,
            reviewerId: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
            subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
            subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes {

    public enum SubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case cancelled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionStatus] {
            return [
                .approved,
                .cancelled,
                .revoked,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .cancelled: return "CANCELLED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.SubscriptionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionSummary()
        value.id = try reader["id"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription.
    public struct SubscriptionSummary {
        /// The timestamp of when the subscription was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The retain permissions included in the subscription.
        public var retainPermissions: Swift.Bool?
        /// The status of the subscription.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionStatus?
        /// The listing included in the subscription.
        /// This member is required.
        public var subscribedListing: DataZoneClientTypes.SubscribedListing?
        /// The principal included in the subscription.
        /// This member is required.
        public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
        /// The identifier of the subscription request for the subscription.
        public var subscriptionRequestId: Swift.String?
        /// The timestamp of when the subscription was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            retainPermissions: Swift.Bool? = nil,
            status: DataZoneClientTypes.SubscriptionStatus? = nil,
            subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
            subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
            subscriptionRequestId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension DataZoneClientTypes.SubscriptionTargetForm {

    static func write(value: DataZoneClientTypes.SubscriptionTargetForm?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionTargetForm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionTargetForm()
        value.formName = try reader["formName"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription target configuration.
    public struct SubscriptionTargetForm {
        /// The content of the subscription target configuration.
        /// This member is required.
        public var content: Swift.String?
        /// The form name included in the subscription target configuration.
        /// This member is required.
        public var formName: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
        }
    }

}

extension DataZoneClientTypes.SubscriptionTargetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionTargetSummary(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes.SubscriptionTargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionTargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionTargetSummary()
        value.id = try reader["id"].readIfPresent()
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.domainId = try reader["domainId"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provider = try reader["provider"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the subscription target.
    public struct SubscriptionTargetSummary {
        /// The asset types included in the subscription target.
        /// This member is required.
        public var applicableAssetTypes: [Swift.String]?
        /// The authorized principals included in the subscription target.
        /// This member is required.
        public var authorizedPrincipals: [Swift.String]?
        /// The timestamp of when the subscription target was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon DataZone user who created the subscription target.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the subscription target exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment of the subscription target.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The identifier of the subscription target.
        /// This member is required.
        public var id: Swift.String?
        /// The manage access role specified in the subscription target.
        /// This member is required.
        public var manageAccessRole: Swift.String?
        /// The name of the subscription target.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project specified in the subscription target.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the subscription target.
        /// This member is required.
        public var provider: Swift.String?
        /// The configuration of the subscription target.
        /// This member is required.
        public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
        /// The type of the subscription target.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the subscription target was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The Amazon DataZone user who updated the subscription target.
        public var updatedBy: Swift.String?

        public init(
            applicableAssetTypes: [Swift.String]? = nil,
            authorizedPrincipals: [Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            manageAccessRole: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The ARN of the resource to be tagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tags for the TagResource action.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes {

    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.TermRelations {

    static func write(value: DataZoneClientTypes.TermRelations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["classifies"].writeList(value.classifies, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["isA"].writeList(value.isa, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TermRelations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TermRelations()
        value.isa = try reader["isA"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.classifies = try reader["classifies"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the term relations.
    public struct TermRelations {
        /// The classifies of the term relations.
        public var classifies: [Swift.String]?
        /// The isA property of the term relations.
        public var isa: [Swift.String]?

        public init(
            classifies: [Swift.String]? = nil,
            isa: [Swift.String]? = nil
        )
        {
            self.classifies = classifies
            self.isa = isa
        }
    }

}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes.TimeSeriesDataPointFormInput {

    static func write(value: DataZoneClientTypes.TimeSeriesDataPointFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: .epochSeconds)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes {
    /// The time series data points form.
    public struct TimeSeriesDataPointFormInput {
        /// The content of the time series data points form.
        public var content: Swift.String?
        /// The name of the time series data points form.
        /// This member is required.
        public var formName: Swift.String?
        /// The timestamp of the time series data points form.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The ID of the type of the time series data points form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision type of the time series data points form.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.TimeSeriesDataPointFormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TimeSeriesDataPointFormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TimeSeriesDataPointFormOutput()
        value.formName = try reader["formName"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.content = try reader["content"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The time series data points form.
    public struct TimeSeriesDataPointFormOutput {
        /// The content of the time series data points form.
        public var content: Swift.String?
        /// The name of the time series data points form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the time series data points form.
        public var id: Swift.String?
        /// The timestamp of the time series data points form.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The ID of the type of the time series data points form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision type of the time series data points form.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            id: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput()
        value.formName = try reader["formName"].readIfPresent()
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.contentSummary = try reader["contentSummary"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The summary of the time series data points form.
    public struct TimeSeriesDataPointSummaryFormOutput {
        /// The content of the summary of the time series data points form.
        public var contentSummary: Swift.String?
        /// The name of the time series data points summary form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the time series data points summary form.
        public var id: Swift.String?
        /// The timestamp of the time series data points summary form.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The type ID of the time series data points summary form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The type revision of the time series data points summary form.
        public var typeRevision: Swift.String?

        public init(
            contentSummary: Swift.String? = nil,
            formName: Swift.String? = nil,
            id: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.contentSummary = contentSummary
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }

}

extension DataZoneClientTypes {

    public enum TimeSeriesEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case listing
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesEntityType] {
            return [
                .asset,
                .listing,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .listing: return "LISTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum Timezone: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case africaJohannesburg
        case americaMontreal
        case americaSaoPaulo
        case asiaBahrain
        case asiaBangkok
        case asiaCalcutta
        case asiaDubai
        case asiaHongKong
        case asiaJakarta
        case asiaKualaLumpur
        case asiaSeoul
        case asiaShanghai
        case asiaSingapore
        case asiaTaipei
        case asiaTokyo
        case australiaMelbourne
        case australiaSydney
        case canadaCentral
        case cet
        case cst6cdt
        case etcGmt
        case etcGmt0
        case etcGmtAdd0
        case etcGmtAdd1
        case etcGmtAdd10
        case etcGmtAdd11
        case etcGmtAdd12
        case etcGmtAdd2
        case etcGmtAdd3
        case etcGmtAdd4
        case etcGmtAdd5
        case etcGmtAdd6
        case etcGmtAdd7
        case etcGmtAdd8
        case etcGmtAdd9
        case etcGmtNeg0
        case etcGmtNeg1
        case etcGmtNeg10
        case etcGmtNeg11
        case etcGmtNeg12
        case etcGmtNeg13
        case etcGmtNeg14
        case etcGmtNeg2
        case etcGmtNeg3
        case etcGmtNeg4
        case etcGmtNeg5
        case etcGmtNeg6
        case etcGmtNeg7
        case etcGmtNeg8
        case etcGmtNeg9
        case europeDublin
        case europeLondon
        case europeParis
        case europeStockholm
        case europeZurich
        case israel
        case mexicoGeneral
        case mst7mdt
        case pacificAuckland
        case usCentral
        case usEastern
        case usMountain
        case usPacific
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [Timezone] {
            return [
                .africaJohannesburg,
                .americaMontreal,
                .americaSaoPaulo,
                .asiaBahrain,
                .asiaBangkok,
                .asiaCalcutta,
                .asiaDubai,
                .asiaHongKong,
                .asiaJakarta,
                .asiaKualaLumpur,
                .asiaSeoul,
                .asiaShanghai,
                .asiaSingapore,
                .asiaTaipei,
                .asiaTokyo,
                .australiaMelbourne,
                .australiaSydney,
                .canadaCentral,
                .cet,
                .cst6cdt,
                .etcGmt,
                .etcGmt0,
                .etcGmtAdd0,
                .etcGmtAdd1,
                .etcGmtAdd10,
                .etcGmtAdd11,
                .etcGmtAdd12,
                .etcGmtAdd2,
                .etcGmtAdd3,
                .etcGmtAdd4,
                .etcGmtAdd5,
                .etcGmtAdd6,
                .etcGmtAdd7,
                .etcGmtAdd8,
                .etcGmtAdd9,
                .etcGmtNeg0,
                .etcGmtNeg1,
                .etcGmtNeg10,
                .etcGmtNeg11,
                .etcGmtNeg12,
                .etcGmtNeg13,
                .etcGmtNeg14,
                .etcGmtNeg2,
                .etcGmtNeg3,
                .etcGmtNeg4,
                .etcGmtNeg5,
                .etcGmtNeg6,
                .etcGmtNeg7,
                .etcGmtNeg8,
                .etcGmtNeg9,
                .europeDublin,
                .europeLondon,
                .europeParis,
                .europeStockholm,
                .europeZurich,
                .israel,
                .mexicoGeneral,
                .mst7mdt,
                .pacificAuckland,
                .usCentral,
                .usEastern,
                .usMountain,
                .usPacific,
                .utc,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .africaJohannesburg: return "AFRICA_JOHANNESBURG"
            case .americaMontreal: return "AMERICA_MONTREAL"
            case .americaSaoPaulo: return "AMERICA_SAO_PAULO"
            case .asiaBahrain: return "ASIA_BAHRAIN"
            case .asiaBangkok: return "ASIA_BANGKOK"
            case .asiaCalcutta: return "ASIA_CALCUTTA"
            case .asiaDubai: return "ASIA_DUBAI"
            case .asiaHongKong: return "ASIA_HONG_KONG"
            case .asiaJakarta: return "ASIA_JAKARTA"
            case .asiaKualaLumpur: return "ASIA_KUALA_LUMPUR"
            case .asiaSeoul: return "ASIA_SEOUL"
            case .asiaShanghai: return "ASIA_SHANGHAI"
            case .asiaSingapore: return "ASIA_SINGAPORE"
            case .asiaTaipei: return "ASIA_TAIPEI"
            case .asiaTokyo: return "ASIA_TOKYO"
            case .australiaMelbourne: return "AUSTRALIA_MELBOURNE"
            case .australiaSydney: return "AUSTRALIA_SYDNEY"
            case .canadaCentral: return "CANADA_CENTRAL"
            case .cet: return "CET"
            case .cst6cdt: return "CST6CDT"
            case .etcGmt: return "ETC_GMT"
            case .etcGmt0: return "ETC_GMT0"
            case .etcGmtAdd0: return "ETC_GMT_ADD_0"
            case .etcGmtAdd1: return "ETC_GMT_ADD_1"
            case .etcGmtAdd10: return "ETC_GMT_ADD_10"
            case .etcGmtAdd11: return "ETC_GMT_ADD_11"
            case .etcGmtAdd12: return "ETC_GMT_ADD_12"
            case .etcGmtAdd2: return "ETC_GMT_ADD_2"
            case .etcGmtAdd3: return "ETC_GMT_ADD_3"
            case .etcGmtAdd4: return "ETC_GMT_ADD_4"
            case .etcGmtAdd5: return "ETC_GMT_ADD_5"
            case .etcGmtAdd6: return "ETC_GMT_ADD_6"
            case .etcGmtAdd7: return "ETC_GMT_ADD_7"
            case .etcGmtAdd8: return "ETC_GMT_ADD_8"
            case .etcGmtAdd9: return "ETC_GMT_ADD_9"
            case .etcGmtNeg0: return "ETC_GMT_NEG_0"
            case .etcGmtNeg1: return "ETC_GMT_NEG_1"
            case .etcGmtNeg10: return "ETC_GMT_NEG_10"
            case .etcGmtNeg11: return "ETC_GMT_NEG_11"
            case .etcGmtNeg12: return "ETC_GMT_NEG_12"
            case .etcGmtNeg13: return "ETC_GMT_NEG_13"
            case .etcGmtNeg14: return "ETC_GMT_NEG_14"
            case .etcGmtNeg2: return "ETC_GMT_NEG_2"
            case .etcGmtNeg3: return "ETC_GMT_NEG_3"
            case .etcGmtNeg4: return "ETC_GMT_NEG_4"
            case .etcGmtNeg5: return "ETC_GMT_NEG_5"
            case .etcGmtNeg6: return "ETC_GMT_NEG_6"
            case .etcGmtNeg7: return "ETC_GMT_NEG_7"
            case .etcGmtNeg8: return "ETC_GMT_NEG_8"
            case .etcGmtNeg9: return "ETC_GMT_NEG_9"
            case .europeDublin: return "EUROPE_DUBLIN"
            case .europeLondon: return "EUROPE_LONDON"
            case .europeParis: return "EUROPE_PARIS"
            case .europeStockholm: return "EUROPE_STOCKHOLM"
            case .europeZurich: return "EUROPE_ZURICH"
            case .israel: return "ISRAEL"
            case .mexicoGeneral: return "MEXICO_GENERAL"
            case .mst7mdt: return "MST7MDT"
            case .pacificAuckland: return "PACIFIC_AUCKLAND"
            case .usCentral: return "US_CENTRAL"
            case .usEastern: return "US_EASTERN"
            case .usMountain: return "US_MOUNTAIN"
            case .usPacific: return "US_PACIFIC"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.Topic {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Topic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Topic()
        value.subject = try reader["subject"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent(with: DataZoneClientTypes.NotificationResource.read(from:))
        value.role = try reader["role"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The topic of the notification.
    public struct Topic {
        /// The details of the resource mentioned in a notification.
        /// This member is required.
        public var resource: DataZoneClientTypes.NotificationResource?
        /// The role of the resource mentioned in a notification.
        /// This member is required.
        public var role: DataZoneClientTypes.NotificationRole?
        /// The subject of the resource mentioned in a notification.
        /// This member is required.
        public var subject: Swift.String?

        public init(
            resource: DataZoneClientTypes.NotificationResource? = nil,
            role: DataZoneClientTypes.NotificationRole? = nil,
            subject: Swift.String? = nil
        )
        {
            self.resource = resource
            self.role = role
            self.subject = subject
        }
    }

}

extension DataZoneClientTypes {

    public enum TypesSearchScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assetType
        case formType
        case sdkUnknown(Swift.String)

        public static var allCases: [TypesSearchScope] {
            return [
                .assetType,
                .formType,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assetType: return "ASSET_TYPE"
            case .formType: return "FORM_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You do not have permission to perform this action.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource to be untagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tag keys for the UntagResource action.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), identifier: \(Swift.String(describing: identifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetFormsInput"].writeList(value.assetFormsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.DataSourceConfigurationInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["enableSetting"].write(value.enableSetting)
        try writer["name"].write(value.name)
        try writer["publishOnImport"].write(value.publishOnImport)
        try writer["recommendation"].write(value.recommendation, with: DataZoneClientTypes.RecommendationConfiguration.write(value:to:))
        try writer["schedule"].write(value.schedule, with: DataZoneClientTypes.ScheduleConfiguration.write(value:to:))
    }
}

public struct UpdateDataSourceInput {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the domain in which to update a data source.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDataSource action.
    public var name: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.identifier = identifier
        self.name = name
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
    }
}

extension UpdateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: .dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct UpdateDataSourceOutput {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was updated.
    public var createdAt: ClientRuntime.Date?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a data source is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the environment in which a data source is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: ClientRuntime.Date?
    /// The last run error message of the data source.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The last run status of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name to be updated as part of the UpdateDataSource action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project where data source is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status to be updated as part of the UpdateDataSource action.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type to be updated as part of the UpdateDataSource action.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: ClientRuntime.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDomainInput {

    static func queryItemProvider(_ value: UpdateDomainInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdateDomainInput {

    static func urlPathProvider(_ value: UpdateDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDomainInput {

    static func write(value: UpdateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["domainExecutionRole"].write(value.domainExecutionRole)
        try writer["name"].write(value.name)
        try writer["singleSignOn"].write(value.singleSignOn, with: DataZoneClientTypes.SingleSignOn.write(value:to:))
    }
}

public struct UpdateDomainInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The ID of the Amazon Web Services domain that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The single sign-on option to be updated as part of the UpdateDomain action.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.identifier = identifier
        self.name = name
        self.singleSignOn = singleSignOn
    }
}

extension UpdateDomainOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        return value
    }
}

public struct UpdateDomainOutput {
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the timestamp of when the domain was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The single sign-on option of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.singleSignOn = singleSignOn
    }
}

enum UpdateDomainOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentInput {

    static func write(value: UpdateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

public struct UpdateEnvironmentInput {
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironment action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct UpdateEnvironmentOutput {
    /// The identifier of the Amazon Web Services account in which the environment is to be updated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which the environment is updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties to be updated as part of the UpdateEnvironment action.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The environment actions to be updated as part of the UpdateEnvironment action.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint identifier of the environment.
    public var environmentBlueprintId: Swift.String?
    /// The profile identifier of the environment.
    /// This member is required.
    public var environmentProfileId: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    public var id: Swift.String?
    /// The last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name to be updated as part of the UpdateEnvironment action.
    /// This member is required.
    public var name: Swift.String?
    /// The project identifier of the environment.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider identifier of the environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources to be updated as part of the UpdateEnvironment action.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties to be updated as part of the UpdateEnvironment action.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status to be updated as part of the UpdateEnvironment action.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when the environment was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters to be updated as part of the UpdateEnvironment action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum UpdateEnvironmentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), description: \(Swift.String(describing: description)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), userParameters: \(Swift.String(describing: userParameters)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentProfileInput {

    static func urlPathProvider(_ value: UpdateEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentProfileInput {

    static func write(value: UpdateEnvironmentProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["awsAccountRegion"].write(value.awsAccountRegion)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateEnvironmentProfileInput {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which an environment profile is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment profile that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    public var name: Swift.String?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.userParameters = userParameters
    }
}

extension UpdateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct UpdateEnvironmentProfileOutput {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment profile was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment profile is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the blueprint of the environment profile that is to be updated.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The identifier of the environment profile that is to be udpated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project of the environment profile that is to be updated.
    public var projectId: Swift.String?
    /// The timestamp of when the environment profile was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

enum UpdateEnvironmentProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryInput {

    static func urlPathProvider(_ value: UpdateGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateGlossaryInput {

    static func write(value: UpdateGlossaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
    }
}

public struct UpdateGlossaryInput {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    public var name: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.status = status
    }
}

extension UpdateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlossaryOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct UpdateGlossaryOutput {
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to update a business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

enum UpdateGlossaryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryTermInput {

    static func urlPathProvider(_ value: UpdateGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateGlossaryTermInput {

    static func write(value: UpdateGlossaryTermInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["glossaryIdentifier"].write(value.glossaryIdentifier)
        try writer["longDescription"].write(value.longDescription)
        try writer["name"].write(value.name)
        try writer["shortDescription"].write(value.shortDescription)
        try writer["status"].write(value.status)
        try writer["termRelations"].write(value.termRelations, with: DataZoneClientTypes.TermRelations.write(value:to:))
    }
}

public struct UpdateGlossaryTermInput {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    public var glossaryIdentifier: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.identifier = identifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension UpdateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension UpdateGlossaryTermOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlossaryTermOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.glossaryId = try reader["glossaryId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        return value
    }
}

public struct UpdateGlossaryTermOutput {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

enum UpdateGlossaryTermOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGroupProfileInput {

    static func urlPathProvider(_ value: UpdateGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = value.groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

extension UpdateGroupProfileInput {

    static func write(value: UpdateGroupProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

public struct UpdateGroupProfileInput {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile that is updated.
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The status of the group profile that is updated.
    /// This member is required.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.status = status
    }
}

extension UpdateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension UpdateGroupProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct UpdateGroupProfileOutput {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    public var domainId: Swift.String?
    /// The name of the group profile that is updated.
    public var groupName: Swift.String?
    /// The identifier of the group profile that is updated.
    public var id: Swift.String?
    /// The status of the group profile that is updated.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

enum UpdateGroupProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

public struct UpdateProjectInput {
    /// The description to be updated as part of the UpdateProject action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a project is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateProject action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateProject action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

public struct UpdateProjectOutput {
    /// The timestamp of when the project was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project that is to be updated.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a project is updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The glossary terms of the project that are to be updated.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the project that is to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the project.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSubscriptionGrantStatusInput {

    static func urlPathProvider(_ value: UpdateSubscriptionGrantStatusInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())/status/\(assetIdentifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionGrantStatusInput {

    static func write(value: UpdateSubscriptionGrantStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failureCause"].write(value.failureCause, with: DataZoneClientTypes.FailureCause.write(value:to:))
        try writer["status"].write(value.status)
        try writer["targetName"].write(value.targetName)
    }
}

public struct UpdateSubscriptionGrantStatusInput {
    /// The identifier of the asset the subscription grant status of which is to be updated.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureCause: DataZoneClientTypes.FailureCause?
    /// The identifier of the subscription grant the status of which is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantStatus?
    /// The target name to be updated as part of the UpdateSubscriptionGrantStatus action.
    public var targetName: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        failureCause: DataZoneClientTypes.FailureCause? = nil,
        identifier: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.failureCause = failureCause
        self.identifier = identifier
        self.status = status
        self.targetName = targetName
    }
}

extension UpdateSubscriptionGrantStatusOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSubscriptionGrantStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionGrantStatusOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct UpdateSubscriptionGrantStatusOutput {
    /// The details of the asset for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant status was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone domain user who created the subscription grant status.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The granted entity to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The identifier of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target whose subscription grant status is to be updated.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant status is to be updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription grant status.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum UpdateSubscriptionGrantStatusOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), requestReason: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionRequestInput {

    static func urlPathProvider(_ value: UpdateSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionRequestInput {

    static func write(value: UpdateSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["requestReason"].write(value.requestReason)
    }
}

public struct UpdateSubscriptionRequestInput {
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestReason: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.requestReason = requestReason
    }
}

extension UpdateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.requestReason = try reader["requestReason"].readIfPresent()
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct UpdateSubscriptionRequestOutput {
    /// The timestamp of when the subscription request was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the UpdateSubscriptionRequest action.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviews the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum UpdateSubscriptionRequestOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), identifier: \(Swift.String(describing: identifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionTargetInput {

    static func urlPathProvider(_ value: UpdateSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionTargetInput {

    static func write(value: UpdateSubscriptionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicableAssetTypes"].writeList(value.applicableAssetTypes, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizedPrincipals"].writeList(value.authorizedPrincipals, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAccessRole"].write(value.manageAccessRole)
        try writer["name"].write(value.name)
        try writer["provider"].write(value.provider)
        try writer["subscriptionTargetConfig"].writeList(value.subscriptionTargetConfig, memberWritingClosure: DataZoneClientTypes.SubscriptionTargetForm.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateSubscriptionTargetInput {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    public var authorizedPrincipals: [Swift.String]?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    public var name: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
    }
}

extension UpdateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent()
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

public struct UpdateSubscriptionTargetOutput {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when a subscription target was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which a subscription target is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

enum UpdateSubscriptionTargetOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateUserProfileInput {

    static func urlPathProvider(_ value: UpdateUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let userIdentifier = value.userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

extension UpdateUserProfileInput {

    static func write(value: UpdateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
        try writer["type"].write(value.type)
    }
}

public struct UpdateUserProfileInput {
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The status of the user profile that are to be updated.
    /// This member is required.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile that are to be updated.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user whose user profile is to be updated.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.status = status
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

extension UpdateUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct UpdateUserProfileOutput {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

enum UpdateUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataZoneClientTypes {

    public enum UserAssignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UserAssignment] {
            return [
                .automatic,
                .manual,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum UserDesignation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case projectContributor
        case projectOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [UserDesignation] {
            return [
                .projectContributor,
                .projectOwner,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.UserDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.UserDetails()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes {
    /// The user details of a project member.
    public struct UserDetails {
        /// The identifier of the Amazon DataZone user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }

}

extension DataZoneClientTypes.UserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "iam":
                return .iam(try reader["iam"].read(with: DataZoneClientTypes.IamUserProfileDetails.read(from:)))
            case "sso":
                return .sso(try reader["sso"].read(with: DataZoneClientTypes.SsoUserProfileDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes {
    /// The details of the user profile in Amazon DataZone.
    public enum UserProfileDetails {
        /// The IAM details included in the user profile details.
        case iam(DataZoneClientTypes.IamUserProfileDetails)
        /// The single sign-on details included in the user profile details.
        case sso(DataZoneClientTypes.SsoUserProfileDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DataZoneClientTypes {

    public enum UserProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case assigned
        case deactivated
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileStatus] {
            return [
                .activated,
                .assigned,
                .deactivated,
                .notAssigned,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .assigned: return "ASSIGNED"
            case .deactivated: return "DEACTIVATED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes.UserProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.UserProfileSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        return value
    }
}

extension DataZoneClientTypes {
    /// The details of the user profile.
    public struct UserProfileSummary {
        /// The details of the user profile.
        public var details: DataZoneClientTypes.UserProfileDetails?
        /// The ID of the Amazon DataZone domain of the user profile.
        public var domainId: Swift.String?
        /// The ID of the user profile.
        public var id: Swift.String?
        /// The status of the user profile.
        public var status: DataZoneClientTypes.UserProfileStatus?
        /// The type of the user profile.
        public var type: DataZoneClientTypes.UserProfileType?

        public init(
            details: DataZoneClientTypes.UserProfileDetails? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.UserProfileStatus? = nil,
            type: DataZoneClientTypes.UserProfileType? = nil
        )
        {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }
    }

}

extension DataZoneClientTypes {

    public enum UserProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileType] {
            return [
                .iam,
                .sso,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum UserSearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datazoneIamUser
        case datazoneSsoUser
        case datazoneUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSearchType] {
            return [
                .datazoneIamUser,
                .datazoneSsoUser,
                .datazoneUser,
                .ssoUser,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datazoneIamUser: return "DATAZONE_IAM_USER"
            case .datazoneSsoUser: return "DATAZONE_SSO_USER"
            case .datazoneUser: return "DATAZONE_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iamRole
        case iamUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .iamRole,
                .iamUser,
                .ssoUser,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamRole: return "IAM_ROLE"
            case .iamUser: return "IAM_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The input fails to satisfy the constraints specified by the Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
