//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAssetFilterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEnvironmentActionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEnvironmentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEnvironmentProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSubscriptionRequestOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSubscriptionTargetOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
    public struct AcceptChoice: Swift.Sendable {
        /// The edit of the prediction.
        public var editedValue: Swift.String?
        /// Specifies the prediction (aka, the automatically generated piece of metadata) that can be accepted.
        public var predictionChoice: Swift.Int?
        /// Specifies the target (for example, a column name) where a prediction can be accepted.
        /// This member is required.
        public var predictionTarget: Swift.String?

        public init(
            editedValue: Swift.String? = nil,
            predictionChoice: Swift.Int? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.editedValue = editedValue
            self.predictionChoice = predictionChoice
            self.predictionTarget = predictionTarget
        }
    }
}

extension DataZoneClientTypes.AcceptChoice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptChoice(predictionChoice: \(Swift.String(describing: predictionChoice)), predictionTarget: \(Swift.String(describing: predictionTarget)), editedValue: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The accepted asset scope.
    public struct AcceptedAssetScope: Swift.Sendable {
        /// The asset ID of the accepted asset scope.
        /// This member is required.
        public var assetId: Swift.String?
        /// The filter IDs of the accepted asset scope.
        /// This member is required.
        public var filterIds: [Swift.String]?

        public init(
            assetId: Swift.String? = nil,
            filterIds: [Swift.String]? = nil
        )
        {
            self.assetId = assetId
            self.filterIds = filterIds
        }
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is a conflict while performing this action.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by the Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes {

    public enum AcceptRuleBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptRuleBehavior] {
            return [
                .all,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies the rule and the threshold under which a prediction can be accepted.
    public struct AcceptRule: Swift.Sendable {
        /// Specifies whether you want to accept the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.AcceptRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be accepted.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.AcceptRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }
}

public struct AcceptPredictionsInput: Swift.Sendable {
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
    public var acceptChoices: [DataZoneClientTypes.AcceptChoice]?
    /// Specifies the rule (or the conditions) under which a prediction can be accepted.
    public var acceptRule: DataZoneClientTypes.AcceptRule?
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision that is to be made to the asset.
    public var revision: Swift.String?

    public init(
        acceptChoices: [DataZoneClientTypes.AcceptChoice]? = nil,
        acceptRule: DataZoneClientTypes.AcceptRule? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.acceptChoices = acceptChoices
        self.acceptRule = acceptRule
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

public struct AcceptPredictionsOutput: Swift.Sendable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The revision that is to be made to the asset.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.domainId = domainId
        self.revision = revision
    }
}

public struct AcceptSubscriptionRequestInput: Swift.Sendable {
    /// The asset scopes of the accept subscription request.
    public var assetScopes: [DataZoneClientTypes.AcceptedAssetScope]?
    /// A description that specifies the reason for accepting the specified subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain where the specified subscription request is being accepted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription request that is to be accepted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        assetScopes: [DataZoneClientTypes.AcceptedAssetScope]? = nil,
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.assetScopes = assetScopes
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension AcceptSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestInput(assetScopes: \(Swift.String(describing: assetScopes)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum SubscriptionRequestStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionRequestStatus] {
            return [
                .accepted,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The asset scope.
    public struct AssetScope: Swift.Sendable {
        /// The asset ID of the asset scope.
        /// This member is required.
        public var assetId: Swift.String?
        /// The error message of the asset scope.
        public var errorMessage: Swift.String?
        /// The filter IDs of the asset scope.
        /// This member is required.
        public var filterIds: [Swift.String]?
        /// The status of the asset scope.
        /// This member is required.
        public var status: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            filterIds: [Swift.String]? = nil,
            status: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.errorMessage = errorMessage
            self.filterIds = filterIds
            self.status = status
        }
    }
}

extension DataZoneClientTypes {

    /// Details of a glossary term attached to the inventory asset.
    public struct DetailedGlossaryTerm: Swift.Sendable {
        /// The name of a glossary term attached to the inventory asset.
        public var name: Swift.String?
        /// The shoft description of a glossary term attached to the inventory asset.
        public var shortDescription: Swift.String?

        public init(
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil
        )
        {
            self.name = name
            self.shortDescription = shortDescription
        }
    }
}

extension DataZoneClientTypes.DetailedGlossaryTerm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetailedGlossaryTerm(name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedAssetListing: Swift.Sendable {
        /// The asset scope of the subscribed asset listing.
        public var assetScope: DataZoneClientTypes.AssetScope?
        /// The identifier of the published asset for which the subscription grant is created.
        public var entityId: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var entityRevision: Swift.String?
        /// The type of the published asset for which the subscription grant is created.
        public var entityType: Swift.String?
        /// The forms attached to the published asset for which the subscription grant is created.
        public var forms: Swift.String?
        /// The glossary terms attached to the published asset for which the subscription grant is created.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?

        public init(
            assetScope: DataZoneClientTypes.AssetScope? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil
        )
        {
            self.assetScope = assetScope
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.forms = forms
            self.glossaryTerms = glossaryTerms
        }
    }
}

extension DataZoneClientTypes {

    /// The listing of the asset in a data product.
    public struct AssetInDataProductListingItem: Swift.Sendable {
        /// The entity ID of the listing of the asset in a data product.
        public var entityId: Swift.String?
        /// The entity revision of the listing of the asset in a data product.
        public var entityRevision: Swift.String?
        /// The entity type of the listing of the asset in a data product.
        public var entityType: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
        }
    }
}

extension DataZoneClientTypes {

    /// The data product listing.
    public struct SubscribedProductListing: Swift.Sendable {
        /// The data assets of the data product listing.
        public var assetListings: [DataZoneClientTypes.AssetInDataProductListingItem]?
        /// The description of the data product listing.
        public var description: Swift.String?
        /// The ID of the data product listing.
        public var entityId: Swift.String?
        /// The revision of the data product listing.
        public var entityRevision: Swift.String?
        /// The glossary terms of the data product listing.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The name of the data product listing.
        public var name: Swift.String?

        public init(
            assetListings: [DataZoneClientTypes.AssetInDataProductListingItem]? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            name: Swift.String? = nil
        )
        {
            self.assetListings = assetListings
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.glossaryTerms = glossaryTerms
            self.name = name
        }
    }
}

extension DataZoneClientTypes {

    /// The published asset for which the subscription grant is created.
    public enum SubscribedListingItem: Swift.Sendable {
        /// The asset for which the subscription grant is created.
        case assetlisting(DataZoneClientTypes.SubscribedAssetListing)
        /// The data product listing.
        case productlisting(DataZoneClientTypes.SubscribedProductListing)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The details of the published asset for which the subscription grant is created.
    public struct SubscribedListing: Swift.Sendable {
        /// The description of the published asset for which the subscription grant is created.
        /// This member is required.
        public var description: Swift.String?
        /// The identifier of the published asset for which the subscription grant is created.
        /// This member is required.
        public var id: Swift.String?
        /// The published asset for which the subscription grant is created.
        /// This member is required.
        public var item: DataZoneClientTypes.SubscribedListingItem?
        /// The name of the published asset for which the subscription grant is created.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project of the published asset for which the subscription grant is created.
        /// This member is required.
        public var ownerProjectId: Swift.String?
        /// The name of the project that owns the published asset for which the subscription grant is created.
        public var ownerProjectName: Swift.String?
        /// The revision of the published asset for which the subscription grant is created.
        public var revision: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            item: DataZoneClientTypes.SubscribedListingItem? = nil,
            name: Swift.String? = nil,
            ownerProjectId: Swift.String? = nil,
            ownerProjectName: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.item = item
            self.name = name
            self.ownerProjectId = ownerProjectId
            self.ownerProjectName = ownerProjectName
            self.revision = revision
        }
    }
}

extension DataZoneClientTypes.SubscribedListing: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedListing(id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), name: \(Swift.String(describing: name)), ownerProjectId: \(Swift.String(describing: ownerProjectId)), ownerProjectName: \(Swift.String(describing: ownerProjectName)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The project that has the subscription grant.
    public struct SubscribedProject: Swift.Sendable {
        /// The identifier of the project that has the subscription grant.
        public var id: Swift.String?
        /// The name of the project that has the subscription grant.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension DataZoneClientTypes.SubscribedProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribedProject(id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The principal that has the subscription grant for the asset.
    public enum SubscribedPrincipal: Swift.Sendable {
        /// The project that has the subscription grant.
        case project(DataZoneClientTypes.SubscribedProject)
        case sdkUnknown(Swift.String)
    }
}

public struct AcceptSubscriptionRequestOutput: Swift.Sendable {
    /// The timestamp that specifies when the subscription request was accepted.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Specifies the Amazon DataZone user that accepted the specified subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// Specifies the reason for accepting the subscription request.
    public var decisionComment: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the specified subscription request was accepted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the reason for requesting a subscription to the asset.
    /// This member is required.
    public var requestReason: Swift.String?
    /// Specifes the ID of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// Specifies the status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// Specifies the asset for which the subscription request was created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// Specifies the Amazon DataZone users who are subscribed to the asset specified in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// Specifies the timestamp when subscription request was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// Specifies the Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension AcceptSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The parameters of the console link specified as part of the environment action.
    public struct AwsConsoleLinkParameters: Swift.Sendable {
        /// The URI of the console link specified as part of the environment action.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }
}

extension DataZoneClientTypes {

    /// The parameters of the environment action.
    public enum ActionParameters: Swift.Sendable {
        /// The console link specified as part of the environment action.
        case awsconsolelink(DataZoneClientTypes.AwsConsoleLinkParameters)
        case sdkUnknown(Swift.String)
    }
}

/// The request has exceeded the specified service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DataZoneClientTypes {

    public enum DataZoneEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [DataZoneEntityType] {
            return [
                .domainUnit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainUnit: return "DOMAIN_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of the domain unit owners group.
    public struct OwnerGroupProperties: Swift.Sendable {
        /// The ID of the domain unit owners group.
        /// This member is required.
        public var groupIdentifier: Swift.String?

        public init(
            groupIdentifier: Swift.String? = nil
        )
        {
            self.groupIdentifier = groupIdentifier
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of the owner user.
    public struct OwnerUserProperties: Swift.Sendable {
        /// The ID of the owner user.
        /// This member is required.
        public var userIdentifier: Swift.String?

        public init(
            userIdentifier: Swift.String? = nil
        )
        {
            self.userIdentifier = userIdentifier
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of a domain unit's owner.
    public enum OwnerProperties: Swift.Sendable {
        /// Specifies that the domain unit owner is a user.
        case user(DataZoneClientTypes.OwnerUserProperties)
        /// Specifies that the domain unit owner is a group.
        case group(DataZoneClientTypes.OwnerGroupProperties)
        case sdkUnknown(Swift.String)
    }
}

public struct AddEntityOwnerInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the domain in which you want to add the entity owner.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity to which you want to add an owner.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of an entity.
    /// This member is required.
    public var entityType: DataZoneClientTypes.DataZoneEntityType?
    /// The owner that you want to add to the entity.
    /// This member is required.
    public var owner: DataZoneClientTypes.OwnerProperties?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.DataZoneEntityType? = nil,
        owner: DataZoneClientTypes.OwnerProperties? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.owner = owner
    }
}

public struct AddEntityOwnerOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct AddToProjectMemberPoolPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateAssetTypePolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateDomainUnitPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy of creating an environment.
    public struct Unit: Swift.Sendable {

        public init() { }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateEnvironmentProfilePolicyGrantDetail: Swift.Sendable {
        /// The ID of the domain unit.
        public var domainUnitId: Swift.String?

        public init(
            domainUnitId: Swift.String? = nil
        )
        {
            self.domainUnitId = domainUnitId
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateFormTypePolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateGlossaryPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public struct CreateProjectPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy grant is applied to child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The grant details of the override domain unit owners policy.
    public struct OverrideDomainUnitOwnersPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy is inherited by child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the override project owners policy grant.
    public struct OverrideProjectOwnersPolicyGrantDetail: Swift.Sendable {
        /// Specifies whether the policy is inherited by child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            includeChildDomainUnits: Swift.Bool? = nil
        )
        {
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the policy grant.
    public enum PolicyGrantDetail: Swift.Sendable {
        /// Specifies that this is a create domain unit policy.
        case createdomainunit(DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail)
        /// Specifies whether to override domain unit owners.
        case overridedomainunitowners(DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail)
        /// Specifies that the policy grant is to be added to the members of the project.
        case addtoprojectmemberpool(DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail)
        /// Specifies whether to override project owners.
        case overrideprojectowners(DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail)
        /// Specifies that this is a create glossary policy.
        case createglossary(DataZoneClientTypes.CreateGlossaryPolicyGrantDetail)
        /// Specifies that this is a create form type policy.
        case createformtype(DataZoneClientTypes.CreateFormTypePolicyGrantDetail)
        /// Specifies that this is a create asset type policy.
        case createassettype(DataZoneClientTypes.CreateAssetTypePolicyGrantDetail)
        /// Specifies that this is a create project policy.
        case createproject(DataZoneClientTypes.CreateProjectPolicyGrantDetail)
        /// Specifies that this is a create environment profile policy.
        case createenvironmentprofile(DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail)
        /// Specifies that this is the delegation of the create environment profile policy.
        case delegatecreateenvironmentprofile(DataZoneClientTypes.Unit)
        /// Specifies that this is a create environment policy.
        case createenvironment(DataZoneClientTypes.Unit)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum TargetEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainUnit
        case environmentBlueprintConfiguration
        case environmentProfile
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetEntityType] {
            return [
                .domainUnit,
                .environmentBlueprintConfiguration,
                .environmentProfile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainUnit: return "DOMAIN_UNIT"
            case .environmentBlueprintConfiguration: return "ENVIRONMENT_BLUEPRINT_CONFIGURATION"
            case .environmentProfile: return "ENVIRONMENT_PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum ManagedPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addToProjectMemberPool
        case createAssetType
        case createDomainUnit
        case createEnvironment
        case createEnvironmentProfile
        case createFormType
        case createGlossary
        case createProject
        case delegateCreateEnvironmentProfile
        case overrideDomainUnitOwners
        case overrideProjectOwners
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagedPolicyType] {
            return [
                .addToProjectMemberPool,
                .createAssetType,
                .createDomainUnit,
                .createEnvironment,
                .createEnvironmentProfile,
                .createFormType,
                .createGlossary,
                .createProject,
                .delegateCreateEnvironmentProfile,
                .overrideDomainUnitOwners,
                .overrideProjectOwners
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addToProjectMemberPool: return "ADD_TO_PROJECT_MEMBER_POOL"
            case .createAssetType: return "CREATE_ASSET_TYPE"
            case .createDomainUnit: return "CREATE_DOMAIN_UNIT"
            case .createEnvironment: return "CREATE_ENVIRONMENT"
            case .createEnvironmentProfile: return "CREATE_ENVIRONMENT_PROFILE"
            case .createFormType: return "CREATE_FORM_TYPE"
            case .createGlossary: return "CREATE_GLOSSARY"
            case .createProject: return "CREATE_PROJECT"
            case .delegateCreateEnvironmentProfile: return "DELEGATE_CREATE_ENVIRONMENT_PROFILE"
            case .overrideDomainUnitOwners: return "OVERRIDE_DOMAIN_UNIT_OWNERS"
            case .overrideProjectOwners: return "OVERRIDE_PROJECT_OWNERS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum DomainUnitDesignation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case owner
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainUnitDesignation] {
            return [
                .owner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .owner: return "OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The grant filter for all domain units.
    public struct AllDomainUnitsGrantFilter: Swift.Sendable {

        public init() { }
    }
}

extension DataZoneClientTypes {

    /// The grant filter for the domain unit. In the current release of Amazon DataZone, the only supported filter is the allDomainUnitsGrantFilter.
    public enum DomainUnitGrantFilter: Swift.Sendable {
        /// Specifies a grant filter containing all domain units.
        case alldomainunitsgrantfilter(DataZoneClientTypes.AllDomainUnitsGrantFilter)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The domain unit principal to whom the policy is granted.
    public struct DomainUnitPolicyGrantPrincipal: Swift.Sendable {
        /// Specifes the designation of the domain unit users.
        /// This member is required.
        public var domainUnitDesignation: DataZoneClientTypes.DomainUnitDesignation?
        /// The grant filter for the domain unit.
        public var domainUnitGrantFilter: DataZoneClientTypes.DomainUnitGrantFilter?
        /// The ID of the domain unit.
        public var domainUnitIdentifier: Swift.String?

        public init(
            domainUnitDesignation: DataZoneClientTypes.DomainUnitDesignation? = nil,
            domainUnitGrantFilter: DataZoneClientTypes.DomainUnitGrantFilter? = nil,
            domainUnitIdentifier: Swift.String? = nil
        )
        {
            self.domainUnitDesignation = domainUnitDesignation
            self.domainUnitGrantFilter = domainUnitGrantFilter
            self.domainUnitIdentifier = domainUnitIdentifier
        }
    }
}

extension DataZoneClientTypes {

    /// The group principal to whom the policy is granted.
    public enum GroupPolicyGrantPrincipal: Swift.Sendable {
        /// The ID Of the group of the group principal.
        case groupidentifier(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum ProjectDesignation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contributor
        case owner
        case projectCatalogSteward
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectDesignation] {
            return [
                .contributor,
                .owner,
                .projectCatalogSteward
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .owner: return "OWNER"
            case .projectCatalogSteward: return "PROJECT_CATALOG_STEWARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The domain unit filter of the project grant filter.
    public struct DomainUnitFilterForProject: Swift.Sendable {
        /// The domain unit ID to use in the filter.
        /// This member is required.
        public var domainUnit: Swift.String?
        /// Specifies whether to include child domain units.
        public var includeChildDomainUnits: Swift.Bool?

        public init(
            domainUnit: Swift.String? = nil,
            includeChildDomainUnits: Swift.Bool? = false
        )
        {
            self.domainUnit = domainUnit
            self.includeChildDomainUnits = includeChildDomainUnits
        }
    }
}

extension DataZoneClientTypes {

    /// The project grant filter.
    public enum ProjectGrantFilter: Swift.Sendable {
        /// The domain unit filter of the project grant filter.
        case domainunitfilter(DataZoneClientTypes.DomainUnitFilterForProject)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The project policy grant principal.
    public struct ProjectPolicyGrantPrincipal: Swift.Sendable {
        /// The project designation of the project policy grant principal.
        /// This member is required.
        public var projectDesignation: DataZoneClientTypes.ProjectDesignation?
        /// The project grant filter of the project policy grant principal.
        public var projectGrantFilter: DataZoneClientTypes.ProjectGrantFilter?
        /// The project ID of the project policy grant principal.
        public var projectIdentifier: Swift.String?

        public init(
            projectDesignation: DataZoneClientTypes.ProjectDesignation? = nil,
            projectGrantFilter: DataZoneClientTypes.ProjectGrantFilter? = nil,
            projectIdentifier: Swift.String? = nil
        )
        {
            self.projectDesignation = projectDesignation
            self.projectGrantFilter = projectGrantFilter
            self.projectIdentifier = projectIdentifier
        }
    }
}

extension DataZoneClientTypes {

    /// The all users grant filter.
    public struct AllUsersGrantFilter: Swift.Sendable {

        public init() { }
    }
}

extension DataZoneClientTypes {

    /// The user policy grant principal.
    public enum UserPolicyGrantPrincipal: Swift.Sendable {
        /// The user ID of the user policy grant principal.
        case useridentifier(Swift.String)
        /// The all users grant filter of the user policy grant principal.
        case allusersgrantfilter(DataZoneClientTypes.AllUsersGrantFilter)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The policy grant principal.
    public enum PolicyGrantPrincipal: Swift.Sendable {
        /// The user of the policy grant principal.
        case user(DataZoneClientTypes.UserPolicyGrantPrincipal)
        /// The group of the policy grant principal.
        case group(DataZoneClientTypes.GroupPolicyGrantPrincipal)
        /// The project of the policy grant principal.
        case project(DataZoneClientTypes.ProjectPolicyGrantPrincipal)
        /// The domain unit of the policy grant principal.
        case domainunit(DataZoneClientTypes.DomainUnitPolicyGrantPrincipal)
        case sdkUnknown(Swift.String)
    }
}

public struct AddPolicyGrantInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The details of the policy grant.
    /// This member is required.
    public var detail: DataZoneClientTypes.PolicyGrantDetail?
    /// The ID of the domain where you want to add a policy grant.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity (resource) to which you want to add a policy grant.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of entity (resource) to which the grant is added.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TargetEntityType?
    /// The type of policy that you want to grant.
    /// This member is required.
    public var policyType: DataZoneClientTypes.ManagedPolicyType?
    /// The principal to whom the permissions are granted.
    /// This member is required.
    public var principal: DataZoneClientTypes.PolicyGrantPrincipal?

    public init(
        clientToken: Swift.String? = nil,
        detail: DataZoneClientTypes.PolicyGrantDetail? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TargetEntityType? = nil,
        policyType: DataZoneClientTypes.ManagedPolicyType? = nil,
        principal: DataZoneClientTypes.PolicyGrantPrincipal? = nil
    )
    {
        self.clientToken = clientToken
        self.detail = detail
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.policyType = policyType
        self.principal = principal
    }
}

public struct AddPolicyGrantOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    public enum ListingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ListingStatus] {
            return [
                .active,
                .creating,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingDetails: Swift.Sendable {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingId: Swift.String?
        /// The status of an asset published in an Amazon DataZone catalog.
        /// This member is required.
        public var listingStatus: DataZoneClientTypes.ListingStatus?

        public init(
            listingId: Swift.String? = nil,
            listingStatus: DataZoneClientTypes.ListingStatus? = nil
        )
        {
            self.listingId = listingId
            self.listingStatus = listingStatus
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a metadata form.
    public struct FormInput: Swift.Sendable {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the metadata form type.
        public var typeIdentifier: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

extension DataZoneClientTypes.FormInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DataZoneClientTypes {

    /// The configuration of the business name generation.
    public struct BusinessNameGenerationConfiguration: Swift.Sendable {
        /// Specifies whether the business name generation is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }
}

extension DataZoneClientTypes {

    /// The configuration of the prediction.
    public struct PredictionConfiguration: Swift.Sendable {
        /// The business name generation mechanism.
        public var businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration?

        public init(
            businessNameGeneration: DataZoneClientTypes.BusinessNameGenerationConfiguration? = nil
        )
        {
            self.businessNameGeneration = businessNameGeneration
        }
    }
}

public struct CreateAssetInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Asset description.
    public var description: Swift.String?
    /// Amazon DataZone domain where the asset is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// Metadata forms attached to the asset.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// Glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// Asset name.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the project that owns this asset.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The unique identifier of this asset's type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of this asset's type.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.externalIdentifier = externalIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.predictionConfiguration = predictionConfiguration
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

extension CreateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of a metadata form.
    public struct FormOutput: Swift.Sendable {
        /// The content of the metadata form.
        public var content: Swift.String?
        /// The name of the metadata form.
        /// This member is required.
        public var formName: Swift.String?
        /// The name of the metadata form type.
        public var typeName: Swift.String?
        /// The revision of the metadata form type.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }
}

extension DataZoneClientTypes.FormOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormOutput(content: \(Swift.String(describing: content)), formName: \(Swift.String(describing: formName)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The summary of the time series data points form.
    public struct TimeSeriesDataPointSummaryFormOutput: Swift.Sendable {
        /// The content of the summary of the time series data points form.
        public var contentSummary: Swift.String?
        /// The name of the time series data points summary form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the time series data points summary form.
        public var id: Swift.String?
        /// The timestamp of the time series data points summary form.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The type ID of the time series data points summary form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The type revision of the time series data points summary form.
        public var typeRevision: Swift.String?

        public init(
            contentSummary: Swift.String? = nil,
            formName: Swift.String? = nil,
            id: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.contentSummary = contentSummary
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

public struct CreateAssetOutput: Swift.Sendable {
    /// The timestamp of when the asset was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user that created this asset in the catalog.
    public var createdBy: Swift.String?
    /// The description of the created asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset took place.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The Amazon DataZone user that made the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that are attached to the created asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that are attached to the created asset.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the created asset.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The details of an asset published in an Amazon DataZone catalog.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the created asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns the created asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that are attached to the created asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the created asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

extension CreateAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAssetRevisionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The revised description of the asset.
    public var description: Swift.String?
    /// The unique identifier of the domain where the asset is being revised.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms to be attached to the asset as part of asset revision.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// The glossary terms to be attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// Te revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The revision type of the asset.
    public var typeRevision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
        self.predictionConfiguration = predictionConfiguration
        self.typeRevision = typeRevision
    }
}

extension CreateAssetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAssetRevisionOutput: Swift.Sendable {
    /// The timestamp of when the asset revision occured.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who performed the asset revision.
    public var createdBy: Swift.String?
    /// The revised asset description.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the asset was revised.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external identifier of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first asset revision occured.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The Amazon DataZone user who performed the first asset revision.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms that were attached to the asset as part of the asset revision.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms that were attached to the asset as part of asset revision.
    public var glossaryTerms: [Swift.String]?
    /// The unique identifier of the asset revision.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The details of an asset published in an Amazon DataZone catalog.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The revised name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the revised project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The configuration of the automatically generated business-friendly metadata for the asset.
    public var predictionConfiguration: DataZoneClientTypes.PredictionConfiguration?
    /// The read-only metadata forms that were attached to the asset as part of the asset revision.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The identifier of the revision type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision type of the asset.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        predictionConfiguration: DataZoneClientTypes.PredictionConfiguration? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.predictionConfiguration = predictionConfiguration
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

extension CreateAssetRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetRevisionOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), predictionConfiguration: \(Swift.String(describing: predictionConfiguration)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct DeleteAssetInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the asset is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteAssetOutput: Swift.Sendable {

    public init() { }
}

public struct GetAssetInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the Amazon DataZone asset.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

public struct GetAssetOutput: Swift.Sendable {
    /// The timestamp of when the asset was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the asset.
    public var createdBy: Swift.String?
    /// The description of the Amazon DataZone asset.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain to which the asset belongs.
    /// This member is required.
    public var domainId: Swift.String?
    /// The external ID of the asset.
    public var externalIdentifier: Swift.String?
    /// The timestamp of when the first revision of the asset was created.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The Amazon DataZone user who created the first revision of the asset.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms attached to the asset.
    /// This member is required.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The business glossary terms attached to the asset.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the asset.
    /// This member is required.
    public var id: Swift.String?
    /// The latest data point that was imported into the time series form for the asset.
    public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// The listing of the asset.
    public var listing: DataZoneClientTypes.AssetListingDetails?
    /// The name of the asset.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns the asset.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The read-only metadata forms attached to the asset.
    public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The revision of the asset.
    /// This member is required.
    public var revision: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var typeIdentifier: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var typeRevision: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        externalIdentifier: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        listing: DataZoneClientTypes.AssetListingDetails? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        revision: Swift.String? = nil,
        typeIdentifier: Swift.String? = nil,
        typeRevision: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.externalIdentifier = externalIdentifier
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
        self.listing = listing
        self.name = name
        self.owningProjectId = owningProjectId
        self.readOnlyFormsOutput = readOnlyFormsOutput
        self.revision = revision
        self.typeIdentifier = typeIdentifier
        self.typeRevision = typeRevision
    }
}

extension GetAssetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), latestTimeSeriesDataPointFormsOutput: \(Swift.String(describing: latestTimeSeriesDataPointFormsOutput)), listing: \(Swift.String(describing: listing)), owningProjectId: \(Swift.String(describing: owningProjectId)), readOnlyFormsOutput: \(Swift.String(describing: readOnlyFormsOutput)), revision: \(Swift.String(describing: revision)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The column configuration of the asset filter.
    public struct ColumnFilterConfiguration: Swift.Sendable {
        /// Specifies whether to include column names.
        public var includedColumnNames: [Swift.String]?

        public init(
            includedColumnNames: [Swift.String]? = nil
        )
        {
            self.includedColumnNames = includedColumnNames
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies whether the value is equal to an expression.
    public struct EqualToExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be equal to an expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies whether the value is greater than an expression.
    public struct GreaterThanExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be greater than an expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies whether the value is greater than or equal to an expression.
    public struct GreaterThanOrEqualToExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be greater than or equal to an expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies whether values are in the expression.
    public struct InExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The values that might be in the expression.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            columnName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.columnName = columnName
            self.values = values
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that the expression is not null.
    public struct IsNotNullExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?

        public init(
            columnName: Swift.String? = nil
        )
        {
            self.columnName = columnName
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that the expression is null.
    public struct IsNullExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?

        public init(
            columnName: Swift.String? = nil
        )
        {
            self.columnName = columnName
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value is less than an expression.
    public struct LessThanExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be less than the expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value is less than or equal to an expression.
    public struct LessThanOrEqualToExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be less than or equal to an expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value is like the expression.
    public struct LikeExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might be like the expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value is not equal to the expression.
    public struct NotEqualToExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might not be equal to the expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value is not in the expression.
    public struct NotInExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might not be in the expression.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            columnName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.columnName = columnName
            self.values = values
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies that a value might be not like the expression.
    public struct NotLikeExpression: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The value that might not be like the expression.
        /// This member is required.
        public var value: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// The row filter expression.
    public enum RowFilterExpression: Swift.Sendable {
        /// The 'equal to' clause of the row filter expression.
        case equalto(DataZoneClientTypes.EqualToExpression)
        /// The 'no equal to' clause of the row filter expression.
        case notequalto(DataZoneClientTypes.NotEqualToExpression)
        /// The 'greater than' clause of the row filter expression.
        case greaterthan(DataZoneClientTypes.GreaterThanExpression)
        /// The 'less than' clause of the row filter expression.
        case lessthan(DataZoneClientTypes.LessThanExpression)
        /// The 'greater than or equal to' clause of the filter expression.
        case greaterthanorequalto(DataZoneClientTypes.GreaterThanOrEqualToExpression)
        /// The 'less than or equal to' clause of the row filter expression.
        case lessthanorequalto(DataZoneClientTypes.LessThanOrEqualToExpression)
        /// The 'is null' clause of the row filter expression.
        case isnull(DataZoneClientTypes.IsNullExpression)
        /// The 'is not null' clause of the row filter expression.
        case isnotnull(DataZoneClientTypes.IsNotNullExpression)
        /// The 'in' clause of the row filter expression.
        case `in`(DataZoneClientTypes.InExpression)
        /// The 'not in' clause of the row filter expression.
        case notin(DataZoneClientTypes.NotInExpression)
        /// The 'like' clause of the row filter expression.
        case like(DataZoneClientTypes.LikeExpression)
        /// The 'not like' clause of the row filter expression.
        case notlike(DataZoneClientTypes.NotLikeExpression)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum FilterStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalid
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterStatus] {
            return [
                .invalid,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalid: return "INVALID"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The summary of the asset filter.
    public struct AssetFilterSummary: Swift.Sendable {
        /// The ID of the data asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The timestamp at which the asset filter was created.
        public var createdAt: Foundation.Date?
        /// The description of the asset filter.
        public var description: Swift.String?
        /// The ID of the domain where the asset filter lives.
        /// This member is required.
        public var domainId: Swift.String?
        /// The effective column names of the asset filter.
        public var effectiveColumnNames: [Swift.String]?
        /// The effective row filter of the asset filter.
        public var effectiveRowFilter: Swift.String?
        /// The error message that is displayed if the action does not succeed.
        public var errorMessage: Swift.String?
        /// The ID of the asset filter.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the asset filter.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the asset filter.
        public var status: DataZoneClientTypes.FilterStatus?

        public init(
            assetId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            effectiveColumnNames: [Swift.String]? = nil,
            effectiveRowFilter: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: DataZoneClientTypes.FilterStatus? = nil
        )
        {
            self.assetId = assetId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.effectiveColumnNames = effectiveColumnNames
            self.effectiveRowFilter = effectiveRowFilter
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

extension DataZoneClientTypes.AssetFilterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetFilterSummary(assetId: \(Swift.String(describing: assetId)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), effectiveColumnNames: \(Swift.String(describing: effectiveColumnNames)), effectiveRowFilter: \(Swift.String(describing: effectiveRowFilter)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The additional attributes of an inventory asset.
    public struct AssetItemAdditionalAttributes: Swift.Sendable {
        /// The forms included in the additional attributes of an inventory asset.
        public var formsOutput: [DataZoneClientTypes.FormOutput]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
        /// The read-only forms included in the additional attributes of an inventory asset.
        public var readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]?

        public init(
            formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
            latestTimeSeriesDataPointFormsOutput: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
            readOnlyFormsOutput: [DataZoneClientTypes.FormOutput]? = nil
        )
        {
            self.formsOutput = formsOutput
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.readOnlyFormsOutput = readOnlyFormsOutput
        }
    }
}

extension DataZoneClientTypes {

    /// A Amazon DataZone inventory asset.
    public struct AssetItem: Swift.Sendable {
        /// The additional attributes of a Amazon DataZone inventory asset.
        public var additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes?
        /// The timestamp of when the Amazon DataZone inventory asset was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the inventory asset.
        public var createdBy: Swift.String?
        /// The description of an Amazon DataZone inventory asset.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the inventory asset exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The external identifier of the Amazon DataZone inventory asset.
        public var externalIdentifier: Swift.String?
        /// The timestamp of when the first revision of the inventory asset was created.
        public var firstRevisionCreatedAt: Foundation.Date?
        /// The Amazon DataZone user who created the first revision of the inventory asset.
        public var firstRevisionCreatedBy: Swift.String?
        /// The glossary terms attached to the Amazon DataZone inventory asset.
        public var glossaryTerms: [Swift.String]?
        /// the identifier of the Amazon DataZone inventory asset.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the Amazon DataZone inventory asset.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the inventory asset.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The identifier of the asset type of the specified Amazon DataZone inventory asset.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision of the inventory asset type.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetItemAdditionalAttributes? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            externalIdentifier: Swift.String? = nil,
            firstRevisionCreatedAt: Foundation.Date? = nil,
            firstRevisionCreatedBy: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.owningProjectId = owningProjectId
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

extension DataZoneClientTypes.AssetItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), owningProjectId: \(Swift.String(describing: owningProjectId)), typeIdentifier: \(Swift.String(describing: typeIdentifier)), typeRevision: \(Swift.String(describing: typeRevision)), description: \"CONTENT_REDACTED\", externalIdentifier: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// An asset published in an Amazon DataZone catalog.
    public struct AssetListing: Swift.Sendable {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public var assetId: Swift.String?
        /// The revision of an asset published in an Amazon DataZone catalog.
        public var assetRevision: Swift.String?
        /// The type of an asset published in an Amazon DataZone catalog.
        public var assetType: Swift.String?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: Foundation.Date?
        /// The metadata forms attached to an asset published in an Amazon DataZone catalog.
        public var forms: Swift.String?
        /// The glossary terms attached to an asset published in an Amazon DataZone catalog.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
        /// The identifier of the project where an asset published in an Amazon DataZone catalog exists.
        public var owningProjectId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            assetType: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetType = assetType
            self.createdAt = createdAt
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
            self.owningProjectId = owningProjectId
        }
    }
}

extension DataZoneClientTypes {

    /// Additional attributes of an inventory asset.
    public struct AssetListingItemAdditionalAttributes: Swift.Sendable {
        /// The metadata forms that form additional attributes of the metadata asset.
        public var forms: Swift.String?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public var latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?

        public init(
            forms: Swift.String? = nil,
            latestTimeSeriesDataPointForms: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil
        )
        {
            self.forms = forms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
        }
    }
}

extension DataZoneClientTypes {

    /// The details of an asset published in an Amazon DataZone catalog.
    public struct AssetListingItem: Swift.Sendable {
        /// The additional attributes of an asset published in an Amazon DataZone catalog.
        public var additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public var createdAt: Foundation.Date?
        /// The description of an asset published in an Amazon DataZone catalog.
        public var description: Swift.String?
        /// The identifier of the inventory asset.
        public var entityId: Swift.String?
        /// The revision of the inventory asset.
        public var entityRevision: Swift.String?
        /// The type of the inventory asset.
        public var entityType: Swift.String?
        /// Glossary terms attached to the inventory asset.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The Amazon DataZone user who created the listing.
        public var listingCreatedBy: Swift.String?
        /// The identifier of the listing (asset published in Amazon DataZone catalog).
        public var listingId: Swift.String?
        /// The revision of the listing (asset published in Amazon DataZone catalog).
        public var listingRevision: Swift.String?
        /// The Amazon DataZone user who updated the listing.
        public var listingUpdatedBy: Swift.String?
        /// The name of the inventory asset.
        public var name: Swift.String?
        /// The identifier of the project that owns the inventory asset.
        public var owningProjectId: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.AssetListingItemAdditionalAttributes? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            entityType: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            listingCreatedBy: Swift.String? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil,
            listingUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.glossaryTerms = glossaryTerms
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }
    }
}

extension DataZoneClientTypes.AssetListingItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetListingItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), entityId: \(Swift.String(describing: entityId)), entityRevision: \(Swift.String(describing: entityRevision)), entityType: \(Swift.String(describing: entityType)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), listingCreatedBy: \(Swift.String(describing: listingCreatedBy)), listingId: \(Swift.String(describing: listingId)), listingRevision: \(Swift.String(describing: listingRevision)), listingUpdatedBy: \(Swift.String(describing: listingUpdatedBy)), owningProjectId: \(Swift.String(describing: owningProjectId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The revision of an inventory asset.
    public struct AssetRevision: Swift.Sendable {
        /// The timestamp of when an inventory asset revison was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the asset revision.
        public var createdBy: Swift.String?
        /// The Amazon DataZone user who created the inventory asset.
        public var domainId: Swift.String?
        /// The identifier of the inventory asset revision.
        public var id: Swift.String?
        /// The revision details of the inventory asset.
        public var revision: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }
    }
}

extension DataZoneClientTypes {

    /// The name map for assets.
    public struct AssetTargetNameMap: Swift.Sendable {
        /// The identifier of the inventory asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The target name in the asset target name map.
        /// This member is required.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.targetName = targetName
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the form entry.
    public struct FormEntryInput: Swift.Sendable {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The type ID of the form entry.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

public struct CreateAssetTypeInput: Swift.Sendable {
    /// The descripton of the custom asset type.
    public var description: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the custom asset type is being created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms that are to be attached to the custom asset type.
    /// This member is required.
    public var formsInput: [Swift.String: DataZoneClientTypes.FormEntryInput]?
    /// The name of the custom asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project that is to own the custom asset type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [Swift.String: DataZoneClientTypes.FormEntryInput]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
    }
}

extension CreateAssetTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), formsInput: \(Swift.String(describing: formsInput)), name: \(Swift.String(describing: name)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the form entry.
    public struct FormEntryOutput: Swift.Sendable {
        /// Specifies whether a form entry is required.
        public var `required`: Swift.Bool?
        /// The name of the type of the form entry.
        /// This member is required.
        public var typeName: Swift.String?
        /// The type revision of the form entry.
        /// This member is required.
        public var typeRevision: Swift.String?

        public init(
            `required`: Swift.Bool? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.typeName = typeName
            self.typeRevision = typeRevision
        }
    }
}

extension DataZoneClientTypes.FormEntryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormEntryOutput(required: \(Swift.String(describing: `required`)), typeRevision: \(Swift.String(describing: typeRevision)), typeName: \"CONTENT_REDACTED\")"}
}

public struct CreateAssetTypeOutput: Swift.Sendable {
    /// The timestamp of when the asset type is to be created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who creates this custom asset type.
    public var createdBy: Swift.String?
    /// The description of the custom asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms that are attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain where the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project where the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that currently owns this asset type.
    public var owningProjectId: Swift.String?
    /// The revision of the custom asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the custom type was created.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user that created the custom asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension CreateAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

public struct DeleteAssetTypeInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the asset type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset type that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteAssetTypeOutput: Swift.Sendable {

    public init() { }
}

public struct GetAssetTypeInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset type.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the asset type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

public struct GetAssetTypeOutput: Swift.Sendable {
    /// The timestamp of when the asset type was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the asset type.
    public var createdBy: Swift.String?
    /// The description of the asset type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The metadata forms attached to the asset type.
    /// This member is required.
    public var formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]?
    /// The name of the asset type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the asset type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the Amazon DataZone project in which the asset type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the Amazon DataZone project that owns the asset type.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the asset type.
    /// This member is required.
    public var revision: Swift.String?
    /// The timestamp of when the asset type was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user that updated the asset type.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.formsOutput = formsOutput
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetAssetTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the asset type.
    public struct AssetTypeItem: Swift.Sendable {
        /// The timestamp of when the asset type was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the asset type.
        public var createdBy: Swift.String?
        /// The description of the asset type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The forms included in the details of the asset type.
        /// This member is required.
        public var formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]?
        /// The name of the asset type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain where the asset type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the Amazon DataZone project where the asset type exists.
        public var originProjectId: Swift.String?
        /// The identifier of the Amazon DataZone project that owns the asset type.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The revision of the asset type.
        /// This member is required.
        public var revision: Swift.String?
        /// The timestamp of when the asset type was updated.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the asset type.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes.AssetTypeItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetTypeItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), formsOutput: \(Swift.String(describing: formsOutput)), name: \(Swift.String(describing: name)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

public struct AssociateEnvironmentRoleInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the environment role is associated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ARN of the environment role.
    /// This member is required.
    public var environmentRoleArn: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        environmentRoleArn: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.environmentRoleArn = environmentRoleArn
    }
}

public struct AssociateEnvironmentRoleOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    public enum AuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case iamIdc
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .disabled,
                .iamIdc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .iamIdc: return "IAM_IDC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelMetadataGenerationRunInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the metadata generation run is to be cancelled.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct CancelMetadataGenerationRunOutput: Swift.Sendable {

    public init() { }
}

public struct CancelSubscriptionInput: Swift.Sendable {
    /// The unique identifier of the Amazon DataZone domain where the subscription request is being cancelled.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The unique identifier of the subscription that is being cancelled.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    public enum SubscriptionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case cancelled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionStatus] {
            return [
                .approved,
                .cancelled,
                .revoked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .cancelled: return "CANCELLED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelSubscriptionOutput: Swift.Sendable {
    /// The timestamp that specifies when the request to cancel the subscription was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Specifies the Amazon DataZone user who is cancelling the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The unique identifier of the Amazon DataZone domain where the subscription is being cancelled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether the permissions to the asset are retained after the subscription is cancelled.
    public var retainPermissions: Swift.Bool?
    /// The status of the request to cancel the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The asset to which a subscription is being cancelled.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The Amazon DataZone user who is made a subscriber to the specified asset by the subscription that is being cancelled.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The unique ID of the subscripton request for the subscription that is being cancelled.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp that specifies when the subscription was cancelled.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user that cancelled the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension DataZoneClientTypes {

    public enum ChangeAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case publish
        case unpublish
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .publish,
                .unpublish
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .unpublish: return "UNPUBLISH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// Part of the provisioning properties of the environment blueprint.
    public struct CloudFormationProperties: Swift.Sendable {
        /// The template URL of the cloud formation provisioning properties of the environment blueprint.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init(
            templateUrl: Swift.String? = nil
        )
        {
            self.templateUrl = templateUrl
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the parameters for the configurable environment action.
    public struct ConfigurableActionParameter: Swift.Sendable {
        /// The key of the configurable action parameter.
        public var key: Swift.String?
        /// The value of the configurable action parameter.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    public enum ConfigurableActionTypeAuthorization: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case https
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurableActionTypeAuthorization] {
            return [
                .https,
                .iam
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The configurable action of a Amazon DataZone environment.
    public struct ConfigurableEnvironmentAction: Swift.Sendable {
        /// The authentication type of a configurable action of a Amazon DataZone environment.
        public var auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization?
        /// The parameters of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var parameters: [DataZoneClientTypes.ConfigurableActionParameter]?
        /// The type of a configurable action in a Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?

        public init(
            auth: DataZoneClientTypes.ConfigurableActionTypeAuthorization? = nil,
            parameters: [DataZoneClientTypes.ConfigurableActionParameter]? = nil,
            type: Swift.String? = nil
        )
        {
            self.auth = auth
            self.parameters = parameters
            self.type = type
        }
    }
}

extension DataZoneClientTypes {

    public enum DataProductItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductItemType] {
            return [
                .asset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The data product.
    public struct DataProductItem: Swift.Sendable {
        /// The glossary terms of the data product.
        public var glossaryTerms: [Swift.String]?
        /// The ID of the data product.
        /// This member is required.
        public var identifier: Swift.String?
        /// The type of the data product.
        /// This member is required.
        public var itemType: DataZoneClientTypes.DataProductItemType?
        /// The revision of the data product.
        public var revision: Swift.String?

        public init(
            glossaryTerms: [Swift.String]? = nil,
            identifier: Swift.String? = nil,
            itemType: DataZoneClientTypes.DataProductItemType? = nil,
            revision: Swift.String? = nil
        )
        {
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.itemType = itemType
            self.revision = revision
        }
    }
}

public struct CreateDataProductInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the data product.
    public var description: Swift.String?
    /// The ID of the domain where the data product is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms of the data product.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// The glossary terms of the data product.
    public var glossaryTerms: [Swift.String]?
    /// The data assets of the data product.
    public var items: [DataZoneClientTypes.DataProductItem]?
    /// The name of the data product.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the owning project of the data product.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        items: [DataZoneClientTypes.DataProductItem]? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.items = items
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
    }
}

extension CreateDataProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataProductInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), items: \(Swift.String(describing: items)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), description: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum DataProductStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductStatus] {
            return [
                .created,
                .createFailed,
                .creating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDataProductOutput: Swift.Sendable {
    /// The timestamp at which the data product was created.
    public var createdAt: Foundation.Date?
    /// The user who created the data product.
    public var createdBy: Swift.String?
    /// The description of the data product.
    public var description: Swift.String?
    /// The ID of the domain where the data product lives.
    /// This member is required.
    public var domainId: Swift.String?
    /// The timestamp at which the first revision of the data product was created.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The user who created the first revision of the data product.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms of the data product.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms of the data product.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the data product.
    /// This member is required.
    public var id: Swift.String?
    /// The data assets of the data product.
    public var items: [DataZoneClientTypes.DataProductItem]?
    /// The name of the data product.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the owning project of the data product.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the data product.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the data product.
    /// This member is required.
    public var status: DataZoneClientTypes.DataProductStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        items: [DataZoneClientTypes.DataProductItem]? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.DataProductStatus? = .created
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.items = items
        self.name = name
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

extension CreateDataProductOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataProductOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), items: \(Swift.String(describing: items)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateDataProductRevisionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the data product revision.
    public var description: Swift.String?
    /// The ID of the domain where the data product revision is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The metadata forms of the data product revision.
    public var formsInput: [DataZoneClientTypes.FormInput]?
    /// The glossary terms of the data product revision.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the data product revision.
    /// This member is required.
    public var identifier: Swift.String?
    /// The data assets of the data product revision.
    public var items: [DataZoneClientTypes.DataProductItem]?
    /// The name of the data product revision.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        formsInput: [DataZoneClientTypes.FormInput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        items: [DataZoneClientTypes.DataProductItem]? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.formsInput = formsInput
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.items = items
        self.name = name
    }
}

extension CreateDataProductRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataProductRevisionInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), items: \(Swift.String(describing: items)), description: \"CONTENT_REDACTED\", formsInput: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateDataProductRevisionOutput: Swift.Sendable {
    /// The timestamp at which the data product revision is created.
    public var createdAt: Foundation.Date?
    /// The user who created the data product revision.
    public var createdBy: Swift.String?
    /// The description of the data product revision.
    public var description: Swift.String?
    /// The ID of the domain where data product revision is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The timestamp at which the first revision of the data product is created.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The user who created the first revision of the data product.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms of the data product revision.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms of the data product revision.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the data product revision.
    /// This member is required.
    public var id: Swift.String?
    /// The data assets of the data product revision.
    public var items: [DataZoneClientTypes.DataProductItem]?
    /// The name of the data product revision.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the owning project of the data product revision.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the data product revision.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the data product revision.
    /// This member is required.
    public var status: DataZoneClientTypes.DataProductStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        items: [DataZoneClientTypes.DataProductItem]? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.DataProductStatus? = .created
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.items = items
        self.name = name
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

extension CreateDataProductRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataProductRevisionOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), items: \(Swift.String(describing: items)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum FilterExpressionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterExpressionType] {
            return [
                .exclude,
                .include
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// A filter expression in Amazon DataZone.
    public struct FilterExpression: Swift.Sendable {
        /// The search filter expression.
        /// This member is required.
        public var expression: Swift.String?
        /// The search filter explresison type.
        /// This member is required.
        public var type: DataZoneClientTypes.FilterExpressionType?

        public init(
            expression: Swift.String? = nil,
            type: DataZoneClientTypes.FilterExpressionType? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }
}

extension DataZoneClientTypes {

    /// The relational filter configuration for the data source.
    public struct RelationalFilterConfiguration: Swift.Sendable {
        /// The database name specified in the relational filter configuration for the data source.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The filter expressions specified in the relational filter configuration for the data source.
        public var filterExpressions: [DataZoneClientTypes.FilterExpression]?
        /// The schema name specified in the relational filter configuration for the data source.
        public var schemaName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            filterExpressions: [DataZoneClientTypes.FilterExpression]? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.filterExpressions = filterExpressions
            self.schemaName = schemaName
        }
    }
}

extension DataZoneClientTypes {

    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationInput: Swift.Sendable {
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public var autoImportDataQualityResult: Swift.Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            autoImportDataQualityResult: Swift.Bool? = nil,
            dataAccessRole: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the credentials required to access an Amazon Redshift cluster.
    public struct RedshiftCredentialConfiguration: Swift.Sendable {
        /// The ARN of a secret manager for an Amazon Redshift cluster.
        /// This member is required.
        public var secretManagerArn: Swift.String?

        public init(
            secretManagerArn: Swift.String? = nil
        )
        {
            self.secretManagerArn = secretManagerArn
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the Amazon Redshift cluster storage.
    public struct RedshiftClusterStorage: Swift.Sendable {
        /// The name of an Amazon Redshift cluster.
        /// This member is required.
        public var clusterName: Swift.String?

        public init(
            clusterName: Swift.String? = nil
        )
        {
            self.clusterName = clusterName
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the Amazon Redshift Serverless workgroup storage.
    public struct RedshiftServerlessStorage: Swift.Sendable {
        /// The name of the Amazon Redshift Serverless workgroup.
        /// This member is required.
        public var workgroupName: Swift.String?

        public init(
            workgroupName: Swift.String? = nil
        )
        {
            self.workgroupName = workgroupName
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
    public enum RedshiftStorage: Swift.Sendable {
        /// The details of the Amazon Redshift cluster source.
        case redshiftclustersource(DataZoneClientTypes.RedshiftClusterStorage)
        /// The details of the Amazon Redshift Serverless workgroup source.
        case redshiftserverlesssource(DataZoneClientTypes.RedshiftServerlessStorage)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationInput: Swift.Sendable {
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }
}

extension DataZoneClientTypes {

    /// The configuration of the data source.
    public enum DataSourceConfigurationInput: Swift.Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationInput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationInput)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum EnableSetting: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableSetting] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The recommendation to be updated as part of the UpdateDataSource action.
    public struct RecommendationConfiguration: Swift.Sendable {
        /// Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
        public var enableBusinessNameGeneration: Swift.Bool?

        public init(
            enableBusinessNameGeneration: Swift.Bool? = nil
        )
        {
            self.enableBusinessNameGeneration = enableBusinessNameGeneration
        }
    }
}

extension DataZoneClientTypes {

    public enum Timezone: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case africaJohannesburg
        case americaMontreal
        case americaSaoPaulo
        case asiaBahrain
        case asiaBangkok
        case asiaCalcutta
        case asiaDubai
        case asiaHongKong
        case asiaJakarta
        case asiaKualaLumpur
        case asiaSeoul
        case asiaShanghai
        case asiaSingapore
        case asiaTaipei
        case asiaTokyo
        case australiaMelbourne
        case australiaSydney
        case canadaCentral
        case cet
        case cst6cdt
        case etcGmt
        case etcGmt0
        case etcGmtAdd0
        case etcGmtAdd1
        case etcGmtAdd10
        case etcGmtAdd11
        case etcGmtAdd12
        case etcGmtAdd2
        case etcGmtAdd3
        case etcGmtAdd4
        case etcGmtAdd5
        case etcGmtAdd6
        case etcGmtAdd7
        case etcGmtAdd8
        case etcGmtAdd9
        case etcGmtNeg0
        case etcGmtNeg1
        case etcGmtNeg10
        case etcGmtNeg11
        case etcGmtNeg12
        case etcGmtNeg13
        case etcGmtNeg14
        case etcGmtNeg2
        case etcGmtNeg3
        case etcGmtNeg4
        case etcGmtNeg5
        case etcGmtNeg6
        case etcGmtNeg7
        case etcGmtNeg8
        case etcGmtNeg9
        case europeDublin
        case europeLondon
        case europeParis
        case europeStockholm
        case europeZurich
        case israel
        case mexicoGeneral
        case mst7mdt
        case pacificAuckland
        case usCentral
        case usEastern
        case usMountain
        case usPacific
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [Timezone] {
            return [
                .africaJohannesburg,
                .americaMontreal,
                .americaSaoPaulo,
                .asiaBahrain,
                .asiaBangkok,
                .asiaCalcutta,
                .asiaDubai,
                .asiaHongKong,
                .asiaJakarta,
                .asiaKualaLumpur,
                .asiaSeoul,
                .asiaShanghai,
                .asiaSingapore,
                .asiaTaipei,
                .asiaTokyo,
                .australiaMelbourne,
                .australiaSydney,
                .canadaCentral,
                .cet,
                .cst6cdt,
                .etcGmt,
                .etcGmt0,
                .etcGmtAdd0,
                .etcGmtAdd1,
                .etcGmtAdd10,
                .etcGmtAdd11,
                .etcGmtAdd12,
                .etcGmtAdd2,
                .etcGmtAdd3,
                .etcGmtAdd4,
                .etcGmtAdd5,
                .etcGmtAdd6,
                .etcGmtAdd7,
                .etcGmtAdd8,
                .etcGmtAdd9,
                .etcGmtNeg0,
                .etcGmtNeg1,
                .etcGmtNeg10,
                .etcGmtNeg11,
                .etcGmtNeg12,
                .etcGmtNeg13,
                .etcGmtNeg14,
                .etcGmtNeg2,
                .etcGmtNeg3,
                .etcGmtNeg4,
                .etcGmtNeg5,
                .etcGmtNeg6,
                .etcGmtNeg7,
                .etcGmtNeg8,
                .etcGmtNeg9,
                .europeDublin,
                .europeLondon,
                .europeParis,
                .europeStockholm,
                .europeZurich,
                .israel,
                .mexicoGeneral,
                .mst7mdt,
                .pacificAuckland,
                .usCentral,
                .usEastern,
                .usMountain,
                .usPacific,
                .utc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .africaJohannesburg: return "AFRICA_JOHANNESBURG"
            case .americaMontreal: return "AMERICA_MONTREAL"
            case .americaSaoPaulo: return "AMERICA_SAO_PAULO"
            case .asiaBahrain: return "ASIA_BAHRAIN"
            case .asiaBangkok: return "ASIA_BANGKOK"
            case .asiaCalcutta: return "ASIA_CALCUTTA"
            case .asiaDubai: return "ASIA_DUBAI"
            case .asiaHongKong: return "ASIA_HONG_KONG"
            case .asiaJakarta: return "ASIA_JAKARTA"
            case .asiaKualaLumpur: return "ASIA_KUALA_LUMPUR"
            case .asiaSeoul: return "ASIA_SEOUL"
            case .asiaShanghai: return "ASIA_SHANGHAI"
            case .asiaSingapore: return "ASIA_SINGAPORE"
            case .asiaTaipei: return "ASIA_TAIPEI"
            case .asiaTokyo: return "ASIA_TOKYO"
            case .australiaMelbourne: return "AUSTRALIA_MELBOURNE"
            case .australiaSydney: return "AUSTRALIA_SYDNEY"
            case .canadaCentral: return "CANADA_CENTRAL"
            case .cet: return "CET"
            case .cst6cdt: return "CST6CDT"
            case .etcGmt: return "ETC_GMT"
            case .etcGmt0: return "ETC_GMT0"
            case .etcGmtAdd0: return "ETC_GMT_ADD_0"
            case .etcGmtAdd1: return "ETC_GMT_ADD_1"
            case .etcGmtAdd10: return "ETC_GMT_ADD_10"
            case .etcGmtAdd11: return "ETC_GMT_ADD_11"
            case .etcGmtAdd12: return "ETC_GMT_ADD_12"
            case .etcGmtAdd2: return "ETC_GMT_ADD_2"
            case .etcGmtAdd3: return "ETC_GMT_ADD_3"
            case .etcGmtAdd4: return "ETC_GMT_ADD_4"
            case .etcGmtAdd5: return "ETC_GMT_ADD_5"
            case .etcGmtAdd6: return "ETC_GMT_ADD_6"
            case .etcGmtAdd7: return "ETC_GMT_ADD_7"
            case .etcGmtAdd8: return "ETC_GMT_ADD_8"
            case .etcGmtAdd9: return "ETC_GMT_ADD_9"
            case .etcGmtNeg0: return "ETC_GMT_NEG_0"
            case .etcGmtNeg1: return "ETC_GMT_NEG_1"
            case .etcGmtNeg10: return "ETC_GMT_NEG_10"
            case .etcGmtNeg11: return "ETC_GMT_NEG_11"
            case .etcGmtNeg12: return "ETC_GMT_NEG_12"
            case .etcGmtNeg13: return "ETC_GMT_NEG_13"
            case .etcGmtNeg14: return "ETC_GMT_NEG_14"
            case .etcGmtNeg2: return "ETC_GMT_NEG_2"
            case .etcGmtNeg3: return "ETC_GMT_NEG_3"
            case .etcGmtNeg4: return "ETC_GMT_NEG_4"
            case .etcGmtNeg5: return "ETC_GMT_NEG_5"
            case .etcGmtNeg6: return "ETC_GMT_NEG_6"
            case .etcGmtNeg7: return "ETC_GMT_NEG_7"
            case .etcGmtNeg8: return "ETC_GMT_NEG_8"
            case .etcGmtNeg9: return "ETC_GMT_NEG_9"
            case .europeDublin: return "EUROPE_DUBLIN"
            case .europeLondon: return "EUROPE_LONDON"
            case .europeParis: return "EUROPE_PARIS"
            case .europeStockholm: return "EUROPE_STOCKHOLM"
            case .europeZurich: return "EUROPE_ZURICH"
            case .israel: return "ISRAEL"
            case .mexicoGeneral: return "MEXICO_GENERAL"
            case .mst7mdt: return "MST7MDT"
            case .pacificAuckland: return "PACIFIC_AUCKLAND"
            case .usCentral: return "US_CENTRAL"
            case .usEastern: return "US_EASTERN"
            case .usMountain: return "US_MOUNTAIN"
            case .usPacific: return "US_PACIFIC"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the schedule of the data source runs.
    public struct ScheduleConfiguration: Swift.Sendable {
        /// The schedule of the data source runs.
        public var schedule: Swift.String?
        /// The timezone of the data source run.
        public var timezone: DataZoneClientTypes.Timezone?

        public init(
            schedule: Swift.String? = nil,
            timezone: DataZoneClientTypes.Timezone? = nil
        )
        {
            self.schedule = schedule
            self.timezone = timezone
        }
    }
}

extension DataZoneClientTypes.ScheduleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreateDataSourceInput: Swift.Sendable {
    /// The metadata forms that are to be attached to the assets that this data source works with.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the data source is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which you want to add this data source.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The type of the data source.
    /// This member is required.
    public var type: Swift.String?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        clientToken: Swift.String? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.type = type
    }
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), type: \(Swift.String(describing: type)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The configuration details of the Amazon Web Services Glue data source.
    public struct GlueRunConfigurationOutput: Swift.Sendable {
        /// The Amazon Web Services account ID included in the configuration details of the Amazon Web Services Glue data source.
        public var accountId: Swift.String?
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public var autoImportDataQualityResult: Swift.Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public var dataAccessRole: Swift.String?
        /// The Amazon Web Services region included in the configuration details of the Amazon Web Services Glue data source.
        public var region: Swift.String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            autoImportDataQualityResult: Swift.Bool? = nil,
            dataAccessRole: Swift.String? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }
}

extension DataZoneClientTypes {

    /// The configuration details of the Amazon Redshift data source.
    public struct RedshiftRunConfigurationOutput: Swift.Sendable {
        /// The ID of the Amazon Web Services account included in the configuration details of the Amazon Redshift data source.
        public var accountId: Swift.String?
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public var dataAccessRole: Swift.String?
        /// The details of the credentials required to access an Amazon Redshift cluster.
        /// This member is required.
        public var redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration?
        /// The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
        /// This member is required.
        public var redshiftStorage: DataZoneClientTypes.RedshiftStorage?
        /// The Amazon Web Services region included in the configuration details of the Amazon Redshift data source.
        public var region: Swift.String?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        /// This member is required.
        public var relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            dataAccessRole: Swift.String? = nil,
            redshiftCredentialConfiguration: DataZoneClientTypes.RedshiftCredentialConfiguration? = nil,
            redshiftStorage: DataZoneClientTypes.RedshiftStorage? = nil,
            region: Swift.String? = nil,
            relationalFilterConfigurations: [DataZoneClientTypes.RelationalFilterConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }
    }
}

extension DataZoneClientTypes {

    /// The configuration of the data source.
    public enum DataSourceConfigurationOutput: Swift.Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case gluerunconfiguration(DataZoneClientTypes.GlueRunConfigurationOutput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftrunconfiguration(DataZoneClientTypes.RedshiftRunConfigurationOutput)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum DataSourceErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDeniedException
        case conflictException
        case internalServerException
        case resourceNotFoundException
        case serviceQuotaExceededException
        case throttlingException
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorType] {
            return [
                .accessDeniedException,
                .conflictException,
                .internalServerException,
                .resourceNotFoundException,
                .serviceQuotaExceededException,
                .throttlingException,
                .validationException
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
            case .conflictException: return "CONFLICT_EXCEPTION"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case .throttlingException: return "THROTTLING_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the error message that is returned if the operation cannot be successfully completed.
    public struct DataSourceErrorMessage: Swift.Sendable {
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorDetail: Swift.String?
        /// The type of the error message that is returned if the operation cannot be successfully completed.
        /// This member is required.
        public var errorType: DataZoneClientTypes.DataSourceErrorType?

        public init(
            errorDetail: Swift.String? = nil,
            errorType: DataZoneClientTypes.DataSourceErrorType? = nil
        )
        {
            self.errorDetail = errorDetail
            self.errorType = errorType
        }
    }
}

extension DataZoneClientTypes {

    public enum DataSourceRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case partiallySucceeded
        case requested
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunStatus] {
            return [
                .failed,
                .partiallySucceeded,
                .requested,
                .running,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .partiallySucceeded: return "PARTIALLY_SUCCEEDED"
            case .requested: return "REQUESTED"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum DataSourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failedCreation
        case failedDeletion
        case failedUpdate
        case ready
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .creating,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .failedUpdate,
                .ready,
                .running,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdate: return "FAILED_UPDATE"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDataSourceOutput: Swift.Sendable {
    /// The metadata forms attached to the assets that this data source creates.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: Foundation.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether the data source is enabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The unique identifier of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp that specifies when the data source was last run.
    public var lastRunAt: Foundation.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project to which the data source is added.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies whether the business name generation is to be enabled for this data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: Foundation.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: Foundation.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension CreateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum UserAssignment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UserAssignment] {
            return [
                .automatic,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The single sign-on details in Amazon DataZone.
    public struct SingleSignOn: Swift.Sendable {
        /// The type of single sign-on in Amazon DataZone.
        public var type: DataZoneClientTypes.AuthType?
        /// The single sign-on user assignment in Amazon DataZone.
        public var userAssignment: DataZoneClientTypes.UserAssignment?

        public init(
            type: DataZoneClientTypes.AuthType? = nil,
            userAssignment: DataZoneClientTypes.UserAssignment? = nil
        )
        {
            self.type = type
            self.userAssignment = userAssignment
        }
    }
}

public struct CreateDomainInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    /// This member is required.
    public var name: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.singleSignOn = singleSignOn
        self.tags = tags
    }
}

extension DataZoneClientTypes {

    public enum DomainStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .available,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDomainOutput: Swift.Sendable {
    /// The ARN of the Amazon DataZone domain.
    public var arn: Swift.String?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The ID of the root domain unit.
    public var rootDomainUnitId: Swift.String?
    /// The single-sign on configuration of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the Amazon DataZone domain.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        rootDomainUnitId: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.portalUrl = portalUrl
        self.rootDomainUnitId = rootDomainUnitId
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

public struct CreateDomainUnitInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the domain unit.
    public var description: Swift.String?
    /// The ID of the domain where you want to crate a domain unit.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The name of the domain unit.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the parent domain unit.
    /// This member is required.
    public var parentDomainUnitIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        parentDomainUnitIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.name = name
        self.parentDomainUnitIdentifier = parentDomainUnitIdentifier
    }
}

extension CreateDomainUnitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainUnitInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), parentDomainUnitIdentifier: \(Swift.String(describing: parentDomainUnitIdentifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The properties of a domain unit group.
    public struct DomainUnitGroupProperties: Swift.Sendable {
        /// The ID of the domain unit group.
        public var groupId: Swift.String?

        public init(
            groupId: Swift.String? = nil
        )
        {
            self.groupId = groupId
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of the domain unit user.
    public struct DomainUnitUserProperties: Swift.Sendable {
        /// The ID of teh domain unit user.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of the domain unit owner.
    public enum DomainUnitOwnerProperties: Swift.Sendable {
        /// Indicates that the domain unit owner is a user.
        case user(DataZoneClientTypes.DomainUnitUserProperties)
        /// Indicates that the domain unit owner is a group.
        case group(DataZoneClientTypes.DomainUnitGroupProperties)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateDomainUnitOutput: Swift.Sendable {
    /// The IDs of the ancestor domain units.
    /// This member is required.
    public var ancestorDomainUnitIds: [Swift.String]?
    /// The timestamp at which the domain unit was created.
    public var createdAt: Foundation.Date?
    /// The user who created the domain unit.
    public var createdBy: Swift.String?
    /// The description of the domain unit.
    public var description: Swift.String?
    /// The ID of the domain where the domain unit was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the domain unit.
    /// This member is required.
    public var name: Swift.String?
    /// The owners of the domain unit.
    /// This member is required.
    public var owners: [DataZoneClientTypes.DomainUnitOwnerProperties]?
    /// The ID of the parent domain unit.
    public var parentDomainUnitId: Swift.String?

    public init(
        ancestorDomainUnitIds: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owners: [DataZoneClientTypes.DomainUnitOwnerProperties]? = nil,
        parentDomainUnitId: Swift.String? = nil
    )
    {
        self.ancestorDomainUnitIds = ancestorDomainUnitIds
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owners = owners
        self.parentDomainUnitId = parentDomainUnitId
    }
}

extension CreateDomainUnitOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainUnitOutput(ancestorDomainUnitIds: \(Swift.String(describing: ancestorDomainUnitIds)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owners: \(Swift.String(describing: owners)), parentDomainUnitId: \(Swift.String(describing: parentDomainUnitId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The parameter details of an evironment profile.
    public struct EnvironmentParameter: Swift.Sendable {
        /// The name of an environment profile parameter.
        public var name: Swift.String?
        /// The value of an environment profile parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

public struct CreateEnvironmentInput: Swift.Sendable {
    /// The description of the Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the account in which the environment is being created.
    public var environmentAccountIdentifier: Swift.String?
    /// The region of the account in which the environment is being created.
    public var environmentAccountRegion: Swift.String?
    /// The ID of the blueprint with which the environment is being created.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The identifier of the environment profile that is used to create this Amazon DataZone environment.
    /// This member is required.
    public var environmentProfileIdentifier: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone environment.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentAccountIdentifier: Swift.String? = nil,
        environmentAccountRegion: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentAccountIdentifier = environmentAccountIdentifier
        self.environmentAccountRegion = environmentAccountRegion
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.glossaryTerms = glossaryTerms
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

extension DataZoneClientTypes {

    /// The deployment properties of the Amazon DataZone blueprint.
    public struct DeploymentProperties: Swift.Sendable {
        /// The end timeout of the environment blueprint deployment.
        public var endTimeoutMinutes: Swift.Int?
        /// The start timeout of the environment blueprint deployment.
        public var startTimeoutMinutes: Swift.Int?

        public init(
            endTimeoutMinutes: Swift.Int? = nil,
            startTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.endTimeoutMinutes = endTimeoutMinutes
            self.startTimeoutMinutes = startTimeoutMinutes
        }
    }
}

extension DataZoneClientTypes {

    public enum DeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case pendingDeployment
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .failed,
                .inProgress,
                .pendingDeployment,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum DeploymentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .create,
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The failure reasons for the environment deployment.
    public struct EnvironmentError: Swift.Sendable {
        /// The error code for the failure reason for the environment deployment.
        public var code: Swift.String?
        /// The error message for the failure reason for the environment deployment.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the last deployment of the environment.
    public struct Deployment: Swift.Sendable {
        /// The identifier of the last deployment of the environment.
        public var deploymentId: Swift.String?
        /// The status of the last deployment of the environment.
        public var deploymentStatus: DataZoneClientTypes.DeploymentStatus?
        /// The type of the last deployment of the environment.
        public var deploymentType: DataZoneClientTypes.DeploymentType?
        /// The failure reason of the last deployment of the environment.
        public var failureReason: DataZoneClientTypes.EnvironmentError?
        /// Specifies whether the last deployment of the environment is complete.
        public var isDeploymentComplete: Swift.Bool?
        /// The messages of the last deployment of the environment.
        public var messages: [Swift.String]?

        public init(
            deploymentId: Swift.String? = nil,
            deploymentStatus: DataZoneClientTypes.DeploymentStatus? = nil,
            deploymentType: DataZoneClientTypes.DeploymentType? = nil,
            failureReason: DataZoneClientTypes.EnvironmentError? = nil,
            isDeploymentComplete: Swift.Bool? = nil,
            messages: [Swift.String]? = nil
        )
        {
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.failureReason = failureReason
            self.isDeploymentComplete = isDeploymentComplete
            self.messages = messages
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a provisioned resource of this Amazon DataZone environment.
    public struct Resource: Swift.Sendable {
        /// The name of a provisioned resource of this Amazon DataZone environment.
        public var name: Swift.String?
        /// The provider of a provisioned resource of this Amazon DataZone environment.
        public var provider: Swift.String?
        /// The type of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var type: Swift.String?
        /// The value of a provisioned resource of this Amazon DataZone environment.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.provider = provider
            self.type = type
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// The provisioning properties of an environment blueprint.
    public enum ProvisioningProperties: Swift.Sendable {
        /// The cloud formation properties included as part of the provisioning properties of an environment blueprint.
        case cloudformation(DataZoneClientTypes.CloudFormationProperties)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum EnvironmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleted
        case deleteFailed
        case deleting
        case disabled
        case expired
        case inaccessible
        case suspended
        case updateFailed
        case updating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleting,
                .disabled,
                .expired,
                .inaccessible,
                .suspended,
                .updateFailed,
                .updating,
                .validationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .expired: return "EXPIRED"
            case .inaccessible: return "INACCESSIBLE"
            case .suspended: return "SUSPENDED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of user parameters of an environment blueprint.
    public struct CustomParameter: Swift.Sendable {
        /// The default value of the parameter.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// The filed type of the parameter.
        /// This member is required.
        public var fieldType: Swift.String?
        /// Specifies whether the parameter is editable.
        public var isEditable: Swift.Bool?
        /// Specifies whether the custom parameter is optional.
        public var isOptional: Swift.Bool?
        /// The key name of the parameter.
        /// This member is required.
        public var keyName: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            fieldType: Swift.String? = nil,
            isEditable: Swift.Bool? = nil,
            isOptional: Swift.Bool? = nil,
            keyName: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.fieldType = fieldType
            self.isEditable = isEditable
            self.isOptional = isOptional
            self.keyName = keyName
        }
    }
}

extension DataZoneClientTypes.CustomParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomParameter(defaultValue: \(Swift.String(describing: defaultValue)), fieldType: \(Swift.String(describing: fieldType)), isEditable: \(Swift.String(describing: isEditable)), isOptional: \(Swift.String(describing: isOptional)), keyName: \(Swift.String(describing: keyName)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateEnvironmentOutput: Swift.Sendable {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which the Amazon DataZone environment is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created this environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of this Amazon DataZone environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone environment.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The configurable actions of this Amazon DataZone environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The ID of the blueprint with which this Amazon DataZone environment was created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which this Amazon DataZone environment was created.
    public var environmentProfileId: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone environment.
    public var id: Swift.String?
    /// The details of the last deployment of this Amazon DataZone environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of this environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = "",
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension CreateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateEnvironmentActionInput: Swift.Sendable {
    /// The description of the environment action that is being created in the environment.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the environment action is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which the environment action is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name of the environment action.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters of the environment action.
    /// This member is required.
    public var parameters: DataZoneClientTypes.ActionParameters?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: DataZoneClientTypes.ActionParameters? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.parameters = parameters
    }
}

public struct CreateEnvironmentActionOutput: Swift.Sendable {
    /// The description of the environment action.
    public var description: Swift.String?
    /// The ID of the domain in which the environment action is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment in which the environment is created.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the environment action.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment action.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters of the environment action.
    /// This member is required.
    public var parameters: DataZoneClientTypes.ActionParameters?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: DataZoneClientTypes.ActionParameters? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.name = name
        self.parameters = parameters
    }
}

public struct CreateEnvironmentProfileInput: Swift.Sendable {
    /// The Amazon Web Services account in which the Amazon DataZone environment is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to create the environment profile.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.name = name
        self.projectIdentifier = projectIdentifier
        self.userParameters = userParameters
    }
}

extension CreateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateEnvironmentProfileOutput: Swift.Sendable {
    /// The Amazon Web Services account ID in which this Amazon DataZone environment profile is created.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region in which this Amazon DataZone environment profile is created.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of this Amazon DataZone environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of this Amazon DataZone environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters of this Amazon DataZone environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension CreateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The model of the API.
    public enum Model: Swift.Sendable {
        /// Indicates the smithy model of the API.
        case smithy(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum FormTypeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FormTypeStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFormTypeInput: Swift.Sendable {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The model of this Amazon DataZone metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project that owns this metadata form type.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this Amazon DataZone metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.model = model
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

extension CreateFormTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateFormTypeOutput: Swift.Sendable {
    /// The description of this Amazon DataZone metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of this Amazon DataZone metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this Amazon DataZone metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this Amazon DataZone metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of this Amazon DataZone metadata form type.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
    }
}

extension CreateFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFormTypeOutput(domainId: \(Swift.String(describing: domainId)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum GlossaryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGlossaryInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns business glossary.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.name = name
        self.owningProjectIdentifier = owningProjectIdentifier
        self.status = status
    }
}

extension CreateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), owningProjectIdentifier: \(Swift.String(describing: owningProjectIdentifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateGlossaryOutput: Swift.Sendable {
    /// The description of this business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of this business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that currently owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of this business glossary.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

extension CreateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum GlossaryTermStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GlossaryTermStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the term relations.
    public struct TermRelations: Swift.Sendable {
        /// The classifies of the term relations.
        public var classifies: [Swift.String]?
        /// The isA property of the term relations.
        public var isa: [Swift.String]?

        public init(
            classifies: [Swift.String]? = nil,
            isa: [Swift.String]? = nil
        )
        {
            self.classifies = classifies
            self.isa = isa
        }
    }
}

public struct CreateGlossaryTermInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryIdentifier: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension CreateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

public struct CreateGlossaryTermOutput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this business glossary term is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary in which this term is created.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of this business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of this business glossary term.
    public var longDescription: Swift.String?
    /// The name of this business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short description of this business glossary term.
    public var shortDescription: Swift.String?
    /// The status of this business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations of this business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension CreateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

public struct CreateGroupProfileInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group for which the group profile is created.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

extension DataZoneClientTypes {

    public enum GroupProfileStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assigned
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupProfileStatus] {
            return [
                .assigned,
                .notAssigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGroupProfileOutput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which the group profile is created.
    public var domainId: Swift.String?
    /// The name of the group for which group profile is created.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The status of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

extension CreateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum EntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case dataProduct
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .asset,
                .dataProduct
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataProduct: return "DATA_PRODUCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateListingChangeSetInput: Swift.Sendable {
    /// Specifies whether to publish or unpublish a listing.
    /// This member is required.
    public var action: DataZoneClientTypes.ChangeAction?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The revision of an asset.
    public var entityRevision: Swift.String?
    /// The type of an entity.
    /// This member is required.
    public var entityType: DataZoneClientTypes.EntityType?

    public init(
        action: DataZoneClientTypes.ChangeAction? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityRevision: Swift.String? = nil,
        entityType: DataZoneClientTypes.EntityType? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityRevision = entityRevision
        self.entityType = entityType
    }
}

public struct CreateListingChangeSetOutput: Swift.Sendable {
    /// The ID of the listing (a record of an asset at a given time).
    /// This member is required.
    public var listingId: Swift.String?
    /// The revision of a listing.
    /// This member is required.
    public var listingRevision: Swift.String?
    /// Specifies the status of the listing.
    /// This member is required.
    public var status: DataZoneClientTypes.ListingStatus?

    public init(
        listingId: Swift.String? = nil,
        listingRevision: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil
    )
    {
        self.listingId = listingId
        self.listingRevision = listingRevision
        self.status = status
    }
}

public struct CreateProjectInput: Swift.Sendable {
    /// The description of the Amazon DataZone project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this project is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the domain unit. This parameter is not required and if it is not specified, then the project is created at the root domain unit level.
    public var domainUnitId: Swift.String?
    /// The glossary terms that can be used in this Amazon DataZone project.
    public var glossaryTerms: [Swift.String]?
    /// The name of the Amazon DataZone project.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        domainUnitId: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.domainUnitId = domainUnitId
        self.glossaryTerms = glossaryTerms
        self.name = name
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), domainUnitId: \(Swift.String(describing: domainUnitId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public struct ProjectDeletionError: Swift.Sendable {
        /// The code of the project deletion error.
        public var code: Swift.String?
        /// The message of the project deletion error.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension DataZoneClientTypes {

    public enum ProjectStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectStatus] {
            return [
                .active,
                .deleteFailed,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProjectOutput: Swift.Sendable {
    /// The timestamp of when the project was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the project was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit.
    public var domainUnitId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the Amazon DataZone project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Amazon DataZone project that was created.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainUnitId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.domainUnitId = domainUnitId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

extension CreateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), domainUnitId: \(Swift.String(describing: domainUnitId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum UserDesignation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case projectCatalogConsumer
        case projectCatalogSteward
        case projectCatalogViewer
        case projectContributor
        case projectOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [UserDesignation] {
            return [
                .projectCatalogConsumer,
                .projectCatalogSteward,
                .projectCatalogViewer,
                .projectContributor,
                .projectOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .projectCatalogConsumer: return "PROJECT_CATALOG_CONSUMER"
            case .projectCatalogSteward: return "PROJECT_CATALOG_STEWARD"
            case .projectCatalogViewer: return "PROJECT_CATALOG_VIEWER"
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details about a project member.
    public enum Member: Swift.Sendable {
        /// The user ID of a project member.
        case useridentifier(Swift.String)
        /// The ID of the group of a project member.
        case groupidentifier(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateProjectMembershipInput: Swift.Sendable {
    /// The designation of the project membership.
    /// This member is required.
    public var designation: DataZoneClientTypes.UserDesignation?
    /// The ID of the Amazon DataZone domain in which project membership is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership was created.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the project for which this project membership was created.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        designation: DataZoneClientTypes.UserDesignation? = nil,
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.designation = designation
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

public struct CreateProjectMembershipOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    /// A revision to be made to an asset published in a Amazon DataZone catalog.
    public struct ListingRevisionInput: Swift.Sendable {
        /// An identifier of revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var identifier: Swift.String?
        /// The details of a revision to be made to an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.revision = revision
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a listing for which a subscription is to be granted.
    public enum GrantedEntityInput: Swift.Sendable {
        /// The listing for which a subscription is to be granted.
        case listing(DataZoneClientTypes.ListingRevisionInput)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateSubscriptionGrantInput: Swift.Sendable {
    /// The names of the assets for which the subscription grant is created.
    public var assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which the subscription grant is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The entity to which the subscription is to be granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntityInput?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetIdentifier: Swift.String?

    public init(
        assetTargetNames: [DataZoneClientTypes.AssetTargetNameMap]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntityInput? = nil,
        subscriptionTargetIdentifier: Swift.String? = nil
    )
    {
        self.assetTargetNames = assetTargetNames
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.grantedEntity = grantedEntity
        self.subscriptionTargetIdentifier = subscriptionTargetIdentifier
    }
}

extension DataZoneClientTypes {

    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public struct FailureCause: Swift.Sendable {
        /// The description of the error message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }
}

extension DataZoneClientTypes {

    public enum SubscriptionGrantStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case granted
        case grantFailed
        case grantInProgress
        case grantPending
        case revoked
        case revokeFailed
        case revokeInProgress
        case revokePending
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantStatus] {
            return [
                .granted,
                .grantFailed,
                .grantInProgress,
                .grantPending,
                .revoked,
                .revokeFailed,
                .revokeInProgress,
                .revokePending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .granted: return "GRANTED"
            case .grantFailed: return "GRANT_FAILED"
            case .grantInProgress: return "GRANT_IN_PROGRESS"
            case .grantPending: return "GRANT_PENDING"
            case .revoked: return "REVOKED"
            case .revokeFailed: return "REVOKE_FAILED"
            case .revokeInProgress: return "REVOKE_IN_PROGRESS"
            case .revokePending: return "REVOKE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the asset for which the subscription grant is created.
    public struct SubscribedAsset: Swift.Sendable {
        /// The identifier of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetId: Swift.String?
        /// The revision of the asset for which the subscription grant is created.
        /// This member is required.
        public var assetRevision: Swift.String?
        /// The asset scope of the subscribed asset.
        public var assetScope: DataZoneClientTypes.AssetScope?
        /// The failure cause included in the details of the asset for which the subscription grant is created.
        public var failureCause: DataZoneClientTypes.FailureCause?
        /// The failure timestamp included in the details of the asset for which the subscription grant is created.
        public var failureTimestamp: Foundation.Date?
        /// The timestamp of when the subscription grant to the asset is created.
        public var grantedTimestamp: Foundation.Date?
        /// The status of the asset for which the subscription grant is created.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantStatus?
        /// The target name of the asset for which the subscription grant is created.
        public var targetName: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            assetRevision: Swift.String? = nil,
            assetScope: DataZoneClientTypes.AssetScope? = nil,
            failureCause: DataZoneClientTypes.FailureCause? = nil,
            failureTimestamp: Foundation.Date? = nil,
            grantedTimestamp: Foundation.Date? = nil,
            status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
            targetName: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetScope = assetScope
            self.failureCause = failureCause
            self.failureTimestamp = failureTimestamp
            self.grantedTimestamp = grantedTimestamp
            self.status = status
            self.targetName = targetName
        }
    }
}

extension DataZoneClientTypes {

    /// A revision of an asset published in a Amazon DataZone catalog.
    public struct ListingRevision: Swift.Sendable {
        /// An identifier of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var id: Swift.String?
        /// The details of a revision of an asset published in a Amazon DataZone catalog.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a listing for which a subscription is granted.
    public enum GrantedEntity: Swift.Sendable {
        /// The listing for which a subscription is granted.
        case listing(DataZoneClientTypes.ListingRevision)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum SubscriptionGrantOverallStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case grantAndRevokeFailed
        case grantFailed
        case inaccessible
        case inProgress
        case pending
        case revokeFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionGrantOverallStatus] {
            return [
                .completed,
                .grantAndRevokeFailed,
                .grantFailed,
                .inaccessible,
                .inProgress,
                .pending,
                .revokeFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .grantAndRevokeFailed: return "GRANT_AND_REVOKE_FAILED"
            case .grantFailed: return "GRANT_FAILED"
            case .inaccessible: return "INACCESSIBLE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .revokeFailed: return "REVOKE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSubscriptionGrantOutput: Swift.Sendable {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// A timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription grant.
    @available(*, deprecated, message: "Multiple subscriptions can exist for a single grant")
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target for which the subscription grant is created.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// A timestamp of when the subscription grant was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension DataZoneClientTypes {

    /// The published asset for which the subscription grant is to be created.
    public struct SubscribedListingInput: Swift.Sendable {
        /// The identifier of the published asset for which the subscription grant is to be created.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }
}

extension DataZoneClientTypes {

    /// The project that is to be given a subscription grant.
    public struct SubscribedProjectInput: Swift.Sendable {
        /// The identifier of the project that is to be given a subscription grant.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }
}

extension DataZoneClientTypes {

    /// The principal that is to be given a subscriptiong grant.
    public enum SubscribedPrincipalInput: Swift.Sendable {
        /// The project that is to be given a subscription grant.
        case project(DataZoneClientTypes.SubscribedProjectInput)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateSubscriptionRequestInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription request is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The published asset for which the subscription grant is to be created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListingInput]?
    /// The Amazon DataZone principals for whom the subscription request is created.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListingInput]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipalInput]? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.requestReason = requestReason
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
    }
}

extension CreateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), requestReason: \"CONTENT_REDACTED\")"}
}

public struct CreateSubscriptionRequestOutput: Swift.Sendable {
    /// A timestamp of when the subscription request is created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The ID of the Amazon DataZone domain in whcih the subscription request is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The ID of the reviewer of the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The published asset for which the subscription grant is to be created.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension CreateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the subscription target configuration.
    public struct SubscriptionTargetForm: Swift.Sendable {
        /// The content of the subscription target configuration.
        /// This member is required.
        public var content: Swift.String?
        /// The form name included in the subscription target configuration.
        /// This member is required.
        public var formName: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
        }
    }
}

public struct CreateSubscriptionTargetInput: Swift.Sendable {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which subscription target is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment in which subscription target is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The manage access role that is used to create the subscription target.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of the subscription target.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
    }
}

extension CreateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateSubscriptionTargetOutput: Swift.Sendable {
    /// The asset types that can be included in the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorised principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment in which the subscription target was created.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// ???
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of the subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension CreateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum UserType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iamRole
        case iamUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .iamRole,
                .iamUser,
                .ssoUser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamRole: return "IAM_ROLE"
            case .iamUser: return "IAM_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUserProfileInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the user for which the user profile is created.
    /// This member is required.
    public var userIdentifier: Swift.String?
    /// The user type of the user for which the user profile is created.
    public var userType: DataZoneClientTypes.UserType?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        userIdentifier: Swift.String? = nil,
        userType: DataZoneClientTypes.UserType? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.userIdentifier = userIdentifier
        self.userType = userType
    }
}

extension DataZoneClientTypes {

    /// The details of an IAM user profile in Amazon DataZone.
    public struct IamUserProfileDetails: Swift.Sendable {
        /// The ARN of an IAM user profile in Amazon DataZone.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension DataZoneClientTypes {

    /// The single sign-on details of the user profile.
    public struct SsoUserProfileDetails: Swift.Sendable {
        /// The first name included in the single sign-on details of the user profile.
        public var firstName: Swift.String?
        /// The last name included in the single sign-on details of the user profile.
        public var lastName: Swift.String?
        /// The username included in the single sign-on details of the user profile.
        public var username: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.firstName = firstName
            self.lastName = lastName
            self.username = username
        }
    }
}

extension DataZoneClientTypes.SsoUserProfileDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SsoUserProfileDetails(firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the user profile in Amazon DataZone.
    public enum UserProfileDetails: Swift.Sendable {
        /// The IAM details included in the user profile details.
        case iam(DataZoneClientTypes.IamUserProfileDetails)
        /// The single sign-on details included in the user profile details.
        case sso(DataZoneClientTypes.SsoUserProfileDetails)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    public enum UserProfileStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case assigned
        case deactivated
        case notAssigned
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileStatus] {
            return [
                .activated,
                .assigned,
                .deactivated,
                .notAssigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .assigned: return "ASSIGNED"
            case .deactivated: return "DEACTIVATED"
            case .notAssigned: return "NOT_ASSIGNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum UserProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [UserProfileType] {
            return [
                .iam,
                .sso
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUserProfileOutput: Swift.Sendable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is created.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

extension DataZoneClientTypes {

    public enum DataAssetActivityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case publishingFailed
        case skippedAlreadyImported
        case skippedArchived
        case skippedNoAccess
        case succeededCreated
        case succeededUpdated
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAssetActivityStatus] {
            return [
                .failed,
                .publishingFailed,
                .skippedAlreadyImported,
                .skippedArchived,
                .skippedNoAccess,
                .succeededCreated,
                .succeededUpdated,
                .unchanged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .publishingFailed: return "PUBLISHING_FAILED"
            case .skippedAlreadyImported: return "SKIPPED_ALREADY_IMPORTED"
            case .skippedArchived: return "SKIPPED_ARCHIVED"
            case .skippedNoAccess: return "SKIPPED_NO_ACCESS"
            case .succeededCreated: return "SUCCEEDED_CREATED"
            case .succeededUpdated: return "SUCCEEDED_UPDATED"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteDataProductInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the data product is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data product that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteDataProductOutput: Swift.Sendable {

    public init() { }
}

public struct GetDataProductInput: Swift.Sendable {
    /// The ID of the domain where the data product lives.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the data product.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the data product.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.revision = revision
    }
}

public struct GetDataProductOutput: Swift.Sendable {
    /// The timestamp at which the data product is created.
    public var createdAt: Foundation.Date?
    /// The user who created the data product.
    public var createdBy: Swift.String?
    /// The description of the data product.
    public var description: Swift.String?
    /// The ID of the domain where the data product lives.
    /// This member is required.
    public var domainId: Swift.String?
    /// The timestamp at which the first revision of the data product is created.
    public var firstRevisionCreatedAt: Foundation.Date?
    /// The user who created the first revision of the data product.
    public var firstRevisionCreatedBy: Swift.String?
    /// The metadata forms of the data product.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The glossary terms of the data product.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the data product.
    /// This member is required.
    public var id: Swift.String?
    /// The data assets of the data product.
    public var items: [DataZoneClientTypes.DataProductItem]?
    /// The name of the data product.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the owning project of the data product.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The revision of the data product.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the data product.
    /// This member is required.
    public var status: DataZoneClientTypes.DataProductStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        firstRevisionCreatedAt: Foundation.Date? = nil,
        firstRevisionCreatedBy: Swift.String? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        items: [DataZoneClientTypes.DataProductItem]? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.DataProductStatus? = .created
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.firstRevisionCreatedAt = firstRevisionCreatedAt
        self.firstRevisionCreatedBy = firstRevisionCreatedBy
        self.formsOutput = formsOutput
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.items = items
        self.name = name
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

extension GetDataProductOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataProductOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), formsOutput: \(Swift.String(describing: formsOutput)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), items: \(Swift.String(describing: items)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The summary of the listing of the data product.
    public struct ListingSummary: Swift.Sendable {
        /// The glossary terms of the data product.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The ID of the data product listing.
        public var listingId: Swift.String?
        /// The revision of the data product listing.
        public var listingRevision: Swift.String?

        public init(
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil
        )
        {
            self.glossaryTerms = glossaryTerms
            self.listingId = listingId
            self.listingRevision = listingRevision
        }
    }
}

extension DataZoneClientTypes {

    /// The data product listing.
    public struct DataProductListing: Swift.Sendable {
        /// The timestamp at which the data product listing was created.
        public var createdAt: Foundation.Date?
        /// The ID of the data product listing.
        public var dataProductId: Swift.String?
        /// The revision of the data product listing.
        public var dataProductRevision: Swift.String?
        /// The metadata forms of the data product listing.
        public var forms: Swift.String?
        /// The glossary terms of the data product listing.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The data assets of the data product listing.
        public var items: [DataZoneClientTypes.ListingSummary]?
        /// The ID of the owning project of the data product listing.
        public var owningProjectId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            dataProductId: Swift.String? = nil,
            dataProductRevision: Swift.String? = nil,
            forms: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            items: [DataZoneClientTypes.ListingSummary]? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.dataProductId = dataProductId
            self.dataProductRevision = dataProductRevision
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.items = items
            self.owningProjectId = owningProjectId
        }
    }
}

extension DataZoneClientTypes {

    /// The additional attributes of the asset of the data product.
    public struct DataProductListingItemAdditionalAttributes: Swift.Sendable {
        /// The metadata forms of the asset of the data product.
        public var forms: Swift.String?

        public init(
            forms: Swift.String? = nil
        )
        {
            self.forms = forms
        }
    }
}

extension DataZoneClientTypes {

    /// The results of the data product summary.
    public struct ListingSummaryItem: Swift.Sendable {
        /// The glossary terms of the data product listing.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The ID of the data product listing.
        public var listingId: Swift.String?
        /// The revision of the data product listing.
        public var listingRevision: Swift.String?

        public init(
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil
        )
        {
            self.glossaryTerms = glossaryTerms
            self.listingId = listingId
            self.listingRevision = listingRevision
        }
    }
}

extension DataZoneClientTypes {

    /// The asset of the data product listing.
    public struct DataProductListingItem: Swift.Sendable {
        /// The additional attributes of the asset of the data product.
        public var additionalAttributes: DataZoneClientTypes.DataProductListingItemAdditionalAttributes?
        /// The timestamp at which the asset of the data product listing was created.
        public var createdAt: Foundation.Date?
        /// The description of the asset of the asset of the data product.
        public var description: Swift.String?
        /// The entity ID of the asset of the asset of the data product.
        public var entityId: Swift.String?
        /// The revision of the asset of the asset of the data product.
        public var entityRevision: Swift.String?
        /// The glossary terms of the asset of the asset of the data product.
        public var glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]?
        /// The data of the asset of the data product.
        public var items: [DataZoneClientTypes.ListingSummaryItem]?
        /// The timestamp at which the listing was created.
        public var listingCreatedBy: Swift.String?
        /// The ID of the listing.
        public var listingId: Swift.String?
        /// The revision of the listing.
        public var listingRevision: Swift.String?
        /// The user who updated the listing.
        public var listingUpdatedBy: Swift.String?
        /// The name of the asset of the data product.
        public var name: Swift.String?
        /// The ID of the owning project of the asset of the data product.
        public var owningProjectId: Swift.String?

        public init(
            additionalAttributes: DataZoneClientTypes.DataProductListingItemAdditionalAttributes? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityRevision: Swift.String? = nil,
            glossaryTerms: [DataZoneClientTypes.DetailedGlossaryTerm]? = nil,
            items: [DataZoneClientTypes.ListingSummaryItem]? = nil,
            listingCreatedBy: Swift.String? = nil,
            listingId: Swift.String? = nil,
            listingRevision: Swift.String? = nil,
            listingUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.glossaryTerms = glossaryTerms
            self.items = items
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }
    }
}

extension DataZoneClientTypes.DataProductListingItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataProductListingItem(additionalAttributes: \(Swift.String(describing: additionalAttributes)), createdAt: \(Swift.String(describing: createdAt)), entityId: \(Swift.String(describing: entityId)), entityRevision: \(Swift.String(describing: entityRevision)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), items: \(Swift.String(describing: items)), listingCreatedBy: \(Swift.String(describing: listingCreatedBy)), listingId: \(Swift.String(describing: listingId)), listingRevision: \(Swift.String(describing: listingRevision)), listingUpdatedBy: \(Swift.String(describing: listingUpdatedBy)), owningProjectId: \(Swift.String(describing: owningProjectId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The data product.
    public struct DataProductResultItem: Swift.Sendable {
        /// The timestamp at which the data product was created.
        public var createdAt: Foundation.Date?
        /// The user who created the data product.
        public var createdBy: Swift.String?
        /// The description of the data product.
        public var description: Swift.String?
        /// The ID of the domain where the data product lives.
        /// This member is required.
        public var domainId: Swift.String?
        /// The timestamp at which first revision of the data product was created.
        public var firstRevisionCreatedAt: Foundation.Date?
        /// The user who created the first revision of the data product.
        public var firstRevisionCreatedBy: Swift.String?
        /// The glossary terms of the data product.
        public var glossaryTerms: [Swift.String]?
        /// The ID of the data product.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the data product.
        /// This member is required.
        public var name: Swift.String?
        /// The ID of the owning project of the data product.
        /// This member is required.
        public var owningProjectId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            firstRevisionCreatedAt: Foundation.Date? = nil,
            firstRevisionCreatedBy: Swift.String? = nil,
            glossaryTerms: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
        }
    }
}

extension DataZoneClientTypes.DataProductResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataProductResultItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), firstRevisionCreatedAt: \(Swift.String(describing: firstRevisionCreatedAt)), firstRevisionCreatedBy: \(Swift.String(describing: firstRevisionCreatedBy)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The data product revision.
    public struct DataProductRevision: Swift.Sendable {
        /// The timestamp at which the data product revision was created.
        public var createdAt: Foundation.Date?
        /// The user who created the data product revision.
        public var createdBy: Swift.String?
        /// The ID of the domain where the data product revision lives.
        public var domainId: Swift.String?
        /// The ID of the data product revision.
        public var id: Swift.String?
        /// The data product revision.
        public var revision: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }
    }
}

public struct DeleteDataSourceInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source that is deleted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
    public var retainPermissionsOnRevokeFailure: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        retainPermissionsOnRevokeFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
    }
}

extension DataZoneClientTypes {

    public enum SelfGrantStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case granted
        case grantFailed
        case grantInProgress
        case grantPending
        case revokeFailed
        case revokeInProgress
        case revokePending
        case sdkUnknown(Swift.String)

        public static var allCases: [SelfGrantStatus] {
            return [
                .granted,
                .grantFailed,
                .grantInProgress,
                .grantPending,
                .revokeFailed,
                .revokeInProgress,
                .revokePending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .granted: return "GRANTED"
            case .grantFailed: return "GRANT_FAILED"
            case .grantInProgress: return "GRANT_IN_PROGRESS"
            case .grantPending: return "GRANT_PENDING"
            case .revokeFailed: return "REVOKE_FAILED"
            case .revokeInProgress: return "REVOKE_IN_PROGRESS"
            case .revokePending: return "REVOKE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details for the self granting status.
    public struct SelfGrantStatusDetail: Swift.Sendable {
        /// The name of the database used for the data source.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The reason for why the operation failed.
        public var failureCause: Swift.String?
        /// The name of the schema used in the data source.
        public var schemaName: Swift.String?
        /// The self granting status of the data source.
        /// This member is required.
        public var status: DataZoneClientTypes.SelfGrantStatus?

        public init(
            databaseName: Swift.String? = nil,
            failureCause: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            status: DataZoneClientTypes.SelfGrantStatus? = nil
        )
        {
            self.databaseName = databaseName
            self.failureCause = failureCause
            self.schemaName = schemaName
            self.status = status
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the self granting status.
    public struct GlueSelfGrantStatusOutput: Swift.Sendable {
        /// The details for the self granting status for a Glue data source.
        /// This member is required.
        public var selfGrantStatusDetails: [DataZoneClientTypes.SelfGrantStatusDetail]?

        public init(
            selfGrantStatusDetails: [DataZoneClientTypes.SelfGrantStatusDetail]? = nil
        )
        {
            self.selfGrantStatusDetails = selfGrantStatusDetails
        }
    }
}

extension DataZoneClientTypes {

    /// The details for the self granting status for an Amazon Redshift data source.
    public struct RedshiftSelfGrantStatusOutput: Swift.Sendable {
        /// The details for the self granting status for an Amazon Redshift data source.
        /// This member is required.
        public var selfGrantStatusDetails: [DataZoneClientTypes.SelfGrantStatusDetail]?

        public init(
            selfGrantStatusDetails: [DataZoneClientTypes.SelfGrantStatusDetail]? = nil
        )
        {
            self.selfGrantStatusDetails = selfGrantStatusDetails
        }
    }
}

extension DataZoneClientTypes {

    /// The details for the self granting status for a data source.
    public enum SelfGrantStatusOutput: Swift.Sendable {
        /// The details for the self granting status for a Glue data source.
        case glueselfgrantstatus(DataZoneClientTypes.GlueSelfGrantStatusOutput)
        /// The details for the self granting status for an Amazon Redshift data source.
        case redshiftselfgrantstatus(DataZoneClientTypes.RedshiftSelfGrantStatusOutput)
        case sdkUnknown(Swift.String)
    }
}

public struct DeleteDataSourceOutput: Swift.Sendable {
    /// The asset data forms associated with this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source that is deleted.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when this data source was created.
    public var createdAt: Foundation.Date?
    /// The description of the data source that is deleted.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting of the data source that specifies whether the data source is enabled or disabled.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environemnt associated with this data source.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: Foundation.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of this data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source that is deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project in which this data source exists and from which it's deleted.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
    public var retainPermissionsOnRevokeFailure: Swift.Bool?
    /// The schedule of runs for this data source.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// Specifies the status of the self-granting functionality.
    public var selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput?
    /// The status of this data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of this data source.
    public var type: Swift.String?
    /// The timestamp of when this data source was updated.
    public var updatedAt: Foundation.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: Foundation.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        retainPermissionsOnRevokeFailure: Swift.Bool? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
        self.schedule = schedule
        self.selfGrantStatus = selfGrantStatus
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension DeleteDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), retainPermissionsOnRevokeFailure: \(Swift.String(describing: retainPermissionsOnRevokeFailure)), selfGrantStatus: \(Swift.String(describing: selfGrantStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

public struct GetDataSourceInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone data source.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetDataSourceOutput: Swift.Sendable {
    /// The metadata forms attached to the assets created by this data source.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration of the data source.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was created.
    public var createdAt: Foundation.Date?
    /// The description of the data source.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the data source exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies whether this data source is enabled or not.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The ID of the environment where this data source creates and publishes assets,
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source.
    /// This member is required.
    public var id: Swift.String?
    /// The number of assets created by the data source during its last run.
    public var lastRunAssetCount: Swift.Int?
    /// The timestamp of the last run of the data source.
    public var lastRunAt: Foundation.Date?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The status of the last run of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project where the data source creates and publishes assets.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
    public var publishOnImport: Swift.Bool?
    /// The recommendation configuration of the data source.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// The schedule of the data source runs.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// Specifies the status of the self-granting functionality.
    public var selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: Foundation.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAssetCount: Swift.Int? = nil,
        lastRunAt: Foundation.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAssetCount = lastRunAssetCount
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.schedule = schedule
        self.selfGrantStatus = selfGrantStatus
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension GetDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), selfGrantStatus: \(Swift.String(describing: selfGrantStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

public struct ListDataSourcesInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which to list the data sources.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which to list the data sources.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of data sources to return in a single call to ListDataSources. When the number of data sources to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSources to list the next set of data sources.
    public var maxResults: Swift.Int?
    /// The name of the data source.
    public var name: Swift.String?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?
    /// The identifier of the project in which to list data sources.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type of the data source.
    public var type: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.status = status
        self.type = type
    }
}

extension ListDataSourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSourcesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the data source.
    public struct DataSourceSummary: Swift.Sendable {
        /// The timestamp of when the data source was created.
        public var createdAt: Foundation.Date?
        /// The ID of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// Specifies whether the data source is enabled.
        public var enableSetting: DataZoneClientTypes.EnableSetting?
        /// The ID of the environment in which the data source exists.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The count of the assets created during the last data source run.
        public var lastRunAssetCount: Swift.Int?
        /// The timestamp of when the data source run was last performed.
        public var lastRunAt: Foundation.Date?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The status of the last data source run.
        public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The details of the schedule of the data source runs.
        public var schedule: DataZoneClientTypes.ScheduleConfiguration?
        /// The status of the data source.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceStatus?
        /// The type of the data source.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the data source was updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            dataSourceId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            enableSetting: DataZoneClientTypes.EnableSetting? = nil,
            environmentId: Swift.String? = nil,
            lastRunAssetCount: Swift.Int? = nil,
            lastRunAt: Foundation.Date? = nil,
            lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
            name: Swift.String? = nil,
            schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
            status: DataZoneClientTypes.DataSourceStatus? = nil,
            type: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.DataSourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceSummary(createdAt: \(Swift.String(describing: createdAt)), dataSourceId: \(Swift.String(describing: dataSourceId)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), lastRunAssetCount: \(Swift.String(describing: lastRunAssetCount)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

public struct ListDataSourcesOutput: Swift.Sendable {
    /// The results of the ListDataSources action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceSummary]?
    /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateDataSourceInput: Swift.Sendable {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsInput: [DataZoneClientTypes.FormInput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationInput?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the domain in which to update a data source.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDataSource action.
    public var name: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
    public var retainPermissionsOnRevokeFailure: Swift.Bool?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?

    public init(
        assetFormsInput: [DataZoneClientTypes.FormInput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationInput? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        retainPermissionsOnRevokeFailure: Swift.Bool? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil
    )
    {
        self.assetFormsInput = assetFormsInput
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.enableSetting = enableSetting
        self.identifier = identifier
        self.name = name
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
        self.schedule = schedule
    }
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), enableSetting: \(Swift.String(describing: enableSetting)), identifier: \(Swift.String(describing: identifier)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), retainPermissionsOnRevokeFailure: \(Swift.String(describing: retainPermissionsOnRevokeFailure)), assetFormsInput: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

public struct UpdateDataSourceOutput: Swift.Sendable {
    /// The asset forms to be updated as part of the UpdateDataSource action.
    public var assetFormsOutput: [DataZoneClientTypes.FormOutput]?
    /// The configuration to be updated as part of the UpdateDataSource action.
    public var configuration: DataZoneClientTypes.DataSourceConfigurationOutput?
    /// The timestamp of when the data source was updated.
    public var createdAt: Foundation.Date?
    /// The description to be updated as part of the UpdateDataSource action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a data source is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enable setting to be updated as part of the UpdateDataSource action.
    public var enableSetting: DataZoneClientTypes.EnableSetting?
    /// The identifier of the environment in which a data source is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the data source was last run.
    public var lastRunAt: Foundation.Date?
    /// The last run error message of the data source.
    public var lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The last run status of the data source.
    public var lastRunStatus: DataZoneClientTypes.DataSourceRunStatus?
    /// The name to be updated as part of the UpdateDataSource action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project where data source is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The publish on import setting to be updated as part of the UpdateDataSource action.
    public var publishOnImport: Swift.Bool?
    /// The recommendation to be updated as part of the UpdateDataSource action.
    public var recommendation: DataZoneClientTypes.RecommendationConfiguration?
    /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
    public var retainPermissionsOnRevokeFailure: Swift.Bool?
    /// The schedule to be updated as part of the UpdateDataSource action.
    public var schedule: DataZoneClientTypes.ScheduleConfiguration?
    /// Specifies the status of the self-granting functionality.
    public var selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput?
    /// The status to be updated as part of the UpdateDataSource action.
    public var status: DataZoneClientTypes.DataSourceStatus?
    /// The type to be updated as part of the UpdateDataSource action.
    public var type: Swift.String?
    /// The timestamp of when the data source was updated.
    public var updatedAt: Foundation.Date?

    public init(
        assetFormsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        configuration: DataZoneClientTypes.DataSourceConfigurationOutput? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enableSetting: DataZoneClientTypes.EnableSetting? = nil,
        environmentId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        lastRunAt: Foundation.Date? = nil,
        lastRunErrorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        lastRunStatus: DataZoneClientTypes.DataSourceRunStatus? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        publishOnImport: Swift.Bool? = nil,
        recommendation: DataZoneClientTypes.RecommendationConfiguration? = nil,
        retainPermissionsOnRevokeFailure: Swift.Bool? = nil,
        schedule: DataZoneClientTypes.ScheduleConfiguration? = nil,
        selfGrantStatus: DataZoneClientTypes.SelfGrantStatusOutput? = nil,
        status: DataZoneClientTypes.DataSourceStatus? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.assetFormsOutput = assetFormsOutput
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.enableSetting = enableSetting
        self.environmentId = environmentId
        self.errorMessage = errorMessage
        self.id = id
        self.lastRunAt = lastRunAt
        self.lastRunErrorMessage = lastRunErrorMessage
        self.lastRunStatus = lastRunStatus
        self.name = name
        self.projectId = projectId
        self.publishOnImport = publishOnImport
        self.recommendation = recommendation
        self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
        self.schedule = schedule
        self.selfGrantStatus = selfGrantStatus
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension UpdateDataSourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceOutput(assetFormsOutput: \(Swift.String(describing: assetFormsOutput)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), enableSetting: \(Swift.String(describing: enableSetting)), environmentId: \(Swift.String(describing: environmentId)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), lastRunAt: \(Swift.String(describing: lastRunAt)), lastRunErrorMessage: \(Swift.String(describing: lastRunErrorMessage)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), projectId: \(Swift.String(describing: projectId)), publishOnImport: \(Swift.String(describing: publishOnImport)), recommendation: \(Swift.String(describing: recommendation)), retainPermissionsOnRevokeFailure: \(Swift.String(describing: retainPermissionsOnRevokeFailure)), selfGrantStatus: \(Swift.String(describing: selfGrantStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", schedule: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum DataSourceRunType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case prioritized
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceRunType] {
            return [
                .prioritized,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .prioritized: return "PRIORITIZED"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDataSourceRunInput: Swift.Sendable {
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the data source run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    /// The asset statistics from the data source run.
    public struct RunStatisticsForAssets: Swift.Sendable {
        /// The added statistic for the data source run.
        public var added: Swift.Int?
        /// The failed statistic for the data source run.
        public var failed: Swift.Int?
        /// The skipped statistic for the data source run.
        public var skipped: Swift.Int?
        /// The unchanged statistic for the data source run.
        public var unchanged: Swift.Int?
        /// The updated statistic for the data source run.
        public var updated: Swift.Int?

        public init(
            added: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            unchanged: Swift.Int? = nil,
            updated: Swift.Int? = nil
        )
        {
            self.added = added
            self.failed = failed
            self.skipped = skipped
            self.unchanged = unchanged
            self.updated = updated
        }
    }
}

public struct GetDataSourceRunOutput: Swift.Sendable {
    /// The timestamp of when the data source run was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The configuration snapshot of the data source run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The ID of the data source for this data source run.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The ID of the domain in which this data source run was performed.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The ID of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project in which this data source run occured.
    /// This member is required.
    public var projectId: Swift.String?
    /// The asset statistics from this data source run.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when this data source run started.
    public var startedAt: Foundation.Date?
    /// The status of this data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when this data source run stopped.
    public var stoppedAt: Foundation.Date?
    /// The type of this data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when this data source run was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: Foundation.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: Foundation.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct ListDataSourceRunsInput: Swift.Sendable {
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to invoke the ListDataSourceRuns action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of runs to return in a single call to ListDataSourceRuns. When the number of runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var maxResults: Swift.Int?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DataSourceRunStatus?

    public init(
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil
    )
    {
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension DataZoneClientTypes {

    /// The details of a data source run.
    public struct DataSourceRunSummary: Swift.Sendable {
        /// The timestamp of when a data source run was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The identifier of the data source of the data source run.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The identifier of the data source run.
        /// This member is required.
        public var id: Swift.String?
        /// The project ID of the data source run.
        /// This member is required.
        public var projectId: Swift.String?
        /// The asset statistics from the data source run.
        public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
        /// The timestamp of when a data source run was started.
        public var startedAt: Foundation.Date?
        /// The status of the data source run.
        /// This member is required.
        public var status: DataZoneClientTypes.DataSourceRunStatus?
        /// The timestamp of when a data source run was stopped.
        public var stoppedAt: Foundation.Date?
        /// The type of the data source run.
        /// This member is required.
        public var type: DataZoneClientTypes.DataSourceRunType?
        /// The timestamp of when a data source run was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            dataSourceId: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            id: Swift.String? = nil,
            projectId: Swift.String? = nil,
            runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
            startedAt: Foundation.Date? = nil,
            status: DataZoneClientTypes.DataSourceRunStatus? = nil,
            stoppedAt: Foundation.Date? = nil,
            type: DataZoneClientTypes.DataSourceRunType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListDataSourceRunsOutput: Swift.Sendable {
    /// The results of the ListDataSourceRuns action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunSummary]?
    /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartDataSourceRunInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceIdentifier = dataSourceIdentifier
        self.domainIdentifier = domainIdentifier
    }
}

public struct StartDataSourceRunOutput: Swift.Sendable {
    /// The timestamp of when data source run was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The configuration snapshot of the data source that is being run.
    public var dataSourceConfigurationSnapshot: Swift.String?
    /// The identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the Amazon DataZone domain in which to start a data source run.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
    /// The identifier of the data source run.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// Specifies run statistics for assets.
    public var runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets?
    /// The timestamp of when the data source run was started.
    public var startedAt: Foundation.Date?
    /// The status of the data source run.
    /// This member is required.
    public var status: DataZoneClientTypes.DataSourceRunStatus?
    /// The timestamp of when the data source run was stopped.
    public var stoppedAt: Foundation.Date?
    /// The type of the data source run.
    /// This member is required.
    public var type: DataZoneClientTypes.DataSourceRunType?
    /// The timestamp of when the data source run was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        dataSourceConfigurationSnapshot: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
        id: Swift.String? = nil,
        projectId: Swift.String? = nil,
        runStatisticsForAssets: DataZoneClientTypes.RunStatisticsForAssets? = nil,
        startedAt: Foundation.Date? = nil,
        status: DataZoneClientTypes.DataSourceRunStatus? = nil,
        stoppedAt: Foundation.Date? = nil,
        type: DataZoneClientTypes.DataSourceRunType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
        self.dataSourceId = dataSourceId
        self.domainId = domainId
        self.errorMessage = errorMessage
        self.id = id
        self.projectId = projectId
        self.runStatisticsForAssets = runStatisticsForAssets
        self.startedAt = startedAt
        self.status = status
        self.stoppedAt = stoppedAt
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension DataZoneClientTypes {

    /// The activity details of the data source run.
    public struct DataSourceRunActivity: Swift.Sendable {
        /// The timestamp of when data source run activity was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The identifier of the asset included in the data source run activity.
        public var dataAssetId: Swift.String?
        /// The status of the asset included in the data source run activity.
        /// This member is required.
        public var dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus?
        /// The identifier of the data source for the data source run activity.
        /// This member is required.
        public var dataSourceRunId: Swift.String?
        /// The database included in the data source run activity.
        /// This member is required.
        public var database: Swift.String?
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public var errorMessage: DataZoneClientTypes.DataSourceErrorMessage?
        /// The project ID included in the data source run activity.
        /// This member is required.
        public var projectId: Swift.String?
        /// The technical description included in the data source run activity.
        public var technicalDescription: Swift.String?
        /// The technical name included in the data source run activity.
        /// This member is required.
        public var technicalName: Swift.String?
        /// The timestamp of when data source run activity was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            dataAssetId: Swift.String? = nil,
            dataAssetStatus: DataZoneClientTypes.DataAssetActivityStatus? = nil,
            dataSourceRunId: Swift.String? = nil,
            database: Swift.String? = nil,
            errorMessage: DataZoneClientTypes.DataSourceErrorMessage? = nil,
            projectId: Swift.String? = nil,
            technicalDescription: Swift.String? = nil,
            technicalName: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAssetId = dataAssetId
            self.dataAssetStatus = dataAssetStatus
            self.dataSourceRunId = dataSourceRunId
            self.database = database
            self.errorMessage = errorMessage
            self.projectId = projectId
            self.technicalDescription = technicalDescription
            self.technicalName = technicalName
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.DataSourceRunActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceRunActivity(createdAt: \(Swift.String(describing: createdAt)), dataAssetId: \(Swift.String(describing: dataAssetId)), dataAssetStatus: \(Swift.String(describing: dataAssetStatus)), dataSourceRunId: \(Swift.String(describing: dataSourceRunId)), errorMessage: \(Swift.String(describing: errorMessage)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), database: \"CONTENT_REDACTED\", technicalDescription: \"CONTENT_REDACTED\", technicalName: \"CONTENT_REDACTED\")"}
}

public struct DeleteAssetFilterInput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The ID of the domain where you want to delete an asset filter.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset filter that you want to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteEnvironmentInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the environment is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteEnvironmentActionInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which an environment action is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment where an environment action is deleted.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the environment action that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

public struct DeleteEnvironmentProfileInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the environment profile is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteProjectInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the project is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the project that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the optional flag to delete all child entities within the project.
    public var skipDeletionCheck: Swift.Bool?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        skipDeletionCheck: Swift.Bool? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.skipDeletionCheck = skipDeletionCheck
    }
}

public struct DeleteProjectOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProjectMembershipInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain where project membership is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The project member whose project membership is deleted.
    /// This member is required.
    public var member: DataZoneClientTypes.Member?
    /// The ID of the Amazon DataZone project the membership to which is deleted.
    /// This member is required.
    public var projectIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        member: DataZoneClientTypes.Member? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.member = member
        self.projectIdentifier = projectIdentifier
    }
}

public struct DeleteProjectMembershipOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSubscriptionGrantInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain where the subscription grant is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteSubscriptionGrantOutput: Swift.Sendable {
    /// The assets for which the subsctiption grant that is deleted gave access.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant that is deleted was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription grant that is deleted.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant is deleted.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is deleted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant that is deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant that is deleted.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subsctiption whose subscription grant is to be deleted.
    @available(*, deprecated, message: "Multiple subscriptions can exist for a single grant")
    public var subscriptionId: Swift.String?
    /// The ID of the subscription target associated with the subscription grant that is deleted.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant that is deleted was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription grant that is deleted.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct DeleteSubscriptionRequestInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the subscription request is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription request that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteSubscriptionTargetInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the subscription target is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment in which the subscription target is deleted.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    public enum TimeSeriesEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case listing
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesEntityType] {
            return [
                .asset,
                .listing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .listing: return "LISTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteTimeSeriesDataPointsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain that houses the asset for which you want to delete a time series form.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to delete a time series form.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to delete a time series form.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series form that you want to delete.
    /// This member is required.
    public var formName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
    }
}

public struct DeleteTimeSeriesDataPointsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateEnvironmentRoleInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which an environment role is disassociated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ARN of the environment role.
    /// This member is required.
    public var environmentRoleArn: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        environmentRoleArn: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.environmentRoleArn = environmentRoleArn
    }
}

public struct DisassociateEnvironmentRoleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Web Services domain that is to be deleted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the optional flag to delete all child entities within the domain.
    public var skipDeletionCheck: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        skipDeletionCheck: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.identifier = identifier
        self.skipDeletionCheck = skipDeletionCheck
    }
}

public struct DeleteDomainOutput: Swift.Sendable {
    /// The status of the domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.status = status
    }
}

public struct GetDomainInput: Swift.Sendable {
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetDomainOutput: Swift.Sendable {
    /// The ARN of the specified Amazon DataZone domain.
    public var arn: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was created.
    public var createdAt: Foundation.Date?
    /// The description of the Amazon DataZone domain.
    public var description: Swift.String?
    /// The domain execution role with which the Amazon DataZone domain is created.
    /// This member is required.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the specified Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
    public var kmsKeyIdentifier: Swift.String?
    /// The timestamp of when the Amazon DataZone domain was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the Amazon DataZone domain.
    public var name: Swift.String?
    /// The URL of the data portal for this Amazon DataZone domain.
    public var portalUrl: Swift.String?
    /// The ID of the root domain in Amazon Datazone.
    public var rootDomainUnitId: Swift.String?
    /// The single sing-on option of the specified Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?
    /// The status of the specified Amazon DataZone domain.
    /// This member is required.
    public var status: DataZoneClientTypes.DomainStatus?
    /// The tags specified for the Amazon DataZone domain.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        portalUrl: Swift.String? = nil,
        rootDomainUnitId: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.portalUrl = portalUrl
        self.rootDomainUnitId = rootDomainUnitId
        self.singleSignOn = singleSignOn
        self.status = status
        self.tags = tags
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of domains to return in a single call to ListDomains. When the number of domains to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomains to list the next set of domains.
    public var maxResults: Swift.Int?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?
    /// The status of the data source.
    public var status: DataZoneClientTypes.DomainStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DomainStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension DataZoneClientTypes {

    /// A summary of a Amazon DataZone domain.
    public struct DomainSummary: Swift.Sendable {
        /// The ARN of the Amazon DataZone domain.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of an Amazon DataZone domain.
        public var description: Swift.String?
        /// The ID of the Amazon DataZone domain.
        /// This member is required.
        public var id: Swift.String?
        /// A timestamp of when a Amazon DataZone domain was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The identifier of the Amazon Web Services account that manages the domain.
        /// This member is required.
        public var managedAccountId: Swift.String?
        /// A name of an Amazon DataZone domain.
        /// This member is required.
        public var name: Swift.String?
        /// The data portal URL for the Amazon DataZone domain.
        public var portalUrl: Swift.String?
        /// The status of the Amazon DataZone domain.
        /// This member is required.
        public var status: DataZoneClientTypes.DomainStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            managedAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            portalUrl: Swift.String? = nil,
            status: DataZoneClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.managedAccountId = managedAccountId
            self.name = name
            self.portalUrl = portalUrl
            self.status = status
        }
    }
}

extension DataZoneClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), managedAccountId: \(Swift.String(describing: managedAccountId)), portalUrl: \(Swift.String(describing: portalUrl)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListDomainsOutput: Swift.Sendable {
    /// The results of the ListDomains action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DomainSummary]?
    /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateDomainInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The ID of the Amazon Web Services domain that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The single sign-on option to be updated as part of the UpdateDomain action.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.identifier = identifier
        self.name = name
        self.singleSignOn = singleSignOn
    }
}

public struct UpdateDomainOutput: Swift.Sendable {
    /// The description to be updated as part of the UpdateDomain action.
    public var description: Swift.String?
    /// The domain execution role to be updated as part of the UpdateDomain action.
    public var domainExecutionRole: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the timestamp of when the domain was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name to be updated as part of the UpdateDomain action.
    public var name: Swift.String?
    /// The ID of the root domain unit.
    public var rootDomainUnitId: Swift.String?
    /// The single sign-on option of the Amazon DataZone domain.
    public var singleSignOn: DataZoneClientTypes.SingleSignOn?

    public init(
        description: Swift.String? = nil,
        domainExecutionRole: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        rootDomainUnitId: Swift.String? = nil,
        singleSignOn: DataZoneClientTypes.SingleSignOn? = nil
    )
    {
        self.description = description
        self.domainExecutionRole = domainExecutionRole
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.rootDomainUnitId = rootDomainUnitId
        self.singleSignOn = singleSignOn
    }
}

public struct DeleteDomainUnitInput: Swift.Sendable {
    /// The ID of the domain where you want to delete a domain unit.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the domain unit that you want to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteDomainUnitOutput: Swift.Sendable {

    public init() { }
}

public struct GetDomainUnitInput: Swift.Sendable {
    /// The ID of the domain where you want to get a domain unit.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the domain unit that you want to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetDomainUnitOutput: Swift.Sendable {
    /// The time stamp at which the domain unit was created.
    public var createdAt: Foundation.Date?
    /// The user who created the domain unit.
    public var createdBy: Swift.String?
    /// The description of the domain unit.
    public var description: Swift.String?
    /// The ID of the domain in which the domain unit lives.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp at which the domain unit was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The user who last updated the domain unit.
    public var lastUpdatedBy: Swift.String?
    /// The name of the domain unit.
    /// This member is required.
    public var name: Swift.String?
    /// The owners of the domain unit.
    /// This member is required.
    public var owners: [DataZoneClientTypes.DomainUnitOwnerProperties]?
    /// The ID of the parent domain unit.
    public var parentDomainUnitId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        owners: [DataZoneClientTypes.DomainUnitOwnerProperties]? = nil,
        parentDomainUnitId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.name = name
        self.owners = owners
        self.parentDomainUnitId = parentDomainUnitId
    }
}

extension GetDomainUnitOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainUnitOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), owners: \(Swift.String(describing: owners)), parentDomainUnitId: \(Swift.String(describing: parentDomainUnitId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListDomainUnitsForParentInput: Swift.Sendable {
    /// The ID of the domain in which you want to list domain units for a parent domain unit.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of domain units to return in a single call to ListDomainUnitsForParent. When the number of domain units to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
    public var maxResults: Swift.Int?
    /// When the number of domain units is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domain units, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
    public var nextToken: Swift.String?
    /// The ID of the parent domain unit.
    /// This member is required.
    public var parentDomainUnitIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parentDomainUnitIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parentDomainUnitIdentifier = parentDomainUnitIdentifier
    }
}

extension DataZoneClientTypes {

    /// The summary of the domain unit.
    public struct DomainUnitSummary: Swift.Sendable {
        /// The ID of the domain unit summary.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the domain unit summary.
        /// This member is required.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

public struct ListDomainUnitsForParentOutput: Swift.Sendable {
    /// The results returned by this action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DomainUnitSummary]?
    /// When the number of domain units is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domain units, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DomainUnitSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateDomainUnitInput: Swift.Sendable {
    /// The description of the domain unit that you want to update.
    public var description: Swift.String?
    /// The ID of the domain where you want to update a domain unit.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the domain unit that you want to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the domain unit that you want to update.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateDomainUnitInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainUnitInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateDomainUnitOutput: Swift.Sendable {
    /// The time stamp at which the domain unit that you want to update was created.
    public var createdAt: Foundation.Date?
    /// The user who created the domain unit that you want to update.
    public var createdBy: Swift.String?
    /// The description of the domain unit that you want to update.
    public var description: Swift.String?
    /// The ID of the domain where you want to update the domain unit.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp at which the domain unit was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The user who last updated the domain unit.
    public var lastUpdatedBy: Swift.String?
    /// The name of the domain unit that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// The owners of the domain unit that you want to update.
    /// This member is required.
    public var owners: [DataZoneClientTypes.DomainUnitOwnerProperties]?
    /// The ID of the parent domain unit.
    public var parentDomainUnitId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        owners: [DataZoneClientTypes.DomainUnitOwnerProperties]? = nil,
        parentDomainUnitId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.name = name
        self.owners = owners
        self.parentDomainUnitId = parentDomainUnitId
    }
}

extension UpdateDomainUnitOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainUnitOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), owners: \(Swift.String(describing: owners)), parentDomainUnitId: \(Swift.String(describing: parentDomainUnitId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct DeleteEnvironmentBlueprintConfigurationInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the blueprint configuration is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the blueprint the configuration of which is deleted.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

public struct DeleteEnvironmentBlueprintConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct GetEnvironmentBlueprintConfigurationInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// He ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
    }
}

extension DataZoneClientTypes {

    /// The Lake Formation configuration of the Data Lake blueprint.
    public struct LakeFormationConfiguration: Swift.Sendable {
        /// Specifies certain Amazon S3 locations if you do not want Amazon DataZone to automatically register them in hybrid mode.
        public var locationRegistrationExcludeS3Locations: [Swift.String]?
        /// The role that is used to manage read/write access to the chosen Amazon S3 bucket(s) for Data Lake using AWS Lake Formation hybrid access mode.
        public var locationRegistrationRole: Swift.String?

        public init(
            locationRegistrationExcludeS3Locations: [Swift.String]? = nil,
            locationRegistrationRole: Swift.String? = nil
        )
        {
            self.locationRegistrationExcludeS3Locations = locationRegistrationExcludeS3Locations
            self.locationRegistrationRole = locationRegistrationRole
        }
    }
}

extension DataZoneClientTypes {

    /// The provisioning configuration of the blueprint.
    public enum ProvisioningConfiguration: Swift.Sendable {
        /// The Lake Formation configuration of the Data Lake blueprint.
        case lakeformationconfiguration(DataZoneClientTypes.LakeFormationConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct GetEnvironmentBlueprintConfigurationOutput: Swift.Sendable {
    /// The timestamp of when this blueprint was created.
    public var createdAt: Foundation.Date?
    /// The ID of the Amazon DataZone domain where this blueprint exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The Amazon Web Services regions in which this blueprint is enabled.
    public var enabledRegions: [Swift.String]?
    /// The ID of the blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role with which this blueprint is created.
    public var manageAccessRoleArn: Swift.String?
    /// The provisioning configuration of a blueprint.
    public var provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]?
    /// The ARN of the provisioning role with which this blueprint is created.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters of the blueprint.
    public var regionalParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The timestamp of when this blueprint was upated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningConfigurations = provisioningConfigurations
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

public struct ListEnvironmentBlueprintConfigurationsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of blueprint configurations to return in a single call to ListEnvironmentBlueprintConfigurations. When the number of configurations to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var maxResults: Swift.Int?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    /// The configuration details of an environment blueprint.
    public struct EnvironmentBlueprintConfigurationItem: Swift.Sendable {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the Amazon DataZone domain in which an environment blueprint exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The enabled Amazon Web Services Regions specified in a blueprint configuration.
        public var enabledRegions: [Swift.String]?
        /// The identifier of the environment blueprint.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The ARN of the manage access role specified in the environment blueprint configuration.
        public var manageAccessRoleArn: Swift.String?
        /// The provisioning configuration of a blueprint.
        public var provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]?
        /// The ARN of the provisioning role specified in the environment blueprint configuration.
        public var provisioningRoleArn: Swift.String?
        /// The regional parameters of the environment blueprint.
        public var regionalParameters: [Swift.String: [Swift.String: Swift.String]]?
        /// The timestamp of when the environment blueprint was updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            domainId: Swift.String? = nil,
            enabledRegions: [Swift.String]? = nil,
            environmentBlueprintId: Swift.String? = nil,
            manageAccessRoleArn: Swift.String? = nil,
            provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]? = nil,
            provisioningRoleArn: Swift.String? = nil,
            regionalParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningConfigurations = provisioningConfigurations
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }
    }
}

public struct ListEnvironmentBlueprintConfigurationsOutput: Swift.Sendable {
    /// The results of the ListEnvironmentBlueprintConfigurations action.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]?
    /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct PutEnvironmentBlueprintConfigurationInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    /// This member is required.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The provisioning configuration of a blueprint.
    public var provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String: [Swift.String: Swift.String]]?

    public init(
        domainIdentifier: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String: [Swift.String: Swift.String]]? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.enabledRegions = enabledRegions
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningConfigurations = provisioningConfigurations
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
    }
}

public struct PutEnvironmentBlueprintConfigurationOutput: Swift.Sendable {
    /// The timestamp of when the environment blueprint was created.
    public var createdAt: Foundation.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Specifies the enabled Amazon Web Services Regions.
    public var enabledRegions: [Swift.String]?
    /// The identifier of the environment blueprint.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ARN of the manage access role.
    public var manageAccessRoleArn: Swift.String?
    /// The provisioning configuration of a blueprint.
    public var provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]?
    /// The ARN of the provisioning role.
    public var provisioningRoleArn: Swift.String?
    /// The regional parameters in the environment blueprint.
    public var regionalParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The timestamp of when the environment blueprint was updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        domainId: Swift.String? = nil,
        enabledRegions: [Swift.String]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        manageAccessRoleArn: Swift.String? = nil,
        provisioningConfigurations: [DataZoneClientTypes.ProvisioningConfiguration]? = nil,
        provisioningRoleArn: Swift.String? = nil,
        regionalParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.domainId = domainId
        self.enabledRegions = enabledRegions
        self.environmentBlueprintId = environmentBlueprintId
        self.manageAccessRoleArn = manageAccessRoleArn
        self.provisioningConfigurations = provisioningConfigurations
        self.provisioningRoleArn = provisioningRoleArn
        self.regionalParameters = regionalParameters
        self.updatedAt = updatedAt
    }
}

public struct DeleteFormTypeInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the metadata form type is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type that is deleted.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
    }
}

public struct DeleteFormTypeOutput: Swift.Sendable {

    public init() { }
}

public struct GetFormTypeInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the metadata form type.
    /// This member is required.
    public var formTypeIdentifier: Swift.String?
    /// The revision of this metadata form type.
    public var revision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        formTypeIdentifier: Swift.String? = nil,
        revision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.formTypeIdentifier = formTypeIdentifier
        self.revision = revision
    }
}

extension DataZoneClientTypes {

    /// The details of the import of the metadata form type.
    public struct Import: Swift.Sendable {
        /// The name of the import.
        /// This member is required.
        public var name: Swift.String?
        /// The revision of the import.
        /// This member is required.
        public var revision: Swift.String?

        public init(
            name: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.name = name
            self.revision = revision
        }
    }
}

extension DataZoneClientTypes.Import: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Import(revision: \(Swift.String(describing: revision)), name: \"CONTENT_REDACTED\")"}
}

public struct GetFormTypeOutput: Swift.Sendable {
    /// The timestamp of when this metadata form type was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created this metadata form type.
    public var createdBy: Swift.String?
    /// The description of the metadata form type.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this metadata form type exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The imports of the metadata form type.
    public var imports: [DataZoneClientTypes.Import]?
    /// The model of the metadata form type.
    /// This member is required.
    public var model: DataZoneClientTypes.Model?
    /// The name of the metadata form type.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone domain in which the metadata form type was originally created.
    public var originDomainId: Swift.String?
    /// The ID of the project in which this metadata form type was originally created.
    public var originProjectId: Swift.String?
    /// The ID of the project that owns this metadata form type.
    public var owningProjectId: Swift.String?
    /// The revision of the metadata form type.
    /// This member is required.
    public var revision: Swift.String?
    /// The status of the metadata form type.
    public var status: DataZoneClientTypes.FormTypeStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        imports: [DataZoneClientTypes.Import]? = nil,
        model: DataZoneClientTypes.Model? = nil,
        name: Swift.String? = nil,
        originDomainId: Swift.String? = nil,
        originProjectId: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        revision: Swift.String? = nil,
        status: DataZoneClientTypes.FormTypeStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.imports = imports
        self.model = model
        self.name = name
        self.originDomainId = originDomainId
        self.originProjectId = originProjectId
        self.owningProjectId = owningProjectId
        self.revision = revision
        self.status = status
    }
}

extension GetFormTypeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFormTypeOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetAssetFilterInput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The ID of the domain where you want to get an asset filter.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset filter.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetEnvironmentInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the Amazon DataZone environment.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetEnvironmentOutput: Swift.Sendable {
    /// The ID of the Amazon Web Services account where the environment exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where the environment exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties of the environment.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of the environment.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where the environment exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The actions of the environment.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint with which the environment is created.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile with which the environment is created.
    public var environmentProfileId: Swift.String?
    /// The business glossary terms that can be used in this environment.
    public var glossaryTerms: [Swift.String]?
    /// The ID of the environment.
    public var id: Swift.String?
    /// The details of the last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment is created.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of this Amazon DataZone environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources of this Amazon DataZone environment.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties of this Amazon DataZone environment.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status of this Amazon DataZone environment.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when this environment was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters of this Amazon DataZone environment.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = "",
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension GetEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetEnvironmentActionInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the GetEnvironmentAction API is invoked.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The environment ID of the environment action.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the environment action
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

public struct GetEnvironmentActionOutput: Swift.Sendable {
    /// The description of the environment action.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the environment action lives.
    /// This member is required.
    public var domainId: Swift.String?
    /// The environment ID of the environment action.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the environment action.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment action.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters of the environment action.
    /// This member is required.
    public var parameters: DataZoneClientTypes.ActionParameters?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: DataZoneClientTypes.ActionParameters? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.name = name
        self.parameters = parameters
    }
}

public struct GetEnvironmentBlueprintInput: Swift.Sendable {
    /// The identifier of the domain in which this blueprint exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetEnvironmentBlueprintOutput: Swift.Sendable {
    /// A timestamp of when this blueprint was created.
    public var createdAt: Foundation.Date?
    /// The deployment properties of this Amazon DataZone blueprint.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description of this Amazon DataZone blueprint.
    public var description: Swift.String?
    /// The glossary terms attached to this Amazon DataZone blueprint.
    public var glossaryTerms: [Swift.String]?
    /// The ID of this Amazon DataZone blueprint.
    /// This member is required.
    public var id: Swift.String?
    /// The name of this Amazon DataZone blueprint.
    /// This member is required.
    public var name: Swift.String?
    /// The provider of this Amazon DataZone blueprint.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioning properties of this Amazon DataZone blueprint.
    /// This member is required.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The timestamp of when this blueprint was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters of this blueprint.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        createdAt: Foundation.Date? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.createdAt = createdAt
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.name = name
        self.provider = provider
        self.provisioningProperties = provisioningProperties
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension GetEnvironmentBlueprintOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentBlueprintOutput(createdAt: \(Swift.String(describing: createdAt)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\")"}
}

public struct GetEnvironmentCredentialsInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this environment and its credentials exist.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment whose credentials this operation gets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
    }
}

public struct GetEnvironmentCredentialsOutput: Swift.Sendable {
    /// The access key ID of the environment.
    public var accessKeyId: Swift.String?
    /// The expiration timestamp of the environment credentials.
    public var expiration: Foundation.Date?
    /// The secret access key of the environment credentials.
    public var secretAccessKey: Swift.String?
    /// The session token of the environment credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

extension GetEnvironmentCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetEnvironmentProfileInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetEnvironmentProfileOutput: Swift.Sendable {
    /// The ID of the Amazon Web Services account where this environment profile exists.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where this environment profile exists.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when this environment profile was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created this environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the environment profile.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this environment profile exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the blueprint with which this environment profile is created.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The ID of the environment profile.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the Amazon DataZone project in which this environment profile is created.
    public var projectId: Swift.String?
    /// The timestamp of when this environment profile was upated.
    public var updatedAt: Foundation.Date?
    /// The user parameters of the environment profile.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension GetEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetGroupProfileInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile.
    /// This member is required.
    public var groupIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
    }
}

public struct GetGroupProfileOutput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which the group profile exists.
    public var domainId: Swift.String?
    /// The name of the group for which the specified group profile exists.
    public var groupName: Swift.String?
    /// The identifier of the group profile.
    public var id: Swift.String?
    /// The identifier of the group profile.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

extension GetGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

public struct GetIamPortalLoginUrlInput: Swift.Sendable {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
    }
}

public struct GetIamPortalLoginUrlOutput: Swift.Sendable {
    /// The data portal URL of the specified Amazon DataZone domain.
    public var authCodeUrl: Swift.String?
    /// The ID of the user profile.
    /// This member is required.
    public var userProfileId: Swift.String?

    public init(
        authCodeUrl: Swift.String? = nil,
        userProfileId: Swift.String? = nil
    )
    {
        self.authCodeUrl = authCodeUrl
        self.userProfileId = userProfileId
    }
}

public struct GetLineageNodeInput: Swift.Sendable {
    /// The ID of the domain in which you want to get the data lineage node.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The event time stamp for which you want to get the data lineage node.
    public var eventTimestamp: Foundation.Date?
    /// The ID of the data lineage node that you want to get. Both, a lineage node identifier generated by Amazon DataZone and a sourceIdentifier of the lineage node are supported. If sourceIdentifier is greater than 1800 characters, you can use lineage node identifier generated by Amazon DataZone to get the node details.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        eventTimestamp: Foundation.Date? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.eventTimestamp = eventTimestamp
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    /// The reference details for the data lineage node.
    public struct LineageNodeReference: Swift.Sendable {
        /// The event timestamp of the data lineage node.
        public var eventTimestamp: Foundation.Date?
        /// The ID of the data lineage node.
        public var id: Swift.String?

        public init(
            eventTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.eventTimestamp = eventTimestamp
            self.id = id
        }
    }
}

public struct GetLineageNodeOutput: Swift.Sendable {
    /// The timestamp at which the data lineage node was created.
    public var createdAt: Foundation.Date?
    /// The user who created the data lineage node.
    public var createdBy: Swift.String?
    /// The description of the data lineage node.
    public var description: Swift.String?
    /// The ID of the domain where you're getting the data lineage node.
    /// This member is required.
    public var domainId: Swift.String?
    /// The downsteam nodes of the specified data lineage node.
    public var downstreamNodes: [DataZoneClientTypes.LineageNodeReference]?
    /// The timestamp of the event described in the data lineage node.
    public var eventTimestamp: Foundation.Date?
    /// The metadata of the specified data lineage node.
    public var formsOutput: [DataZoneClientTypes.FormOutput]?
    /// The ID of the data lineage node.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the data lineage node.
    public var name: Swift.String?
    /// The source identifier of the data lineage node.
    public var sourceIdentifier: Swift.String?
    /// The name of the type of the specified data lineage node.
    /// This member is required.
    public var typeName: Swift.String?
    /// The revision type of the specified data lineage node.
    public var typeRevision: Swift.String?
    /// The timestamp at which the data lineage node was updated.
    public var updatedAt: Foundation.Date?
    /// The user who updated the data lineage node.
    public var updatedBy: Swift.String?
    /// The upstream nodes of the specified data lineage node.
    public var upstreamNodes: [DataZoneClientTypes.LineageNodeReference]?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        downstreamNodes: [DataZoneClientTypes.LineageNodeReference]? = nil,
        eventTimestamp: Foundation.Date? = nil,
        formsOutput: [DataZoneClientTypes.FormOutput]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceIdentifier: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeRevision: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        upstreamNodes: [DataZoneClientTypes.LineageNodeReference]? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.downstreamNodes = downstreamNodes
        self.eventTimestamp = eventTimestamp
        self.formsOutput = formsOutput
        self.id = id
        self.name = name
        self.sourceIdentifier = sourceIdentifier
        self.typeName = typeName
        self.typeRevision = typeRevision
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.upstreamNodes = upstreamNodes
    }
}

public struct GetProjectInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetProjectOutput: Swift.Sendable {
    /// The timestamp of when the project was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which the project exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit.
    public var domainUnitId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The business glossary terms that can be used in the project.
    public var glossaryTerms: [Swift.String]?
    /// >The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the project.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainUnitId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.domainUnitId = domainUnitId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

extension GetProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), domainUnitId: \(Swift.String(describing: domainUnitId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetSubscriptionInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetSubscriptionOutput: Swift.Sendable {
    /// The timestamp of when the subscription was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The retain permissions of the subscription.
    public var retainPermissions: Swift.Bool?
    /// The status of the subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The details of the published asset for which the subscription grant is created.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The principal that owns the subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The ID of the subscription request.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct GetSubscriptionGrantInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the subscription grant.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetSubscriptionGrantOutput: Swift.Sendable {
    /// The assets for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant is created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription grant.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription grant exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The entity to which the subscription is granted.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The ID of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the subscription grant.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    @available(*, deprecated, message: "Multiple subscriptions can exist for a single grant")
    public var subscriptionId: Swift.String?
    /// The subscription target ID associated with the subscription grant.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant was upated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription grant.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct GetSubscriptionRequestDetailsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which to get the subscription request details.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request the details of which to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetSubscriptionRequestDetailsOutput: Swift.Sendable {
    /// The timestamp of when the specified subscription request was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the subscription request.
    public var decisionComment: Swift.String?
    /// The Amazon DataZone domain of the subscription request.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviewed the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings in the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals in the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetSubscriptionRequestDetailsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionRequestDetailsOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

public struct GetSubscriptionTargetInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
    }
}

public struct GetSubscriptionTargetOutput: Swift.Sendable {
    /// The asset types associated with the subscription target.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals of the subscription target.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when the subscription target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the subscription target exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the environment associated with the subscription target.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the subscription target.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role with which the subscription target was created.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name of the subscription target.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project associated with the subscription target.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider of the subscription target.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration of teh subscription target.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type of the subscription target.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

public struct GetTimeSeriesDataPointInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain that houses the asset for which you want to get the data point.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to get the data point.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to get the data point.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series form that houses the data point that you want to get.
    /// This member is required.
    public var formName: Swift.String?
    /// The ID of the data point that you want to get.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    /// The time series data points form.
    public struct TimeSeriesDataPointFormOutput: Swift.Sendable {
        /// The content of the time series data points form.
        public var content: Swift.String?
        /// The name of the time series data points form.
        /// This member is required.
        public var formName: Swift.String?
        /// The ID of the time series data points form.
        public var id: Swift.String?
        /// The timestamp of the time series data points form.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The ID of the type of the time series data points form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision type of the time series data points form.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            id: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

public struct GetTimeSeriesDataPointOutput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain that houses the asset data point that you want to get.
    public var domainId: Swift.String?
    /// The ID of the asset for which you want to get the data point.
    public var entityId: Swift.String?
    /// The type of the asset for which you want to get the data point.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The time series form that houses the data point that you want to get.
    public var form: DataZoneClientTypes.TimeSeriesDataPointFormOutput?
    /// The name of the time series form that houses the data point that you want to get.
    public var formName: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        form: DataZoneClientTypes.TimeSeriesDataPointFormOutput? = nil,
        formName: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.entityId = entityId
        self.entityType = entityType
        self.form = form
        self.formName = formName
    }
}

public struct GetUserProfileInput: Swift.Sendable {
    /// the ID of the Amazon DataZone domain the data portal of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user for which you want to get the user profile.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

public struct GetUserProfileOutput: Swift.Sendable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// the identifier of the Amazon DataZone domain of which you want to get the user profile.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

public struct DeleteGlossaryInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the business glossary is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteGlossaryOutput: Swift.Sendable {

    public init() { }
}

public struct GetGlossaryInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetGlossaryOutput: Swift.Sendable {
    /// The timestamp of when this business glossary was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created this business glossary.
    public var createdBy: Swift.String?
    /// The description of the business glossary.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the business glossary.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the project that owns this business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of the business glossary.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryStatus?
    /// The timestamp of when the business glossary was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the business glossary.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGlossaryInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    public var name: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.status = status
    }
}

extension UpdateGlossaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGlossaryOutput: Swift.Sendable {
    /// The description to be updated as part of the UpdateGlossary action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateGlossary action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which to update a business glossary.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status to be updated as part of the UpdateGlossary action.
    public var status: DataZoneClientTypes.GlossaryStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.id = id
        self.name = name
        self.owningProjectId = owningProjectId
        self.status = status
    }
}

extension UpdateGlossaryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct DeleteGlossaryTermInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the business glossary term is deleted.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term that is deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteGlossaryTermOutput: Swift.Sendable {

    public init() { }
}

public struct GetGlossaryTermInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct GetGlossaryTermOutput: Swift.Sendable {
    /// The timestamp of when the business glossary term was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the business glossary.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which this business glossary term exists.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the business glossary to which this term belongs.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The ID of the business glossary term.
    /// This member is required.
    public var id: Swift.String?
    /// The long description of the business glossary term.
    public var longDescription: Swift.String?
    /// The name of the business glossary term.
    /// This member is required.
    public var name: Swift.String?
    /// The short decription of the business glossary term.
    public var shortDescription: Swift.String?
    /// The status of the business glossary term.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The relations of the business glossary term.
    public var termRelations: DataZoneClientTypes.TermRelations?
    /// The timestamp of when the business glossary term was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the business glossary term.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlossaryTermOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

public struct UpdateGlossaryTermInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    public var glossaryIdentifier: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainIdentifier: Swift.String? = nil,
        glossaryIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.glossaryIdentifier = glossaryIdentifier
        self.identifier = identifier
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension UpdateGlossaryTermInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryIdentifier: \(Swift.String(describing: glossaryIdentifier)), identifier: \(Swift.String(describing: identifier)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

public struct UpdateGlossaryTermOutput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the business glossary in which a term is to be updated.
    /// This member is required.
    public var glossaryId: Swift.String?
    /// The identifier of the business glossary term that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The long description to be updated as part of the UpdateGlossaryTerm action.
    public var longDescription: Swift.String?
    /// The name to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var name: Swift.String?
    /// The short description to be updated as part of the UpdateGlossaryTerm action.
    public var shortDescription: Swift.String?
    /// The status to be updated as part of the UpdateGlossaryTerm action.
    /// This member is required.
    public var status: DataZoneClientTypes.GlossaryTermStatus?
    /// The term relations to be updated as part of the UpdateGlossaryTerm action.
    public var termRelations: DataZoneClientTypes.TermRelations?

    public init(
        domainId: Swift.String? = nil,
        glossaryId: Swift.String? = nil,
        id: Swift.String? = nil,
        longDescription: Swift.String? = nil,
        name: Swift.String? = nil,
        shortDescription: Swift.String? = nil,
        status: DataZoneClientTypes.GlossaryTermStatus? = nil,
        termRelations: DataZoneClientTypes.TermRelations? = nil
    )
    {
        self.domainId = domainId
        self.glossaryId = glossaryId
        self.id = id
        self.longDescription = longDescription
        self.name = name
        self.shortDescription = shortDescription
        self.status = status
        self.termRelations = termRelations
    }
}

extension UpdateGlossaryTermOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlossaryTermOutput(domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

public struct ListAssetFiltersInput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The ID of the domain where you want to list asset filters.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of asset filters to return in a single call to ListAssetFilters. When the number of asset filters to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetFilters to list the next set of asset filters.
    public var maxResults: Swift.Int?
    /// When the number of asset filters is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of asset filters, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetFilters to list the next set of asset filters.
    public var nextToken: Swift.String?
    /// The status of the asset filter.
    public var status: DataZoneClientTypes.FilterStatus?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.FilterStatus? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListAssetFiltersOutput: Swift.Sendable {
    /// The results of the ListAssetFilters action.
    /// This member is required.
    public var items: [DataZoneClientTypes.AssetFilterSummary]?
    /// When the number of asset filters is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of asset filters, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetFilters to list the next set of asset filters.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.AssetFilterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListAssetRevisionsInput: Swift.Sendable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the asset.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of revisions to return in a single call to ListAssetRevisions. When the number of revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var maxResults: Swift.Int?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetRevisionsOutput: Swift.Sendable {
    /// The results of the ListAssetRevisions action.
    public var items: [DataZoneClientTypes.AssetRevision]?
    /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.AssetRevision]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDataProductRevisionsInput: Swift.Sendable {
    /// The ID of the domain of the data product revisions that you want to list.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the data product revision.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of asset filters to return in a single call to ListDataProductRevisions. When the number of data product revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
    public var maxResults: Swift.Int?
    /// When the number of data product revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data product revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDataProductRevisionsOutput: Swift.Sendable {
    /// The results of the ListDataProductRevisions action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataProductRevision]?
    /// When the number of data product revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data product revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataProductRevision]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDataSourceRunActivitiesInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which to list data source run activities.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the data source run.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of activities to return in a single call to ListDataSourceRunActivities. When the number of activities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var maxResults: Swift.Int?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?
    /// The status of the data source run.
    public var status: DataZoneClientTypes.DataAssetActivityStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.DataAssetActivityStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListDataSourceRunActivitiesOutput: Swift.Sendable {
    /// The results of the ListDataSourceRunActivities action.
    /// This member is required.
    public var items: [DataZoneClientTypes.DataSourceRunActivity]?
    /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.DataSourceRunActivity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEntityOwnersInput: Swift.Sendable {
    /// The ID of the domain where you want to list entity owners.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity that you want to list.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the entity that you want to list.
    /// This member is required.
    public var entityType: DataZoneClientTypes.DataZoneEntityType?
    /// The maximum number of entities to return in a single call to ListEntityOwners. When the number of entities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEntityOwners to list the next set of entities.
    public var maxResults: Swift.Int?
    /// When the number of entities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of entities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEntityOwners to list the next set of entities.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.DataZoneEntityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    /// The properties of the domain unit owners group.
    public struct OwnerGroupPropertiesOutput: Swift.Sendable {
        /// The ID of the domain unit owners group.
        public var groupId: Swift.String?

        public init(
            groupId: Swift.String? = nil
        )
        {
            self.groupId = groupId
        }
    }
}

extension DataZoneClientTypes {

    /// The properties of the owner user.
    public struct OwnerUserPropertiesOutput: Swift.Sendable {
        /// The ID of the owner user.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }
}

extension DataZoneClientTypes {

    /// The ID of the domain unit owners group.
    public enum OwnerPropertiesOutput: Swift.Sendable {
        /// Specifies that the domain unit owner is a user.
        case user(DataZoneClientTypes.OwnerUserPropertiesOutput)
        /// Specifies that the domain unit owner is a group.
        case group(DataZoneClientTypes.OwnerGroupPropertiesOutput)
        case sdkUnknown(Swift.String)
    }
}

public struct ListEntityOwnersOutput: Swift.Sendable {
    /// When the number of entities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of entities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEntityOwners to list the next set of entities.
    public var nextToken: Swift.String?
    /// The owners of the entity.
    /// This member is required.
    public var owners: [DataZoneClientTypes.OwnerPropertiesOutput]?

    public init(
        nextToken: Swift.String? = nil,
        owners: [DataZoneClientTypes.OwnerPropertiesOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.owners = owners
    }
}

public struct ListEnvironmentActionsInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which the environment actions are listed.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the envrironment whose environment actions are listed.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of environment actions to return in a single call to ListEnvironmentActions. When the number of environment actions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
    public var maxResults: Swift.Int?
    /// When the number of environment actions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment actions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    /// The details about the specified action configured for an environment. For example, the details of the specified console links for an analytics tool that is available in this environment.
    public struct EnvironmentActionSummary: Swift.Sendable {
        /// The environment action description.
        public var description: Swift.String?
        /// The Amazon DataZone domain ID of the environment action.
        /// This member is required.
        public var domainId: Swift.String?
        /// The environment ID of the environment action.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The ID of the environment action.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the environment action.
        /// This member is required.
        public var name: Swift.String?
        /// The parameters of the environment action.
        /// This member is required.
        public var parameters: DataZoneClientTypes.ActionParameters?

        public init(
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: DataZoneClientTypes.ActionParameters? = nil
        )
        {
            self.description = description
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.name = name
            self.parameters = parameters
        }
    }
}

public struct ListEnvironmentActionsOutput: Swift.Sendable {
    /// The results of ListEnvironmentActions.
    public var items: [DataZoneClientTypes.EnvironmentActionSummary]?
    /// When the number of environment actions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment actions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentBlueprintsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the environment blueprint is managed by Amazon DataZone.
    public var managed: Swift.Bool?
    /// The maximum number of blueprints to return in a single call to ListEnvironmentBlueprints. When the number of blueprints to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprints to list the next set of blueprints.
    public var maxResults: Swift.Int?
    /// The name of the Amazon DataZone environment.
    public var name: Swift.String?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.managed = managed
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    /// The details of an environment blueprint summary.
    public struct EnvironmentBlueprintSummary: Swift.Sendable {
        /// The timestamp of when an environment blueprint was created.
        public var createdAt: Foundation.Date?
        /// The description of a blueprint.
        public var description: Swift.String?
        /// The identifier of the blueprint.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the blueprint.
        /// This member is required.
        public var name: Swift.String?
        /// The provider of the blueprint.
        /// This member is required.
        public var provider: Swift.String?
        /// The provisioning properties of the blueprint.
        /// This member is required.
        public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
        /// The timestamp of when the blueprint was enabled.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: Swift.String? = nil,
            provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentBlueprintSummary(createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provider: \(Swift.String(describing: provider)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListEnvironmentBlueprintsOutput: Swift.Sendable {
    /// The results of the ListEnvironmentBlueprints action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentBlueprintSummary]?
    /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentBlueprintSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentProfilesInput: Swift.Sendable {
    /// The identifier of the Amazon Web Services account where you want to list environment profiles.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environment profiles.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the blueprint that was used to create the environment profiles that you want to list.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The maximum number of environment profiles to return in a single call to ListEnvironmentProfiles. When the number of environment profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var maxResults: Swift.Int?
    ///
    public var name: Swift.String?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    public var projectIdentifier: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
    }
}

extension ListEnvironmentProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentProfilesInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentBlueprintIdentifier: \(Swift.String(describing: environmentBlueprintIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectIdentifier: \(Swift.String(describing: projectIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of an environment profile.
    public struct EnvironmentProfileSummary: Swift.Sendable {
        /// The identifier of an Amazon Web Services account in which an environment profile exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment profile exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when an environment profile was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the environment profile.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment profile.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment profile exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of a blueprint with which an environment profile is created.
        /// This member is required.
        public var environmentBlueprintId: Swift.String?
        /// The identifier of the environment profile.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the environment profile.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of a project in which an environment profile exists.
        public var projectId: Swift.String?
        /// The timestamp of when the environment profile was updated.
        public var updatedAt: Foundation.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentBlueprintId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.EnvironmentProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentProfileSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListEnvironmentProfilesOutput: Swift.Sendable {
    /// The results of the ListEnvironmentProfiles action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentProfileSummary]?
    /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsInput: Swift.Sendable {
    /// The identifier of the Amazon Web Services account where you want to list environments.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services region where you want to list environments.
    public var awsAccountRegion: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone blueprint.
    public var environmentBlueprintIdentifier: Swift.String?
    /// The identifier of the environment profile.
    public var environmentProfileIdentifier: Swift.String?
    /// The maximum number of environments to return in a single call to ListEnvironments. When the number of environments to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironments to list the next set of environments.
    public var maxResults: Swift.Int?
    /// The name of the environment.
    public var name: Swift.String?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone project.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The provider of the environment.
    public var provider: Swift.String?
    /// The status of the environments that you want to list.
    public var status: DataZoneClientTypes.EnvironmentStatus?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentBlueprintIdentifier: Swift.String? = nil,
        environmentProfileIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        provider: Swift.String? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.domainIdentifier = domainIdentifier
        self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        self.environmentProfileIdentifier = environmentProfileIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.provider = provider
        self.status = status
    }
}

extension DataZoneClientTypes {

    /// The details of an environment.
    public struct EnvironmentSummary: Swift.Sendable {
        /// The identifier of the Amazon Web Services account in which an environment exists.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region in which an environment exists.
        public var awsAccountRegion: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the environment.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the environment exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment profile with which the environment was created.
        public var environmentProfileId: Swift.String?
        /// The identifier of the environment.
        public var id: Swift.String?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project in which the environment exists.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the environment.
        /// This member is required.
        public var provider: Swift.String?
        /// The status of the environment.
        public var status: DataZoneClientTypes.EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public var updatedAt: Foundation.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            awsAccountRegion: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentProfileId: Swift.String? = "",
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            status: DataZoneClientTypes.EnvironmentStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentProfileId = environmentProfileId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListEnvironmentsOutput: Swift.Sendable {
    /// The results of the ListEnvironments action.
    /// This member is required.
    public var items: [DataZoneClientTypes.EnvironmentSummary]?
    /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct DeleteListingInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the listing to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

public struct DeleteListingOutput: Swift.Sendable {

    public init() { }
}

public struct GetListingInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the listing.
    /// This member is required.
    public var identifier: Swift.String?
    /// The revision of the listing.
    public var listingRevision: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        listingRevision: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.listingRevision = listingRevision
    }
}

extension DataZoneClientTypes {

    /// The details of a listing (aka asset published in a Amazon DataZone catalog).
    public enum ListingItem: Swift.Sendable {
        /// An asset published in an Amazon DataZone catalog.
        case assetlisting(DataZoneClientTypes.AssetListing)
        /// The data product listing.
        case dataproductlisting(DataZoneClientTypes.DataProductListing)
        case sdkUnknown(Swift.String)
    }
}

public struct GetListingOutput: Swift.Sendable {
    /// The timestamp of when the listing was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the listing.
    public var createdBy: Swift.String?
    /// The description of the listing.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the listing.
    /// This member is required.
    public var id: Swift.String?
    /// The details of a listing.
    public var item: DataZoneClientTypes.ListingItem?
    /// The revision of a listing.
    /// This member is required.
    public var listingRevision: Swift.String?
    /// The name of the listing.
    public var name: Swift.String?
    /// The status of the listing.
    public var status: DataZoneClientTypes.ListingStatus?
    /// The timestamp of when the listing was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the listing.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        item: DataZoneClientTypes.ListingItem? = nil,
        listingRevision: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.ListingStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.id = id
        self.item = item
        self.listingRevision = listingRevision
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetListingOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetListingOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), item: \(Swift.String(describing: item)), listingRevision: \(Swift.String(describing: listingRevision)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    public enum EdgeDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case downstream
        case upstream
        case sdkUnknown(Swift.String)

        public static var allCases: [EdgeDirection] {
            return [
                .downstream,
                .upstream
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .downstream: return "DOWNSTREAM"
            case .upstream: return "UPSTREAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListLineageNodeHistoryInput: Swift.Sendable {
    /// The direction of the data lineage node refers to the lineage node having neighbors in that direction. For example, if direction is UPSTREAM, the ListLineageNodeHistory API responds with historical versions with upstream neighbors only.
    public var direction: DataZoneClientTypes.EdgeDirection?
    /// The ID of the domain where you want to list the history of the specified data lineage node.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies whether the action is to return data lineage node history from the time after the event timestamp.
    public var eventTimestampGTE: Foundation.Date?
    /// Specifies whether the action is to return data lineage node history from the time prior of the event timestamp.
    public var eventTimestampLTE: Foundation.Date?
    /// The ID of the data lineage node whose history you want to list.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of history items to return in a single call to ListLineageNodeHistory. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListLineageNodeHistory to list the next set of items.
    public var maxResults: Swift.Int?
    /// When the number of history items is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of items, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageNodeHistory to list the next set of items.
    public var nextToken: Swift.String?
    /// The order by which you want data lineage node history to be sorted.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        direction: DataZoneClientTypes.EdgeDirection? = nil,
        domainIdentifier: Swift.String? = nil,
        eventTimestampGTE: Foundation.Date? = nil,
        eventTimestampLTE: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.direction = direction
        self.domainIdentifier = domainIdentifier
        self.eventTimestampGTE = eventTimestampGTE
        self.eventTimestampLTE = eventTimestampLTE
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

extension DataZoneClientTypes {

    /// The summary of the data lineage node.
    public struct LineageNodeSummary: Swift.Sendable {
        /// The timestamp at which the data lineage node was created.
        public var createdAt: Foundation.Date?
        /// The user who created the data lineage node.
        public var createdBy: Swift.String?
        /// The description of the data lineage node.
        public var description: Swift.String?
        /// The ID of the domain of the data lineage node.
        /// This member is required.
        public var domainId: Swift.String?
        /// The event timestamp of the data lineage node.
        public var eventTimestamp: Foundation.Date?
        /// The ID of the data lineage node.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the data lineage node.
        public var name: Swift.String?
        /// The alternate ID of the data lineage node.
        public var sourceIdentifier: Swift.String?
        /// The name of the type of the data lineage node.
        /// This member is required.
        public var typeName: Swift.String?
        /// The type of the revision of the data lineage node.
        public var typeRevision: Swift.String?
        /// The timestamp at which the data lineage node was updated.
        public var updatedAt: Foundation.Date?
        /// The user who updated the data lineage node.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            eventTimestamp: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            typeName: Swift.String? = nil,
            typeRevision: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.eventTimestamp = eventTimestamp
            self.id = id
            self.name = name
            self.sourceIdentifier = sourceIdentifier
            self.typeName = typeName
            self.typeRevision = typeRevision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListLineageNodeHistoryOutput: Swift.Sendable {
    /// When the number of history items is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of items, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageNodeHistory to list the next set of items.
    public var nextToken: Swift.String?
    /// The nodes returned by the ListLineageNodeHistory action.
    public var nodes: [DataZoneClientTypes.LineageNodeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [DataZoneClientTypes.LineageNodeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

extension DataZoneClientTypes {

    public enum TaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum NotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .event,
                .task
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListNotificationsInput: Swift.Sendable {
    /// The time after which you want to list notifications.
    public var afterTimestamp: Foundation.Date?
    /// The time before which you want to list notifications.
    public var beforeTimestamp: Foundation.Date?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of notifications to return in a single call to ListNotifications. When the number of notifications to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListNotifications to list the next set of notifications.
    public var maxResults: Swift.Int?
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The subjects of notifications.
    public var subjects: [Swift.String]?
    /// The task status of notifications.
    public var taskStatus: DataZoneClientTypes.TaskStatus?
    /// The type of notifications.
    /// This member is required.
    public var type: DataZoneClientTypes.NotificationType?

    public init(
        afterTimestamp: Foundation.Date? = nil,
        beforeTimestamp: Foundation.Date? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subjects: [Swift.String]? = nil,
        taskStatus: DataZoneClientTypes.TaskStatus? = nil,
        type: DataZoneClientTypes.NotificationType? = nil
    )
    {
        self.afterTimestamp = afterTimestamp
        self.beforeTimestamp = beforeTimestamp
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subjects = subjects
        self.taskStatus = taskStatus
        self.type = type
    }
}

extension DataZoneClientTypes {

    public enum NotificationResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationResourceType] {
            return [
                .project
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the resource mentioned in a notification.
    public struct NotificationResource: Swift.Sendable {
        /// The ID of the resource mentioned in a notification.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the resource mentioned in a notification.
        public var name: Swift.String?
        /// The type of the resource mentioned in a notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationResourceType?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DataZoneClientTypes.NotificationResourceType? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
        }
    }
}

extension DataZoneClientTypes {

    public enum NotificationRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainOwner
        case projectContributor
        case projectOwner
        case projectSubscriber
        case projectViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationRole] {
            return [
                .domainOwner,
                .projectContributor,
                .projectOwner,
                .projectSubscriber,
                .projectViewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainOwner: return "DOMAIN_OWNER"
            case .projectContributor: return "PROJECT_CONTRIBUTOR"
            case .projectOwner: return "PROJECT_OWNER"
            case .projectSubscriber: return "PROJECT_SUBSCRIBER"
            case .projectViewer: return "PROJECT_VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The topic of the notification.
    public struct Topic: Swift.Sendable {
        /// The details of the resource mentioned in a notification.
        /// This member is required.
        public var resource: DataZoneClientTypes.NotificationResource?
        /// The role of the resource mentioned in a notification.
        /// This member is required.
        public var role: DataZoneClientTypes.NotificationRole?
        /// The subject of the resource mentioned in a notification.
        /// This member is required.
        public var subject: Swift.String?

        public init(
            resource: DataZoneClientTypes.NotificationResource? = nil,
            role: DataZoneClientTypes.NotificationRole? = nil,
            subject: Swift.String? = nil
        )
        {
            self.resource = resource
            self.role = role
            self.subject = subject
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a notification generated in Amazon DataZone.
    public struct NotificationOutput: Swift.Sendable {
        /// The action link included in the notification.
        /// This member is required.
        public var actionLink: Swift.String?
        /// The timestamp of when a notification was created.
        /// This member is required.
        public var creationTimestamp: Foundation.Date?
        /// The identifier of a Amazon DataZone domain in which the notification exists.
        /// This member is required.
        public var domainIdentifier: Swift.String?
        /// The identifier of the notification.
        /// This member is required.
        public var identifier: Swift.String?
        /// The timestamp of when the notification was last updated.
        /// This member is required.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The message included in the notification.
        /// This member is required.
        public var message: Swift.String?
        /// The metadata included in the notification.
        public var metadata: [Swift.String: Swift.String]?
        /// The status included in the notification.
        public var status: DataZoneClientTypes.TaskStatus?
        /// The title of the notification.
        /// This member is required.
        public var title: Swift.String?
        /// The topic of the notification.
        /// This member is required.
        public var topic: DataZoneClientTypes.Topic?
        /// The type of the notification.
        /// This member is required.
        public var type: DataZoneClientTypes.NotificationType?

        public init(
            actionLink: Swift.String? = nil,
            creationTimestamp: Foundation.Date? = nil,
            domainIdentifier: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            message: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            status: DataZoneClientTypes.TaskStatus? = nil,
            title: Swift.String? = nil,
            topic: DataZoneClientTypes.Topic? = nil,
            type: DataZoneClientTypes.NotificationType? = nil
        )
        {
            self.actionLink = actionLink
            self.creationTimestamp = creationTimestamp
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.message = message
            self.metadata = metadata
            self.status = status
            self.title = title
            self.topic = topic
            self.type = type
        }
    }
}

extension DataZoneClientTypes.NotificationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationOutput(creationTimestamp: \(Swift.String(describing: creationTimestamp)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), topic: \(Swift.String(describing: topic)), type: \(Swift.String(describing: type)), actionLink: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

public struct ListNotificationsOutput: Swift.Sendable {
    /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
    public var nextToken: Swift.String?
    /// The results of the ListNotifications action.
    public var notifications: [DataZoneClientTypes.NotificationOutput]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [DataZoneClientTypes.NotificationOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

public struct ListPolicyGrantsInput: Swift.Sendable {
    /// The ID of the domain where you want to list policy grants.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity for which you want to list policy grants.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of entity for which you want to list policy grants.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TargetEntityType?
    /// The maximum number of grants to return in a single call to ListPolicyGrants. When the number of grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListPolicyGrants to list the next set of grants.
    public var maxResults: Swift.Int?
    /// When the number of grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListPolicyGrants to list the next set of grants.
    public var nextToken: Swift.String?
    /// The type of policy that you want to list.
    /// This member is required.
    public var policyType: DataZoneClientTypes.ManagedPolicyType?

    public init(
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TargetEntityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyType: DataZoneClientTypes.ManagedPolicyType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyType = policyType
    }
}

extension DataZoneClientTypes {

    /// A member of the policy grant list.
    public struct PolicyGrantMember: Swift.Sendable {
        /// Specifies the timestamp at which policy grant member was created.
        public var createdAt: Foundation.Date?
        /// Specifies the user who created the policy grant member.
        public var createdBy: Swift.String?
        /// The details of the policy grant member.
        public var detail: DataZoneClientTypes.PolicyGrantDetail?
        /// The principal of the policy grant member.
        public var principal: DataZoneClientTypes.PolicyGrantPrincipal?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            detail: DataZoneClientTypes.PolicyGrantDetail? = nil,
            principal: DataZoneClientTypes.PolicyGrantPrincipal? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.detail = detail
            self.principal = principal
        }
    }
}

public struct ListPolicyGrantsOutput: Swift.Sendable {
    /// The results of this action - the listed grants.
    /// This member is required.
    public var grantList: [DataZoneClientTypes.PolicyGrantMember]?
    /// When the number of grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListPolicyGrants to list the next set of grants.
    public var nextToken: Swift.String?

    public init(
        grantList: [DataZoneClientTypes.PolicyGrantMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grantList = grantList
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    public enum SortFieldProject: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [SortFieldProject] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProjectMembershipsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which you want to list project memberships.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of memberships to return in a single call to ListProjectMemberships. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var maxResults: Swift.Int?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?
    /// The identifier of the project whose memberships you want to list.
    /// This member is required.
    public var projectIdentifier: Swift.String?
    /// The method by which you want to sort the project memberships.
    public var sortBy: DataZoneClientTypes.SortFieldProject?
    /// The sort order of the project memberships.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectIdentifier: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortFieldProject? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectIdentifier = projectIdentifier
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension DataZoneClientTypes {

    /// The details of a group in Amazon DataZone.
    public struct GroupDetails: Swift.Sendable {
        /// The identifier of the group in Amazon DataZone.
        /// This member is required.
        public var groupId: Swift.String?

        public init(
            groupId: Swift.String? = nil
        )
        {
            self.groupId = groupId
        }
    }
}

extension DataZoneClientTypes {

    /// The user details of a project member.
    public struct UserDetails: Swift.Sendable {
        /// The identifier of the Amazon DataZone user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            userId: Swift.String? = nil
        )
        {
            self.userId = userId
        }
    }
}

extension DataZoneClientTypes {

    /// The details about a project member.
    public enum MemberDetails: Swift.Sendable {
        /// The user details of a project member.
        case user(DataZoneClientTypes.UserDetails)
        /// The group details of a project member.
        case group(DataZoneClientTypes.GroupDetails)
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The details of a project member.
    public struct ProjectMember: Swift.Sendable {
        /// The designated role of a project member.
        /// This member is required.
        public var designation: DataZoneClientTypes.UserDesignation?
        /// The membership details of a project member.
        /// This member is required.
        public var memberDetails: DataZoneClientTypes.MemberDetails?

        public init(
            designation: DataZoneClientTypes.UserDesignation? = nil,
            memberDetails: DataZoneClientTypes.MemberDetails? = nil
        )
        {
            self.designation = designation
            self.memberDetails = memberDetails
        }
    }
}

public struct ListProjectMembershipsOutput: Swift.Sendable {
    /// The members of the project.
    /// This member is required.
    public var members: [DataZoneClientTypes.ProjectMember]?
    /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
    public var nextToken: Swift.String?

    public init(
        members: [DataZoneClientTypes.ProjectMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListProjectsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of a group.
    public var groupIdentifier: Swift.String?
    /// The maximum number of projects to return in a single call to ListProjects. When the number of projects to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjects to list the next set of projects.
    public var maxResults: Swift.Int?
    /// The name of the project.
    public var name: Swift.String?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon DataZone user.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userIdentifier = userIdentifier
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupIdentifier: \(Swift.String(describing: groupIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userIdentifier: \(Swift.String(describing: userIdentifier)), name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of a Amazon DataZone project.
    public struct ProjectSummary: Swift.Sendable {
        /// The timestamp of when a project was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the project.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of a project.
        public var description: Swift.String?
        /// The identifier of a Amazon DataZone domain where the project exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The ID of the domain unit.
        public var domainUnitId: Swift.String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
        /// The identifier of a project.
        /// This member is required.
        public var id: Swift.String?
        /// The name of a project.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the project.
        public var projectStatus: DataZoneClientTypes.ProjectStatus?
        /// The timestamp of when the project was updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainUnitId: Swift.String? = nil,
            failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            projectStatus: DataZoneClientTypes.ProjectStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.failureReasons = failureReasons
            self.id = id
            self.name = name
            self.projectStatus = projectStatus
            self.updatedAt = updatedAt
        }
    }
}

extension DataZoneClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), domainUnitId: \(Swift.String(describing: domainUnitId)), failureReasons: \(Swift.String(describing: failureReasons)), id: \(Swift.String(describing: id)), projectStatus: \(Swift.String(describing: projectStatus)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListProjectsOutput: Swift.Sendable {
    /// The results of the ListProjects action.
    public var items: [DataZoneClientTypes.ProjectSummary]?
    /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.ProjectSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    public enum SortKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdAt
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .createdAt,
                .updatedAt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdAt: return "CREATED_AT"
            case .updatedAt: return "UPDATED_AT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSubscriptionGrantsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone environment.
    public var environmentId: Swift.String?
    /// The maximum number of subscription grants to return in a single call to ListSubscriptionGrants. When the number of subscription grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var maxResults: Swift.Int?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?
    /// The ID of the owning project of the subscription grants.
    public var owningProjectId: Swift.String?
    /// Specifies the way of sorting the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription.
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target.
    public var subscriptionTargetId: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.subscribedListingId = subscribedListingId
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
    }
}

extension DataZoneClientTypes {

    /// The details of the subscription grant.
    public struct SubscriptionGrantSummary: Swift.Sendable {
        /// The assets included in the subscription grant.
        public var assets: [DataZoneClientTypes.SubscribedAsset]?
        /// The timestamp of when a subscription grant was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The datazone user who created the subscription grant.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription grant exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The entity to which the subscription is granted.
        /// This member is required.
        public var grantedEntity: DataZoneClientTypes.GrantedEntity?
        /// The identifier of the subscription grant.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the subscription grant.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
        /// The ID of the subscription.
        @available(*, deprecated, message: "Multiple subscriptions can exist for a single grant")
        public var subscriptionId: Swift.String?
        /// The identifier of the target of the subscription grant.
        /// This member is required.
        public var subscriptionTargetId: Swift.String?
        /// The timestampf of when the subscription grant was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the subscription grant.
        public var updatedBy: Swift.String?

        public init(
            assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
            subscriptionId: Swift.String? = nil,
            subscriptionTargetId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListSubscriptionGrantsOutput: Swift.Sendable {
    /// The results of the ListSubscriptionGrants action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionGrantSummary]?
    /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionGrantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListSubscriptionRequestsInput: Swift.Sendable {
    /// The identifier of the subscription request approver's project.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscription requests to return in a single call to ListSubscriptionRequests. When the number of subscription requests to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var maxResults: Swift.Int?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?
    /// The identifier of the project for the subscription requests.
    public var owningProjectId: Swift.String?
    /// Specifies the way to sort the results of this action.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// Specifies the status of the subscription requests. This is not a required parameter, but if not specified, by default, Amazon DataZone returns only PENDING subscription requests.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The identifier of the subscribed listing.
    public var subscribedListingId: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListingId: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
    }
}

extension DataZoneClientTypes {

    /// The details of the subscription request.
    public struct SubscriptionRequestSummary: Swift.Sendable {
        /// The timestamp of when a subscription request was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the subscription request.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The decision comment of the subscription request.
        public var decisionComment: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription request exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription request.
        /// This member is required.
        public var id: Swift.String?
        /// The reason for the subscription request.
        /// This member is required.
        public var requestReason: Swift.String?
        /// The identifier of the subscription request reviewer.
        public var reviewerId: Swift.String?
        /// The status of the subscription request.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionRequestStatus?
        /// The listings included in the subscription request.
        /// This member is required.
        public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
        /// The principals included in the subscription request.
        /// This member is required.
        public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
        /// The timestamp of when the subscription request was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The identifier of the Amazon DataZone user who updated the subscription request.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            decisionComment: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            requestReason: Swift.String? = nil,
            reviewerId: Swift.String? = nil,
            status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
            subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
            subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes.SubscriptionRequestSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionRequestSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

public struct ListSubscriptionRequestsOutput: Swift.Sendable {
    /// The results of the ListSubscriptionRequests action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionRequestSummary]?
    /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionRequestSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListSubscriptionsInput: Swift.Sendable {
    /// The identifier of the project for the subscription's approver.
    public var approverProjectId: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of subscriptions to return in a single call to ListSubscriptions. When the number of subscriptions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptions to list the next set of Subscriptions.
    public var maxResults: Swift.Int?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?
    /// The identifier of the owning project.
    public var owningProjectId: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?
    /// The status of the subscriptions that you want to list. This is not a required parameter, but if not provided, by default, Amazon DataZone returns only APPROVED subscriptions.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The identifier of the subscribed listing for the subscriptions that you want to list.
    public var subscribedListingId: Swift.String?
    /// The identifier of the subscription request for the subscriptions that you want to list.
    public var subscriptionRequestIdentifier: Swift.String?

    public init(
        approverProjectId: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListingId: Swift.String? = nil,
        subscriptionRequestIdentifier: Swift.String? = nil
    )
    {
        self.approverProjectId = approverProjectId
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectId = owningProjectId
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.subscribedListingId = subscribedListingId
        self.subscriptionRequestIdentifier = subscriptionRequestIdentifier
    }
}

extension DataZoneClientTypes {

    /// The details of the subscription.
    public struct SubscriptionSummary: Swift.Sendable {
        /// The timestamp of when the subscription was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the subscription.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which a subscription exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The retain permissions included in the subscription.
        public var retainPermissions: Swift.Bool?
        /// The status of the subscription.
        /// This member is required.
        public var status: DataZoneClientTypes.SubscriptionStatus?
        /// The listing included in the subscription.
        /// This member is required.
        public var subscribedListing: DataZoneClientTypes.SubscribedListing?
        /// The principal included in the subscription.
        /// This member is required.
        public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
        /// The identifier of the subscription request for the subscription.
        public var subscriptionRequestId: Swift.String?
        /// The timestamp of when the subscription was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the subscription.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            retainPermissions: Swift.Bool? = nil,
            status: DataZoneClientTypes.SubscriptionStatus? = nil,
            subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
            subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
            subscriptionRequestId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListSubscriptionsOutput: Swift.Sendable {
    /// The results of the ListSubscriptions action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionSummary]?
    /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListSubscriptionTargetsInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain where you want to list subscription targets.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment where you want to list subscription targets.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of subscription targets to return in a single call to ListSubscriptionTargets. When the number of subscription targets to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var maxResults: Swift.Int?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?
    /// Specifies the way in which the results of this action are to be sorted.
    public var sortBy: DataZoneClientTypes.SortKey?
    /// Specifies the sort order for the results of this action.
    public var sortOrder: DataZoneClientTypes.SortOrder?

    public init(
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: DataZoneClientTypes.SortKey? = nil,
        sortOrder: DataZoneClientTypes.SortOrder? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension DataZoneClientTypes {

    /// The details of the subscription target.
    public struct SubscriptionTargetSummary: Swift.Sendable {
        /// The asset types included in the subscription target.
        /// This member is required.
        public var applicableAssetTypes: [Swift.String]?
        /// The authorized principals included in the subscription target.
        /// This member is required.
        public var authorizedPrincipals: [Swift.String]?
        /// The timestamp of when the subscription target was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the subscription target.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the subscription target exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the environment of the subscription target.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The identifier of the subscription target.
        /// This member is required.
        public var id: Swift.String?
        /// The manage access role specified in the subscription target.
        /// This member is required.
        public var manageAccessRole: Swift.String?
        /// The name of the subscription target.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project specified in the subscription target.
        /// This member is required.
        public var projectId: Swift.String?
        /// The provider of the subscription target.
        /// This member is required.
        public var provider: Swift.String?
        /// The configuration of the subscription target.
        /// This member is required.
        public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
        /// The type of the subscription target.
        /// This member is required.
        public var type: Swift.String?
        /// The timestamp of when the subscription target was updated.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the subscription target.
        public var updatedBy: Swift.String?

        public init(
            applicableAssetTypes: [Swift.String]? = nil,
            authorizedPrincipals: [Swift.String]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            manageAccessRole: Swift.String? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            provider: Swift.String? = nil,
            subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
            type: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes.SubscriptionTargetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionTargetSummary(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

public struct ListSubscriptionTargetsOutput: Swift.Sendable {
    /// The results of the ListSubscriptionTargets action.
    /// This member is required.
    public var items: [DataZoneClientTypes.SubscriptionTargetSummary]?
    /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.SubscriptionTargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags of the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTimeSeriesDataPointsInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain that houses the assets for which you want to list time series data points.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The timestamp at which the data points that you wanted to list ended.
    public var endedAt: Foundation.Date?
    /// The ID of the asset for which you want to list data points.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to list data points.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The name of the time series data points form.
    /// This member is required.
    public var formName: Swift.String?
    /// The maximum number of data points to return in a single call to ListTimeSeriesDataPoints. When the number of data points to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var maxResults: Swift.Int?
    /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var nextToken: Swift.String?
    /// The timestamp at which the data points that you want to list started.
    public var startedAt: Foundation.Date?

    public init(
        domainIdentifier: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        formName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startedAt: Foundation.Date? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.endedAt = endedAt
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.formName = formName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startedAt = startedAt
    }
}

public struct ListTimeSeriesDataPointsOutput: Swift.Sendable {
    /// The results of the ListTimeSeriesDataPoints action.
    public var items: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]?
    /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetMetadataGenerationRunInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the metadata generation run.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension DataZoneClientTypes {

    public enum MetadataGenerationRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case submitted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationRunStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .submitted,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    public enum MetadataGenerationTargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationTargetType] {
            return [
                .asset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The asset for which metadata was generated.
    public struct MetadataGenerationRunTarget: Swift.Sendable {
        /// The ID of the metadata generation run's target.
        /// This member is required.
        public var identifier: Swift.String?
        /// The revision of the asset for which metadata was generated.
        public var revision: Swift.String?
        /// The type of the asset for which metadata was generated.
        /// This member is required.
        public var type: DataZoneClientTypes.MetadataGenerationTargetType?

        public init(
            identifier: Swift.String? = nil,
            revision: Swift.String? = nil,
            type: DataZoneClientTypes.MetadataGenerationTargetType? = nil
        )
        {
            self.identifier = identifier
            self.revision = revision
            self.type = type
        }
    }
}

extension DataZoneClientTypes {

    public enum MetadataGenerationRunType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessDescriptions
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataGenerationRunType] {
            return [
                .businessDescriptions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessDescriptions: return "BUSINESS_DESCRIPTIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMetadataGenerationRunOutput: Swift.Sendable {
    /// The timestamp of when the metadata generation run was start.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who started the metadata generation run.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project that owns the assets for which you're running metadata generation.
    /// This member is required.
    public var owningProjectId: Swift.String?
    /// The status of the metadata generation run.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The asset for which you're generating metadata.
    public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
    /// The type of metadata generation run.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.owningProjectId = owningProjectId
        self.status = status
        self.target = target
        self.type = type
    }
}

public struct ListMetadataGenerationRunsInput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain where you want to list metadata generation runs.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of metadata generation runs to return in a single call to ListMetadataGenerationRuns. When the number of metadata generation runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var maxResults: Swift.Int?
    /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var nextToken: Swift.String?
    /// The status of the metadata generation runs.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The type of the metadata generation runs.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.type = type
    }
}

extension DataZoneClientTypes {

    /// The metadata generation run.
    public struct MetadataGenerationRunItem: Swift.Sendable {
        /// The timestamp at which the metadata generation run was created.
        public var createdAt: Foundation.Date?
        /// The user who created the metadata generation run.
        public var createdBy: Swift.String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was created.
        /// This member is required.
        public var domainId: Swift.String?
        /// The ID of the metadata generation run.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the project that owns the asset for which the metadata generation was ran.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The status of the metadata generation run.
        public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
        /// The asset for which metadata was generated.
        public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
        /// The type of the metadata generation run.
        public var type: DataZoneClientTypes.MetadataGenerationRunType?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
            target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
            type: DataZoneClientTypes.MetadataGenerationRunType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }
    }
}

public struct ListMetadataGenerationRunsOutput: Swift.Sendable {
    /// The results of the ListMetadataGenerationRuns action.
    public var items: [DataZoneClientTypes.MetadataGenerationRunItem]?
    /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.MetadataGenerationRunItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartMetadataGenerationRunInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain where you want to start a metadata generation run.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the project that owns the asset for which you want to start a metadata generation run.
    /// This member is required.
    public var owningProjectIdentifier: Swift.String?
    /// The asset for which you want to start a metadata generation run.
    /// This member is required.
    public var target: DataZoneClientTypes.MetadataGenerationRunTarget?
    /// The type of the metadata generation run.
    /// This member is required.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        target: DataZoneClientTypes.MetadataGenerationRunTarget? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.owningProjectIdentifier = owningProjectIdentifier
        self.target = target
        self.type = type
    }
}

public struct StartMetadataGenerationRunOutput: Swift.Sendable {
    /// The timestamp at which the metadata generation run was started.
    public var createdAt: Foundation.Date?
    /// The ID of the user who started the metadata generation run.
    public var createdBy: Swift.String?
    /// The ID of the Amazon DataZone domain in which the metadata generation run was started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the metadata generation run.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the project that owns the asset for which the metadata generation run was started.
    public var owningProjectId: Swift.String?
    /// The status of the metadata generation run.
    public var status: DataZoneClientTypes.MetadataGenerationRunStatus?
    /// The type of the metadata generation run.
    public var type: DataZoneClientTypes.MetadataGenerationRunType?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        owningProjectId: Swift.String? = nil,
        status: DataZoneClientTypes.MetadataGenerationRunStatus? = nil,
        type: DataZoneClientTypes.MetadataGenerationRunType? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.owningProjectId = owningProjectId
        self.status = status
        self.type = type
    }
}

public struct PostLineageEventInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the domain where you want to post a data lineage event.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The data lineage event that you want to post. Only open-lineage run event are supported as events.
    /// This member is required.
    public var event: Foundation.Data?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        event: Foundation.Data? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.event = event
    }
}

extension PostLineageEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostLineageEventInput(clientToken: \(Swift.String(describing: clientToken)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), event: \"CONTENT_REDACTED\")"}
}

public struct PostLineageEventOutput: Swift.Sendable {

    public init() { }
}

extension DataZoneClientTypes {

    /// The time series data points form.
    public struct TimeSeriesDataPointFormInput: Swift.Sendable {
        /// The content of the time series data points form.
        public var content: Swift.String?
        /// The name of the time series data points form.
        /// This member is required.
        public var formName: Swift.String?
        /// The timestamp of the time series data points form.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The ID of the type of the time series data points form.
        /// This member is required.
        public var typeIdentifier: Swift.String?
        /// The revision type of the time series data points form.
        public var typeRevision: Swift.String?

        public init(
            content: Swift.String? = nil,
            formName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            typeIdentifier: Swift.String? = nil,
            typeRevision: Swift.String? = nil
        )
        {
            self.content = content
            self.formName = formName
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }
    }
}

public struct PostTimeSeriesDataPointsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the Amazon DataZone domain in which you want to post time series data points.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset for which you want to post time series data points.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the asset for which you want to post data points.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The forms that contain the data points that you want to post.
    /// This member is required.
    public var forms: [DataZoneClientTypes.TimeSeriesDataPointFormInput]?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        forms: [DataZoneClientTypes.TimeSeriesDataPointFormInput]? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.forms = forms
    }
}

public struct PostTimeSeriesDataPointsOutput: Swift.Sendable {
    /// The ID of the Amazon DataZone domain in which you want to post time series data points.
    public var domainId: Swift.String?
    /// The ID of the asset for which you want to post time series data points.
    public var entityId: Swift.String?
    /// The type of the asset for which you want to post data points.
    public var entityType: DataZoneClientTypes.TimeSeriesEntityType?
    /// The forms that contain the data points that you have posted.
    public var forms: [DataZoneClientTypes.TimeSeriesDataPointFormOutput]?

    public init(
        domainId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: DataZoneClientTypes.TimeSeriesEntityType? = nil,
        forms: [DataZoneClientTypes.TimeSeriesDataPointFormOutput]? = nil
    )
    {
        self.domainId = domainId
        self.entityId = entityId
        self.entityType = entityType
        self.forms = forms
    }
}

extension DataZoneClientTypes {

    /// The details of the automatically generated business metadata that is rejected.
    public struct RejectChoice: Swift.Sendable {
        /// Specifies the the automatically generated business metadata that can be rejected.
        public var predictionChoices: [Swift.Int]?
        /// Specifies the target (for example, a column name) where a prediction can be rejected.
        /// This member is required.
        public var predictionTarget: Swift.String?

        public init(
            predictionChoices: [Swift.Int]? = nil,
            predictionTarget: Swift.String? = nil
        )
        {
            self.predictionChoices = predictionChoices
            self.predictionTarget = predictionTarget
        }
    }
}

extension DataZoneClientTypes {

    public enum RejectRuleBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RejectRuleBehavior] {
            return [
                .all,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// Specifies the rule and the threshold under which a prediction can be rejected.
    public struct RejectRule: Swift.Sendable {
        /// Specifies whether you want to reject the top prediction for all targets or none.
        public var rule: DataZoneClientTypes.RejectRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be rejected.
        public var threshold: Swift.Float?

        public init(
            rule: DataZoneClientTypes.RejectRuleBehavior? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.rule = rule
            self.threshold = threshold
        }
    }
}

public struct RejectPredictionsInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the prediction.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be rejected.
    public var rejectChoices: [DataZoneClientTypes.RejectChoice]?
    /// Specifies the rule (or the conditions) under which a prediction can be rejected.
    public var rejectRule: DataZoneClientTypes.RejectRule?
    /// The revision that is to be made to the asset.
    public var revision: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        rejectChoices: [DataZoneClientTypes.RejectChoice]? = nil,
        rejectRule: DataZoneClientTypes.RejectRule? = nil,
        revision: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.rejectChoices = rejectChoices
        self.rejectRule = rejectRule
        self.revision = revision
    }
}

public struct RejectPredictionsOutput: Swift.Sendable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The revision that is to be made to the asset.
    /// This member is required.
    public var assetRevision: Swift.String?
    /// The ID of the Amazon DataZone domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        assetRevision: Swift.String? = nil,
        domainId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.assetRevision = assetRevision
        self.domainId = domainId
    }
}

public struct RejectSubscriptionRequestInput: Swift.Sendable {
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        decisionComment: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.decisionComment = decisionComment
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
    }
}

extension RejectSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), decisionComment: \"CONTENT_REDACTED\")"}
}

public struct RejectSubscriptionRequestOutput: Swift.Sendable {
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp of when the subscription request was rejected.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the rejected subscription request.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that was rejected.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the subscription request.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the subscription request reviewer.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension RejectSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

public struct RemoveEntityOwnerInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the domain where you want to remove an owner from an entity.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity from which you want to remove an owner.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the entity from which you want to remove an owner.
    /// This member is required.
    public var entityType: DataZoneClientTypes.DataZoneEntityType?
    /// The owner that you want to remove from an entity.
    /// This member is required.
    public var owner: DataZoneClientTypes.OwnerProperties?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.DataZoneEntityType? = nil,
        owner: DataZoneClientTypes.OwnerProperties? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.owner = owner
    }
}

public struct RemoveEntityOwnerOutput: Swift.Sendable {

    public init() { }
}

public struct RemovePolicyGrantInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the domain where you want to remove a policy grant.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the entity from which you want to remove a policy grant.
    /// This member is required.
    public var entityIdentifier: Swift.String?
    /// The type of the entity from which you want to remove a policy grant.
    /// This member is required.
    public var entityType: DataZoneClientTypes.TargetEntityType?
    /// The type of the policy that you want to remove.
    /// This member is required.
    public var policyType: DataZoneClientTypes.ManagedPolicyType?
    /// The principal from which you want to remove a policy grant.
    /// This member is required.
    public var principal: DataZoneClientTypes.PolicyGrantPrincipal?

    public init(
        clientToken: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: DataZoneClientTypes.TargetEntityType? = nil,
        policyType: DataZoneClientTypes.ManagedPolicyType? = nil,
        principal: DataZoneClientTypes.PolicyGrantPrincipal? = nil
    )
    {
        self.clientToken = clientToken
        self.domainIdentifier = domainIdentifier
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.policyType = policyType
        self.principal = principal
    }
}

public struct RemovePolicyGrantOutput: Swift.Sendable {

    public init() { }
}

public struct RevokeSubscriptionInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.retainPermissions = retainPermissions
    }
}

public struct RevokeSubscriptionOutput: Swift.Sendable {
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The identifier of the user who revoked the subscription.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the revoked subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies whether permissions are retained when the subscription is revoked.
    public var retainPermissions: Swift.Bool?
    /// The status of the revoked subscription.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionStatus?
    /// The subscribed listing of the revoked subscription.
    /// This member is required.
    public var subscribedListing: DataZoneClientTypes.SubscribedListing?
    /// The subscribed principal of the revoked subscription.
    /// This member is required.
    public var subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal?
    /// The identifier of the subscription request for the revoked subscription.
    public var subscriptionRequestId: Swift.String?
    /// The timestamp of when the subscription was revoked.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who revoked the subscription.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        retainPermissions: Swift.Bool? = nil,
        status: DataZoneClientTypes.SubscriptionStatus? = nil,
        subscribedListing: DataZoneClientTypes.SubscribedListing? = nil,
        subscribedPrincipal: DataZoneClientTypes.SubscribedPrincipal? = nil,
        subscriptionRequestId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.id = id
        self.retainPermissions = retainPermissions
        self.status = status
        self.subscribedListing = subscribedListing
        self.subscribedPrincipal = subscribedPrincipal
        self.subscriptionRequestId = subscriptionRequestId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension DataZoneClientTypes {

    public enum SearchOutputAdditionalAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forms
        case timeSeriesDataPointForms
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchOutputAdditionalAttribute] {
            return [
                .forms,
                .timeSeriesDataPointForms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forms: return "FORMS"
            case .timeSeriesDataPointForms: return "TIME_SERIES_DATA_POINT_FORMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// A search filter in Amazon DataZone.
    public struct Filter: Swift.Sendable {
        /// A search filter attribute in Amazon DataZone.
        /// This member is required.
        public var attribute: Swift.String?
        /// A search filter value in Amazon DataZone.
        /// This member is required.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.value = value
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the search.
    public struct SearchInItem: Swift.Sendable {
        /// The search attribute.
        /// This member is required.
        public var attribute: Swift.String?

        public init(
            attribute: Swift.String? = nil
        )
        {
            self.attribute = attribute
        }
    }
}

extension DataZoneClientTypes {

    public enum InventorySearchScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case dataProduct
        case glossary
        case glossaryTerm
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySearchScope] {
            return [
                .asset,
                .dataProduct,
                .glossary,
                .glossaryTerm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataProduct: return "DATA_PRODUCT"
            case .glossary: return "GLOSSARY"
            case .glossaryTerm: return "GLOSSARY_TERM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the way to sort search results.
    public struct SearchSort: Swift.Sendable {
        /// The attribute detail of the way to sort search results.
        /// This member is required.
        public var attribute: Swift.String?
        /// The order detail of the wya to sort search results.
        public var order: DataZoneClientTypes.SortOrder?

        public init(
            attribute: Swift.String? = nil,
            order: DataZoneClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }
}

extension DataZoneClientTypes {

    /// The details of a business glossary.
    public struct GlossaryItem: Swift.Sendable {
        /// The timestamp of when the glossary was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the glossary.
        public var createdBy: Swift.String?
        /// The business glossary description.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the glossary.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the glossary.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the project that owns the business glosary.
        /// This member is required.
        public var owningProjectId: Swift.String?
        /// The business glossary status.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryStatus?
        /// The timestamp of when the business glossary was updated.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the business glossary.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes.GlossaryItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), owningProjectId: \(Swift.String(describing: owningProjectId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of a business glossary term.
    public struct GlossaryTermItem: Swift.Sendable {
        /// The timestamp of when a business glossary term was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created the business glossary.
        public var createdBy: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The identifier of the business glossary to which the term belongs.
        /// This member is required.
        public var glossaryId: Swift.String?
        /// The identifier of the business glossary term.
        /// This member is required.
        public var id: Swift.String?
        /// The long description of the business glossary term.
        public var longDescription: Swift.String?
        /// The name of the business glossary term.
        /// This member is required.
        public var name: Swift.String?
        /// The short description of the business glossary term.
        public var shortDescription: Swift.String?
        /// The status of the business glossary term.
        /// This member is required.
        public var status: DataZoneClientTypes.GlossaryTermStatus?
        /// The relations of the business glossary term.
        public var termRelations: DataZoneClientTypes.TermRelations?
        /// The timestamp of when a business glossary term was updated.
        public var updatedAt: Foundation.Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            domainId: Swift.String? = nil,
            glossaryId: Swift.String? = nil,
            id: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            name: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            status: DataZoneClientTypes.GlossaryTermStatus? = nil,
            termRelations: DataZoneClientTypes.TermRelations? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes.GlossaryTermItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlossaryTermItem(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), glossaryId: \(Swift.String(describing: glossaryId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), termRelations: \(Swift.String(describing: termRelations)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), longDescription: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", shortDescription: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the search results.
    public enum SearchInventoryResultItem: Swift.Sendable {
        /// The glossary item included in the search results.
        case glossaryitem(DataZoneClientTypes.GlossaryItem)
        /// The glossary term item included in the search results.
        case glossarytermitem(DataZoneClientTypes.GlossaryTermItem)
        /// The asset item included in the search results.
        case assetitem(DataZoneClientTypes.AssetItem)
        /// The data product.
        case dataproductitem(DataZoneClientTypes.DataProductResultItem)
        case sdkUnknown(Swift.String)
    }
}

public struct SearchOutput: Swift.Sendable {
    /// The results of the Search action.
    public var items: [DataZoneClientTypes.SearchInventoryResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchInventoryResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

extension DataZoneClientTypes {

    public enum GroupSearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datazoneSsoGroup
        case ssoGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupSearchType] {
            return [
                .datazoneSsoGroup,
                .ssoGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datazoneSsoGroup: return "DATAZONE_SSO_GROUP"
            case .ssoGroup: return "SSO_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchGroupProfilesInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which you want to search group profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The group type for which to search.
    /// This member is required.
    public var groupType: DataZoneClientTypes.GroupSearchType?
    /// The maximum number of results to return in a single call to SearchGroupProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupType: DataZoneClientTypes.GroupSearchType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupType = groupType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
    }
}

extension SearchGroupProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchGroupProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), groupType: \(Swift.String(describing: groupType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchText: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of a group profile.
    public struct GroupProfileSummary: Swift.Sendable {
        /// The ID of the Amazon DataZone domain of a group profile.
        public var domainId: Swift.String?
        /// The group name of a group profile.
        public var groupName: Swift.String?
        /// The ID of a group profile.
        public var id: Swift.String?
        /// The status of a group profile.
        public var status: DataZoneClientTypes.GroupProfileStatus?

        public init(
            domainId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.GroupProfileStatus? = nil
        )
        {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }
    }
}

extension DataZoneClientTypes.GroupProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupProfileSummary(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

public struct SearchGroupProfilesOutput: Swift.Sendable {
    /// The results of the SearchGroupProfiles action.
    public var items: [DataZoneClientTypes.GroupProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.GroupProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension DataZoneClientTypes {

    /// The details of the results of the SearchListings action.
    public enum SearchResultItem: Swift.Sendable {
        /// The asset listing included in the results of the SearchListings action.
        case assetlisting(DataZoneClientTypes.AssetListingItem)
        /// The data product listing.
        case dataproductlisting(DataZoneClientTypes.DataProductListingItem)
        case sdkUnknown(Swift.String)
    }
}

public struct SearchListingsOutput: Swift.Sendable {
    /// The results of the SearchListings action.
    public var items: [DataZoneClientTypes.SearchResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

extension DataZoneClientTypes {

    public enum TypesSearchScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assetType
        case formType
        case lineageNodeType
        case sdkUnknown(Swift.String)

        public static var allCases: [TypesSearchScope] {
            return [
                .assetType,
                .formType,
                .lineageNodeType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assetType: return "ASSET_TYPE"
            case .formType: return "FORM_TYPE"
            case .lineageNodeType: return "LINEAGE_NODE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the metadata form type.
    public struct FormTypeData: Swift.Sendable {
        /// The timestamp of when the metadata form type was created.
        public var createdAt: Foundation.Date?
        /// The Amazon DataZone user who created teh metadata form type.
        public var createdBy: Swift.String?
        /// The description of the metadata form type.
        public var description: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type exists.
        /// This member is required.
        public var domainId: Swift.String?
        /// The imports specified in the form type.
        public var imports: [DataZoneClientTypes.Import]?
        /// The model of the form type.
        public var model: DataZoneClientTypes.Model?
        /// The name of the form type.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the Amazon DataZone domain in which the form type was originally created.
        public var originDomainId: Swift.String?
        /// The identifier of the project in which the form type was originally created.
        public var originProjectId: Swift.String?
        /// The identifier of the project that owns the form type.
        public var owningProjectId: Swift.String?
        /// The revision of the form type.
        /// This member is required.
        public var revision: Swift.String?
        /// The status of the form type.
        public var status: DataZoneClientTypes.FormTypeStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            imports: [DataZoneClientTypes.Import]? = nil,
            model: DataZoneClientTypes.Model? = nil,
            name: Swift.String? = nil,
            originDomainId: Swift.String? = nil,
            originProjectId: Swift.String? = nil,
            owningProjectId: Swift.String? = nil,
            revision: Swift.String? = nil,
            status: DataZoneClientTypes.FormTypeStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }
    }
}

extension DataZoneClientTypes.FormTypeData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FormTypeData(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), imports: \(Swift.String(describing: imports)), originDomainId: \(Swift.String(describing: originDomainId)), originProjectId: \(Swift.String(describing: originProjectId)), owningProjectId: \(Swift.String(describing: owningProjectId)), revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of a data lineage node type.
    public struct LineageNodeTypeItem: Swift.Sendable {
        /// The timestamp at which the data lineage node type was created.
        public var createdAt: Foundation.Date?
        /// The user who created the data lineage node type.
        public var createdBy: Swift.String?
        /// The description of the data lineage node type.
        public var description: Swift.String?
        /// The ID of the domain where the data lineage node type lives.
        /// This member is required.
        public var domainId: Swift.String?
        /// The forms output of the data lineage node type.
        /// This member is required.
        public var formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]?
        /// The name of the data lineage node type.
        public var name: Swift.String?
        /// The revision of the data lineage node type.
        /// This member is required.
        public var revision: Swift.String?
        /// The timestamp at which the data lineage node type was updated.
        public var updatedAt: Foundation.Date?
        /// The user who updated the data lineage node type.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            formsOutput: [Swift.String: DataZoneClientTypes.FormEntryOutput]? = nil,
            name: Swift.String? = nil,
            revision: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DataZoneClientTypes {

    /// The details of the results of the SearchTypes action.
    public enum SearchTypesResultItem: Swift.Sendable {
        /// The asset type included in the results of the SearchTypes action.
        case assettypeitem(DataZoneClientTypes.AssetTypeItem)
        /// The form type included in the results of the SearchTypes action.
        case formtypeitem(DataZoneClientTypes.FormTypeData)
        /// The details of a data lineage node type.
        case lineagenodetypeitem(DataZoneClientTypes.LineageNodeTypeItem)
        case sdkUnknown(Swift.String)
    }
}

public struct SearchTypesOutput: Swift.Sendable {
    /// The results of the SearchTypes action.
    public var items: [DataZoneClientTypes.SearchTypesResultItem]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    /// Total number of search results.
    public var totalMatchCount: Swift.Int?

    public init(
        items: [DataZoneClientTypes.SearchTypesResultItem]? = nil,
        nextToken: Swift.String? = nil,
        totalMatchCount: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.totalMatchCount = totalMatchCount
    }
}

extension DataZoneClientTypes {

    public enum UserSearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datazoneIamUser
        case datazoneSsoUser
        case datazoneUser
        case ssoUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSearchType] {
            return [
                .datazoneIamUser,
                .datazoneSsoUser,
                .datazoneUser,
                .ssoUser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datazoneIamUser: return "DATAZONE_IAM_USER"
            case .datazoneSsoUser: return "DATAZONE_SSO_USER"
            case .datazoneUser: return "DATAZONE_USER"
            case .ssoUser: return "SSO_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchUserProfilesInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which you want to search user profiles.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The maximum number of results to return in a single call to SearchUserProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchUserProfiles to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the user type for the SearchUserProfiles action.
    /// This member is required.
    public var userType: DataZoneClientTypes.UserSearchType?

    public init(
        domainIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchText: Swift.String? = nil,
        userType: DataZoneClientTypes.UserSearchType? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchText = searchText
        self.userType = userType
    }
}

extension SearchUserProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchUserProfilesInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userType: \(Swift.String(describing: userType)), searchText: \"CONTENT_REDACTED\")"}
}

extension DataZoneClientTypes {

    /// The details of the user profile.
    public struct UserProfileSummary: Swift.Sendable {
        /// The details of the user profile.
        public var details: DataZoneClientTypes.UserProfileDetails?
        /// The ID of the Amazon DataZone domain of the user profile.
        public var domainId: Swift.String?
        /// The ID of the user profile.
        public var id: Swift.String?
        /// The status of the user profile.
        public var status: DataZoneClientTypes.UserProfileStatus?
        /// The type of the user profile.
        public var type: DataZoneClientTypes.UserProfileType?

        public init(
            details: DataZoneClientTypes.UserProfileDetails? = nil,
            domainId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: DataZoneClientTypes.UserProfileStatus? = nil,
            type: DataZoneClientTypes.UserProfileType? = nil
        )
        {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }
    }
}

public struct SearchUserProfilesOutput: Swift.Sendable {
    /// The results of the SearchUserProfiles action.
    public var items: [DataZoneClientTypes.UserProfileSummary]?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [DataZoneClientTypes.UserProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to be tagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tags for the TagResource action.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// You do not have permission to perform this action.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to be untagged in Amazon DataZone.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tag keys for the UntagResource action.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEnvironmentInput: Swift.Sendable {
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironment action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

public struct UpdateEnvironmentOutput: Swift.Sendable {
    /// The identifier of the Amazon Web Services account in which the environment is to be updated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which the environment is updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the environment.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The deployment properties to be updated as part of the UpdateEnvironment action.
    public var deploymentProperties: DataZoneClientTypes.DeploymentProperties?
    /// The description to be updated as part of the UpdateEnvironment action.
    public var description: Swift.String?
    /// The identifier of the domain in which the environment is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The environment actions to be updated as part of the UpdateEnvironment action.
    public var environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]?
    /// The blueprint identifier of the environment.
    public var environmentBlueprintId: Swift.String?
    /// The profile identifier of the environment.
    public var environmentProfileId: Swift.String?
    /// The glossary terms to be updated as part of the UpdateEnvironment action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the environment that is to be updated.
    public var id: Swift.String?
    /// The last deployment of the environment.
    public var lastDeployment: DataZoneClientTypes.Deployment?
    /// The name to be updated as part of the UpdateEnvironment action.
    /// This member is required.
    public var name: Swift.String?
    /// The project identifier of the environment.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider identifier of the environment.
    /// This member is required.
    public var provider: Swift.String?
    /// The provisioned resources to be updated as part of the UpdateEnvironment action.
    public var provisionedResources: [DataZoneClientTypes.Resource]?
    /// The provisioning properties to be updated as part of the UpdateEnvironment action.
    public var provisioningProperties: DataZoneClientTypes.ProvisioningProperties?
    /// The status to be updated as part of the UpdateEnvironment action.
    public var status: DataZoneClientTypes.EnvironmentStatus?
    /// The timestamp of when the environment was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters to be updated as part of the UpdateEnvironment action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        deploymentProperties: DataZoneClientTypes.DeploymentProperties? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentActions: [DataZoneClientTypes.ConfigurableEnvironmentAction]? = nil,
        environmentBlueprintId: Swift.String? = nil,
        environmentProfileId: Swift.String? = "",
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastDeployment: DataZoneClientTypes.Deployment? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        provisionedResources: [DataZoneClientTypes.Resource]? = nil,
        provisioningProperties: DataZoneClientTypes.ProvisioningProperties? = nil,
        status: DataZoneClientTypes.EnvironmentStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deploymentProperties = deploymentProperties
        self.description = description
        self.domainId = domainId
        self.environmentActions = environmentActions
        self.environmentBlueprintId = environmentBlueprintId
        self.environmentProfileId = environmentProfileId
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastDeployment = lastDeployment
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.provisionedResources = provisionedResources
        self.provisioningProperties = provisioningProperties
        self.status = status
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension UpdateEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), deploymentProperties: \(Swift.String(describing: deploymentProperties)), domainId: \(Swift.String(describing: domainId)), environmentActions: \(Swift.String(describing: environmentActions)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), environmentProfileId: \(Swift.String(describing: environmentProfileId)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastDeployment: \(Swift.String(describing: lastDeployment)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), provisionedResources: \(Swift.String(describing: provisionedResources)), provisioningProperties: \(Swift.String(describing: provisioningProperties)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateEnvironmentActionInput: Swift.Sendable {
    /// The description of the environment action.
    public var description: Swift.String?
    /// The domain ID of the environment action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The environment ID of the environment action.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the environment action.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the environment action.
    public var name: Swift.String?
    /// The parameters of the environment action.
    public var parameters: DataZoneClientTypes.ActionParameters?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: DataZoneClientTypes.ActionParameters? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
        self.name = name
        self.parameters = parameters
    }
}

public struct UpdateEnvironmentActionOutput: Swift.Sendable {
    /// The description of the environment action.
    public var description: Swift.String?
    /// The domain ID of the environment action.
    /// This member is required.
    public var domainId: Swift.String?
    /// The environment ID of the environment action.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ID of the environment action.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the environment action.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters of the environment action.
    /// This member is required.
    public var parameters: DataZoneClientTypes.ActionParameters?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: DataZoneClientTypes.ActionParameters? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.name = name
        self.parameters = parameters
    }
}

public struct UpdateEnvironmentProfileInput: Swift.Sendable {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which an environment profile is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment profile that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    public var name: Swift.String?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.EnvironmentParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        userParameters: [DataZoneClientTypes.EnvironmentParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
        self.userParameters = userParameters
    }
}

extension UpdateEnvironmentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileInput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), description: \(Swift.String(describing: description)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), userParameters: \(Swift.String(describing: userParameters)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateEnvironmentProfileOutput: Swift.Sendable {
    /// The Amazon Web Services account in which a specified environment profile is to be udpated.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services Region in which a specified environment profile is to be updated.
    public var awsAccountRegion: Swift.String?
    /// The timestamp of when the environment profile was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the environment profile.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description to be updated as part of the UpdateEnvironmentProfile action.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which the environment profile is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the blueprint of the environment profile that is to be updated.
    /// This member is required.
    public var environmentBlueprintId: Swift.String?
    /// The identifier of the environment profile that is to be udpated.
    /// This member is required.
    public var id: Swift.String?
    /// The name to be updated as part of the UpdateEnvironmentProfile action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project of the environment profile that is to be updated.
    public var projectId: Swift.String?
    /// The timestamp of when the environment profile was updated.
    public var updatedAt: Foundation.Date?
    /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
    public var userParameters: [DataZoneClientTypes.CustomParameter]?

    public init(
        awsAccountId: Swift.String? = nil,
        awsAccountRegion: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentBlueprintId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        userParameters: [DataZoneClientTypes.CustomParameter]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.awsAccountRegion = awsAccountRegion
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.environmentBlueprintId = environmentBlueprintId
        self.id = id
        self.name = name
        self.projectId = projectId
        self.updatedAt = updatedAt
        self.userParameters = userParameters
    }
}

extension UpdateEnvironmentProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentProfileOutput(awsAccountId: \(Swift.String(describing: awsAccountId)), awsAccountRegion: \(Swift.String(describing: awsAccountRegion)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentBlueprintId: \(Swift.String(describing: environmentBlueprintId)), id: \(Swift.String(describing: id)), projectId: \(Swift.String(describing: projectId)), updatedAt: \(Swift.String(describing: updatedAt)), userParameters: \(Swift.String(describing: userParameters)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGroupProfileInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the group profile that is updated.
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The status of the group profile that is updated.
    /// This member is required.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainIdentifier: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.groupIdentifier = groupIdentifier
        self.status = status
    }
}

public struct UpdateGroupProfileOutput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a group profile is updated.
    public var domainId: Swift.String?
    /// The name of the group profile that is updated.
    public var groupName: Swift.String?
    /// The identifier of the group profile that is updated.
    public var id: Swift.String?
    /// The status of the group profile that is updated.
    public var status: DataZoneClientTypes.GroupProfileStatus?

    public init(
        domainId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.GroupProfileStatus? = nil
    )
    {
        self.domainId = domainId
        self.groupName = groupName
        self.id = id
        self.status = status
    }
}

extension UpdateGroupProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGroupProfileOutput(domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), groupName: \"CONTENT_REDACTED\")"}
}

public struct UpdateProjectInput: Swift.Sendable {
    /// The description to be updated as part of the UpdateProject action.
    public var description: Swift.String?
    /// The ID of the Amazon DataZone domain where a project is being updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The glossary terms to be updated as part of the UpdateProject action.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name to be updated as part of the UpdateProject action.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        glossaryTerms: [Swift.String]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.glossaryTerms = glossaryTerms
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), identifier: \(Swift.String(describing: identifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateProjectOutput: Swift.Sendable {
    /// The timestamp of when the project was created.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the project.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the project that is to be updated.
    public var description: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a project is updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The ID of the domain unit.
    public var domainUnitId: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureReasons: [DataZoneClientTypes.ProjectDeletionError]?
    /// The glossary terms of the project that are to be updated.
    public var glossaryTerms: [Swift.String]?
    /// The identifier of the project that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp of when the project was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the project that is to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the project.
    public var projectStatus: DataZoneClientTypes.ProjectStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainUnitId: Swift.String? = nil,
        failureReasons: [DataZoneClientTypes.ProjectDeletionError]? = nil,
        glossaryTerms: [Swift.String]? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        projectStatus: DataZoneClientTypes.ProjectStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.domainId = domainId
        self.domainUnitId = domainUnitId
        self.failureReasons = failureReasons
        self.glossaryTerms = glossaryTerms
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.projectStatus = projectStatus
    }
}

extension UpdateProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), domainUnitId: \(Swift.String(describing: domainUnitId)), failureReasons: \(Swift.String(describing: failureReasons)), glossaryTerms: \(Swift.String(describing: glossaryTerms)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), projectStatus: \(Swift.String(describing: projectStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateSubscriptionGrantStatusInput: Swift.Sendable {
    /// The identifier of the asset the subscription grant status of which is to be updated.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the error message that is returned if the operation cannot be successfully completed.
    public var failureCause: DataZoneClientTypes.FailureCause?
    /// The identifier of the subscription grant the status of which is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantStatus?
    /// The target name to be updated as part of the UpdateSubscriptionGrantStatus action.
    public var targetName: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        failureCause: DataZoneClientTypes.FailureCause? = nil,
        identifier: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantStatus? = nil,
        targetName: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.domainIdentifier = domainIdentifier
        self.failureCause = failureCause
        self.identifier = identifier
        self.status = status
        self.targetName = targetName
    }
}

public struct UpdateSubscriptionGrantStatusOutput: Swift.Sendable {
    /// The details of the asset for which the subscription grant is created.
    public var assets: [DataZoneClientTypes.SubscribedAsset]?
    /// The timestamp of when the subscription grant status was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone domain user who created the subscription grant status.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The granted entity to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var grantedEntity: DataZoneClientTypes.GrantedEntity?
    /// The identifier of the subscription grant.
    /// This member is required.
    public var id: Swift.String?
    /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionGrantOverallStatus?
    /// The identifier of the subscription.
    @available(*, deprecated, message: "Multiple subscriptions can exist for a single grant")
    public var subscriptionId: Swift.String?
    /// The identifier of the subscription target whose subscription grant status is to be updated.
    /// This member is required.
    public var subscriptionTargetId: Swift.String?
    /// The timestamp of when the subscription grant status is to be updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription grant status.
    public var updatedBy: Swift.String?

    public init(
        assets: [DataZoneClientTypes.SubscribedAsset]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        grantedEntity: DataZoneClientTypes.GrantedEntity? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionGrantOverallStatus? = nil,
        subscriptionId: Swift.String? = nil,
        subscriptionTargetId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.assets = assets
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.grantedEntity = grantedEntity
        self.id = id
        self.status = status
        self.subscriptionId = subscriptionId
        self.subscriptionTargetId = subscriptionTargetId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct UpdateSubscriptionRequestInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestReason: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.requestReason = requestReason
    }
}

extension UpdateSubscriptionRequestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestInput(domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), requestReason: \"CONTENT_REDACTED\")"}
}

public struct UpdateSubscriptionRequestOutput: Swift.Sendable {
    /// The timestamp of when the subscription request was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription request.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The decision comment of the UpdateSubscriptionRequest action.
    public var decisionComment: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the subscription request that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The reason for the UpdateSubscriptionRequest action.
    /// This member is required.
    public var requestReason: Swift.String?
    /// The identifier of the Amazon DataZone user who reviews the subscription request.
    public var reviewerId: Swift.String?
    /// The status of the subscription request.
    /// This member is required.
    public var status: DataZoneClientTypes.SubscriptionRequestStatus?
    /// The subscribed listings of the subscription request.
    /// This member is required.
    public var subscribedListings: [DataZoneClientTypes.SubscribedListing]?
    /// The subscribed principals of the subscription request.
    /// This member is required.
    public var subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]?
    /// The timestamp of when the subscription request was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription request.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        decisionComment: Swift.String? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        requestReason: Swift.String? = nil,
        reviewerId: Swift.String? = nil,
        status: DataZoneClientTypes.SubscriptionRequestStatus? = nil,
        subscribedListings: [DataZoneClientTypes.SubscribedListing]? = nil,
        subscribedPrincipals: [DataZoneClientTypes.SubscribedPrincipal]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.decisionComment = decisionComment
        self.domainId = domainId
        self.id = id
        self.requestReason = requestReason
        self.reviewerId = reviewerId
        self.status = status
        self.subscribedListings = subscribedListings
        self.subscribedPrincipals = subscribedPrincipals
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension UpdateSubscriptionRequestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionRequestOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), id: \(Swift.String(describing: id)), reviewerId: \(Swift.String(describing: reviewerId)), status: \(Swift.String(describing: status)), subscribedListings: \(Swift.String(describing: subscribedListings)), subscribedPrincipals: \(Swift.String(describing: subscribedPrincipals)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), decisionComment: \"CONTENT_REDACTED\", requestReason: \"CONTENT_REDACTED\")"}
}

public struct UpdateSubscriptionTargetInput: Swift.Sendable {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    public var authorizedPrincipals: [Swift.String]?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    public var name: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        domainIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.domainIdentifier = domainIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.identifier = identifier
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
    }
}

extension UpdateSubscriptionTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetInput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), environmentIdentifier: \(Swift.String(describing: environmentIdentifier)), identifier: \(Swift.String(describing: identifier)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateSubscriptionTargetOutput: Swift.Sendable {
    /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var applicableAssetTypes: [Swift.String]?
    /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var authorizedPrincipals: [Swift.String]?
    /// The timestamp of when a subscription target was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon DataZone user who created the subscription target.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the environment in which a subscription target is to be updated.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Identifier of the subscription target that is to be updated.
    /// This member is required.
    public var id: Swift.String?
    /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var manageAccessRole: Swift.String?
    /// The name to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the project in which a subscription target is to be updated.
    /// This member is required.
    public var projectId: Swift.String?
    /// The provider to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var provider: Swift.String?
    /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]?
    /// The type to be updated as part of the UpdateSubscriptionTarget action.
    /// This member is required.
    public var type: Swift.String?
    /// The timestamp of when the subscription target was updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon DataZone user who updated the subscription target.
    public var updatedBy: Swift.String?

    public init(
        applicableAssetTypes: [Swift.String]? = nil,
        authorizedPrincipals: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        domainId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        id: Swift.String? = nil,
        manageAccessRole: Swift.String? = nil,
        name: Swift.String? = nil,
        projectId: Swift.String? = nil,
        provider: Swift.String? = nil,
        subscriptionTargetConfig: [DataZoneClientTypes.SubscriptionTargetForm]? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.applicableAssetTypes = applicableAssetTypes
        self.authorizedPrincipals = authorizedPrincipals
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.domainId = domainId
        self.environmentId = environmentId
        self.id = id
        self.manageAccessRole = manageAccessRole
        self.name = name
        self.projectId = projectId
        self.provider = provider
        self.subscriptionTargetConfig = subscriptionTargetConfig
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension UpdateSubscriptionTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubscriptionTargetOutput(applicableAssetTypes: \(Swift.String(describing: applicableAssetTypes)), authorizedPrincipals: \(Swift.String(describing: authorizedPrincipals)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), domainId: \(Swift.String(describing: domainId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), manageAccessRole: \(Swift.String(describing: manageAccessRole)), projectId: \(Swift.String(describing: projectId)), provider: \(Swift.String(describing: provider)), subscriptionTargetConfig: \(Swift.String(describing: subscriptionTargetConfig)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateUserProfileInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The status of the user profile that are to be updated.
    /// This member is required.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile that are to be updated.
    public var type: DataZoneClientTypes.UserProfileType?
    /// The identifier of the user whose user profile is to be updated.
    /// This member is required.
    public var userIdentifier: Swift.String?

    public init(
        domainIdentifier: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil,
        userIdentifier: Swift.String? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.status = status
        self.type = type
        self.userIdentifier = userIdentifier
    }
}

public struct UpdateUserProfileOutput: Swift.Sendable {
    /// The details of the user profile in Amazon DataZone.
    public var details: DataZoneClientTypes.UserProfileDetails?
    /// The identifier of the Amazon DataZone domain in which a user profile is updated.
    public var domainId: Swift.String?
    /// The identifier of the user profile.
    public var id: Swift.String?
    /// The status of the user profile.
    public var status: DataZoneClientTypes.UserProfileStatus?
    /// The type of the user profile.
    public var type: DataZoneClientTypes.UserProfileType?

    public init(
        details: DataZoneClientTypes.UserProfileDetails? = nil,
        domainId: Swift.String? = nil,
        id: Swift.String? = nil,
        status: DataZoneClientTypes.UserProfileStatus? = nil,
        type: DataZoneClientTypes.UserProfileType? = nil
    )
    {
        self.details = details
        self.domainId = domainId
        self.id = id
        self.status = status
        self.type = type
    }
}

extension DataZoneClientTypes {

    /// A search filter clause in Amazon DataZone.
    public indirect enum FilterClause: Swift.Sendable {
        /// A search filter in Amazon DataZone.
        case filter(DataZoneClientTypes.Filter)
        /// The 'and' search filter clause in Amazon DataZone.
        case and([DataZoneClientTypes.FilterClause])
        /// The 'or' search filter clause in Amazon DataZone.
        case or([DataZoneClientTypes.FilterClause])
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The row filter.
    public indirect enum RowFilter: Swift.Sendable {
        /// The expression of the row filter.
        case expression(DataZoneClientTypes.RowFilterExpression)
        /// The 'and' clause of the row filter.
        case and([DataZoneClientTypes.RowFilter])
        /// The 'or' clause of the row filter.
        case or([DataZoneClientTypes.RowFilter])
        case sdkUnknown(Swift.String)
    }
}

extension DataZoneClientTypes {

    /// The row filter configuration details.
    public struct RowFilterConfiguration: Swift.Sendable {
        /// The row filter.
        /// This member is required.
        public var rowFilter: DataZoneClientTypes.RowFilter?
        /// Specifies whether the row filter is sensitive.
        public var sensitive: Swift.Bool?

        public init(
            rowFilter: DataZoneClientTypes.RowFilter? = nil,
            sensitive: Swift.Bool? = true
        )
        {
            self.rowFilter = rowFilter
            self.sensitive = sensitive
        }
    }
}

public struct SearchInput: Swift.Sendable {
    /// Specifies additional attributes for the Search action.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the Amazon DataZone domain.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the search filters.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to Search. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to Search to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the owning project specified for the search.
    public var owningProjectIdentifier: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// The scope of the search.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.InventorySearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way in which the search results are to be sorted.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owningProjectIdentifier: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.InventorySearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owningProjectIdentifier = owningProjectIdentifier
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

public struct SearchListingsInput: Swift.Sendable {
    /// Specifies additional attributes for the search.
    public var additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]?
    /// The identifier of the domain in which to search listings.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// Specifies the filters for the search of listings.
    public var filters: DataZoneClientTypes.FilterClause?
    /// The maximum number of results to return in a single call to SearchListings. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchListings to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
    public var nextToken: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// Specifies the way for sorting the search results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        additionalAttributes: [DataZoneClientTypes.SearchOutputAdditionalAttribute]? = nil,
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchText = searchText
        self.sort = sort
    }
}

public struct SearchTypesInput: Swift.Sendable {
    /// The identifier of the Amazon DataZone domain in which to invoke the SearchTypes action.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The filters for the SearchTypes action.
    public var filters: DataZoneClientTypes.FilterClause?
    /// Specifies whether the search is managed.
    /// This member is required.
    public var managed: Swift.Bool?
    /// The maximum number of results to return in a single call to SearchTypes. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchTypes to list the next set of results.
    public var maxResults: Swift.Int?
    /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
    public var nextToken: Swift.String?
    /// The details of the search.
    public var searchIn: [DataZoneClientTypes.SearchInItem]?
    /// Specifies the scope of the search for types.
    /// This member is required.
    public var searchScope: DataZoneClientTypes.TypesSearchScope?
    /// Specifies the text for which to search.
    public var searchText: Swift.String?
    /// The specifies the way to sort the SearchTypes results.
    public var sort: DataZoneClientTypes.SearchSort?

    public init(
        domainIdentifier: Swift.String? = nil,
        filters: DataZoneClientTypes.FilterClause? = nil,
        managed: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchIn: [DataZoneClientTypes.SearchInItem]? = nil,
        searchScope: DataZoneClientTypes.TypesSearchScope? = nil,
        searchText: Swift.String? = nil,
        sort: DataZoneClientTypes.SearchSort? = nil
    )
    {
        self.domainIdentifier = domainIdentifier
        self.filters = filters
        self.managed = managed
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchIn = searchIn
        self.searchScope = searchScope
        self.searchText = searchText
        self.sort = sort
    }
}

extension DataZoneClientTypes {

    /// The configuration details of the asset filter.
    public indirect enum AssetFilterConfiguration: Swift.Sendable {
        /// The column configuration of the asset filter.
        case columnconfiguration(DataZoneClientTypes.ColumnFilterConfiguration)
        /// The row configuration of the asset filter.
        case rowconfiguration(DataZoneClientTypes.RowFilterConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateAssetFilterInput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The configuration of the asset filter.
    /// This member is required.
    public var configuration: DataZoneClientTypes.AssetFilterConfiguration?
    /// The description of the asset filter.
    public var description: Swift.String?
    /// The ID of the domain in which you want to create an asset filter.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The name of the asset filter.
    /// This member is required.
    public var name: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: DataZoneClientTypes.AssetFilterConfiguration? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.name = name
    }
}

extension CreateAssetFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetFilterInput(assetIdentifier: \(Swift.String(describing: assetIdentifier)), clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAssetFilterOutput: Swift.Sendable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The configuration of the asset filter.
    /// This member is required.
    public var configuration: DataZoneClientTypes.AssetFilterConfiguration?
    /// The timestamp at which the asset filter was created.
    public var createdAt: Foundation.Date?
    /// The description of the asset filter.
    public var description: Swift.String?
    /// The ID of the domain where the asset filter is created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The column names in the asset filter.
    public var effectiveColumnNames: [Swift.String]?
    /// The row filter in the asset filter.
    public var effectiveRowFilter: Swift.String?
    /// The error message that is displayed if the asset filter is not created successfully.
    public var errorMessage: Swift.String?
    /// The ID of the asset filter.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the asset filter.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the asset filter.
    public var status: DataZoneClientTypes.FilterStatus?

    public init(
        assetId: Swift.String? = nil,
        configuration: DataZoneClientTypes.AssetFilterConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        effectiveColumnNames: [Swift.String]? = nil,
        effectiveRowFilter: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.FilterStatus? = nil
    )
    {
        self.assetId = assetId
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.effectiveColumnNames = effectiveColumnNames
        self.effectiveRowFilter = effectiveRowFilter
        self.errorMessage = errorMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension CreateAssetFilterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetFilterOutput(assetId: \(Swift.String(describing: assetId)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), effectiveColumnNames: \(Swift.String(describing: effectiveColumnNames)), effectiveRowFilter: \(Swift.String(describing: effectiveRowFilter)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetAssetFilterOutput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The configuration of the asset filter.
    /// This member is required.
    public var configuration: DataZoneClientTypes.AssetFilterConfiguration?
    /// The timestamp at which the asset filter was created.
    public var createdAt: Foundation.Date?
    /// The description of the asset filter.
    public var description: Swift.String?
    /// The ID of the domain where you want to get an asset filter.
    /// This member is required.
    public var domainId: Swift.String?
    /// The column names of the asset filter.
    public var effectiveColumnNames: [Swift.String]?
    /// The row filter of the asset filter.
    public var effectiveRowFilter: Swift.String?
    /// The error message that is displayed if the action does not complete successfully.
    public var errorMessage: Swift.String?
    /// The ID of the asset filter.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the asset filter.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the asset filter.
    public var status: DataZoneClientTypes.FilterStatus?

    public init(
        assetId: Swift.String? = nil,
        configuration: DataZoneClientTypes.AssetFilterConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        effectiveColumnNames: [Swift.String]? = nil,
        effectiveRowFilter: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.FilterStatus? = nil
    )
    {
        self.assetId = assetId
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.effectiveColumnNames = effectiveColumnNames
        self.effectiveRowFilter = effectiveRowFilter
        self.errorMessage = errorMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension GetAssetFilterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetFilterOutput(assetId: \(Swift.String(describing: assetId)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), effectiveColumnNames: \(Swift.String(describing: effectiveColumnNames)), effectiveRowFilter: \(Swift.String(describing: effectiveRowFilter)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssetFilterInput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetIdentifier: Swift.String?
    /// The configuration of the asset filter.
    public var configuration: DataZoneClientTypes.AssetFilterConfiguration?
    /// The description of the asset filter.
    public var description: Swift.String?
    /// The ID of the domain where you want to update an asset filter.
    /// This member is required.
    public var domainIdentifier: Swift.String?
    /// The ID of the asset filter.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the asset filter.
    public var name: Swift.String?

    public init(
        assetIdentifier: Swift.String? = nil,
        configuration: DataZoneClientTypes.AssetFilterConfiguration? = nil,
        description: Swift.String? = nil,
        domainIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.assetIdentifier = assetIdentifier
        self.configuration = configuration
        self.description = description
        self.domainIdentifier = domainIdentifier
        self.identifier = identifier
        self.name = name
    }
}

extension UpdateAssetFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetFilterInput(assetIdentifier: \(Swift.String(describing: assetIdentifier)), configuration: \(Swift.String(describing: configuration)), domainIdentifier: \(Swift.String(describing: domainIdentifier)), identifier: \(Swift.String(describing: identifier)), name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssetFilterOutput: Swift.Sendable {
    /// The ID of the data asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The configuration of the asset filter.
    /// This member is required.
    public var configuration: DataZoneClientTypes.AssetFilterConfiguration?
    /// The timestamp at which the asset filter was created.
    public var createdAt: Foundation.Date?
    /// The description of the asset filter.
    public var description: Swift.String?
    /// The ID of the domain where the asset filter was created.
    /// This member is required.
    public var domainId: Swift.String?
    /// The column names of the asset filter.
    public var effectiveColumnNames: [Swift.String]?
    /// The row filter of the asset filter.
    public var effectiveRowFilter: Swift.String?
    /// The error message that is displayed if the action is not completed successfully.
    public var errorMessage: Swift.String?
    /// The ID of the asset filter.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the asset filter.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the asset filter.
    public var status: DataZoneClientTypes.FilterStatus?

    public init(
        assetId: Swift.String? = nil,
        configuration: DataZoneClientTypes.AssetFilterConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        effectiveColumnNames: [Swift.String]? = nil,
        effectiveRowFilter: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: DataZoneClientTypes.FilterStatus? = nil
    )
    {
        self.assetId = assetId
        self.configuration = configuration
        self.createdAt = createdAt
        self.description = description
        self.domainId = domainId
        self.effectiveColumnNames = effectiveColumnNames
        self.effectiveRowFilter = effectiveRowFilter
        self.errorMessage = errorMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension UpdateAssetFilterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetFilterOutput(assetId: \(Swift.String(describing: assetId)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), effectiveColumnNames: \(Swift.String(describing: effectiveColumnNames)), effectiveRowFilter: \(Swift.String(describing: effectiveRowFilter)), errorMessage: \(Swift.String(describing: errorMessage)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension AcceptPredictionsInput {

    static func urlPathProvider(_ value: AcceptPredictionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/accept-predictions"
    }
}

extension AcceptPredictionsInput {

    static func queryItemProvider(_ value: AcceptPredictionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension AcceptSubscriptionRequestInput {

    static func urlPathProvider(_ value: AcceptSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/accept"
    }
}

extension AddEntityOwnerInput {

    static func urlPathProvider(_ value: AddEntityOwnerInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/addOwner"
    }
}

extension AddPolicyGrantInput {

    static func urlPathProvider(_ value: AddPolicyGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/policies/managed/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/addGrant"
    }
}

extension AssociateEnvironmentRoleInput {

    static func urlPathProvider(_ value: AssociateEnvironmentRoleInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let environmentRoleArn = value.environmentRoleArn else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/roles/\(environmentRoleArn.urlPercentEncoding())"
    }
}

extension CancelMetadataGenerationRunInput {

    static func urlPathProvider(_ value: CancelMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs/\(identifier.urlPercentEncoding())/cancel"
    }
}

extension CancelSubscriptionInput {

    static func urlPathProvider(_ value: CancelSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/cancel"
    }
}

extension CreateAssetInput {

    static func urlPathProvider(_ value: CreateAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets"
    }
}

extension CreateAssetFilterInput {

    static func urlPathProvider(_ value: CreateAssetFilterInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(assetIdentifier.urlPercentEncoding())/filters"
    }
}

extension CreateAssetRevisionInput {

    static func urlPathProvider(_ value: CreateAssetRevisionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

extension CreateAssetTypeInput {

    static func urlPathProvider(_ value: CreateAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types"
    }
}

extension CreateDataProductInput {

    static func urlPathProvider(_ value: CreateDataProductInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-products"
    }
}

extension CreateDataProductRevisionInput {

    static func urlPathProvider(_ value: CreateDataProductRevisionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-products/\(identifier.urlPercentEncoding())/revisions"
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/v2/domains"
    }
}

extension CreateDomainUnitInput {

    static func urlPathProvider(_ value: CreateDomainUnitInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/domain-units"
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

extension CreateEnvironmentActionInput {

    static func urlPathProvider(_ value: CreateEnvironmentActionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/actions"
    }
}

extension CreateEnvironmentProfileInput {

    static func urlPathProvider(_ value: CreateEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

extension CreateFormTypeInput {

    static func urlPathProvider(_ value: CreateFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types"
    }
}

extension CreateGlossaryInput {

    static func urlPathProvider(_ value: CreateGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries"
    }
}

extension CreateGlossaryTermInput {

    static func urlPathProvider(_ value: CreateGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms"
    }
}

extension CreateGroupProfileInput {

    static func urlPathProvider(_ value: CreateGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles"
    }
}

extension CreateListingChangeSetInput {

    static func urlPathProvider(_ value: CreateListingChangeSetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/change-set"
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

extension CreateProjectMembershipInput {

    static func urlPathProvider(_ value: CreateProjectMembershipInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/createMembership"
    }
}

extension CreateSubscriptionGrantInput {

    static func urlPathProvider(_ value: CreateSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

extension CreateSubscriptionRequestInput {

    static func urlPathProvider(_ value: CreateSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

extension CreateSubscriptionTargetInput {

    static func urlPathProvider(_ value: CreateSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

extension CreateUserProfileInput {

    static func urlPathProvider(_ value: CreateUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles"
    }
}

extension DeleteAssetInput {

    static func urlPathProvider(_ value: DeleteAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteAssetFilterInput {

    static func urlPathProvider(_ value: DeleteAssetFilterInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(assetIdentifier.urlPercentEncoding())/filters/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteAssetTypeInput {

    static func urlPathProvider(_ value: DeleteAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDataProductInput {

    static func urlPathProvider(_ value: DeleteDataProductInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-products/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDataSourceInput {

    static func queryItemProvider(_ value: DeleteDataSourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let retainPermissionsOnRevokeFailure = value.retainPermissionsOnRevokeFailure {
            let retainPermissionsOnRevokeFailureQueryItem = Smithy.URIQueryItem(name: "retainPermissionsOnRevokeFailure".urlPercentEncoding(), value: Swift.String(retainPermissionsOnRevokeFailure).urlPercentEncoding())
            items.append(retainPermissionsOnRevokeFailureQueryItem)
        }
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDomainInput {

    static func queryItemProvider(_ value: DeleteDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        if let skipDeletionCheck = value.skipDeletionCheck {
            let skipDeletionCheckQueryItem = Smithy.URIQueryItem(name: "skipDeletionCheck".urlPercentEncoding(), value: Swift.String(skipDeletionCheck).urlPercentEncoding())
            items.append(skipDeletionCheckQueryItem)
        }
        return items
    }
}

extension DeleteDomainUnitInput {

    static func urlPathProvider(_ value: DeleteDomainUnitInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/domain-units/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentActionInput {

    static func urlPathProvider(_ value: DeleteEnvironmentActionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/actions/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: DeleteEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentProfileInput {

    static func urlPathProvider(_ value: DeleteEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteFormTypeInput {

    static func urlPathProvider(_ value: DeleteFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = value.formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGlossaryInput {

    static func urlPathProvider(_ value: DeleteGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteGlossaryTermInput {

    static func urlPathProvider(_ value: DeleteGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteListingInput {

    static func urlPathProvider(_ value: DeleteListingInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func queryItemProvider(_ value: DeleteProjectInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipDeletionCheck = value.skipDeletionCheck {
            let skipDeletionCheckQueryItem = Smithy.URIQueryItem(name: "skipDeletionCheck".urlPercentEncoding(), value: Swift.String(skipDeletionCheck).urlPercentEncoding())
            items.append(skipDeletionCheckQueryItem)
        }
        return items
    }
}

extension DeleteProjectMembershipInput {

    static func urlPathProvider(_ value: DeleteProjectMembershipInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/deleteMembership"
    }
}

extension DeleteSubscriptionGrantInput {

    static func urlPathProvider(_ value: DeleteSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteSubscriptionRequestInput {

    static func urlPathProvider(_ value: DeleteSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteSubscriptionTargetInput {

    static func urlPathProvider(_ value: DeleteSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: DeleteTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

extension DeleteTimeSeriesDataPointsInput {

    static func queryItemProvider(_ value: DeleteTimeSeriesDataPointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formNameQueryItem = Smithy.URIQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        return items
    }
}

extension DisassociateEnvironmentRoleInput {

    static func urlPathProvider(_ value: DisassociateEnvironmentRoleInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let environmentRoleArn = value.environmentRoleArn else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/roles/\(environmentRoleArn.urlPercentEncoding())"
    }
}

extension GetAssetInput {

    static func urlPathProvider(_ value: GetAssetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())"
    }
}

extension GetAssetInput {

    static func queryItemProvider(_ value: GetAssetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetAssetFilterInput {

    static func urlPathProvider(_ value: GetAssetFilterInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(assetIdentifier.urlPercentEncoding())/filters/\(identifier.urlPercentEncoding())"
    }
}

extension GetAssetTypeInput {

    static func urlPathProvider(_ value: GetAssetTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/asset-types/\(identifier.urlPercentEncoding())"
    }
}

extension GetAssetTypeInput {

    static func queryItemProvider(_ value: GetAssetTypeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetDataProductInput {

    static func urlPathProvider(_ value: GetDataProductInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-products/\(identifier.urlPercentEncoding())"
    }
}

extension GetDataProductInput {

    static func queryItemProvider(_ value: GetDataProductInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

extension GetDataSourceRunInput {

    static func urlPathProvider(_ value: GetDataSourceRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())"
    }
}

extension GetDomainInput {

    static func urlPathProvider(_ value: GetDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

extension GetDomainUnitInput {

    static func urlPathProvider(_ value: GetDomainUnitInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/domain-units/\(identifier.urlPercentEncoding())"
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

extension GetEnvironmentActionInput {

    static func urlPathProvider(_ value: GetEnvironmentActionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/actions/\(identifier.urlPercentEncoding())"
    }
}

extension GetEnvironmentBlueprintInput {

    static func urlPathProvider(_ value: GetEnvironmentBlueprintInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints/\(identifier.urlPercentEncoding())"
    }
}

extension GetEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: GetEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

extension GetEnvironmentCredentialsInput {

    static func urlPathProvider(_ value: GetEnvironmentCredentialsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/credentials"
    }
}

extension GetEnvironmentProfileInput {

    static func urlPathProvider(_ value: GetEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension GetFormTypeInput {

    static func urlPathProvider(_ value: GetFormTypeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let formTypeIdentifier = value.formTypeIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/form-types/\(formTypeIdentifier.urlPercentEncoding())"
    }
}

extension GetFormTypeInput {

    static func queryItemProvider(_ value: GetFormTypeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension GetGlossaryInput {

    static func urlPathProvider(_ value: GetGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

extension GetGlossaryTermInput {

    static func urlPathProvider(_ value: GetGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

extension GetGroupProfileInput {

    static func urlPathProvider(_ value: GetGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = value.groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

extension GetIamPortalLoginUrlInput {

    static func urlPathProvider(_ value: GetIamPortalLoginUrlInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/get-portal-login-url"
    }
}

extension GetLineageNodeInput {

    static func urlPathProvider(_ value: GetLineageNodeInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/lineage/nodes/\(identifier.urlPercentEncoding())"
    }
}

extension GetLineageNodeInput {

    static func queryItemProvider(_ value: GetLineageNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let eventTimestamp = value.eventTimestamp {
            let eventTimestampQueryItem = Smithy.URIQueryItem(name: "timestamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: eventTimestamp)).urlPercentEncoding())
            items.append(eventTimestampQueryItem)
        }
        return items
    }
}

extension GetListingInput {

    static func urlPathProvider(_ value: GetListingInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/\(identifier.urlPercentEncoding())"
    }
}

extension GetListingInput {

    static func queryItemProvider(_ value: GetListingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let listingRevision = value.listingRevision {
            let listingRevisionQueryItem = Smithy.URIQueryItem(name: "listingRevision".urlPercentEncoding(), value: Swift.String(listingRevision).urlPercentEncoding())
            items.append(listingRevisionQueryItem)
        }
        return items
    }
}

extension GetMetadataGenerationRunInput {

    static func urlPathProvider(_ value: GetMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs/\(identifier.urlPercentEncoding())"
    }
}

extension GetProjectInput {

    static func urlPathProvider(_ value: GetProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

extension GetSubscriptionInput {

    static func urlPathProvider(_ value: GetSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())"
    }
}

extension GetSubscriptionGrantInput {

    static func urlPathProvider(_ value: GetSubscriptionGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())"
    }
}

extension GetSubscriptionRequestDetailsInput {

    static func urlPathProvider(_ value: GetSubscriptionRequestDetailsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

extension GetSubscriptionTargetInput {

    static func urlPathProvider(_ value: GetSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

extension GetTimeSeriesDataPointInput {

    static func urlPathProvider(_ value: GetTimeSeriesDataPointInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points/\(identifier.urlPercentEncoding())"
    }
}

extension GetTimeSeriesDataPointInput {

    static func queryItemProvider(_ value: GetTimeSeriesDataPointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formNameQueryItem = Smithy.URIQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        return items
    }
}

extension GetUserProfileInput {

    static func urlPathProvider(_ value: GetUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let userIdentifier = value.userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

extension GetUserProfileInput {

    static func queryItemProvider(_ value: GetUserProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListAssetFiltersInput {

    static func urlPathProvider(_ value: ListAssetFiltersInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(assetIdentifier.urlPercentEncoding())/filters"
    }
}

extension ListAssetFiltersInput {

    static func queryItemProvider(_ value: ListAssetFiltersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListAssetRevisionsInput {

    static func urlPathProvider(_ value: ListAssetRevisionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/revisions"
    }
}

extension ListAssetRevisionsInput {

    static func queryItemProvider(_ value: ListAssetRevisionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataProductRevisionsInput {

    static func urlPathProvider(_ value: ListDataProductRevisionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-products/\(identifier.urlPercentEncoding())/revisions"
    }
}

extension ListDataProductRevisionsInput {

    static func queryItemProvider(_ value: ListDataProductRevisionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListDataSourceRunActivitiesInput {

    static func urlPathProvider(_ value: ListDataSourceRunActivitiesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-source-runs/\(identifier.urlPercentEncoding())/activities"
    }
}

extension ListDataSourceRunActivitiesInput {

    static func queryItemProvider(_ value: ListDataSourceRunActivitiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDataSourceRunsInput {

    static func urlPathProvider(_ value: ListDataSourceRunsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = value.dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

extension ListDataSourceRunsInput {

    static func queryItemProvider(_ value: ListDataSourceRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources"
    }
}

extension ListDataSourcesInput {

    static func queryItemProvider(_ value: ListDataSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let environmentIdentifier = value.environmentIdentifier {
            let environmentIdentifierQueryItem = Smithy.URIQueryItem(name: "environmentIdentifier".urlPercentEncoding(), value: Swift.String(environmentIdentifier).urlPercentEncoding())
            items.append(environmentIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        guard let projectIdentifier = value.projectIdentifier else {
            let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let projectIdentifierQueryItem = Smithy.URIQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
        items.append(projectIdentifierQueryItem)
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/v2/domains"
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDomainUnitsForParentInput {

    static func urlPathProvider(_ value: ListDomainUnitsForParentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/domain-units"
    }
}

extension ListDomainUnitsForParentInput {

    static func queryItemProvider(_ value: ListDomainUnitsForParentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let parentDomainUnitIdentifier = value.parentDomainUnitIdentifier else {
            let message = "Creating a URL Query Item failed. parentDomainUnitIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let parentDomainUnitIdentifierQueryItem = Smithy.URIQueryItem(name: "parentDomainUnitIdentifier".urlPercentEncoding(), value: Swift.String(parentDomainUnitIdentifier).urlPercentEncoding())
        items.append(parentDomainUnitIdentifierQueryItem)
        return items
    }
}

extension ListEntityOwnersInput {

    static func urlPathProvider(_ value: ListEntityOwnersInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/owners"
    }
}

extension ListEntityOwnersInput {

    static func queryItemProvider(_ value: ListEntityOwnersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEnvironmentActionsInput {

    static func urlPathProvider(_ value: ListEnvironmentActionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/actions"
    }
}

extension ListEnvironmentActionsInput {

    static func queryItemProvider(_ value: ListEnvironmentActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentBlueprintConfigurationsInput {

    static func urlPathProvider(_ value: ListEnvironmentBlueprintConfigurationsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations"
    }
}

extension ListEnvironmentBlueprintConfigurationsInput {

    static func queryItemProvider(_ value: ListEnvironmentBlueprintConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEnvironmentBlueprintsInput {

    static func urlPathProvider(_ value: ListEnvironmentBlueprintsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprints"
    }
}

extension ListEnvironmentBlueprintsInput {

    static func queryItemProvider(_ value: ListEnvironmentBlueprintsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let managed = value.managed {
            let managedQueryItem = Smithy.URIQueryItem(name: "managed".urlPercentEncoding(), value: Swift.String(managed).urlPercentEncoding())
            items.append(managedQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListEnvironmentProfilesInput {

    static func urlPathProvider(_ value: ListEnvironmentProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles"
    }
}

extension ListEnvironmentProfilesInput {

    static func queryItemProvider(_ value: ListEnvironmentProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier {
            let environmentBlueprintIdentifierQueryItem = Smithy.URIQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
            items.append(environmentBlueprintIdentifierQueryItem)
        }
        if let awsAccountId = value.awsAccountId {
            let awsAccountIdQueryItem = Smithy.URIQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
            items.append(awsAccountIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let awsAccountRegion = value.awsAccountRegion {
            let awsAccountRegionQueryItem = Smithy.URIQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
            items.append(awsAccountRegionQueryItem)
        }
        if let projectIdentifier = value.projectIdentifier {
            let projectIdentifierQueryItem = Smithy.URIQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
            items.append(projectIdentifierQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments"
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier {
            let environmentBlueprintIdentifierQueryItem = Smithy.URIQueryItem(name: "environmentBlueprintIdentifier".urlPercentEncoding(), value: Swift.String(environmentBlueprintIdentifier).urlPercentEncoding())
            items.append(environmentBlueprintIdentifierQueryItem)
        }
        if let awsAccountId = value.awsAccountId {
            let awsAccountIdQueryItem = Smithy.URIQueryItem(name: "awsAccountId".urlPercentEncoding(), value: Swift.String(awsAccountId).urlPercentEncoding())
            items.append(awsAccountIdQueryItem)
        }
        if let environmentProfileIdentifier = value.environmentProfileIdentifier {
            let environmentProfileIdentifierQueryItem = Smithy.URIQueryItem(name: "environmentProfileIdentifier".urlPercentEncoding(), value: Swift.String(environmentProfileIdentifier).urlPercentEncoding())
            items.append(environmentProfileIdentifierQueryItem)
        }
        if let provider = value.provider {
            let providerQueryItem = Smithy.URIQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
            items.append(providerQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let awsAccountRegion = value.awsAccountRegion {
            let awsAccountRegionQueryItem = Smithy.URIQueryItem(name: "awsAccountRegion".urlPercentEncoding(), value: Swift.String(awsAccountRegion).urlPercentEncoding())
            items.append(awsAccountRegionQueryItem)
        }
        guard let projectIdentifier = value.projectIdentifier else {
            let message = "Creating a URL Query Item failed. projectIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let projectIdentifierQueryItem = Smithy.URIQueryItem(name: "projectIdentifier".urlPercentEncoding(), value: Swift.String(projectIdentifier).urlPercentEncoding())
        items.append(projectIdentifierQueryItem)
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListLineageNodeHistoryInput {

    static func urlPathProvider(_ value: ListLineageNodeHistoryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/lineage/nodes/\(identifier.urlPercentEncoding())/history"
    }
}

extension ListLineageNodeHistoryInput {

    static func queryItemProvider(_ value: ListLineageNodeHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let eventTimestampGTE = value.eventTimestampGTE {
            let eventTimestampGTEQueryItem = Smithy.URIQueryItem(name: "timestampGTE".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: eventTimestampGTE)).urlPercentEncoding())
            items.append(eventTimestampGTEQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let direction = value.direction {
            let directionQueryItem = Smithy.URIQueryItem(name: "direction".urlPercentEncoding(), value: Swift.String(direction.rawValue).urlPercentEncoding())
            items.append(directionQueryItem)
        }
        if let eventTimestampLTE = value.eventTimestampLTE {
            let eventTimestampLTEQueryItem = Smithy.URIQueryItem(name: "timestampLTE".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: eventTimestampLTE)).urlPercentEncoding())
            items.append(eventTimestampLTEQueryItem)
        }
        return items
    }
}

extension ListMetadataGenerationRunsInput {

    static func urlPathProvider(_ value: ListMetadataGenerationRunsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs"
    }
}

extension ListMetadataGenerationRunsInput {

    static func queryItemProvider(_ value: ListMetadataGenerationRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListNotificationsInput {

    static func urlPathProvider(_ value: ListNotificationsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/notifications"
    }
}

extension ListNotificationsInput {

    static func queryItemProvider(_ value: ListNotificationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let beforeTimestamp = value.beforeTimestamp {
            let beforeTimestampQueryItem = Smithy.URIQueryItem(name: "beforeTimestamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: beforeTimestamp)).urlPercentEncoding())
            items.append(beforeTimestampQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let subjects = value.subjects {
            subjects.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "subjects".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
        items.append(typeQueryItem)
        if let afterTimestamp = value.afterTimestamp {
            let afterTimestampQueryItem = Smithy.URIQueryItem(name: "afterTimestamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: afterTimestamp)).urlPercentEncoding())
            items.append(afterTimestampQueryItem)
        }
        if let taskStatus = value.taskStatus {
            let taskStatusQueryItem = Smithy.URIQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
            items.append(taskStatusQueryItem)
        }
        return items
    }
}

extension ListPolicyGrantsInput {

    static func urlPathProvider(_ value: ListPolicyGrantsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/policies/managed/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/grants"
    }
}

extension ListPolicyGrantsInput {

    static func queryItemProvider(_ value: ListPolicyGrantsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let policyType = value.policyType else {
            let message = "Creating a URL Query Item failed. policyType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let policyTypeQueryItem = Smithy.URIQueryItem(name: "policyType".urlPercentEncoding(), value: Swift.String(policyType.rawValue).urlPercentEncoding())
        items.append(policyTypeQueryItem)
        return items
    }
}

extension ListProjectMembershipsInput {

    static func urlPathProvider(_ value: ListProjectMembershipsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let projectIdentifier = value.projectIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(projectIdentifier.urlPercentEncoding())/memberships"
    }
}

extension ListProjectMembershipsInput {

    static func queryItemProvider(_ value: ListProjectMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects"
    }
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userIdentifier = value.userIdentifier {
            let userIdentifierQueryItem = Smithy.URIQueryItem(name: "userIdentifier".urlPercentEncoding(), value: Swift.String(userIdentifier).urlPercentEncoding())
            items.append(userIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let groupIdentifier = value.groupIdentifier {
            let groupIdentifierQueryItem = Smithy.URIQueryItem(name: "groupIdentifier".urlPercentEncoding(), value: Swift.String(groupIdentifier).urlPercentEncoding())
            items.append(groupIdentifierQueryItem)
        }
        return items
    }
}

extension ListSubscriptionGrantsInput {

    static func urlPathProvider(_ value: ListSubscriptionGrantsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants"
    }
}

extension ListSubscriptionGrantsInput {

    static func queryItemProvider(_ value: ListSubscriptionGrantsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let environmentId = value.environmentId {
            let environmentIdQueryItem = Smithy.URIQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            items.append(environmentIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = Smithy.URIQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let subscriptionTargetId = value.subscriptionTargetId {
            let subscriptionTargetIdQueryItem = Smithy.URIQueryItem(name: "subscriptionTargetId".urlPercentEncoding(), value: Swift.String(subscriptionTargetId).urlPercentEncoding())
            items.append(subscriptionTargetIdQueryItem)
        }
        if let owningProjectId = value.owningProjectId {
            let owningProjectIdQueryItem = Smithy.URIQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
            items.append(owningProjectIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let subscriptionId = value.subscriptionId {
            let subscriptionIdQueryItem = Smithy.URIQueryItem(name: "subscriptionId".urlPercentEncoding(), value: Swift.String(subscriptionId).urlPercentEncoding())
            items.append(subscriptionIdQueryItem)
        }
        return items
    }
}

extension ListSubscriptionRequestsInput {

    static func urlPathProvider(_ value: ListSubscriptionRequestsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests"
    }
}

extension ListSubscriptionRequestsInput {

    static func queryItemProvider(_ value: ListSubscriptionRequestsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let approverProjectId = value.approverProjectId {
            let approverProjectIdQueryItem = Smithy.URIQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
            items.append(approverProjectIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = Smithy.URIQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let owningProjectId = value.owningProjectId {
            let owningProjectIdQueryItem = Smithy.URIQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
            items.append(owningProjectIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSubscriptionsInput {

    static func urlPathProvider(_ value: ListSubscriptionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions"
    }
}

extension ListSubscriptionsInput {

    static func queryItemProvider(_ value: ListSubscriptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let approverProjectId = value.approverProjectId {
            let approverProjectIdQueryItem = Smithy.URIQueryItem(name: "approverProjectId".urlPercentEncoding(), value: Swift.String(approverProjectId).urlPercentEncoding())
            items.append(approverProjectIdQueryItem)
        }
        if let subscribedListingId = value.subscribedListingId {
            let subscribedListingIdQueryItem = Smithy.URIQueryItem(name: "subscribedListingId".urlPercentEncoding(), value: Swift.String(subscribedListingId).urlPercentEncoding())
            items.append(subscribedListingIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let owningProjectId = value.owningProjectId {
            let owningProjectIdQueryItem = Smithy.URIQueryItem(name: "owningProjectId".urlPercentEncoding(), value: Swift.String(owningProjectId).urlPercentEncoding())
            items.append(owningProjectIdQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let subscriptionRequestIdentifier = value.subscriptionRequestIdentifier {
            let subscriptionRequestIdentifierQueryItem = Smithy.URIQueryItem(name: "subscriptionRequestIdentifier".urlPercentEncoding(), value: Swift.String(subscriptionRequestIdentifier).urlPercentEncoding())
            items.append(subscriptionRequestIdentifierQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSubscriptionTargetsInput {

    static func urlPathProvider(_ value: ListSubscriptionTargetsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets"
    }
}

extension ListSubscriptionTargetsInput {

    static func queryItemProvider(_ value: ListSubscriptionTargetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: ListTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

extension ListTimeSeriesDataPointsInput {

    static func queryItemProvider(_ value: ListTimeSeriesDataPointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endedAt = value.endedAt {
            let endedAtQueryItem = Smithy.URIQueryItem(name: "endedAt".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endedAt)).urlPercentEncoding())
            items.append(endedAtQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let formName = value.formName else {
            let message = "Creating a URL Query Item failed. formName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formNameQueryItem = Smithy.URIQueryItem(name: "formName".urlPercentEncoding(), value: Swift.String(formName).urlPercentEncoding())
        items.append(formNameQueryItem)
        if let startedAt = value.startedAt {
            let startedAtQueryItem = Smithy.URIQueryItem(name: "startedAt".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startedAt)).urlPercentEncoding())
            items.append(startedAtQueryItem)
        }
        return items
    }
}

extension PostLineageEventInput {

    static func urlPathProvider(_ value: PostLineageEventInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/lineage/events"
    }
}

extension PostLineageEventInput {

    static func queryItemProvider(_ value: PostLineageEventInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension PostTimeSeriesDataPointsInput {

    static func urlPathProvider(_ value: PostTimeSeriesDataPointsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/time-series-data-points"
    }
}

extension PutEnvironmentBlueprintConfigurationInput {

    static func urlPathProvider(_ value: PutEnvironmentBlueprintConfigurationInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentBlueprintIdentifier = value.environmentBlueprintIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-blueprint-configurations/\(environmentBlueprintIdentifier.urlPercentEncoding())"
    }
}

extension RejectPredictionsInput {

    static func urlPathProvider(_ value: RejectPredictionsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(identifier.urlPercentEncoding())/reject-predictions"
    }
}

extension RejectPredictionsInput {

    static func queryItemProvider(_ value: RejectPredictionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revision = value.revision {
            let revisionQueryItem = Smithy.URIQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(revision).urlPercentEncoding())
            items.append(revisionQueryItem)
        }
        return items
    }
}

extension RejectSubscriptionRequestInput {

    static func urlPathProvider(_ value: RejectSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())/reject"
    }
}

extension RemoveEntityOwnerInput {

    static func urlPathProvider(_ value: RemoveEntityOwnerInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/entities/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/removeOwner"
    }
}

extension RemovePolicyGrantInput {

    static func urlPathProvider(_ value: RemovePolicyGrantInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let entityType = value.entityType else {
            return nil
        }
        guard let entityIdentifier = value.entityIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/policies/managed/\(entityType.rawValue.urlPercentEncoding())/\(entityIdentifier.urlPercentEncoding())/removeGrant"
    }
}

extension RevokeSubscriptionInput {

    static func urlPathProvider(_ value: RevokeSubscriptionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscriptions/\(identifier.urlPercentEncoding())/revoke"
    }
}

extension SearchInput {

    static func urlPathProvider(_ value: SearchInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search"
    }
}

extension SearchGroupProfilesInput {

    static func urlPathProvider(_ value: SearchGroupProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-group-profiles"
    }
}

extension SearchListingsInput {

    static func urlPathProvider(_ value: SearchListingsInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/listings/search"
    }
}

extension SearchTypesInput {

    static func urlPathProvider(_ value: SearchTypesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/types-search"
    }
}

extension SearchUserProfilesInput {

    static func urlPathProvider(_ value: SearchUserProfilesInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/search-user-profiles"
    }
}

extension StartDataSourceRunInput {

    static func urlPathProvider(_ value: StartDataSourceRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let dataSourceIdentifier = value.dataSourceIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(dataSourceIdentifier.urlPercentEncoding())/runs"
    }
}

extension StartMetadataGenerationRunInput {

    static func urlPathProvider(_ value: StartMetadataGenerationRunInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/metadata-generation-runs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAssetFilterInput {

    static func urlPathProvider(_ value: UpdateAssetFilterInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/assets/\(assetIdentifier.urlPercentEncoding())/filters/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/data-sources/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDomainInput {

    static func urlPathProvider(_ value: UpdateDomainInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDomainInput {

    static func queryItemProvider(_ value: UpdateDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdateDomainUnitInput {

    static func urlPathProvider(_ value: UpdateDomainUnitInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/domain-units/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentActionInput {

    static func urlPathProvider(_ value: UpdateEnvironmentActionInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/actions/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentProfileInput {

    static func urlPathProvider(_ value: UpdateEnvironmentProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environment-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateGlossaryInput {

    static func urlPathProvider(_ value: UpdateGlossaryInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossaries/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateGlossaryTermInput {

    static func urlPathProvider(_ value: UpdateGlossaryTermInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/glossary-terms/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateGroupProfileInput {

    static func urlPathProvider(_ value: UpdateGroupProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let groupIdentifier = value.groupIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/group-profiles/\(groupIdentifier.urlPercentEncoding())"
    }
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/projects/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionGrantStatusInput {

    static func urlPathProvider(_ value: UpdateSubscriptionGrantStatusInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        guard let assetIdentifier = value.assetIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-grants/\(identifier.urlPercentEncoding())/status/\(assetIdentifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionRequestInput {

    static func urlPathProvider(_ value: UpdateSubscriptionRequestInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/subscription-requests/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionTargetInput {

    static func urlPathProvider(_ value: UpdateSubscriptionTargetInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let environmentIdentifier = value.environmentIdentifier else {
            return nil
        }
        guard let identifier = value.identifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/environments/\(environmentIdentifier.urlPercentEncoding())/subscription-targets/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateUserProfileInput {

    static func urlPathProvider(_ value: UpdateUserProfileInput) -> Swift.String? {
        guard let domainIdentifier = value.domainIdentifier else {
            return nil
        }
        guard let userIdentifier = value.userIdentifier else {
            return nil
        }
        return "/v2/domains/\(domainIdentifier.urlPercentEncoding())/user-profiles/\(userIdentifier.urlPercentEncoding())"
    }
}

extension AcceptPredictionsInput {

    static func write(value: AcceptPredictionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceptChoices"].writeList(value.acceptChoices, memberWritingClosure: DataZoneClientTypes.AcceptChoice.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["acceptRule"].write(value.acceptRule, with: DataZoneClientTypes.AcceptRule.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
    }
}

extension AcceptSubscriptionRequestInput {

    static func write(value: AcceptSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetScopes"].writeList(value.assetScopes, memberWritingClosure: DataZoneClientTypes.AcceptedAssetScope.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["decisionComment"].write(value.decisionComment)
    }
}

extension AddEntityOwnerInput {

    static func write(value: AddEntityOwnerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["owner"].write(value.owner, with: DataZoneClientTypes.OwnerProperties.write(value:to:))
    }
}

extension AddPolicyGrantInput {

    static func write(value: AddPolicyGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["detail"].write(value.detail, with: DataZoneClientTypes.PolicyGrantDetail.write(value:to:))
        try writer["policyType"].write(value.policyType)
        try writer["principal"].write(value.principal, with: DataZoneClientTypes.PolicyGrantPrincipal.write(value:to:))
    }
}

extension CreateAssetInput {

    static func write(value: CreateAssetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["externalIdentifier"].write(value.externalIdentifier)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["predictionConfiguration"].write(value.predictionConfiguration, with: DataZoneClientTypes.PredictionConfiguration.write(value:to:))
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension CreateAssetFilterInput {

    static func write(value: CreateAssetFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.AssetFilterConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension CreateAssetRevisionInput {

    static func write(value: CreateAssetRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["predictionConfiguration"].write(value.predictionConfiguration, with: DataZoneClientTypes.PredictionConfiguration.write(value:to:))
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension CreateAssetTypeInput {

    static func write(value: CreateAssetTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["formsInput"].writeMap(value.formsInput, valueWritingClosure: DataZoneClientTypes.FormEntryInput.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
    }
}

extension CreateDataProductInput {

    static func write(value: CreateDataProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["items"].writeList(value.items, memberWritingClosure: DataZoneClientTypes.DataProductItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
    }
}

extension CreateDataProductRevisionInput {

    static func write(value: CreateDataProductRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["formsInput"].writeList(value.formsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["items"].writeList(value.items, memberWritingClosure: DataZoneClientTypes.DataProductItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetFormsInput"].writeList(value.assetFormsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.DataSourceConfigurationInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["enableSetting"].write(value.enableSetting)
        try writer["environmentIdentifier"].write(value.environmentIdentifier)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["publishOnImport"].write(value.publishOnImport)
        try writer["recommendation"].write(value.recommendation, with: DataZoneClientTypes.RecommendationConfiguration.write(value:to:))
        try writer["schedule"].write(value.schedule, with: DataZoneClientTypes.ScheduleConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["domainExecutionRole"].write(value.domainExecutionRole)
        try writer["kmsKeyIdentifier"].write(value.kmsKeyIdentifier)
        try writer["name"].write(value.name)
        try writer["singleSignOn"].write(value.singleSignOn, with: DataZoneClientTypes.SingleSignOn.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDomainUnitInput {

    static func write(value: CreateDomainUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parentDomainUnitIdentifier"].write(value.parentDomainUnitIdentifier)
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["environmentAccountIdentifier"].write(value.environmentAccountIdentifier)
        try writer["environmentAccountRegion"].write(value.environmentAccountRegion)
        try writer["environmentBlueprintIdentifier"].write(value.environmentBlueprintIdentifier)
        try writer["environmentProfileIdentifier"].write(value.environmentProfileIdentifier)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEnvironmentActionInput {

    static func write(value: CreateEnvironmentActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parameters"].write(value.parameters, with: DataZoneClientTypes.ActionParameters.write(value:to:))
    }
}

extension CreateEnvironmentProfileInput {

    static func write(value: CreateEnvironmentProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["awsAccountRegion"].write(value.awsAccountRegion)
        try writer["description"].write(value.description)
        try writer["environmentBlueprintIdentifier"].write(value.environmentBlueprintIdentifier)
        try writer["name"].write(value.name)
        try writer["projectIdentifier"].write(value.projectIdentifier)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFormTypeInput {

    static func write(value: CreateFormTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["model"].write(value.model, with: DataZoneClientTypes.Model.write(value:to:))
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["status"].write(value.status)
    }
}

extension CreateGlossaryInput {

    static func write(value: CreateGlossaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["status"].write(value.status)
    }
}

extension CreateGlossaryTermInput {

    static func write(value: CreateGlossaryTermInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["glossaryIdentifier"].write(value.glossaryIdentifier)
        try writer["longDescription"].write(value.longDescription)
        try writer["name"].write(value.name)
        try writer["shortDescription"].write(value.shortDescription)
        try writer["status"].write(value.status)
        try writer["termRelations"].write(value.termRelations, with: DataZoneClientTypes.TermRelations.write(value:to:))
    }
}

extension CreateGroupProfileInput {

    static func write(value: CreateGroupProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["groupIdentifier"].write(value.groupIdentifier)
    }
}

extension CreateListingChangeSetInput {

    static func write(value: CreateListingChangeSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["clientToken"].write(value.clientToken)
        try writer["entityIdentifier"].write(value.entityIdentifier)
        try writer["entityRevision"].write(value.entityRevision)
        try writer["entityType"].write(value.entityType)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["domainUnitId"].write(value.domainUnitId)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension CreateProjectMembershipInput {

    static func write(value: CreateProjectMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["designation"].write(value.designation)
        try writer["member"].write(value.member, with: DataZoneClientTypes.Member.write(value:to:))
    }
}

extension CreateSubscriptionGrantInput {

    static func write(value: CreateSubscriptionGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetTargetNames"].writeList(value.assetTargetNames, memberWritingClosure: DataZoneClientTypes.AssetTargetNameMap.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentIdentifier"].write(value.environmentIdentifier)
        try writer["grantedEntity"].write(value.grantedEntity, with: DataZoneClientTypes.GrantedEntityInput.write(value:to:))
        try writer["subscriptionTargetIdentifier"].write(value.subscriptionTargetIdentifier)
    }
}

extension CreateSubscriptionRequestInput {

    static func write(value: CreateSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["requestReason"].write(value.requestReason)
        try writer["subscribedListings"].writeList(value.subscribedListings, memberWritingClosure: DataZoneClientTypes.SubscribedListingInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subscribedPrincipals"].writeList(value.subscribedPrincipals, memberWritingClosure: DataZoneClientTypes.SubscribedPrincipalInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSubscriptionTargetInput {

    static func write(value: CreateSubscriptionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicableAssetTypes"].writeList(value.applicableAssetTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizedPrincipals"].writeList(value.authorizedPrincipals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["manageAccessRole"].write(value.manageAccessRole)
        try writer["name"].write(value.name)
        try writer["provider"].write(value.provider)
        try writer["subscriptionTargetConfig"].writeList(value.subscriptionTargetConfig, memberWritingClosure: DataZoneClientTypes.SubscriptionTargetForm.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateUserProfileInput {

    static func write(value: CreateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["userIdentifier"].write(value.userIdentifier)
        try writer["userType"].write(value.userType)
    }
}

extension DeleteProjectMembershipInput {

    static func write(value: DeleteProjectMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["member"].write(value.member, with: DataZoneClientTypes.Member.write(value:to:))
    }
}

extension PostLineageEventInput {

    static func write(value: PostLineageEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["event"].write(value.event)
    }
}

extension PostTimeSeriesDataPointsInput {

    static func write(value: PostTimeSeriesDataPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["forms"].writeList(value.forms, memberWritingClosure: DataZoneClientTypes.TimeSeriesDataPointFormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutEnvironmentBlueprintConfigurationInput {

    static func write(value: PutEnvironmentBlueprintConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabledRegions"].writeList(value.enabledRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAccessRoleArn"].write(value.manageAccessRoleArn)
        try writer["provisioningConfigurations"].writeList(value.provisioningConfigurations, memberWritingClosure: DataZoneClientTypes.ProvisioningConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["provisioningRoleArn"].write(value.provisioningRoleArn)
        try writer["regionalParameters"].writeMap(value.regionalParameters, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension RejectPredictionsInput {

    static func write(value: RejectPredictionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["rejectChoices"].writeList(value.rejectChoices, memberWritingClosure: DataZoneClientTypes.RejectChoice.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rejectRule"].write(value.rejectRule, with: DataZoneClientTypes.RejectRule.write(value:to:))
    }
}

extension RejectSubscriptionRequestInput {

    static func write(value: RejectSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decisionComment"].write(value.decisionComment)
    }
}

extension RemoveEntityOwnerInput {

    static func write(value: RemoveEntityOwnerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["owner"].write(value.owner, with: DataZoneClientTypes.OwnerProperties.write(value:to:))
    }
}

extension RemovePolicyGrantInput {

    static func write(value: RemovePolicyGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["policyType"].write(value.policyType)
        try writer["principal"].write(value.principal, with: DataZoneClientTypes.PolicyGrantPrincipal.write(value:to:))
    }
}

extension RevokeSubscriptionInput {

    static func write(value: RevokeSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["retainPermissions"].write(value.retainPermissions)
    }
}

extension SearchInput {

    static func write(value: SearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DataZoneClientTypes.SearchOutputAdditionalAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchScope"].write(value.searchScope)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

extension SearchGroupProfilesInput {

    static func write(value: SearchGroupProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupType"].write(value.groupType)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchText"].write(value.searchText)
    }
}

extension SearchListingsInput {

    static func write(value: SearchListingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DataZoneClientTypes.SearchOutputAdditionalAttribute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

extension SearchTypesInput {

    static func write(value: SearchTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].write(value.filters, with: DataZoneClientTypes.FilterClause.write(value:to:))
        try writer["managed"].write(value.managed)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchIn"].writeList(value.searchIn, memberWritingClosure: DataZoneClientTypes.SearchInItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["searchScope"].write(value.searchScope)
        try writer["searchText"].write(value.searchText)
        try writer["sort"].write(value.sort, with: DataZoneClientTypes.SearchSort.write(value:to:))
    }
}

extension SearchUserProfilesInput {

    static func write(value: SearchUserProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchText"].write(value.searchText)
        try writer["userType"].write(value.userType)
    }
}

extension StartDataSourceRunInput {

    static func write(value: StartDataSourceRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension StartMetadataGenerationRunInput {

    static func write(value: StartMetadataGenerationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["owningProjectIdentifier"].write(value.owningProjectIdentifier)
        try writer["target"].write(value.target, with: DataZoneClientTypes.MetadataGenerationRunTarget.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAssetFilterInput {

    static func write(value: UpdateAssetFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.AssetFilterConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetFormsInput"].writeList(value.assetFormsInput, memberWritingClosure: DataZoneClientTypes.FormInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["configuration"].write(value.configuration, with: DataZoneClientTypes.DataSourceConfigurationInput.write(value:to:))
        try writer["description"].write(value.description)
        try writer["enableSetting"].write(value.enableSetting)
        try writer["name"].write(value.name)
        try writer["publishOnImport"].write(value.publishOnImport)
        try writer["recommendation"].write(value.recommendation, with: DataZoneClientTypes.RecommendationConfiguration.write(value:to:))
        try writer["retainPermissionsOnRevokeFailure"].write(value.retainPermissionsOnRevokeFailure)
        try writer["schedule"].write(value.schedule, with: DataZoneClientTypes.ScheduleConfiguration.write(value:to:))
    }
}

extension UpdateDomainInput {

    static func write(value: UpdateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["domainExecutionRole"].write(value.domainExecutionRole)
        try writer["name"].write(value.name)
        try writer["singleSignOn"].write(value.singleSignOn, with: DataZoneClientTypes.SingleSignOn.write(value:to:))
    }
}

extension UpdateDomainUnitInput {

    static func write(value: UpdateDomainUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateEnvironmentInput {

    static func write(value: UpdateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension UpdateEnvironmentActionInput {

    static func write(value: UpdateEnvironmentActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parameters"].write(value.parameters, with: DataZoneClientTypes.ActionParameters.write(value:to:))
    }
}

extension UpdateEnvironmentProfileInput {

    static func write(value: UpdateEnvironmentProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["awsAccountRegion"].write(value.awsAccountRegion)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["userParameters"].writeList(value.userParameters, memberWritingClosure: DataZoneClientTypes.EnvironmentParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGlossaryInput {

    static func write(value: UpdateGlossaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
    }
}

extension UpdateGlossaryTermInput {

    static func write(value: UpdateGlossaryTermInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["glossaryIdentifier"].write(value.glossaryIdentifier)
        try writer["longDescription"].write(value.longDescription)
        try writer["name"].write(value.name)
        try writer["shortDescription"].write(value.shortDescription)
        try writer["status"].write(value.status)
        try writer["termRelations"].write(value.termRelations, with: DataZoneClientTypes.TermRelations.write(value:to:))
    }
}

extension UpdateGroupProfileInput {

    static func write(value: UpdateGroupProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension UpdateSubscriptionGrantStatusInput {

    static func write(value: UpdateSubscriptionGrantStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failureCause"].write(value.failureCause, with: DataZoneClientTypes.FailureCause.write(value:to:))
        try writer["status"].write(value.status)
        try writer["targetName"].write(value.targetName)
    }
}

extension UpdateSubscriptionRequestInput {

    static func write(value: UpdateSubscriptionRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["requestReason"].write(value.requestReason)
    }
}

extension UpdateSubscriptionTargetInput {

    static func write(value: UpdateSubscriptionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicableAssetTypes"].writeList(value.applicableAssetTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizedPrincipals"].writeList(value.authorizedPrincipals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAccessRole"].write(value.manageAccessRole)
        try writer["name"].write(value.name)
        try writer["provider"].write(value.provider)
        try writer["subscriptionTargetConfig"].writeList(value.subscriptionTargetConfig, memberWritingClosure: DataZoneClientTypes.SubscriptionTargetForm.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUserProfileInput {

    static func write(value: UpdateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
        try writer["type"].write(value.type)
    }
}

extension AcceptPredictionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptPredictionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptPredictionsOutput()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        return value
    }
}

extension AcceptSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension AddEntityOwnerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddEntityOwnerOutput {
        return AddEntityOwnerOutput()
    }
}

extension AddPolicyGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddPolicyGrantOutput {
        return AddPolicyGrantOutput()
    }
}

extension AssociateEnvironmentRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateEnvironmentRoleOutput {
        return AssociateEnvironmentRoleOutput()
    }
}

extension CancelMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMetadataGenerationRunOutput {
        return CancelMetadataGenerationRunOutput()
    }
}

extension CancelSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.predictionConfiguration = try reader["predictionConfiguration"].readIfPresent(with: DataZoneClientTypes.PredictionConfiguration.read(from:))
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAssetFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetFilterOutput()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.AssetFilterConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.effectiveColumnNames = try reader["effectiveColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.effectiveRowFilter = try reader["effectiveRowFilter"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateAssetRevisionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetRevisionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.predictionConfiguration = try reader["predictionConfiguration"].readIfPresent(with: DataZoneClientTypes.PredictionConfiguration.read(from:))
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAssetTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.name = try reader["name"].readIfPresent() ?? ""
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateDataProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataProductOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataProductItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .created
        return value
    }
}

extension CreateDataProductRevisionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataProductRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataProductRevisionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataProductItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .created
        return value
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.rootDomainUnitId = try reader["rootDomainUnitId"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateDomainUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainUnitOutput()
        value.ancestorDomainUnitIds = try reader["ancestorDomainUnitIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owners = try reader["owners"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainUnitOwnerProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.parentDomainUnitId = try reader["parentDomainUnitId"].readIfPresent()
        return value
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent() ?? ""
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateEnvironmentActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentActionOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readIfPresent(with: DataZoneClientTypes.ActionParameters.read(from:))
        return value
    }
}

extension CreateEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateFormTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFormTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFormTypeOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGlossaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlossaryOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateGlossaryTermOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlossaryTermOutput()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.glossaryId = try reader["glossaryId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        return value
    }
}

extension CreateGroupProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateListingChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateListingChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListingChangeSetOutput()
        value.listingId = try reader["listingId"].readIfPresent() ?? ""
        value.listingRevision = try reader["listingRevision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainUnitId = try reader["domainUnitId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

extension CreateProjectMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectMembershipOutput {
        return CreateProjectMembershipOutput()
    }
}

extension CreateSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension CreateUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DeleteAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetOutput {
        return DeleteAssetOutput()
    }
}

extension DeleteAssetFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetFilterOutput {
        return DeleteAssetFilterOutput()
    }
}

extension DeleteAssetTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetTypeOutput {
        return DeleteAssetTypeOutput()
    }
}

extension DeleteDataProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataProductOutput {
        return DeleteDataProductOutput()
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.retainPermissionsOnRevokeFailure = try reader["retainPermissionsOnRevokeFailure"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.selfGrantStatus = try reader["selfGrantStatus"].readIfPresent(with: DataZoneClientTypes.SelfGrantStatusOutput.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteDomainUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainUnitOutput {
        return DeleteDomainUnitOutput()
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        return DeleteEnvironmentOutput()
    }
}

extension DeleteEnvironmentActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentActionOutput {
        return DeleteEnvironmentActionOutput()
    }
}

extension DeleteEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentBlueprintConfigurationOutput {
        return DeleteEnvironmentBlueprintConfigurationOutput()
    }
}

extension DeleteEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentProfileOutput {
        return DeleteEnvironmentProfileOutput()
    }
}

extension DeleteFormTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFormTypeOutput {
        return DeleteFormTypeOutput()
    }
}

extension DeleteGlossaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGlossaryOutput {
        return DeleteGlossaryOutput()
    }
}

extension DeleteGlossaryTermOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGlossaryTermOutput {
        return DeleteGlossaryTermOutput()
    }
}

extension DeleteListingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteListingOutput {
        return DeleteListingOutput()
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

extension DeleteProjectMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectMembershipOutput {
        return DeleteProjectMembershipOutput()
    }
}

extension DeleteSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeleteSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriptionRequestOutput {
        return DeleteSubscriptionRequestOutput()
    }
}

extension DeleteSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriptionTargetOutput {
        return DeleteSubscriptionTargetOutput()
    }
}

extension DeleteTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTimeSeriesDataPointsOutput {
        return DeleteTimeSeriesDataPointsOutput()
    }
}

extension DisassociateEnvironmentRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateEnvironmentRoleOutput {
        return DisassociateEnvironmentRoleOutput()
    }
}

extension GetAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listing = try reader["listing"].readIfPresent(with: DataZoneClientTypes.AssetListingDetails.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent() ?? ""
        return value
    }
}

extension GetAssetFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetFilterOutput()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.AssetFilterConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.effectiveColumnNames = try reader["effectiveColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.effectiveRowFilter = try reader["effectiveRowFilter"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetAssetTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.name = try reader["name"].readIfPresent() ?? ""
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetDataProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataProductOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataProductItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .created
        return value
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastRunAssetCount = try reader["lastRunAssetCount"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.selfGrantStatus = try reader["selfGrantStatus"].readIfPresent(with: DataZoneClientTypes.SelfGrantStatusOutput.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetDataSourceRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dataSourceConfigurationSnapshot = try reader["dataSourceConfigurationSnapshot"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.rootDomainUnitId = try reader["rootDomainUnitId"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDomainUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainUnitOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owners = try reader["owners"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainUnitOwnerProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.parentDomainUnitId = try reader["parentDomainUnitId"].readIfPresent()
        return value
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent() ?? ""
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEnvironmentActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentActionOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readIfPresent(with: DataZoneClientTypes.ActionParameters.read(from:))
        return value
    }
}

extension GetEnvironmentBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentBlueprintOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentBlueprintConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentBlueprintConfigurationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.provisioningConfigurations = try reader["provisioningConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProvisioningConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetEnvironmentCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentCredentialsOutput()
        value.accessKeyId = try reader["accessKeyId"].readIfPresent()
        value.expiration = try reader["expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.secretAccessKey = try reader["secretAccessKey"].readIfPresent()
        value.sessionToken = try reader["sessionToken"].readIfPresent()
        return value
    }
}

extension GetEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFormTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFormTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFormTypeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.imports = try reader["imports"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Import.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.model = try reader["model"].readIfPresent(with: DataZoneClientTypes.Model.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetGlossaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlossaryOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetGlossaryTermOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlossaryTermOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.glossaryId = try reader["glossaryId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetGroupProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetIamPortalLoginUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIamPortalLoginUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIamPortalLoginUrlOutput()
        value.authCodeUrl = try reader["authCodeUrl"].readIfPresent()
        value.userProfileId = try reader["userProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension GetLineageNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLineageNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLineageNodeOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.downstreamNodes = try reader["downstreamNodes"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.LineageNodeReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.sourceIdentifier = try reader["sourceIdentifier"].readIfPresent()
        value.typeName = try reader["typeName"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.upstreamNodes = try reader["upstreamNodes"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.LineageNodeReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetListingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetListingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListingOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.item = try reader["item"].readIfPresent(with: DataZoneClientTypes.ListingItem.read(from:))
        value.listingRevision = try reader["listingRevision"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetadataGenerationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetadataGenerationRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.target = try reader["target"].readIfPresent(with: DataZoneClientTypes.MetadataGenerationRunTarget.read(from:))
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension GetProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainUnitId = try reader["domainUnitId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

extension GetSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetSubscriptionGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionGrantOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetSubscriptionRequestDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionRequestDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionRequestDetailsOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetTimeSeriesDataPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTimeSeriesDataPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTimeSeriesDataPointOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.form = try reader["form"].readIfPresent(with: DataZoneClientTypes.TimeSeriesDataPointFormOutput.read(from:))
        value.formName = try reader["formName"].readIfPresent()
        return value
    }
}

extension GetUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension ListAssetFiltersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetFiltersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetFiltersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.AssetFilterSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetRevisionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetRevisionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.AssetRevision.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataProductRevisionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataProductRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataProductRevisionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataProductRevision.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourceRunActivitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourceRunActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourceRunActivitiesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceRunActivity.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourceRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourceRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourceRunsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DataSourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainUnitsForParentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainUnitsForParentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainUnitsForParentOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainUnitSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEntityOwnersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntityOwnersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntityOwnersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.owners = try reader["owners"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.OwnerPropertiesOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListEnvironmentActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentActionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentBlueprintConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentBlueprintConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentBlueprintConfigurationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentBlueprintConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentBlueprintsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentBlueprintSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLineageNodeHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLineageNodeHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLineageNodeHistoryOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.nodes = try reader["nodes"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.LineageNodeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMetadataGenerationRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetadataGenerationRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetadataGenerationRunsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.MetadataGenerationRunItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notifications = try reader["notifications"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.NotificationOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPolicyGrantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyGrantsOutput()
        value.grantList = try reader["grantList"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.PolicyGrantMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProjectMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectMembershipsOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSubscriptionGrantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionGrantsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionGrantSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSubscriptionRequestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionRequestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionRequestsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionRequestSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSubscriptionTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTimeSeriesDataPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTimeSeriesDataPointsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PostLineageEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostLineageEventOutput {
        return PostLineageEventOutput()
    }
}

extension PostTimeSeriesDataPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostTimeSeriesDataPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostTimeSeriesDataPointsOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.forms = try reader["forms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutEnvironmentBlueprintConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEnvironmentBlueprintConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEnvironmentBlueprintConfigurationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.provisioningConfigurations = try reader["provisioningConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProvisioningConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension RejectPredictionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectPredictionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectPredictionsOutput()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.assetRevision = try reader["assetRevision"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        return value
    }
}

extension RejectSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension RemoveEntityOwnerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveEntityOwnerOutput {
        return RemoveEntityOwnerOutput()
    }
}

extension RemovePolicyGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemovePolicyGrantOutput {
        return RemovePolicyGrantOutput()
    }
}

extension RevokeSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RevokeSubscriptionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension SearchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchInventoryResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

extension SearchGroupProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchGroupProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchGroupProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.GroupProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchListingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchListingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchListingsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

extension SearchTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTypesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SearchTypesResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalMatchCount = try reader["totalMatchCount"].readIfPresent()
        return value
    }
}

extension SearchUserProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchUserProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchUserProfilesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.UserProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension StartDataSourceRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataSourceRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataSourceRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dataSourceConfigurationSnapshot = try reader["dataSourceConfigurationSnapshot"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension StartMetadataGenerationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataGenerationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataGenerationRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAssetFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssetFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssetFilterOutput()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.AssetFilterConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.effectiveColumnNames = try reader["effectiveColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.effectiveRowFilter = try reader["effectiveRowFilter"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.assetFormsOutput = try reader["assetFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent(with: DataZoneClientTypes.DataSourceConfigurationOutput.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.publishOnImport = try reader["publishOnImport"].readIfPresent()
        value.recommendation = try reader["recommendation"].readIfPresent(with: DataZoneClientTypes.RecommendationConfiguration.read(from:))
        value.retainPermissionsOnRevokeFailure = try reader["retainPermissionsOnRevokeFailure"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.selfGrantStatus = try reader["selfGrantStatus"].readIfPresent(with: DataZoneClientTypes.SelfGrantStatusOutput.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension UpdateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainExecutionRole = try reader["domainExecutionRole"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.rootDomainUnitId = try reader["rootDomainUnitId"].readIfPresent()
        value.singleSignOn = try reader["singleSignOn"].readIfPresent(with: DataZoneClientTypes.SingleSignOn.read(from:))
        return value
    }
}

extension UpdateDomainUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainUnitOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owners = try reader["owners"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DomainUnitOwnerProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.parentDomainUnitId = try reader["parentDomainUnitId"].readIfPresent()
        return value
    }
}

extension UpdateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.deploymentProperties = try reader["deploymentProperties"].readIfPresent(with: DataZoneClientTypes.DeploymentProperties.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentActions = try reader["environmentActions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableEnvironmentAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent() ?? ""
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.lastDeployment = try reader["lastDeployment"].readIfPresent(with: DataZoneClientTypes.Deployment.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.provisionedResources = try reader["provisionedResources"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateEnvironmentActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentActionOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readIfPresent(with: DataZoneClientTypes.ActionParameters.read(from:))
        return value
    }
}

extension UpdateEnvironmentProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentProfileOutput()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userParameters = try reader["userParameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateGlossaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlossaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlossaryOutput()
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateGlossaryTermOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlossaryTermOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlossaryTermOutput()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.glossaryId = try reader["glossaryId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        return value
    }
}

extension UpdateGroupProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupProfileOutput()
        value.domainId = try reader["domainId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProjectOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainUnitId = try reader["domainUnitId"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        return value
    }
}

extension UpdateSubscriptionGrantStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionGrantStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionGrantStatusOutput()
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension UpdateSubscriptionRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionRequestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionRequestOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension UpdateSubscriptionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionTargetOutput()
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension UpdateUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserProfileOutput()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
        default: return nil
    }
}

enum AcceptPredictionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AcceptSubscriptionRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddEntityOwnerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddPolicyGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateEnvironmentRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetRevisionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataProductRevisionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFormTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGlossaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGlossaryTermOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateListingChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFormTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGlossaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGlossaryTermOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteListingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriptionGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriptionRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriptionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateEnvironmentRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFormTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGlossaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGlossaryTermOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIamPortalLoginUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLineageNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetListingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionRequestDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTimeSeriesDataPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetFiltersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetRevisionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataProductRevisionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourceRunActivitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourceRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainUnitsForParentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntityOwnersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentBlueprintConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLineageNodeHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetadataGenerationRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyGrantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionGrantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionRequestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostLineageEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostTimeSeriesDataPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEnvironmentBlueprintConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectPredictionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectSubscriptionRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveEntityOwnerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemovePolicyGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchGroupProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchListingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchUserProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataSourceRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataGenerationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssetFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlossaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlossaryTermOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionGrantStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DataZoneClientTypes.SubscribedPrincipal {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "project":
                return .project(try reader["project"].read(with: DataZoneClientTypes.SubscribedProject.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.SubscribedProject {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedProject()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscribedListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedListing()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.item = try reader["item"].readIfPresent(with: DataZoneClientTypes.SubscribedListingItem.read(from:))
        value.ownerProjectId = try reader["ownerProjectId"].readIfPresent() ?? ""
        value.ownerProjectName = try reader["ownerProjectName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscribedListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.SubscribedAssetListing.read(from:)))
            case "productListing":
                return .productlisting(try reader["productListing"].read(with: DataZoneClientTypes.SubscribedProductListing.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.SubscribedProductListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedProductListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedProductListing()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.assetListings = try reader["assetListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.AssetInDataProductListingItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.AssetInDataProductListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetInDataProductListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetInDataProductListingItem()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DetailedGlossaryTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DetailedGlossaryTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DetailedGlossaryTerm()
        value.name = try reader["name"].readIfPresent()
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscribedAssetListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedAssetListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedAssetListing()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.forms = try reader["forms"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetScope = try reader["assetScope"].readIfPresent(with: DataZoneClientTypes.AssetScope.read(from:))
        return value
    }
}

extension DataZoneClientTypes.AssetScope {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetScope()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.filterIds = try reader["filterIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetListingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingDetails()
        value.listingId = try reader["listingId"].readIfPresent() ?? ""
        value.listingStatus = try reader["listingStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DataZoneClientTypes.FormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormOutput()
        value.formName = try reader["formName"].readIfPresent() ?? ""
        value.typeName = try reader["typeName"].readIfPresent()
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput()
        value.formName = try reader["formName"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.contentSummary = try reader["contentSummary"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.PredictionConfiguration {

    static func write(value: DataZoneClientTypes.PredictionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessNameGeneration"].write(value.businessNameGeneration, with: DataZoneClientTypes.BusinessNameGenerationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.PredictionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.PredictionConfiguration()
        value.businessNameGeneration = try reader["businessNameGeneration"].readIfPresent(with: DataZoneClientTypes.BusinessNameGenerationConfiguration.read(from:))
        return value
    }
}

extension DataZoneClientTypes.BusinessNameGenerationConfiguration {

    static func write(value: DataZoneClientTypes.BusinessNameGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.BusinessNameGenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.BusinessNameGenerationConfiguration()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetFilterConfiguration {

    static func write(value: DataZoneClientTypes.AssetFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .columnconfiguration(columnconfiguration):
                try writer["columnConfiguration"].write(columnconfiguration, with: DataZoneClientTypes.ColumnFilterConfiguration.write(value:to:))
            case let .rowconfiguration(rowconfiguration):
                try writer["rowConfiguration"].write(rowconfiguration, with: DataZoneClientTypes.RowFilterConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "columnConfiguration":
                return .columnconfiguration(try reader["columnConfiguration"].read(with: DataZoneClientTypes.ColumnFilterConfiguration.read(from:)))
            case "rowConfiguration":
                return .rowconfiguration(try reader["rowConfiguration"].read(with: DataZoneClientTypes.RowFilterConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.RowFilterConfiguration {

    static func write(value: DataZoneClientTypes.RowFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rowFilter"].write(value.rowFilter, with: DataZoneClientTypes.RowFilter.write(value:to:))
        try writer["sensitive"].write(value.sensitive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RowFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RowFilterConfiguration()
        value.rowFilter = try reader["rowFilter"].readIfPresent(with: DataZoneClientTypes.RowFilter.read(from:))
        value.sensitive = try reader["sensitive"].readIfPresent() ?? true
        return value
    }
}

extension DataZoneClientTypes.RowFilter {

    static func write(value: DataZoneClientTypes.RowFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .and(and):
                try writer["and"].writeList(and, memberWritingClosure: DataZoneClientTypes.RowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .expression(expression):
                try writer["expression"].write(expression, with: DataZoneClientTypes.RowFilterExpression.write(value:to:))
            case let .or(or):
                try writer["or"].writeList(or, memberWritingClosure: DataZoneClientTypes.RowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RowFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "expression":
                return .expression(try reader["expression"].read(with: DataZoneClientTypes.RowFilterExpression.read(from:)))
            case "and":
                return .and(try reader["and"].readList(memberReadingClosure: DataZoneClientTypes.RowFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "or":
                return .or(try reader["or"].readList(memberReadingClosure: DataZoneClientTypes.RowFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.RowFilterExpression {

    static func write(value: DataZoneClientTypes.RowFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .equalto(equalto):
                try writer["equalTo"].write(equalto, with: DataZoneClientTypes.EqualToExpression.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: DataZoneClientTypes.GreaterThanExpression.write(value:to:))
            case let .greaterthanorequalto(greaterthanorequalto):
                try writer["greaterThanOrEqualTo"].write(greaterthanorequalto, with: DataZoneClientTypes.GreaterThanOrEqualToExpression.write(value:to:))
            case let .`in`(`in`):
                try writer["in"].write(`in`, with: DataZoneClientTypes.InExpression.write(value:to:))
            case let .isnotnull(isnotnull):
                try writer["isNotNull"].write(isnotnull, with: DataZoneClientTypes.IsNotNullExpression.write(value:to:))
            case let .isnull(isnull):
                try writer["isNull"].write(isnull, with: DataZoneClientTypes.IsNullExpression.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: DataZoneClientTypes.LessThanExpression.write(value:to:))
            case let .lessthanorequalto(lessthanorequalto):
                try writer["lessThanOrEqualTo"].write(lessthanorequalto, with: DataZoneClientTypes.LessThanOrEqualToExpression.write(value:to:))
            case let .like(like):
                try writer["like"].write(like, with: DataZoneClientTypes.LikeExpression.write(value:to:))
            case let .notequalto(notequalto):
                try writer["notEqualTo"].write(notequalto, with: DataZoneClientTypes.NotEqualToExpression.write(value:to:))
            case let .notin(notin):
                try writer["notIn"].write(notin, with: DataZoneClientTypes.NotInExpression.write(value:to:))
            case let .notlike(notlike):
                try writer["notLike"].write(notlike, with: DataZoneClientTypes.NotLikeExpression.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RowFilterExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "equalTo":
                return .equalto(try reader["equalTo"].read(with: DataZoneClientTypes.EqualToExpression.read(from:)))
            case "notEqualTo":
                return .notequalto(try reader["notEqualTo"].read(with: DataZoneClientTypes.NotEqualToExpression.read(from:)))
            case "greaterThan":
                return .greaterthan(try reader["greaterThan"].read(with: DataZoneClientTypes.GreaterThanExpression.read(from:)))
            case "lessThan":
                return .lessthan(try reader["lessThan"].read(with: DataZoneClientTypes.LessThanExpression.read(from:)))
            case "greaterThanOrEqualTo":
                return .greaterthanorequalto(try reader["greaterThanOrEqualTo"].read(with: DataZoneClientTypes.GreaterThanOrEqualToExpression.read(from:)))
            case "lessThanOrEqualTo":
                return .lessthanorequalto(try reader["lessThanOrEqualTo"].read(with: DataZoneClientTypes.LessThanOrEqualToExpression.read(from:)))
            case "isNull":
                return .isnull(try reader["isNull"].read(with: DataZoneClientTypes.IsNullExpression.read(from:)))
            case "isNotNull":
                return .isnotnull(try reader["isNotNull"].read(with: DataZoneClientTypes.IsNotNullExpression.read(from:)))
            case "in":
                return .`in`(try reader["in"].read(with: DataZoneClientTypes.InExpression.read(from:)))
            case "notIn":
                return .notin(try reader["notIn"].read(with: DataZoneClientTypes.NotInExpression.read(from:)))
            case "like":
                return .like(try reader["like"].read(with: DataZoneClientTypes.LikeExpression.read(from:)))
            case "notLike":
                return .notlike(try reader["notLike"].read(with: DataZoneClientTypes.NotLikeExpression.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.NotLikeExpression {

    static func write(value: DataZoneClientTypes.NotLikeExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotLikeExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotLikeExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.LikeExpression {

    static func write(value: DataZoneClientTypes.LikeExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LikeExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LikeExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.NotInExpression {

    static func write(value: DataZoneClientTypes.NotInExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotInExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotInExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DataZoneClientTypes.InExpression {

    static func write(value: DataZoneClientTypes.InExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.InExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.InExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DataZoneClientTypes.IsNotNullExpression {

    static func write(value: DataZoneClientTypes.IsNotNullExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.IsNotNullExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.IsNotNullExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.IsNullExpression {

    static func write(value: DataZoneClientTypes.IsNullExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.IsNullExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.IsNullExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.LessThanOrEqualToExpression {

    static func write(value: DataZoneClientTypes.LessThanOrEqualToExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LessThanOrEqualToExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LessThanOrEqualToExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.GreaterThanOrEqualToExpression {

    static func write(value: DataZoneClientTypes.GreaterThanOrEqualToExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GreaterThanOrEqualToExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GreaterThanOrEqualToExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.LessThanExpression {

    static func write(value: DataZoneClientTypes.LessThanExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LessThanExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LessThanExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.GreaterThanExpression {

    static func write(value: DataZoneClientTypes.GreaterThanExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GreaterThanExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GreaterThanExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.NotEqualToExpression {

    static func write(value: DataZoneClientTypes.NotEqualToExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotEqualToExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotEqualToExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.EqualToExpression {

    static func write(value: DataZoneClientTypes.EqualToExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EqualToExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EqualToExpression()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.ColumnFilterConfiguration {

    static func write(value: DataZoneClientTypes.ColumnFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includedColumnNames"].writeList(value.includedColumnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ColumnFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ColumnFilterConfiguration()
        value.includedColumnNames = try reader["includedColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.FormEntryOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormEntryOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormEntryOutput()
        value.typeName = try reader["typeName"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent() ?? ""
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DataProductItem {

    static func write(value: DataZoneClientTypes.DataProductItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["glossaryTerms"].writeList(value.glossaryTerms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["identifier"].write(value.identifier)
        try writer["itemType"].write(value.itemType)
        try writer["revision"].write(value.revision)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductItem()
        value.itemType = try reader["itemType"].readIfPresent() ?? .sdkUnknown("")
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.DataSourceConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glueRunConfiguration":
                return .gluerunconfiguration(try reader["glueRunConfiguration"].read(with: DataZoneClientTypes.GlueRunConfigurationOutput.read(from:)))
            case "redshiftRunConfiguration":
                return .redshiftrunconfiguration(try reader["redshiftRunConfiguration"].read(with: DataZoneClientTypes.RedshiftRunConfigurationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.RedshiftRunConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftRunConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftRunConfigurationOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.dataAccessRole = try reader["dataAccessRole"].readIfPresent()
        value.relationalFilterConfigurations = try reader["relationalFilterConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.RelationalFilterConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.redshiftCredentialConfiguration = try reader["redshiftCredentialConfiguration"].readIfPresent(with: DataZoneClientTypes.RedshiftCredentialConfiguration.read(from:))
        value.redshiftStorage = try reader["redshiftStorage"].readIfPresent(with: DataZoneClientTypes.RedshiftStorage.read(from:))
        return value
    }
}

extension DataZoneClientTypes.RedshiftStorage {

    static func write(value: DataZoneClientTypes.RedshiftStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .redshiftclustersource(redshiftclustersource):
                try writer["redshiftClusterSource"].write(redshiftclustersource, with: DataZoneClientTypes.RedshiftClusterStorage.write(value:to:))
            case let .redshiftserverlesssource(redshiftserverlesssource):
                try writer["redshiftServerlessSource"].write(redshiftserverlesssource, with: DataZoneClientTypes.RedshiftServerlessStorage.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "redshiftClusterSource":
                return .redshiftclustersource(try reader["redshiftClusterSource"].read(with: DataZoneClientTypes.RedshiftClusterStorage.read(from:)))
            case "redshiftServerlessSource":
                return .redshiftserverlesssource(try reader["redshiftServerlessSource"].read(with: DataZoneClientTypes.RedshiftServerlessStorage.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.RedshiftServerlessStorage {

    static func write(value: DataZoneClientTypes.RedshiftServerlessStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workgroupName"].write(value.workgroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftServerlessStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftServerlessStorage()
        value.workgroupName = try reader["workgroupName"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.RedshiftClusterStorage {

    static func write(value: DataZoneClientTypes.RedshiftClusterStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusterName"].write(value.clusterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftClusterStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftClusterStorage()
        value.clusterName = try reader["clusterName"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.RedshiftCredentialConfiguration {

    static func write(value: DataZoneClientTypes.RedshiftCredentialConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretManagerArn"].write(value.secretManagerArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftCredentialConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftCredentialConfiguration()
        value.secretManagerArn = try reader["secretManagerArn"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.RelationalFilterConfiguration {

    static func write(value: DataZoneClientTypes.RelationalFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["filterExpressions"].writeList(value.filterExpressions, memberWritingClosure: DataZoneClientTypes.FilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["schemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RelationalFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RelationalFilterConfiguration()
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.filterExpressions = try reader["filterExpressions"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FilterExpression.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.FilterExpression {

    static func write(value: DataZoneClientTypes.FilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FilterExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FilterExpression()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.GlueRunConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlueRunConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlueRunConfigurationOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.dataAccessRole = try reader["dataAccessRole"].readIfPresent()
        value.relationalFilterConfigurations = try reader["relationalFilterConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.RelationalFilterConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.autoImportDataQualityResult = try reader["autoImportDataQualityResult"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.RecommendationConfiguration {

    static func write(value: DataZoneClientTypes.RecommendationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableBusinessNameGeneration"].write(value.enableBusinessNameGeneration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RecommendationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RecommendationConfiguration()
        value.enableBusinessNameGeneration = try reader["enableBusinessNameGeneration"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.ScheduleConfiguration {

    static func write(value: DataZoneClientTypes.ScheduleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schedule"].write(value.schedule)
        try writer["timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ScheduleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ScheduleConfiguration()
        value.timezone = try reader["timezone"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DataSourceErrorMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceErrorMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceErrorMessage()
        value.errorType = try reader["errorType"].readIfPresent() ?? .sdkUnknown("")
        value.errorDetail = try reader["errorDetail"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SingleSignOn {

    static func write(value: DataZoneClientTypes.SingleSignOn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["userAssignment"].write(value.userAssignment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SingleSignOn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SingleSignOn()
        value.type = try reader["type"].readIfPresent()
        value.userAssignment = try reader["userAssignment"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DomainUnitOwnerProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitOwnerProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "user":
                return .user(try reader["user"].read(with: DataZoneClientTypes.DomainUnitUserProperties.read(from:)))
            case "group":
                return .group(try reader["group"].read(with: DataZoneClientTypes.DomainUnitGroupProperties.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DomainUnitGroupProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitGroupProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainUnitGroupProperties()
        value.groupId = try reader["groupId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DomainUnitUserProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitUserProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainUnitUserProperties()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Resource()
        value.provider = try reader["provider"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.ConfigurableEnvironmentAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ConfigurableEnvironmentAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ConfigurableEnvironmentAction()
        value.type = try reader["type"].readIfPresent() ?? ""
        value.auth = try reader["auth"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ConfigurableActionParameter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DataZoneClientTypes.ConfigurableActionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ConfigurableActionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ConfigurableActionParameter()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CustomParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CustomParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CustomParameter()
        value.keyName = try reader["keyName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.fieldType = try reader["fieldType"].readIfPresent() ?? ""
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.isEditable = try reader["isEditable"].readIfPresent()
        value.isOptional = try reader["isOptional"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Deployment()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentType = try reader["deploymentType"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent(with: DataZoneClientTypes.EnvironmentError.read(from:))
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isDeploymentComplete = try reader["isDeploymentComplete"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.EnvironmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.ProvisioningProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProvisioningProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cloudFormation":
                return .cloudformation(try reader["cloudFormation"].read(with: DataZoneClientTypes.CloudFormationProperties.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.CloudFormationProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CloudFormationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CloudFormationProperties()
        value.templateUrl = try reader["templateUrl"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.DeploymentProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DeploymentProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DeploymentProperties()
        value.startTimeoutMinutes = try reader["startTimeoutMinutes"].readIfPresent()
        value.endTimeoutMinutes = try reader["endTimeoutMinutes"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.ActionParameters {

    static func write(value: DataZoneClientTypes.ActionParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .awsconsolelink(awsconsolelink):
                try writer["awsConsoleLink"].write(awsconsolelink, with: DataZoneClientTypes.AwsConsoleLinkParameters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ActionParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "awsConsoleLink":
                return .awsconsolelink(try reader["awsConsoleLink"].read(with: DataZoneClientTypes.AwsConsoleLinkParameters.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.AwsConsoleLinkParameters {

    static func write(value: DataZoneClientTypes.AwsConsoleLinkParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AwsConsoleLinkParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AwsConsoleLinkParameters()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.TermRelations {

    static func write(value: DataZoneClientTypes.TermRelations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["classifies"].writeList(value.classifies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["isA"].writeList(value.isa, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TermRelations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TermRelations()
        value.isa = try reader["isA"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.classifies = try reader["classifies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.ProjectDeletionError {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectDeletionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectDeletionError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.GrantedEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GrantedEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "listing":
                return .listing(try reader["listing"].read(with: DataZoneClientTypes.ListingRevision.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.ListingRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ListingRevision()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.SubscribedAsset {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscribedAsset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscribedAsset()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.assetRevision = try reader["assetRevision"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetName = try reader["targetName"].readIfPresent()
        value.failureCause = try reader["failureCause"].readIfPresent(with: DataZoneClientTypes.FailureCause.read(from:))
        value.grantedTimestamp = try reader["grantedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureTimestamp = try reader["failureTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assetScope = try reader["assetScope"].readIfPresent(with: DataZoneClientTypes.AssetScope.read(from:))
        return value
    }
}

extension DataZoneClientTypes.FailureCause {

    static func write(value: DataZoneClientTypes.FailureCause?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FailureCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FailureCause()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscriptionTargetForm {

    static func write(value: DataZoneClientTypes.SubscriptionTargetForm?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionTargetForm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionTargetForm()
        value.formName = try reader["formName"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.UserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "iam":
                return .iam(try reader["iam"].read(with: DataZoneClientTypes.IamUserProfileDetails.read(from:)))
            case "sso":
                return .sso(try reader["sso"].read(with: DataZoneClientTypes.SsoUserProfileDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.SsoUserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SsoUserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SsoUserProfileDetails()
        value.username = try reader["username"].readIfPresent()
        value.firstName = try reader["firstName"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.IamUserProfileDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.IamUserProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.IamUserProfileDetails()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SelfGrantStatusOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SelfGrantStatusOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glueSelfGrantStatus":
                return .glueselfgrantstatus(try reader["glueSelfGrantStatus"].read(with: DataZoneClientTypes.GlueSelfGrantStatusOutput.read(from:)))
            case "redshiftSelfGrantStatus":
                return .redshiftselfgrantstatus(try reader["redshiftSelfGrantStatus"].read(with: DataZoneClientTypes.RedshiftSelfGrantStatusOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.RedshiftSelfGrantStatusOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RedshiftSelfGrantStatusOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RedshiftSelfGrantStatusOutput()
        value.selfGrantStatusDetails = try reader["selfGrantStatusDetails"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SelfGrantStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DataZoneClientTypes.SelfGrantStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SelfGrantStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SelfGrantStatusDetail()
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.failureCause = try reader["failureCause"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.GlueSelfGrantStatusOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlueSelfGrantStatusOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlueSelfGrantStatusOutput()
        value.selfGrantStatusDetails = try reader["selfGrantStatusDetails"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SelfGrantStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DataZoneClientTypes.RunStatisticsForAssets {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.RunStatisticsForAssets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.RunStatisticsForAssets()
        value.added = try reader["added"].readIfPresent()
        value.updated = try reader["updated"].readIfPresent()
        value.unchanged = try reader["unchanged"].readIfPresent()
        value.skipped = try reader["skipped"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.ProvisioningConfiguration {

    static func write(value: DataZoneClientTypes.ProvisioningConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .lakeformationconfiguration(lakeformationconfiguration):
                try writer["lakeFormationConfiguration"].write(lakeformationconfiguration, with: DataZoneClientTypes.LakeFormationConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProvisioningConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "lakeFormationConfiguration":
                return .lakeformationconfiguration(try reader["lakeFormationConfiguration"].read(with: DataZoneClientTypes.LakeFormationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.LakeFormationConfiguration {

    static func write(value: DataZoneClientTypes.LakeFormationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["locationRegistrationExcludeS3Locations"].writeList(value.locationRegistrationExcludeS3Locations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["locationRegistrationRole"].write(value.locationRegistrationRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LakeFormationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LakeFormationConfiguration()
        value.locationRegistrationRole = try reader["locationRegistrationRole"].readIfPresent()
        value.locationRegistrationExcludeS3Locations = try reader["locationRegistrationExcludeS3Locations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.Model {

    static func write(value: DataZoneClientTypes.Model?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .smithy(smithy):
                try writer["smithy"].write(smithy)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "smithy":
                return .smithy(try reader["smithy"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.Import {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Import {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Import()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.LineageNodeReference {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LineageNodeReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LineageNodeReference()
        value.id = try reader["id"].readIfPresent()
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DataZoneClientTypes.ListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.AssetListing.read(from:)))
            case "dataProductListing":
                return .dataproductlisting(try reader["dataProductListing"].read(with: DataZoneClientTypes.DataProductListing.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DataProductListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductListing()
        value.dataProductId = try reader["dataProductId"].readIfPresent()
        value.dataProductRevision = try reader["dataProductRevision"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.forms = try reader["forms"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ListingSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.ListingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ListingSummary()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.AssetListing {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListing()
        value.assetId = try reader["assetId"].readIfPresent()
        value.assetRevision = try reader["assetRevision"].readIfPresent()
        value.assetType = try reader["assetType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.forms = try reader["forms"].readIfPresent()
        value.latestTimeSeriesDataPointForms = try reader["latestTimeSeriesDataPointForms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.MetadataGenerationRunTarget {

    static func write(value: DataZoneClientTypes.MetadataGenerationRunTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["revision"].write(value.revision)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MetadataGenerationRunTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.MetadataGenerationRunTarget()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.TimeSeriesDataPointFormOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.TimeSeriesDataPointFormOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.TimeSeriesDataPointFormOutput()
        value.formName = try reader["formName"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.content = try reader["content"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetFilterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetFilterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetFilterSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.effectiveColumnNames = try reader["effectiveColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.effectiveRowFilter = try reader["effectiveRowFilter"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetRevision()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DataZoneClientTypes.DataProductRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductRevision()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.DataSourceRunActivity {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceRunActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceRunActivity()
        value.database = try reader["database"].readIfPresent() ?? ""
        value.dataSourceRunId = try reader["dataSourceRunId"].readIfPresent() ?? ""
        value.technicalName = try reader["technicalName"].readIfPresent() ?? ""
        value.dataAssetStatus = try reader["dataAssetStatus"].readIfPresent() ?? .sdkUnknown("")
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.dataAssetId = try reader["dataAssetId"].readIfPresent()
        value.technicalDescription = try reader["technicalDescription"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DataZoneClientTypes.DataSourceRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceRunSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.runStatisticsForAssets = try reader["runStatisticsForAssets"].readIfPresent(with: DataZoneClientTypes.RunStatisticsForAssets.read(from:))
        value.errorMessage = try reader["errorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DataZoneClientTypes.DataSourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataSourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataSourceSummary()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.enableSetting = try reader["enableSetting"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: DataZoneClientTypes.ScheduleConfiguration.read(from:))
        value.lastRunStatus = try reader["lastRunStatus"].readIfPresent()
        value.lastRunAt = try reader["lastRunAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastRunErrorMessage = try reader["lastRunErrorMessage"].readIfPresent(with: DataZoneClientTypes.DataSourceErrorMessage.read(from:))
        value.lastRunAssetCount = try reader["lastRunAssetCount"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DataZoneClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.managedAccountId = try reader["managedAccountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.portalUrl = try reader["portalUrl"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DataZoneClientTypes.DomainUnitSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainUnitSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.OwnerPropertiesOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.OwnerPropertiesOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "user":
                return .user(try reader["user"].read(with: DataZoneClientTypes.OwnerUserPropertiesOutput.read(from:)))
            case "group":
                return .group(try reader["group"].read(with: DataZoneClientTypes.OwnerGroupPropertiesOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.OwnerGroupPropertiesOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.OwnerGroupPropertiesOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.OwnerGroupPropertiesOutput()
        value.groupId = try reader["groupId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.OwnerUserPropertiesOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.OwnerUserPropertiesOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.OwnerUserPropertiesOutput()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.EnvironmentActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentActionSummary()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readIfPresent(with: DataZoneClientTypes.ActionParameters.read(from:))
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentBlueprintConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentBlueprintConfigurationItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.manageAccessRoleArn = try reader["manageAccessRoleArn"].readIfPresent()
        value.enabledRegions = try reader["enabledRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.regionalParameters = try reader["regionalParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.provisioningConfigurations = try reader["provisioningConfigurations"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProvisioningConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.EnvironmentBlueprintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentBlueprintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentBlueprintSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.provisioningProperties = try reader["provisioningProperties"].readIfPresent(with: DataZoneClientTypes.ProvisioningProperties.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DataZoneClientTypes.EnvironmentProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentProfileSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.environmentBlueprintId = try reader["environmentBlueprintId"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.EnvironmentSummary()
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.environmentProfileId = try reader["environmentProfileId"].readIfPresent() ?? ""
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.awsAccountRegion = try reader["awsAccountRegion"].readIfPresent()
        value.provider = try reader["provider"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.LineageNodeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LineageNodeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LineageNodeSummary()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.typeName = try reader["typeName"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent()
        value.sourceIdentifier = try reader["sourceIdentifier"].readIfPresent()
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DataZoneClientTypes.MetadataGenerationRunItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MetadataGenerationRunItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.MetadataGenerationRunItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.target = try reader["target"].readIfPresent(with: DataZoneClientTypes.MetadataGenerationRunTarget.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.NotificationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotificationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotificationOutput()
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.domainIdentifier = try reader["domainIdentifier"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.topic = try reader["topic"].readIfPresent(with: DataZoneClientTypes.Topic.read(from:))
        value.title = try reader["title"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.actionLink = try reader["actionLink"].readIfPresent() ?? ""
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.Topic {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Topic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.Topic()
        value.subject = try reader["subject"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent(with: DataZoneClientTypes.NotificationResource.read(from:))
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DataZoneClientTypes.NotificationResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.NotificationResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.NotificationResource()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.PolicyGrantMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.PolicyGrantMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.PolicyGrantMember()
        value.principal = try reader["principal"].readIfPresent(with: DataZoneClientTypes.PolicyGrantPrincipal.read(from:))
        value.detail = try reader["detail"].readIfPresent(with: DataZoneClientTypes.PolicyGrantDetail.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.PolicyGrantDetail {

    static func write(value: DataZoneClientTypes.PolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addtoprojectmemberpool(addtoprojectmemberpool):
                try writer["addToProjectMemberPool"].write(addtoprojectmemberpool, with: DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail.write(value:to:))
            case let .createassettype(createassettype):
                try writer["createAssetType"].write(createassettype, with: DataZoneClientTypes.CreateAssetTypePolicyGrantDetail.write(value:to:))
            case let .createdomainunit(createdomainunit):
                try writer["createDomainUnit"].write(createdomainunit, with: DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail.write(value:to:))
            case let .createenvironment(createenvironment):
                try writer["createEnvironment"].write(createenvironment, with: DataZoneClientTypes.Unit.write(value:to:))
            case let .createenvironmentprofile(createenvironmentprofile):
                try writer["createEnvironmentProfile"].write(createenvironmentprofile, with: DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail.write(value:to:))
            case let .createformtype(createformtype):
                try writer["createFormType"].write(createformtype, with: DataZoneClientTypes.CreateFormTypePolicyGrantDetail.write(value:to:))
            case let .createglossary(createglossary):
                try writer["createGlossary"].write(createglossary, with: DataZoneClientTypes.CreateGlossaryPolicyGrantDetail.write(value:to:))
            case let .createproject(createproject):
                try writer["createProject"].write(createproject, with: DataZoneClientTypes.CreateProjectPolicyGrantDetail.write(value:to:))
            case let .delegatecreateenvironmentprofile(delegatecreateenvironmentprofile):
                try writer["delegateCreateEnvironmentProfile"].write(delegatecreateenvironmentprofile, with: DataZoneClientTypes.Unit.write(value:to:))
            case let .overridedomainunitowners(overridedomainunitowners):
                try writer["overrideDomainUnitOwners"].write(overridedomainunitowners, with: DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail.write(value:to:))
            case let .overrideprojectowners(overrideprojectowners):
                try writer["overrideProjectOwners"].write(overrideprojectowners, with: DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.PolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "createDomainUnit":
                return .createdomainunit(try reader["createDomainUnit"].read(with: DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail.read(from:)))
            case "overrideDomainUnitOwners":
                return .overridedomainunitowners(try reader["overrideDomainUnitOwners"].read(with: DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail.read(from:)))
            case "addToProjectMemberPool":
                return .addtoprojectmemberpool(try reader["addToProjectMemberPool"].read(with: DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail.read(from:)))
            case "overrideProjectOwners":
                return .overrideprojectowners(try reader["overrideProjectOwners"].read(with: DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail.read(from:)))
            case "createGlossary":
                return .createglossary(try reader["createGlossary"].read(with: DataZoneClientTypes.CreateGlossaryPolicyGrantDetail.read(from:)))
            case "createFormType":
                return .createformtype(try reader["createFormType"].read(with: DataZoneClientTypes.CreateFormTypePolicyGrantDetail.read(from:)))
            case "createAssetType":
                return .createassettype(try reader["createAssetType"].read(with: DataZoneClientTypes.CreateAssetTypePolicyGrantDetail.read(from:)))
            case "createProject":
                return .createproject(try reader["createProject"].read(with: DataZoneClientTypes.CreateProjectPolicyGrantDetail.read(from:)))
            case "createEnvironmentProfile":
                return .createenvironmentprofile(try reader["createEnvironmentProfile"].read(with: DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail.read(from:)))
            case "delegateCreateEnvironmentProfile":
                return .delegatecreateenvironmentprofile(try reader["delegateCreateEnvironmentProfile"].read(with: DataZoneClientTypes.Unit.read(from:)))
            case "createEnvironment":
                return .createenvironment(try reader["createEnvironment"].read(with: DataZoneClientTypes.Unit.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.Unit {

    static func write(value: DataZoneClientTypes.Unit?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.Unit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return DataZoneClientTypes.Unit()
    }
}

extension DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainUnitId"].write(value.domainUnitId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateEnvironmentProfilePolicyGrantDetail()
        value.domainUnitId = try reader["domainUnitId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CreateProjectPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateProjectPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateProjectPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateProjectPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CreateAssetTypePolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateAssetTypePolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateAssetTypePolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateAssetTypePolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CreateFormTypePolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateFormTypePolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateFormTypePolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateFormTypePolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CreateGlossaryPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateGlossaryPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateGlossaryPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateGlossaryPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.OverrideProjectOwnersPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AddToProjectMemberPoolPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.OverrideDomainUnitOwnersPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail {

    static func write(value: DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.CreateDomainUnitPolicyGrantDetail()
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.PolicyGrantPrincipal {

    static func write(value: DataZoneClientTypes.PolicyGrantPrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .domainunit(domainunit):
                try writer["domainUnit"].write(domainunit, with: DataZoneClientTypes.DomainUnitPolicyGrantPrincipal.write(value:to:))
            case let .group(group):
                try writer["group"].write(group, with: DataZoneClientTypes.GroupPolicyGrantPrincipal.write(value:to:))
            case let .project(project):
                try writer["project"].write(project, with: DataZoneClientTypes.ProjectPolicyGrantPrincipal.write(value:to:))
            case let .user(user):
                try writer["user"].write(user, with: DataZoneClientTypes.UserPolicyGrantPrincipal.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.PolicyGrantPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "user":
                return .user(try reader["user"].read(with: DataZoneClientTypes.UserPolicyGrantPrincipal.read(from:)))
            case "group":
                return .group(try reader["group"].read(with: DataZoneClientTypes.GroupPolicyGrantPrincipal.read(from:)))
            case "project":
                return .project(try reader["project"].read(with: DataZoneClientTypes.ProjectPolicyGrantPrincipal.read(from:)))
            case "domainUnit":
                return .domainunit(try reader["domainUnit"].read(with: DataZoneClientTypes.DomainUnitPolicyGrantPrincipal.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DomainUnitPolicyGrantPrincipal {

    static func write(value: DataZoneClientTypes.DomainUnitPolicyGrantPrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainUnitDesignation"].write(value.domainUnitDesignation)
        try writer["domainUnitGrantFilter"].write(value.domainUnitGrantFilter, with: DataZoneClientTypes.DomainUnitGrantFilter.write(value:to:))
        try writer["domainUnitIdentifier"].write(value.domainUnitIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitPolicyGrantPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainUnitPolicyGrantPrincipal()
        value.domainUnitDesignation = try reader["domainUnitDesignation"].readIfPresent() ?? .sdkUnknown("")
        value.domainUnitIdentifier = try reader["domainUnitIdentifier"].readIfPresent()
        value.domainUnitGrantFilter = try reader["domainUnitGrantFilter"].readIfPresent(with: DataZoneClientTypes.DomainUnitGrantFilter.read(from:))
        return value
    }
}

extension DataZoneClientTypes.DomainUnitGrantFilter {

    static func write(value: DataZoneClientTypes.DomainUnitGrantFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .alldomainunitsgrantfilter(alldomainunitsgrantfilter):
                try writer["allDomainUnitsGrantFilter"].write(alldomainunitsgrantfilter, with: DataZoneClientTypes.AllDomainUnitsGrantFilter.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitGrantFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "allDomainUnitsGrantFilter":
                return .alldomainunitsgrantfilter(try reader["allDomainUnitsGrantFilter"].read(with: DataZoneClientTypes.AllDomainUnitsGrantFilter.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.AllDomainUnitsGrantFilter {

    static func write(value: DataZoneClientTypes.AllDomainUnitsGrantFilter?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AllDomainUnitsGrantFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return DataZoneClientTypes.AllDomainUnitsGrantFilter()
    }
}

extension DataZoneClientTypes.ProjectPolicyGrantPrincipal {

    static func write(value: DataZoneClientTypes.ProjectPolicyGrantPrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectDesignation"].write(value.projectDesignation)
        try writer["projectGrantFilter"].write(value.projectGrantFilter, with: DataZoneClientTypes.ProjectGrantFilter.write(value:to:))
        try writer["projectIdentifier"].write(value.projectIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectPolicyGrantPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectPolicyGrantPrincipal()
        value.projectDesignation = try reader["projectDesignation"].readIfPresent() ?? .sdkUnknown("")
        value.projectIdentifier = try reader["projectIdentifier"].readIfPresent()
        value.projectGrantFilter = try reader["projectGrantFilter"].readIfPresent(with: DataZoneClientTypes.ProjectGrantFilter.read(from:))
        return value
    }
}

extension DataZoneClientTypes.ProjectGrantFilter {

    static func write(value: DataZoneClientTypes.ProjectGrantFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .domainunitfilter(domainunitfilter):
                try writer["domainUnitFilter"].write(domainunitfilter, with: DataZoneClientTypes.DomainUnitFilterForProject.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectGrantFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "domainUnitFilter":
                return .domainunitfilter(try reader["domainUnitFilter"].read(with: DataZoneClientTypes.DomainUnitFilterForProject.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DomainUnitFilterForProject {

    static func write(value: DataZoneClientTypes.DomainUnitFilterForProject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainUnit"].write(value.domainUnit)
        try writer["includeChildDomainUnits"].write(value.includeChildDomainUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DomainUnitFilterForProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DomainUnitFilterForProject()
        value.domainUnit = try reader["domainUnit"].readIfPresent() ?? ""
        value.includeChildDomainUnits = try reader["includeChildDomainUnits"].readIfPresent() ?? false
        return value
    }
}

extension DataZoneClientTypes.GroupPolicyGrantPrincipal {

    static func write(value: DataZoneClientTypes.GroupPolicyGrantPrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .groupidentifier(groupidentifier):
                try writer["groupIdentifier"].write(groupidentifier)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GroupPolicyGrantPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "groupIdentifier":
                return .groupidentifier(try reader["groupIdentifier"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.UserPolicyGrantPrincipal {

    static func write(value: DataZoneClientTypes.UserPolicyGrantPrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .allusersgrantfilter(allusersgrantfilter):
                try writer["allUsersGrantFilter"].write(allusersgrantfilter, with: DataZoneClientTypes.AllUsersGrantFilter.write(value:to:))
            case let .useridentifier(useridentifier):
                try writer["userIdentifier"].write(useridentifier)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserPolicyGrantPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "userIdentifier":
                return .useridentifier(try reader["userIdentifier"].read())
            case "allUsersGrantFilter":
                return .allusersgrantfilter(try reader["allUsersGrantFilter"].read(with: DataZoneClientTypes.AllUsersGrantFilter.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.AllUsersGrantFilter {

    static func write(value: DataZoneClientTypes.AllUsersGrantFilter?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AllUsersGrantFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return DataZoneClientTypes.AllUsersGrantFilter()
    }
}

extension DataZoneClientTypes.ProjectMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectMember()
        value.memberDetails = try reader["memberDetails"].readIfPresent(with: DataZoneClientTypes.MemberDetails.read(from:))
        value.designation = try reader["designation"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DataZoneClientTypes.MemberDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.MemberDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "user":
                return .user(try reader["user"].read(with: DataZoneClientTypes.UserDetails.read(from:)))
            case "group":
                return .group(try reader["group"].read(with: DataZoneClientTypes.GroupDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.GroupDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GroupDetails()
        value.groupId = try reader["groupId"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.UserDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.UserDetails()
        value.userId = try reader["userId"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ProjectSummary()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.projectStatus = try reader["projectStatus"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ProjectDeletionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainUnitId = try reader["domainUnitId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscriptionGrantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionGrantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionGrantSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.subscriptionTargetId = try reader["subscriptionTargetId"].readIfPresent() ?? ""
        value.grantedEntity = try reader["grantedEntity"].readIfPresent(with: DataZoneClientTypes.GrantedEntity.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.assets = try reader["assets"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedAsset.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subscriptionId = try reader["subscriptionId"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscriptionRequestSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionRequestSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionRequestSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.requestReason = try reader["requestReason"].readIfPresent() ?? ""
        value.subscribedPrincipals = try reader["subscribedPrincipals"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribedListings = try reader["subscribedListings"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscribedListing.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.reviewerId = try reader["reviewerId"].readIfPresent()
        value.decisionComment = try reader["decisionComment"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscriptionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.subscribedPrincipal = try reader["subscribedPrincipal"].readIfPresent(with: DataZoneClientTypes.SubscribedPrincipal.read(from:))
        value.subscribedListing = try reader["subscribedListing"].readIfPresent(with: DataZoneClientTypes.SubscribedListing.read(from:))
        value.subscriptionRequestId = try reader["subscriptionRequestId"].readIfPresent()
        value.retainPermissions = try reader["retainPermissions"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SubscriptionTargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SubscriptionTargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.SubscriptionTargetSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.authorizedPrincipals = try reader["authorizedPrincipals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.manageAccessRole = try reader["manageAccessRole"].readIfPresent() ?? ""
        value.applicableAssetTypes = try reader["applicableAssetTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscriptionTargetConfig = try reader["subscriptionTargetConfig"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.SubscriptionTargetForm.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.provider = try reader["provider"].readIfPresent() ?? ""
        return value
    }
}

extension DataZoneClientTypes.SearchInventoryResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchInventoryResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glossaryItem":
                return .glossaryitem(try reader["glossaryItem"].read(with: DataZoneClientTypes.GlossaryItem.read(from:)))
            case "glossaryTermItem":
                return .glossarytermitem(try reader["glossaryTermItem"].read(with: DataZoneClientTypes.GlossaryTermItem.read(from:)))
            case "assetItem":
                return .assetitem(try reader["assetItem"].read(with: DataZoneClientTypes.AssetItem.read(from:)))
            case "dataProductItem":
                return .dataproductitem(try reader["dataProductItem"].read(with: DataZoneClientTypes.DataProductResultItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DataProductResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductResultItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.typeIdentifier = try reader["typeIdentifier"].readIfPresent() ?? ""
        value.typeRevision = try reader["typeRevision"].readIfPresent() ?? ""
        value.externalIdentifier = try reader["externalIdentifier"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.firstRevisionCreatedAt = try reader["firstRevisionCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstRevisionCreatedBy = try reader["firstRevisionCreatedBy"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.additionalAttributes = try reader["additionalAttributes"].readIfPresent(with: DataZoneClientTypes.AssetItemAdditionalAttributes.read(from:))
        return value
    }
}

extension DataZoneClientTypes.AssetItemAdditionalAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetItemAdditionalAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetItemAdditionalAttributes()
        value.formsOutput = try reader["formsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.readOnlyFormsOutput = try reader["readOnlyFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.FormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestTimeSeriesDataPointFormsOutput = try reader["latestTimeSeriesDataPointFormsOutput"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.GlossaryTermItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlossaryTermItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlossaryTermItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.glossaryId = try reader["glossaryId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.shortDescription = try reader["shortDescription"].readIfPresent()
        value.longDescription = try reader["longDescription"].readIfPresent()
        value.termRelations = try reader["termRelations"].readIfPresent(with: DataZoneClientTypes.TermRelations.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.GlossaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GlossaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GlossaryItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.GroupProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.GroupProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.GroupProfileSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.SearchResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetListing":
                return .assetlisting(try reader["assetListing"].read(with: DataZoneClientTypes.AssetListingItem.read(from:)))
            case "dataProductListing":
                return .dataproductlisting(try reader["dataProductListing"].read(with: DataZoneClientTypes.DataProductListingItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.DataProductListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductListingItem()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.listingCreatedBy = try reader["listingCreatedBy"].readIfPresent()
        value.listingUpdatedBy = try reader["listingUpdatedBy"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.additionalAttributes = try reader["additionalAttributes"].readIfPresent(with: DataZoneClientTypes.DataProductListingItemAdditionalAttributes.read(from:))
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.ListingSummaryItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.ListingSummaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.ListingSummaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.ListingSummaryItem()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.DataProductListingItemAdditionalAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.DataProductListingItemAdditionalAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.DataProductListingItemAdditionalAttributes()
        value.forms = try reader["forms"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.AssetListingItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingItem()
        value.listingId = try reader["listingId"].readIfPresent()
        value.listingRevision = try reader["listingRevision"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityRevision = try reader["entityRevision"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.listingCreatedBy = try reader["listingCreatedBy"].readIfPresent()
        value.listingUpdatedBy = try reader["listingUpdatedBy"].readIfPresent()
        value.glossaryTerms = try reader["glossaryTerms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.DetailedGlossaryTerm.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.additionalAttributes = try reader["additionalAttributes"].readIfPresent(with: DataZoneClientTypes.AssetListingItemAdditionalAttributes.read(from:))
        return value
    }
}

extension DataZoneClientTypes.AssetListingItemAdditionalAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetListingItemAdditionalAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetListingItemAdditionalAttributes()
        value.forms = try reader["forms"].readIfPresent()
        value.latestTimeSeriesDataPointForms = try reader["latestTimeSeriesDataPointForms"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.TimeSeriesDataPointSummaryFormOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.SearchTypesResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.SearchTypesResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "assetTypeItem":
                return .assettypeitem(try reader["assetTypeItem"].read(with: DataZoneClientTypes.AssetTypeItem.read(from:)))
            case "formTypeItem":
                return .formtypeitem(try reader["formTypeItem"].read(with: DataZoneClientTypes.FormTypeData.read(from:)))
            case "lineageNodeTypeItem":
                return .lineagenodetypeitem(try reader["lineageNodeTypeItem"].read(with: DataZoneClientTypes.LineageNodeTypeItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DataZoneClientTypes.LineageNodeTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.LineageNodeTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.LineageNodeTypeItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DataZoneClientTypes.FormTypeData {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.FormTypeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.FormTypeData()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.model = try reader["model"].readIfPresent(with: DataZoneClientTypes.Model.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.owningProjectId = try reader["owningProjectId"].readIfPresent()
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.imports = try reader["imports"].readListIfPresent(memberReadingClosure: DataZoneClientTypes.Import.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DataZoneClientTypes.AssetTypeItem {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.AssetTypeItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.AssetTypeItem()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.formsOutput = try reader["formsOutput"].readMapIfPresent(valueReadingClosure: DataZoneClientTypes.FormEntryOutput.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.owningProjectId = try reader["owningProjectId"].readIfPresent() ?? ""
        value.originDomainId = try reader["originDomainId"].readIfPresent()
        value.originProjectId = try reader["originProjectId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DataZoneClientTypes.UserProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DataZoneClientTypes.UserProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DataZoneClientTypes.UserProfileSummary()
        value.domainId = try reader["domainId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.details = try reader["details"].readIfPresent(with: DataZoneClientTypes.UserProfileDetails.read(from:))
        return value
    }
}

extension DataZoneClientTypes.AcceptRule {

    static func write(value: DataZoneClientTypes.AcceptRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rule"].write(value.rule)
        try writer["threshold"].write(value.threshold)
    }
}

extension DataZoneClientTypes.AcceptChoice {

    static func write(value: DataZoneClientTypes.AcceptChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["editedValue"].write(value.editedValue)
        try writer["predictionChoice"].write(value.predictionChoice)
        try writer["predictionTarget"].write(value.predictionTarget)
    }
}

extension DataZoneClientTypes.AcceptedAssetScope {

    static func write(value: DataZoneClientTypes.AcceptedAssetScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["filterIds"].writeList(value.filterIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DataZoneClientTypes.OwnerProperties {

    static func write(value: DataZoneClientTypes.OwnerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .group(group):
                try writer["group"].write(group, with: DataZoneClientTypes.OwnerGroupProperties.write(value:to:))
            case let .user(user):
                try writer["user"].write(user, with: DataZoneClientTypes.OwnerUserProperties.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.OwnerGroupProperties {

    static func write(value: DataZoneClientTypes.OwnerGroupProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupIdentifier"].write(value.groupIdentifier)
    }
}

extension DataZoneClientTypes.OwnerUserProperties {

    static func write(value: DataZoneClientTypes.OwnerUserProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userIdentifier"].write(value.userIdentifier)
    }
}

extension DataZoneClientTypes.FormInput {

    static func write(value: DataZoneClientTypes.FormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes.FormEntryInput {

    static func write(value: DataZoneClientTypes.FormEntryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["required"].write(value.`required`)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes.DataSourceConfigurationInput {

    static func write(value: DataZoneClientTypes.DataSourceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .gluerunconfiguration(gluerunconfiguration):
                try writer["glueRunConfiguration"].write(gluerunconfiguration, with: DataZoneClientTypes.GlueRunConfigurationInput.write(value:to:))
            case let .redshiftrunconfiguration(redshiftrunconfiguration):
                try writer["redshiftRunConfiguration"].write(redshiftrunconfiguration, with: DataZoneClientTypes.RedshiftRunConfigurationInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.RedshiftRunConfigurationInput {

    static func write(value: DataZoneClientTypes.RedshiftRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataAccessRole"].write(value.dataAccessRole)
        try writer["redshiftCredentialConfiguration"].write(value.redshiftCredentialConfiguration, with: DataZoneClientTypes.RedshiftCredentialConfiguration.write(value:to:))
        try writer["redshiftStorage"].write(value.redshiftStorage, with: DataZoneClientTypes.RedshiftStorage.write(value:to:))
        try writer["relationalFilterConfigurations"].writeList(value.relationalFilterConfigurations, memberWritingClosure: DataZoneClientTypes.RelationalFilterConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DataZoneClientTypes.GlueRunConfigurationInput {

    static func write(value: DataZoneClientTypes.GlueRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoImportDataQualityResult"].write(value.autoImportDataQualityResult)
        try writer["dataAccessRole"].write(value.dataAccessRole)
        try writer["relationalFilterConfigurations"].writeList(value.relationalFilterConfigurations, memberWritingClosure: DataZoneClientTypes.RelationalFilterConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DataZoneClientTypes.EnvironmentParameter {

    static func write(value: DataZoneClientTypes.EnvironmentParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension DataZoneClientTypes.Member {

    static func write(value: DataZoneClientTypes.Member?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .groupidentifier(groupidentifier):
                try writer["groupIdentifier"].write(groupidentifier)
            case let .useridentifier(useridentifier):
                try writer["userIdentifier"].write(useridentifier)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.GrantedEntityInput {

    static func write(value: DataZoneClientTypes.GrantedEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .listing(listing):
                try writer["listing"].write(listing, with: DataZoneClientTypes.ListingRevisionInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.ListingRevisionInput {

    static func write(value: DataZoneClientTypes.ListingRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["revision"].write(value.revision)
    }
}

extension DataZoneClientTypes.AssetTargetNameMap {

    static func write(value: DataZoneClientTypes.AssetTargetNameMap?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["targetName"].write(value.targetName)
    }
}

extension DataZoneClientTypes.SubscribedPrincipalInput {

    static func write(value: DataZoneClientTypes.SubscribedPrincipalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .project(project):
                try writer["project"].write(project, with: DataZoneClientTypes.SubscribedProjectInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.SubscribedProjectInput {

    static func write(value: DataZoneClientTypes.SubscribedProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DataZoneClientTypes.SubscribedListingInput {

    static func write(value: DataZoneClientTypes.SubscribedListingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DataZoneClientTypes.TimeSeriesDataPointFormInput {

    static func write(value: DataZoneClientTypes.TimeSeriesDataPointFormInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
        try writer["formName"].write(value.formName)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["typeIdentifier"].write(value.typeIdentifier)
        try writer["typeRevision"].write(value.typeRevision)
    }
}

extension DataZoneClientTypes.RejectRule {

    static func write(value: DataZoneClientTypes.RejectRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rule"].write(value.rule)
        try writer["threshold"].write(value.threshold)
    }
}

extension DataZoneClientTypes.RejectChoice {

    static func write(value: DataZoneClientTypes.RejectChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["predictionChoices"].writeList(value.predictionChoices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["predictionTarget"].write(value.predictionTarget)
    }
}

extension DataZoneClientTypes.SearchInItem {

    static func write(value: DataZoneClientTypes.SearchInItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
    }
}

extension DataZoneClientTypes.FilterClause {

    static func write(value: DataZoneClientTypes.FilterClause?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .and(and):
                try writer["and"].writeList(and, memberWritingClosure: DataZoneClientTypes.FilterClause.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .filter(filter):
                try writer["filter"].write(filter, with: DataZoneClientTypes.Filter.write(value:to:))
            case let .or(or):
                try writer["or"].writeList(or, memberWritingClosure: DataZoneClientTypes.FilterClause.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DataZoneClientTypes.Filter {

    static func write(value: DataZoneClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["value"].write(value.value)
    }
}

extension DataZoneClientTypes.SearchSort {

    static func write(value: DataZoneClientTypes.SearchSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["order"].write(value.order)
    }
}

public enum DataZoneClientTypes {}
