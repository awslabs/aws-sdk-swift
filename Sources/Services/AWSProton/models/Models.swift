// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension AcceptEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct AcceptEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension AcceptEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension AcceptEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct AcceptEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The environment account connection data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct AcceptEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension AcceptEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum AcceptEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \"CONTENT_REDACTED\")"}
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There isn't sufficient access for performing this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineCodebuildRoleArn
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineCodebuildRoleArn = self.pipelineCodebuildRoleArn {
            try encodeContainer.encode(pipelineCodebuildRoleArn, forKey: .pipelineCodebuildRoleArn)
        }
        if let pipelineProvisioningRepository = self.pipelineProvisioningRepository {
            try encodeContainer.encode(pipelineProvisioningRepository, forKey: .pipelineProvisioningRepository)
        }
        if let pipelineServiceRoleArn = self.pipelineServiceRoleArn {
            try encodeContainer.encode(pipelineServiceRoleArn, forKey: .pipelineServiceRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineServiceRoleArn)
        pipelineServiceRoleArn = pipelineServiceRoleArnDecoded
        let pipelineProvisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranch.self, forKey: .pipelineProvisioningRepository)
        pipelineProvisioningRepository = pipelineProvisioningRepositoryDecoded
        let pipelineCodebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineCodebuildRoleArn)
        pipelineCodebuildRoleArn = pipelineCodebuildRoleArnDecoded
    }
}

extension ProtonClientTypes {
    /// Proton settings that are used for multiple services in the Amazon Web Services account.
    public struct AccountSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service role that Proton uses for provisioning pipelines. Proton assumes this role for CodeBuild-based provisioning.
        public var pipelineCodebuildRoleArn: Swift.String?
        /// The linked repository for pipeline provisioning. Required if you have environments configured for self-managed provisioning with services that include pipelines. A linked repository is a repository that has been registered with Proton. For more information, see [CreateRepository].
        public var pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranch?
        /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Assumed by Proton for Amazon Web Services-managed provisioning, and by customer-owned automation for self-managed provisioning.
        public var pipelineServiceRoleArn: Swift.String?

        public init(
            pipelineCodebuildRoleArn: Swift.String? = nil,
            pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranch? = nil,
            pipelineServiceRoleArn: Swift.String? = nil
        )
        {
            self.pipelineCodebuildRoleArn = pipelineCodebuildRoleArn
            self.pipelineProvisioningRepository = pipelineProvisioningRepository
            self.pipelineServiceRoleArn = pipelineServiceRoleArn
        }
    }

}

extension ProtonClientTypes {
    public enum BlockerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockerStatus] {
            return [
                .active,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockerStatus(rawValue: rawValue) ?? BlockerStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum BlockerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automated
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockerType] {
            return [
                .automated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockerType(rawValue: rawValue) ?? BlockerType.sdkUnknown(rawValue)
        }
    }
}

extension CancelComponentDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
    }
}

extension CancelComponentDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelComponentDeploymentInput: Swift.Equatable {
    /// The name of the component with the deployment to cancel.
    /// This member is required.
    public var componentName: Swift.String?

    public init(
        componentName: Swift.String? = nil
    )
    {
        self.componentName = componentName
    }
}

struct CancelComponentDeploymentInputBody: Swift.Equatable {
    let componentName: Swift.String?
}

extension CancelComponentDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension CancelComponentDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelComponentDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct CancelComponentDeploymentOutput: Swift.Equatable {
    /// The detailed data of the component with the deployment that is being canceled.
    /// This member is required.
    public var component: ProtonClientTypes.Component?

    public init(
        component: ProtonClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct CancelComponentDeploymentOutputBody: Swift.Equatable {
    let component: ProtonClientTypes.Component?
}

extension CancelComponentDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum CancelComponentDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelEnvironmentDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
    }
}

extension CancelEnvironmentDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelEnvironmentDeploymentInput: Swift.Equatable {
    /// The name of the environment with the deployment to cancel.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        environmentName: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
    }
}

struct CancelEnvironmentDeploymentInputBody: Swift.Equatable {
    let environmentName: Swift.String?
}

extension CancelEnvironmentDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
    }
}

extension CancelEnvironmentDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelEnvironmentDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct CancelEnvironmentDeploymentOutput: Swift.Equatable {
    /// The environment summary data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init(
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct CancelEnvironmentDeploymentOutputBody: Swift.Equatable {
    let environment: ProtonClientTypes.Environment?
}

extension CancelEnvironmentDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CancelEnvironmentDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelServiceInstanceDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension CancelServiceInstanceDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelServiceInstanceDeploymentInput: Swift.Equatable {
    /// The name of the service instance with the deployment to cancel.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The name of the service with the service instance deployment to cancel.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct CancelServiceInstanceDeploymentInputBody: Swift.Equatable {
    let serviceInstanceName: Swift.String?
    let serviceName: Swift.String?
}

extension CancelServiceInstanceDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CancelServiceInstanceDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelServiceInstanceDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct CancelServiceInstanceDeploymentOutput: Swift.Equatable {
    /// The service instance summary data that's returned by Proton.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init(
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct CancelServiceInstanceDeploymentOutputBody: Swift.Equatable {
    let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension CancelServiceInstanceDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

enum CancelServiceInstanceDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelServicePipelineDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension CancelServicePipelineDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelServicePipelineDeploymentInput: Swift.Equatable {
    /// The name of the service with the service pipeline deployment to cancel.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

struct CancelServicePipelineDeploymentInputBody: Swift.Equatable {
    let serviceName: Swift.String?
}

extension CancelServicePipelineDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension CancelServicePipelineDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelServicePipelineDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct CancelServicePipelineDeploymentOutput: Swift.Equatable {
    /// The service pipeline detail data that's returned by Proton.
    /// This member is required.
    public var pipeline: ProtonClientTypes.ServicePipeline?

    public init(
        pipeline: ProtonClientTypes.ServicePipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct CancelServicePipelineDeploymentOutputBody: Swift.Equatable {
    let pipeline: ProtonClientTypes.ServicePipeline?
}

extension CancelServicePipelineDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum CancelServicePipelineDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.CompatibleEnvironmentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes {
    /// Compatible environment template data.
    public struct CompatibleEnvironmentTemplate: Swift.Equatable {
        /// The major version of the compatible environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The compatible environment template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.CompatibleEnvironmentTemplateInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes {
    /// Compatible environment template data.
    public struct CompatibleEnvironmentTemplateInput: Swift.Equatable {
        /// The major version of the compatible environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The compatible environment template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case description
        case environmentName
        case lastAttemptedDeploymentId
        case lastClientRequestToken
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastModifiedAt
        case lastSucceededDeploymentId
        case name
        case serviceInstanceName
        case serviceName
        case serviceSpec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastClientRequestToken = self.lastClientRequestToken {
            try encodeContainer.encode(lastClientRequestToken, forKey: .lastClientRequestToken)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceSpec = self.serviceSpec {
            try encodeContainer.encode(serviceSpec, forKey: .serviceSpec)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let serviceSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpec)
        serviceSpec = serviceSpecDecoded
        let lastClientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastClientRequestToken)
        lastClientRequestToken = lastClientRequestTokenDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.Component: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Component(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentName: \(Swift.String(describing: environmentName)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastClientRequestToken: \(Swift.String(describing: lastClientRequestToken)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), deploymentStatusMessage: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", serviceSpec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton component resource. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public struct Component: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the component was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The component deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// The message associated with the component deployment status.
        public var deploymentStatusMessage: Swift.String?
        /// A description of the component.
        public var description: Swift.String?
        /// The name of the Proton environment that this component is associated with.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the last attempted deployment of this component.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The last token the client requested.
        public var lastClientRequestToken: Swift.String?
        /// The time when a deployment of the component was last attempted.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the component was last deployed successfully.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The time when the component was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this component.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public var serviceInstanceName: Swift.String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public var serviceName: Swift.String?
        /// The service spec that the component uses to access service inputs. Provided when a component is attached to a service instance.
        public var serviceSpec: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastClientRequestToken: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceSpec: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastClientRequestToken = lastClientRequestToken
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
        }
    }

}

extension ProtonClientTypes {
    public enum ComponentDeploymentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case currentVersion
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentDeploymentUpdateType] {
            return [
                .currentVersion,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentVersion: return "CURRENT_VERSION"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentDeploymentUpdateType(rawValue: rawValue) ?? ComponentDeploymentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.ComponentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
        case serviceSpec
        case templateFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceSpec = self.serviceSpec {
            try encodeContainer.encode(serviceSpec, forKey: .serviceSpec)
        }
        if let templateFile = self.templateFile {
            try encodeContainer.encode(templateFile, forKey: .templateFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpec)
        serviceSpec = serviceSpecDecoded
        let templateFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateFile)
        templateFile = templateFileDecoded
    }
}

extension ProtonClientTypes.ComponentState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentState(serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), serviceSpec: \"CONTENT_REDACTED\", templateFile: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The detailed data about the current state of the component.
    public struct ComponentState: Swift.Equatable {
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public var serviceInstanceName: Swift.String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public var serviceName: Swift.String?
        /// The service spec that the component uses to access service inputs. Provided when a component is attached to a service instance.
        public var serviceSpec: Swift.String?
        /// The template file used.
        public var templateFile: Swift.String?

        public init(
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceSpec: Swift.String? = nil,
            templateFile: Swift.String? = nil
        )
        {
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.serviceSpec = serviceSpec
            self.templateFile = templateFile
        }
    }

}

extension ProtonClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case lastAttemptedDeploymentId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastModifiedAt
        case lastSucceededDeploymentId
        case name
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.ComponentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentName: \(Swift.String(describing: environmentName)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), deploymentStatusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton component resource. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public struct ComponentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the component was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The component deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// The message associated with the component deployment status.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the Proton environment that this component is associated with.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the last attempted deployment of this component.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The time when a deployment of the component was last attempted.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the component was last deployed successfully.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The time when the component was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this component.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service instance that this component is attached to. Provided when a component is attached to a service instance.
        public var serviceInstanceName: Swift.String?
        /// The name of the service that serviceInstanceName is associated with. Provided when a component is attached to a service instance.
        public var serviceName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \"CONTENT_REDACTED\")"}
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be made due to a conflicting operation or resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes.CountsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case environmentTemplates
        case environments
        case pipelines
        case serviceInstances
        case serviceTemplates
        case services
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = self.components {
            try encodeContainer.encode(components, forKey: .components)
        }
        if let environmentTemplates = self.environmentTemplates {
            try encodeContainer.encode(environmentTemplates, forKey: .environmentTemplates)
        }
        if let environments = self.environments {
            try encodeContainer.encode(environments, forKey: .environments)
        }
        if let pipelines = self.pipelines {
            try encodeContainer.encode(pipelines, forKey: .pipelines)
        }
        if let serviceInstances = self.serviceInstances {
            try encodeContainer.encode(serviceInstances, forKey: .serviceInstances)
        }
        if let serviceTemplates = self.serviceTemplates {
            try encodeContainer.encode(serviceTemplates, forKey: .serviceTemplates)
        }
        if let services = self.services {
            try encodeContainer.encode(services, forKey: .services)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .components)
        components = componentsDecoded
        let environmentsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .environments)
        environments = environmentsDecoded
        let environmentTemplatesDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .environmentTemplates)
        environmentTemplates = environmentTemplatesDecoded
        let serviceInstancesDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .serviceInstances)
        serviceInstances = serviceInstancesDecoded
        let servicesDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .services)
        services = servicesDecoded
        let serviceTemplatesDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .serviceTemplates)
        serviceTemplates = serviceTemplatesDecoded
        let pipelinesDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceCountsSummary.self, forKey: .pipelines)
        pipelines = pipelinesDecoded
    }
}

extension ProtonClientTypes {
    /// Summary counts of each Proton resource type.
    public struct CountsSummary: Swift.Equatable {
        /// The total number of components in the Amazon Web Services account. The semantics of the components field are different from the semantics of results for other infrastructure-provisioning resources. That's because at this time components don't have associated templates, therefore they don't have the concept of staleness. The components object will only contain total and failed members.
        public var components: ProtonClientTypes.ResourceCountsSummary?
        /// The total number of environment templates in the Amazon Web Services account. The environmentTemplates object will only contain total members.
        public var environmentTemplates: ProtonClientTypes.ResourceCountsSummary?
        /// The staleness counts for Proton environments in the Amazon Web Services account. The environments object will only contain total members.
        public var environments: ProtonClientTypes.ResourceCountsSummary?
        /// The staleness counts for Proton pipelines in the Amazon Web Services account.
        public var pipelines: ProtonClientTypes.ResourceCountsSummary?
        /// The staleness counts for Proton service instances in the Amazon Web Services account.
        public var serviceInstances: ProtonClientTypes.ResourceCountsSummary?
        /// The total number of service templates in the Amazon Web Services account. The serviceTemplates object will only contain total members.
        public var serviceTemplates: ProtonClientTypes.ResourceCountsSummary?
        /// The staleness counts for Proton services in the Amazon Web Services account.
        public var services: ProtonClientTypes.ResourceCountsSummary?

        public init(
            components: ProtonClientTypes.ResourceCountsSummary? = nil,
            environmentTemplates: ProtonClientTypes.ResourceCountsSummary? = nil,
            environments: ProtonClientTypes.ResourceCountsSummary? = nil,
            pipelines: ProtonClientTypes.ResourceCountsSummary? = nil,
            serviceInstances: ProtonClientTypes.ResourceCountsSummary? = nil,
            serviceTemplates: ProtonClientTypes.ResourceCountsSummary? = nil,
            services: ProtonClientTypes.ResourceCountsSummary? = nil
        )
        {
            self.components = components
            self.environmentTemplates = environmentTemplates
            self.environments = environments
            self.pipelines = pipelines
            self.serviceInstances = serviceInstances
            self.serviceTemplates = serviceTemplates
            self.services = services
        }
    }

}

extension CreateComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComponentInput(clientToken: \(Swift.String(describing: clientToken)), environmentName: \(Swift.String(describing: environmentName)), name: \(Swift.String(describing: name)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", manifest: \"CONTENT_REDACTED\", serviceSpec: \"CONTENT_REDACTED\", templateFile: \"CONTENT_REDACTED\")"}
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case environmentName
        case manifest
        case name
        case serviceInstanceName
        case serviceName
        case serviceSpec
        case tags
        case templateFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let manifest = self.manifest {
            try encodeContainer.encode(manifest, forKey: .manifest)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceSpec = self.serviceSpec {
            try encodeContainer.encode(serviceSpec, forKey: .serviceSpec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateFile = self.templateFile {
            try encodeContainer.encode(templateFile, forKey: .templateFile)
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The client token for the created component.
    public var clientToken: Swift.String?
    /// An optional customer-provided description of the component.
    public var description: Swift.String?
    /// The name of the Proton environment that you want to associate this component with. You must specify this when you don't specify serviceInstanceName and serviceName.
    public var environmentName: Swift.String?
    /// A path to a manifest file that lists the Infrastructure as Code (IaC) file, template language, and rendering engine for infrastructure that a custom component provisions.
    /// This member is required.
    public var manifest: Swift.String?
    /// The customer-provided name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service instance that you want to attach this component to. If you don't specify this, the component isn't attached to any service instance. Specify both serviceInstanceName and serviceName or neither of them.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that serviceInstanceName is associated with. If you don't specify this, the component isn't attached to any service instance. Specify both serviceInstanceName and serviceName or neither of them.
    public var serviceName: Swift.String?
    /// The service spec that you want the component to use to access service inputs. Set this only when you attach the component to a service instance.
    public var serviceSpec: Swift.String?
    /// An optional list of metadata items that you can associate with the Proton component. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions. Components support a single IaC file, even if you use Terraform as your template language.
    /// This member is required.
    public var templateFile: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        manifest: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceSpec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateFile: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.environmentName = environmentName
        self.manifest = manifest
        self.name = name
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
        self.serviceSpec = serviceSpec
        self.tags = tags
        self.templateFile = templateFile
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let environmentName: Swift.String?
    let templateFile: Swift.String?
    let manifest: Swift.String?
    let serviceSpec: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case environmentName
        case manifest
        case name
        case serviceInstanceName
        case serviceName
        case serviceSpec
        case tags
        case templateFile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let templateFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateFile)
        templateFile = templateFileDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifest)
        manifest = manifestDecoded
        let serviceSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpec)
        serviceSpec = serviceSpecDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct CreateComponentOutput: Swift.Equatable {
    /// The detailed data of the created component.
    /// This member is required.
    public var component: ProtonClientTypes.Component?

    public init(
        component: ProtonClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct CreateComponentOutputBody: Swift.Equatable {
    let component: ProtonClientTypes.Component?
}

extension CreateComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum CreateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case codebuildRoleArn
        case componentRoleArn
        case environmentName
        case managementAccountId
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let managementAccountId = self.managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentAccountConnectionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the environment account connection that the first request created.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
    public var codebuildRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. You must specify componentRoleArn to allow directly defined components to be associated with any environments running in this account. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var componentRoleArn: Swift.String?
    /// The name of the Proton environment that's created in the associated management account.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The ID of the management account that accepts or rejects the environment account connection. You create and manage the Proton environment in this account. If the management account accepts the environment account connection, Proton can use the associated IAM role to provision environment infrastructure resources in the associated environment account.
    /// This member is required.
    public var managementAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that's created in the environment account. Proton uses this role to provision infrastructure resources in the associated environment account.
    public var roleArn: Swift.String?
    /// An optional list of metadata items that you can associate with the Proton environment account connection. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        codebuildRoleArn: Swift.String? = nil,
        componentRoleArn: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        managementAccountId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.codebuildRoleArn = codebuildRoleArn
        self.componentRoleArn = componentRoleArn
        self.environmentName = environmentName
        self.managementAccountId = managementAccountId
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let managementAccountId: Swift.String?
    let roleArn: Swift.String?
    let environmentName: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
    let componentRoleArn: Swift.String?
    let codebuildRoleArn: Swift.String?
}

extension CreateEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case codebuildRoleArn
        case componentRoleArn
        case environmentName
        case managementAccountId
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
    }
}

extension CreateEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct CreateEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct CreateEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension CreateEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum CreateEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(codebuildRoleArn: \(Swift.String(describing: codebuildRoleArn)), componentRoleArn: \(Swift.String(describing: componentRoleArn)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), tags: \(Swift.String(describing: tags)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = self.environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = self.protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioningRepository = self.provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf. To use CodeBuild-based provisioning for the environment or for any service instance running in the environment, specify either the environmentAccountConnectionId or codebuildRoleArn parameter.
    public var codebuildRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. You must specify componentRoleArn to allow directly defined components to be associated with this environment. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var componentRoleArn: Swift.String?
    /// A description of the environment that's being created and deployed.
    public var description: Swift.String?
    /// The ID of the environment account connection that you provide if you're provisioning your environment infrastructure resources to an environment account. For more information, see [Environment account connections](https://docs.aws.amazon.com/proton/latest/userguide/ag-env-account-connections.html) in the Proton User guide. To use Amazon Web Services-managed provisioning for the environment, specify either the environmentAccountConnectionId or protonServiceRoleArn parameter and omit the provisioningRepository parameter.
    public var environmentAccountConnectionId: Swift.String?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf. To use Amazon Web Services-managed provisioning for the environment, specify either the environmentAccountConnectionId or protonServiceRoleArn parameter and omit the provisioningRepository parameter.
    public var protonServiceRoleArn: Swift.String?
    /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see [CreateRepository]. To use self-managed provisioning for the environment, specify this parameter and omit the environmentAccountConnectionId and protonServiceRoleArn parameters.
    public var provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// A YAML formatted string that provides inputs as defined in the environment template bundle schema file. For more information, see [Environments](https://docs.aws.amazon.com/proton/latest/userguide/ag-environments.html) in the Proton User Guide.
    /// This member is required.
    public var spec: Swift.String?
    /// An optional list of metadata items that you can associate with the Proton environment. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// The major version of the environment template.
    /// This member is required.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the environment template.
    public var templateMinorVersion: Swift.String?
    /// The name of the environment template. For more information, see [Environment Templates](https://docs.aws.amazon.com/proton/latest/userguide/ag-templates.html) in the Proton User Guide.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        codebuildRoleArn: Swift.String? = nil,
        componentRoleArn: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentAccountConnectionId: Swift.String? = nil,
        name: Swift.String? = nil,
        protonServiceRoleArn: Swift.String? = nil,
        provisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        spec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.codebuildRoleArn = codebuildRoleArn
        self.componentRoleArn = componentRoleArn
        self.description = description
        self.environmentAccountConnectionId = environmentAccountConnectionId
        self.name = name
        self.protonServiceRoleArn = protonServiceRoleArn
        self.provisioningRepository = provisioningRepository
        self.spec = spec
        self.tags = tags
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
        self.templateName = templateName
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let templateName: Swift.String?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
    let description: Swift.String?
    let spec: Swift.String?
    let protonServiceRoleArn: Swift.String?
    let environmentAccountConnectionId: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
    let provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    let componentRoleArn: Swift.String?
    let codebuildRoleArn: Swift.String?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init(
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let environment: ProtonClientTypes.Environment?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateInput(encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case provisioning
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = self.provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEnvironmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentTemplateInput: Swift.Equatable {
    /// A description of the environment template.
    public var description: Swift.String?
    /// The environment template name as displayed in the developer interface.
    public var displayName: Swift.String?
    /// A customer provided encryption key that Proton uses to encrypt data.
    public var encryptionKey: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var name: Swift.String?
    /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
    public var provisioning: ProtonClientTypes.Provisioning?
    /// An optional list of metadata items that you can associate with the Proton environment template. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioning: ProtonClientTypes.Provisioning? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.encryptionKey = encryptionKey
        self.name = name
        self.provisioning = provisioning
        self.tags = tags
    }
}

struct CreateEnvironmentTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let encryptionKey: Swift.String?
    let provisioning: ProtonClientTypes.Provisioning?
    let tags: [ProtonClientTypes.Tag]?
}

extension CreateEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case provisioning
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct CreateEnvironmentTemplateOutput: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init(
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct CreateEnvironmentTemplateOutputBody: Swift.Equatable {
    let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension CreateEnvironmentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

enum CreateEnvironmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentTemplateVersionInput(clientToken: \(Swift.String(describing: clientToken)), majorVersion: \(Swift.String(describing: majorVersion)), source: \(Swift.String(describing: source)), tags: \(Swift.String(describing: tags)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension CreateEnvironmentTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentTemplateVersionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the environment template version that the first request created.
    public var clientToken: Swift.String?
    /// A description of the new version of an environment template.
    public var description: Swift.String?
    /// To create a new minor version of the environment template, include major Version. To create a new major and minor version of the environment template, exclude major Version.
    public var majorVersion: Swift.String?
    /// An object that includes the template bundle S3 bucket path and name for the new version of an template.
    /// This member is required.
    public var source: ProtonClientTypes.TemplateVersionSourceInput?
    /// An optional list of metadata items that you can associate with the Proton environment template version. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        source: ProtonClientTypes.TemplateVersionSourceInput? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.majorVersion = majorVersion
        self.source = source
        self.tags = tags
        self.templateName = templateName
    }
}

struct CreateEnvironmentTemplateVersionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let templateName: Swift.String?
    let description: Swift.String?
    let majorVersion: Swift.String?
    let source: ProtonClientTypes.TemplateVersionSourceInput?
    let tags: [ProtonClientTypes.Tag]?
}

extension CreateEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case majorVersion
        case source
        case tags
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionSourceInput.self, forKey: .source)
        source = sourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct CreateEnvironmentTemplateVersionOutput: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init(
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct CreateEnvironmentTemplateVersionOutputBody: Swift.Equatable {
    let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension CreateEnvironmentTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

enum CreateEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn
        case encryptionKey
        case name
        case provider
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your AWS CodeStar connection that connects Proton to your repository provider account. For more information, see [Setting up for Proton](https://docs.aws.amazon.com/proton/latest/userguide/setting-up-for-service.html) in the Proton User Guide.
    /// This member is required.
    public var connectionArn: Swift.String?
    /// The ARN of your customer Amazon Web Services Key Management Service (Amazon Web Services KMS) key.
    public var encryptionKey: Swift.String?
    /// The repository name (for example, myrepos/myrepo).
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?
    /// An optional list of metadata items that you can associate with the Proton repository. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        connectionArn: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.connectionArn = connectionArn
        self.encryptionKey = encryptionKey
        self.name = name
        self.provider = provider
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let provider: ProtonClientTypes.RepositoryProvider?
    let name: Swift.String?
    let connectionArn: Swift.String?
    let encryptionKey: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn
        case encryptionKey
        case name
        case provider
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutput: Swift.Equatable {
    /// The repository link's detail data that's returned by Proton.
    /// This member is required.
    public var repository: ProtonClientTypes.Repository?

    public init(
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputBody: Swift.Equatable {
    let repository: ProtonClientTypes.Repository?
}

extension CreateRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum CreateRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(branchName: \(Swift.String(describing: branchName)), name: \(Swift.String(describing: name)), repositoryConnectionArn: \(Swift.String(describing: repositoryConnectionArn)), repositoryId: \(Swift.String(describing: repositoryId)), tags: \(Swift.String(describing: tags)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
        case name
        case repositoryConnectionArn
        case repositoryId
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let repositoryConnectionArn = self.repositoryConnectionArn {
            try encodeContainer.encode(repositoryConnectionArn, forKey: .repositoryConnectionArn)
        }
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The name of the code repository branch that holds the code that's deployed in Proton. Don't include this parameter if your service template doesn't include a service pipeline.
    public var branchName: Swift.String?
    /// A description of the Proton service.
    public var description: Swift.String?
    /// The service name.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the repository connection. For more information, see [Setting up an AWS CodeStar connection](https://docs.aws.amazon.com/proton/latest/userguide/setting-up-for-service.html#setting-up-vcontrol) in the Proton User Guide. Don't include this parameter if your service template doesn't include a service pipeline.
    public var repositoryConnectionArn: Swift.String?
    /// The ID of the code repository. Don't include this parameter if your service template doesn't include a service pipeline.
    public var repositoryId: Swift.String?
    /// A link to a spec file that provides inputs as defined in the service template bundle schema file. The spec file is in YAML format. Dont include pipeline inputs in the spec if your service template doesnt include a service pipeline. For more information, see [Create a service](https://docs.aws.amazon.com/proton/latest/userguide/ag-create-svc.html) in the Proton User Guide.
    /// This member is required.
    public var spec: Swift.String?
    /// An optional list of metadata items that you can associate with the Proton service. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// The major version of the service template that was used to create the service.
    /// This member is required.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template that was used to create the service.
    public var templateMinorVersion: Swift.String?
    /// The name of the service template that's used to create the service.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        repositoryConnectionArn: Swift.String? = nil,
        repositoryId: Swift.String? = nil,
        spec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.description = description
        self.name = name
        self.repositoryConnectionArn = repositoryConnectionArn
        self.repositoryId = repositoryId
        self.spec = spec
        self.tags = tags
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
        self.templateName = templateName
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let templateName: Swift.String?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
    let spec: Swift.String?
    let repositoryConnectionArn: Swift.String?
    let repositoryId: Swift.String?
    let branchName: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
        case name
        case repositoryConnectionArn
        case repositoryId
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let repositoryConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryConnectionArn)
        repositoryConnectionArn = repositoryConnectionArnDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInstanceInput(clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), tags: \(Swift.String(describing: tags)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), spec: \"CONTENT_REDACTED\")"}
}

extension CreateServiceInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case serviceName
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

extension CreateServiceInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceInstanceInput: Swift.Equatable {
    /// The client token of the service instance to create.
    public var clientToken: Swift.String?
    /// The name of the service instance to create.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service the service instance is added to.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The spec for the service instance you want to create.
    /// This member is required.
    public var spec: Swift.String?
    /// An optional list of metadata items that you can associate with the Proton service instance. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// To create a new major and minor version of the service template, exclude major Version.
    public var templateMajorVersion: Swift.String?
    /// To create a new minor version of the service template, include a major Version.
    public var templateMinorVersion: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        spec: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.serviceName = serviceName
        self.spec = spec
        self.tags = tags
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct CreateServiceInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let serviceName: Swift.String?
    let spec: Swift.String?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
    let tags: [ProtonClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateServiceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case serviceName
        case spec
        case tags
        case templateMajorVersion
        case templateMinorVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateServiceInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct CreateServiceInstanceOutput: Swift.Equatable {
    /// The detailed data of the service instance being created.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init(
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct CreateServiceInstanceOutputBody: Swift.Equatable {
    let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension CreateServiceInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

enum CreateServiceInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutput: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    /// This member is required.
    public var service: ProtonClientTypes.Service?

    public init(
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputBody: Swift.Equatable {
    let service: ProtonClientTypes.Service?
}

extension CreateServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

enum CreateServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case filePath
        case repositoryName
        case repositoryProvider
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension CreateServiceSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceSyncConfigInput: Swift.Equatable {
    /// The repository branch for your Proton Ops file.
    /// This member is required.
    public var branch: Swift.String?
    /// The path to the Proton Ops file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The repository name.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The provider type for your repository.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The name of the service the Proton Ops file is for.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        branch: Swift.String? = nil,
        filePath: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.branch = branch
        self.filePath = filePath
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.serviceName = serviceName
    }
}

struct CreateServiceSyncConfigInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let repositoryName: Swift.String?
    let branch: Swift.String?
    let filePath: Swift.String?
}

extension CreateServiceSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case filePath
        case repositoryName
        case repositoryProvider
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension CreateServiceSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSyncConfig = output.serviceSyncConfig
        } else {
            self.serviceSyncConfig = nil
        }
    }
}

public struct CreateServiceSyncConfigOutput: Swift.Equatable {
    /// The detailed data of the Proton Ops file.
    public var serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?

    public init(
        serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig? = nil
    )
    {
        self.serviceSyncConfig = serviceSyncConfig
    }
}

struct CreateServiceSyncConfigOutputBody: Swift.Equatable {
    let serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?
}

extension CreateServiceSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceSyncConfig.self, forKey: .serviceSyncConfig)
        serviceSyncConfig = serviceSyncConfigDecoded
    }
}

enum CreateServiceSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateInput(encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension CreateServiceTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case pipelineProvisioning
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = self.pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateServiceTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceTemplateInput: Swift.Equatable {
    /// A description of the service template.
    public var description: Swift.String?
    /// The name of the service template as displayed in the developer interface.
    public var displayName: Swift.String?
    /// A customer provided encryption key that's used to encrypt data.
    public var encryptionKey: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var name: Swift.String?
    /// By default, Proton provides a service pipeline for your service. When this parameter is included, it indicates that an Proton service pipeline isn't provided for your service. After it's included, it can't be changed. For more information, see [Template bundles](https://docs.aws.amazon.com/proton/latest/userguide/ag-template-authoring.html#ag-template-bundles) in the Proton User Guide.
    public var pipelineProvisioning: ProtonClientTypes.Provisioning?
    /// An optional list of metadata items that you can associate with the Proton service template. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        name: Swift.String? = nil,
        pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.encryptionKey = encryptionKey
        self.name = name
        self.pipelineProvisioning = pipelineProvisioning
        self.tags = tags
    }
}

struct CreateServiceTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let encryptionKey: Swift.String?
    let pipelineProvisioning: ProtonClientTypes.Provisioning?
    let tags: [ProtonClientTypes.Tag]?
}

extension CreateServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case encryptionKey
        case name
        case pipelineProvisioning
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct CreateServiceTemplateOutput: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init(
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct CreateServiceTemplateOutputBody: Swift.Equatable {
    let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension CreateServiceTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

enum CreateServiceTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceTemplateVersionInput(clientToken: \(Swift.String(describing: clientToken)), compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), majorVersion: \(Swift.String(describing: majorVersion)), source: \(Swift.String(describing: source)), supportedComponentSources: \(Swift.String(describing: supportedComponentSources)), tags: \(Swift.String(describing: tags)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\")"}
}

extension CreateServiceTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case source
        case supportedComponentSources
        case tags
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplateinput0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplateinput0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let supportedComponentSources = supportedComponentSources {
            var supportedComponentSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedComponentSources)
            for servicetemplatesupportedcomponentsourcetype0 in supportedComponentSources {
                try supportedComponentSourcesContainer.encode(servicetemplatesupportedcomponentsourcetype0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension CreateServiceTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceTemplateVersionInput: Swift.Equatable {
    /// When included, if two identical requests are made with the same client token, Proton returns the service template version that the first request created.
    public var clientToken: Swift.String?
    /// An array of environment template objects that are compatible with the new service template version. A service instance based on this service template version can run in environments based on compatible templates.
    /// This member is required.
    public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    /// A description of the new version of a service template.
    public var description: Swift.String?
    /// To create a new minor version of the service template, include a major Version. To create a new major and minor version of the service template, exclude major Version.
    public var majorVersion: Swift.String?
    /// An object that includes the template bundle S3 bucket path and name for the new version of a service template.
    /// This member is required.
    public var source: ProtonClientTypes.TemplateVersionSourceInput?
    /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]?
    /// An optional list of metadata items that you can associate with the Proton service template version. A tag is a key-value pair. For more information, see [Proton resources and tagging](https://docs.aws.amazon.com/proton/latest/userguide/resources.html) in the Proton User Guide.
    public var tags: [ProtonClientTypes.Tag]?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        source: ProtonClientTypes.TemplateVersionSourceInput? = nil,
        supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil,
        tags: [ProtonClientTypes.Tag]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
        self.description = description
        self.majorVersion = majorVersion
        self.source = source
        self.supportedComponentSources = supportedComponentSources
        self.tags = tags
        self.templateName = templateName
    }
}

struct CreateServiceTemplateVersionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let templateName: Swift.String?
    let description: Swift.String?
    let majorVersion: Swift.String?
    let source: ProtonClientTypes.TemplateVersionSourceInput?
    let compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    let tags: [ProtonClientTypes.Tag]?
    let supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]?
}

extension CreateServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case source
        case supportedComponentSources
        case tags
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionSourceInput.self, forKey: .source)
        source = sourceDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplateInput?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplateInput]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let supportedComponentSourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateSupportedComponentSourceType?].self, forKey: .supportedComponentSources)
        var supportedComponentSourcesDecoded0:[ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil
        if let supportedComponentSourcesContainer = supportedComponentSourcesContainer {
            supportedComponentSourcesDecoded0 = [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]()
            for string0 in supportedComponentSourcesContainer {
                if let string0 = string0 {
                    supportedComponentSourcesDecoded0?.append(string0)
                }
            }
        }
        supportedComponentSources = supportedComponentSourcesDecoded0
    }
}

extension CreateServiceTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct CreateServiceTemplateVersionOutput: Swift.Equatable {
    /// The service template version summary of detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init(
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct CreateServiceTemplateVersionOutputBody: Swift.Equatable {
    let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension CreateServiceTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

enum CreateServiceTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTemplateSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = self.subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension CreateTemplateSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTemplateSyncConfigInput: Swift.Equatable {
    /// The repository branch for your template.
    /// This member is required.
    public var branch: Swift.String?
    /// The repository name (for example, myrepos/myrepo).
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The provider type for your repository.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// A repository subdirectory path to your template bundle directory. When included, Proton limits the template bundle search to this repository directory.
    public var subdirectory: Swift.String?
    /// The name of your registered template.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type of the registered template.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init(
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        subdirectory: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.subdirectory = subdirectory
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct CreateTemplateSyncConfigInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateType: ProtonClientTypes.TemplateType?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let repositoryName: Swift.String?
    let branch: Swift.String?
    let subdirectory: Swift.String?
}

extension CreateTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension CreateTemplateSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTemplateSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct CreateTemplateSyncConfigOutput: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init(
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct CreateTemplateSyncConfigOutputBody: Swift.Equatable {
    let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension CreateTemplateSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

enum CreateTemplateSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The name of the component to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct DeleteComponentOutput: Swift.Equatable {
    /// The detailed data of the component being deleted.
    public var component: ProtonClientTypes.Component?

    public init(
        component: ProtonClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct DeleteComponentOutputBody: Swift.Equatable {
    let component: ProtonClientTypes.Component?
}

extension DeleteComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum DeleteComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDeploymentInput: Swift.Equatable {
    /// The ID of the deployment to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployment = output.deployment
        } else {
            self.deployment = nil
        }
    }
}

public struct DeleteDeploymentOutput: Swift.Equatable {
    /// The detailed data of the deployment being deleted.
    public var deployment: ProtonClientTypes.Deployment?

    public init(
        deployment: ProtonClientTypes.Deployment? = nil
    )
    {
        self.deployment = deployment
    }
}

struct DeleteDeploymentOutputBody: Swift.Equatable {
    let deployment: ProtonClientTypes.Deployment?
}

extension DeleteDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Deployment.self, forKey: .deployment)
        deployment = deploymentDecoded
    }
}

enum DeleteDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct DeleteEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The detailed data of the environment account connection being deleted.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct DeleteEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension DeleteEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum DeleteEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The name of the environment to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {
    /// The detailed data of the environment being deleted.
    public var environment: ProtonClientTypes.Environment?

    public init(
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct DeleteEnvironmentOutputBody: Swift.Equatable {
    let environment: ProtonClientTypes.Environment?
}

extension DeleteEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEnvironmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentTemplateInput: Swift.Equatable {
    /// The name of the environment template to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEnvironmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEnvironmentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct DeleteEnvironmentTemplateOutput: Swift.Equatable {
    /// The detailed data of the environment template being deleted.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init(
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct DeleteEnvironmentTemplateOutputBody: Swift.Equatable {
    let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension DeleteEnvironmentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

enum DeleteEnvironmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension DeleteEnvironmentTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentTemplateVersionInput: Swift.Equatable {
    /// The environment template major version to delete.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// The environment template minor version to delete.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct DeleteEnvironmentTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
}

extension DeleteEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension DeleteEnvironmentTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEnvironmentTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct DeleteEnvironmentTemplateVersionOutput: Swift.Equatable {
    /// The detailed data of the environment template version being deleted.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init(
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct DeleteEnvironmentTemplateVersionOutputBody: Swift.Equatable {
    let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension DeleteEnvironmentTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

enum DeleteEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// The repository name.
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?

    public init(
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil
    )
    {
        self.name = name
        self.provider = provider
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    let provider: ProtonClientTypes.RepositoryProvider?
    let name: Swift.String?
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutput: Swift.Equatable {
    /// The deleted repository link's detail data that's returned by Proton.
    public var repository: ProtonClientTypes.Repository?

    public init(
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputBody: Swift.Equatable {
    let repository: ProtonClientTypes.Repository?
}

extension DeleteRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum DeleteRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The name of the service to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DeleteServiceOutput: Swift.Equatable {
    /// The detailed data of the service being deleted.
    public var service: ProtonClientTypes.Service?

    public init(
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct DeleteServiceOutputBody: Swift.Equatable {
    let service: ProtonClientTypes.Service?
}

extension DeleteServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

enum DeleteServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension DeleteServiceSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceSyncConfigInput: Swift.Equatable {
    /// The name of the service that you want to delete the service sync configuration for.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

struct DeleteServiceSyncConfigInputBody: Swift.Equatable {
    let serviceName: Swift.String?
}

extension DeleteServiceSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension DeleteServiceSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSyncConfig = output.serviceSyncConfig
        } else {
            self.serviceSyncConfig = nil
        }
    }
}

public struct DeleteServiceSyncConfigOutput: Swift.Equatable {
    /// The detailed data for the service sync config.
    public var serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?

    public init(
        serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig? = nil
    )
    {
        self.serviceSyncConfig = serviceSyncConfig
    }
}

struct DeleteServiceSyncConfigOutputBody: Swift.Equatable {
    let serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?
}

extension DeleteServiceSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceSyncConfig.self, forKey: .serviceSyncConfig)
        serviceSyncConfig = serviceSyncConfigDecoded
    }
}

enum DeleteServiceSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteServiceTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceTemplateInput: Swift.Equatable {
    /// The name of the service template to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteServiceTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteServiceTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct DeleteServiceTemplateOutput: Swift.Equatable {
    /// The detailed data of the service template being deleted.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init(
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct DeleteServiceTemplateOutputBody: Swift.Equatable {
    let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension DeleteServiceTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

enum DeleteServiceTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension DeleteServiceTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceTemplateVersionInput: Swift.Equatable {
    /// The service template major version to delete.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// The service template minor version to delete.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct DeleteServiceTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
}

extension DeleteServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension DeleteServiceTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct DeleteServiceTemplateVersionOutput: Swift.Equatable {
    /// The detailed data of the service template version being deleted.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init(
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct DeleteServiceTemplateVersionOutputBody: Swift.Equatable {
    let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension DeleteServiceTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

enum DeleteServiceTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTemplateSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension DeleteTemplateSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTemplateSyncConfigInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init(
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct DeleteTemplateSyncConfigInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateType: ProtonClientTypes.TemplateType?
}

extension DeleteTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
    }
}

extension DeleteTemplateSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTemplateSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct DeleteTemplateSyncConfigOutput: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init(
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct DeleteTemplateSyncConfigOutputBody: Swift.Equatable {
    let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension DeleteTemplateSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

enum DeleteTemplateSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case completedAt
        case componentName
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case id
        case initialState
        case lastAttemptedDeploymentId
        case lastModifiedAt
        case lastSucceededDeploymentId
        case serviceInstanceName
        case serviceName
        case targetArn
        case targetResourceCreatedAt
        case targetResourceType
        case targetState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .epochSeconds, forKey: .completedAt)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initialState = self.initialState {
            try encodeContainer.encode(initialState, forKey: .initialState)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let targetResourceCreatedAt = self.targetResourceCreatedAt {
            try encodeContainer.encodeTimestamp(targetResourceCreatedAt, format: .epochSeconds, forKey: .targetResourceCreatedAt)
        }
        if let targetResourceType = self.targetResourceType {
            try encodeContainer.encode(targetResourceType.rawValue, forKey: .targetResourceType)
        }
        if let targetState = self.targetState {
            try encodeContainer.encode(targetState, forKey: .targetState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let targetResourceCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .targetResourceCreatedAt)
        targetResourceCreatedAt = targetResourceCreatedAtDecoded
        let targetResourceTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentTargetResourceType.self, forKey: .targetResourceType)
        targetResourceType = targetResourceTypeDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
        let initialStateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentState.self, forKey: .initialState)
        initialState = initialStateDecoded
        let targetStateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentState.self, forKey: .targetState)
        targetState = targetStateDecoded
    }
}

extension ProtonClientTypes.Deployment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Deployment(arn: \(Swift.String(describing: arn)), completedAt: \(Swift.String(describing: completedAt)), componentName: \(Swift.String(describing: componentName)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentName: \(Swift.String(describing: environmentName)), id: \(Swift.String(describing: id)), initialState: \(Swift.String(describing: initialState)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), targetArn: \(Swift.String(describing: targetArn)), targetResourceCreatedAt: \(Swift.String(describing: targetResourceCreatedAt)), targetResourceType: \(Swift.String(describing: targetResourceType)), targetState: \(Swift.String(describing: targetState)), deploymentStatusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The detailed information about a deployment.
    public struct Deployment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the deployment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the deployment was completed.
        public var completedAt: ClientRuntime.Date?
        /// The name of the component associated with this deployment.
        public var componentName: Swift.String?
        /// The date and time the deployment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The status of the deployment.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// The deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the environment associated with this deployment.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the deployment.
        /// This member is required.
        public var id: Swift.String?
        /// The initial state of the target resource at the time of the deployment.
        public var initialState: ProtonClientTypes.DeploymentState?
        /// The ID of the last attempted deployment.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The date and time the deployment was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the last successful deployment.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the deployment's service instance.
        public var serviceInstanceName: Swift.String?
        /// The name of the service in this deployment.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the target of the deployment.
        /// This member is required.
        public var targetArn: Swift.String?
        /// The date and time the depoyment target was created.
        /// This member is required.
        public var targetResourceCreatedAt: ClientRuntime.Date?
        /// The resource type of the deployment target. It can be an environment, service, service instance, or component.
        /// This member is required.
        public var targetResourceType: ProtonClientTypes.DeploymentTargetResourceType?
        /// The target state of the target resource at the time of the deployment.
        public var targetState: ProtonClientTypes.DeploymentState?

        public init(
            arn: Swift.String? = nil,
            completedAt: ClientRuntime.Date? = nil,
            componentName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            initialState: ProtonClientTypes.DeploymentState? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            targetArn: Swift.String? = nil,
            targetResourceCreatedAt: ClientRuntime.Date? = nil,
            targetResourceType: ProtonClientTypes.DeploymentTargetResourceType? = nil,
            targetState: ProtonClientTypes.DeploymentState? = nil
        )
        {
            self.arn = arn
            self.completedAt = completedAt
            self.componentName = componentName
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.id = id
            self.initialState = initialState
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.targetArn = targetArn
            self.targetResourceCreatedAt = targetResourceCreatedAt
            self.targetResourceType = targetResourceType
            self.targetState = targetState
        }
    }

}

extension ProtonClientTypes.DeploymentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
        case environment
        case sdkUnknown
        case serviceinstance = "serviceInstance"
        case servicepipeline = "servicePipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .component(component):
                try container.encode(component, forKey: .component)
            case let .environment(environment):
                try container.encode(environment, forKey: .environment)
            case let .serviceinstance(serviceinstance):
                try container.encode(serviceinstance, forKey: .serviceinstance)
            case let .servicepipeline(servicepipeline):
                try container.encode(servicepipeline, forKey: .servicepipeline)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let serviceinstanceDecoded = try values.decodeIfPresent(ProtonClientTypes.ServiceInstanceState.self, forKey: .serviceinstance)
        if let serviceinstance = serviceinstanceDecoded {
            self = .serviceinstance(serviceinstance)
            return
        }
        let environmentDecoded = try values.decodeIfPresent(ProtonClientTypes.EnvironmentState.self, forKey: .environment)
        if let environment = environmentDecoded {
            self = .environment(environment)
            return
        }
        let servicepipelineDecoded = try values.decodeIfPresent(ProtonClientTypes.ServicePipelineState.self, forKey: .servicepipeline)
        if let servicepipeline = servicepipelineDecoded {
            self = .servicepipeline(servicepipeline)
            return
        }
        let componentDecoded = try values.decodeIfPresent(ProtonClientTypes.ComponentState.self, forKey: .component)
        if let component = componentDecoded {
            self = .component(component)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ProtonClientTypes {
    /// The detailed data about the current state of the deployment.
    public enum DeploymentState: Swift.Equatable {
        /// The state of the service instance associated with the deployment.
        case serviceinstance(ProtonClientTypes.ServiceInstanceState)
        /// The state of the environment associated with the deployment.
        case environment(ProtonClientTypes.EnvironmentState)
        /// The state of the service pipeline associated with the deployment.
        case servicepipeline(ProtonClientTypes.ServicePipelineState)
        /// The state of the component associated with the deployment.
        case component(ProtonClientTypes.ComponentState)
        case sdkUnknown(Swift.String)
    }

}

extension ProtonClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case deleteComplete
        case deleteFailed
        case deleteInProgress
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .cancelled,
                .cancelling,
                .deleteComplete,
                .deleteFailed,
                .deleteInProgress,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.DeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case completedAt
        case componentName
        case createdAt
        case deploymentStatus
        case environmentName
        case id
        case lastAttemptedDeploymentId
        case lastModifiedAt
        case lastSucceededDeploymentId
        case serviceInstanceName
        case serviceName
        case targetArn
        case targetResourceCreatedAt
        case targetResourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .epochSeconds, forKey: .completedAt)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let targetResourceCreatedAt = self.targetResourceCreatedAt {
            try encodeContainer.encodeTimestamp(targetResourceCreatedAt, format: .epochSeconds, forKey: .targetResourceCreatedAt)
        }
        if let targetResourceType = self.targetResourceType {
            try encodeContainer.encode(targetResourceType.rawValue, forKey: .targetResourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let targetResourceCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .targetResourceCreatedAt)
        targetResourceCreatedAt = targetResourceCreatedAtDecoded
        let targetResourceTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentTargetResourceType.self, forKey: .targetResourceType)
        targetResourceType = targetResourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
    }
}

extension ProtonClientTypes {
    /// Summary data of the deployment.
    public struct DeploymentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the deployment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the deployment was completed.
        public var completedAt: ClientRuntime.Date?
        /// The name of the component associated with the deployment.
        public var componentName: Swift.String?
        /// The date and time the deployment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The current status of the deployment.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// The name of the environment associated with the deployment.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the deployment.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the last attempted deployment.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The date and time the deployment was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the last successful deployment.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the service instance associated with the deployment.
        public var serviceInstanceName: Swift.String?
        /// The name of the service associated with the deployment.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the target of the deployment.
        /// This member is required.
        public var targetArn: Swift.String?
        /// The date and time the target resource was created.
        /// This member is required.
        public var targetResourceCreatedAt: ClientRuntime.Date?
        /// The resource type of the deployment target. It can be an environment, service, service instance, or component.
        /// This member is required.
        public var targetResourceType: ProtonClientTypes.DeploymentTargetResourceType?

        public init(
            arn: Swift.String? = nil,
            completedAt: ClientRuntime.Date? = nil,
            componentName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            targetArn: Swift.String? = nil,
            targetResourceCreatedAt: ClientRuntime.Date? = nil,
            targetResourceType: ProtonClientTypes.DeploymentTargetResourceType? = nil
        )
        {
            self.arn = arn
            self.completedAt = completedAt
            self.componentName = componentName
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.environmentName = environmentName
            self.id = id
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastModifiedAt = lastModifiedAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
            self.targetArn = targetArn
            self.targetResourceCreatedAt = targetResourceCreatedAt
            self.targetResourceType = targetResourceType
        }
    }

}

extension ProtonClientTypes {
    public enum DeploymentTargetResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case component
        case environment
        case serviceInstance
        case servicePipeline
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentTargetResourceType] {
            return [
                .component,
                .environment,
                .serviceInstance,
                .servicePipeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .component: return "COMPONENT"
            case .environment: return "ENVIRONMENT"
            case .serviceInstance: return "SERVICE_INSTANCE"
            case .servicePipeline: return "SERVICE_PIPELINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentTargetResourceType(rawValue: rawValue) ?? DeploymentTargetResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum DeploymentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case currentVersion
        case majorVersion
        case minorVersion
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentUpdateType] {
            return [
                .currentVersion,
                .majorVersion,
                .minorVersion,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .currentVersion: return "CURRENT_VERSION"
            case .majorVersion: return "MAJOR_VERSION"
            case .minorVersion: return "MINOR_VERSION"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentUpdateType(rawValue: rawValue) ?? DeploymentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case codebuildRoleArn
        case componentRoleArn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case description
        case environmentAccountConnectionId
        case environmentAccountId
        case lastAttemptedDeploymentId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastSucceededDeploymentId
        case name
        case protonServiceRoleArn
        case provisioning
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = self.environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let environmentAccountId = self.environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = self.protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioning = self.provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let provisioningRepository = self.provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranch.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(arn: \(Swift.String(describing: arn)), codebuildRoleArn: \(Swift.String(describing: codebuildRoleArn)), componentRoleArn: \(Swift.String(describing: componentRoleArn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioning: \(Swift.String(describing: provisioning)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), deploymentStatusMessage: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton environment resource. An Proton environment is a set of resources shared across Proton services.
    public struct Environment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf.
        public var codebuildRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
        public var componentRoleArn: Swift.String?
        /// The time when the environment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The environment deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// An environment deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The ID of the environment account connection that's used to provision infrastructure resources in an environment account.
        public var environmentAccountConnectionId: Swift.String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public var environmentAccountId: Swift.String?
        /// The ID of the last attempted deployment of this environment.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The time when a deployment of the environment was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the environment was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this environment.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public var protonServiceRoleArn: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see [CreateRepository](https://docs.aws.amazon.com/proton/latest/APIReference/API_CreateRepository.html).
        public var provisioningRepository: ProtonClientTypes.RepositoryBranch?
        /// The environment spec.
        public var spec: Swift.String?
        /// The major version of the environment template.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the environment template.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            codebuildRoleArn: Swift.String? = nil,
            componentRoleArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentAccountConnectionId: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            protonServiceRoleArn: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            provisioningRepository: ProtonClientTypes.RepositoryBranch? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.provisioningRepository = provisioningRepository
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentAccountConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case codebuildRoleArn
        case componentRoleArn
        case environmentAccountId
        case environmentName
        case id
        case lastModifiedAt
        case managementAccountId
        case requestedAt
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let environmentAccountId = self.environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let managementAccountId = self.managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let requestedAt = self.requestedAt {
            try encodeContainer.encodeTimestamp(requestedAt, format: .epochSeconds, forKey: .requestedAt)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let requestedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedAt)
        requestedAt = requestedAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
    }
}

extension ProtonClientTypes {
    /// Detailed data of an Proton environment account connection resource.
    public struct EnvironmentAccountConnection: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
        public var codebuildRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
        public var componentRoleArn: Swift.String?
        /// The environment account that's connected to the environment account connection.
        /// This member is required.
        public var environmentAccountId: Swift.String?
        /// The name of the environment that's associated with the environment account connection.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the environment account connection.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the environment account connection was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the management account that's connected to the environment account connection.
        /// This member is required.
        public var managementAccountId: Swift.String?
        /// The time when the environment account connection request was made.
        /// This member is required.
        public var requestedAt: ClientRuntime.Date?
        /// The IAM service role that's associated with the environment account connection.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the environment account connection.
        /// This member is required.
        public var status: ProtonClientTypes.EnvironmentAccountConnectionStatus?

        public init(
            arn: Swift.String? = nil,
            codebuildRoleArn: Swift.String? = nil,
            componentRoleArn: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            managementAccountId: Swift.String? = nil,
            requestedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: ProtonClientTypes.EnvironmentAccountConnectionStatus? = nil
        )
        {
            self.arn = arn
            self.codebuildRoleArn = codebuildRoleArn
            self.componentRoleArn = componentRoleArn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension ProtonClientTypes {
    public enum EnvironmentAccountConnectionRequesterAccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case environmentAccount
        case managementAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentAccountConnectionRequesterAccountType] {
            return [
                .environmentAccount,
                .managementAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .environmentAccount: return "ENVIRONMENT_ACCOUNT"
            case .managementAccount: return "MANAGEMENT_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentAccountConnectionRequesterAccountType(rawValue: rawValue) ?? EnvironmentAccountConnectionRequesterAccountType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum EnvironmentAccountConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentAccountConnectionStatus] {
            return [
                .connected,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentAccountConnectionStatus(rawValue: rawValue) ?? EnvironmentAccountConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.EnvironmentAccountConnectionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentRoleArn
        case environmentAccountId
        case environmentName
        case id
        case lastModifiedAt
        case managementAccountId
        case requestedAt
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let environmentAccountId = self.environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let managementAccountId = self.managementAccountId {
            try encodeContainer.encode(managementAccountId, forKey: .managementAccountId)
        }
        if let requestedAt = self.requestedAt {
            try encodeContainer.encodeTimestamp(requestedAt, format: .epochSeconds, forKey: .requestedAt)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managementAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementAccountId)
        managementAccountId = managementAccountIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let requestedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedAt)
        requestedAt = requestedAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
    }
}

extension ProtonClientTypes {
    /// Summary data of an Proton environment account connection resource.
    public struct EnvironmentAccountConnectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment account connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
        public var componentRoleArn: Swift.String?
        /// The ID of the environment account that's connected to the environment account connection.
        /// This member is required.
        public var environmentAccountId: Swift.String?
        /// The name of the environment that's associated with the environment account connection.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the environment account connection.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the environment account connection was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The ID of the management account that's connected to the environment account connection.
        /// This member is required.
        public var managementAccountId: Swift.String?
        /// The time when the environment account connection request was made.
        /// This member is required.
        public var requestedAt: ClientRuntime.Date?
        /// The IAM service role that's associated with the environment account connection.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the environment account connection.
        /// This member is required.
        public var status: ProtonClientTypes.EnvironmentAccountConnectionStatus?

        public init(
            arn: Swift.String? = nil,
            componentRoleArn: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            managementAccountId: Swift.String? = nil,
            requestedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: ProtonClientTypes.EnvironmentAccountConnectionStatus? = nil
        )
        {
            self.arn = arn
            self.componentRoleArn = componentRoleArn
            self.environmentAccountId = environmentAccountId
            self.environmentName = environmentName
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.managementAccountId = managementAccountId
            self.requestedAt = requestedAt
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension ProtonClientTypes.EnvironmentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
    }
}

extension ProtonClientTypes.EnvironmentState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentState(templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The detailed data about the current state of the environment.
    public struct EnvironmentState: Swift.Equatable {
        /// The environment spec that was used to create the environment.
        public var spec: Swift.String?
        /// The major version of the environment template that was used to create the environment.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the environment template that was used to create the environment.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the environment template that was used to create the environment.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentRoleArn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case description
        case environmentAccountConnectionId
        case environmentAccountId
        case lastAttemptedDeploymentId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastSucceededDeploymentId
        case name
        case protonServiceRoleArn
        case provisioning
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = self.environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let environmentAccountId = self.environmentAccountId {
            try encodeContainer.encode(environmentAccountId, forKey: .environmentAccountId)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = self.protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioning = self.provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let environmentAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountId)
        environmentAccountId = environmentAccountIdDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(arn: \(Swift.String(describing: arn)), componentRoleArn: \(Swift.String(describing: componentRoleArn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), environmentAccountId: \(Swift.String(describing: environmentAccountId)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioning: \(Swift.String(describing: provisioning)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), deploymentStatusMessage: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton environment resource. An Proton environment is a set of resources shared across Proton services.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
        public var componentRoleArn: Swift.String?
        /// The time when the environment was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The environment deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// An environment deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The ID of the environment account connection that the environment is associated with.
        public var environmentAccountConnectionId: Swift.String?
        /// The ID of the environment account that the environment infrastructure resources are provisioned in.
        public var environmentAccountId: Swift.String?
        /// The ID of the last attempted deployment of this environment.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The time when a deployment of the environment was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the environment was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this environment.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the environment.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make calls to other services on your behalf.
        public var protonServiceRoleArn: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The major version of the environment template.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the environment template.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            componentRoleArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentAccountConnectionId: Swift.String? = nil,
            environmentAccountId: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            protonServiceRoleArn: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentRoleArn = componentRoleArn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
            self.environmentAccountConnectionId = environmentAccountConnectionId
            self.environmentAccountId = environmentAccountId
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.protonServiceRoleArn = protonServiceRoleArn
            self.provisioning = provisioning
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case encryptionKey
        case lastModifiedAt
        case name
        case provisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = self.provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let recommendedVersion = self.recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplate(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The environment template data.
    public struct EnvironmentTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the environment template.
        public var description: Swift.String?
        /// The name of the environment template as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The customer provided encryption key for the environment template.
        public var encryptionKey: Swift.String?
        /// The time when the environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the environment template.
        /// This member is required.
        public var name: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The ID of the recommended version of the environment template.
        public var recommendedVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ProtonClientTypes {
    /// A search filter for environment templates.
    public struct EnvironmentTemplateFilter: Swift.Equatable {
        /// Include majorVersion to filter search for a major version.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// Include templateName to filter search for a template name.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            majorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.majorVersion = majorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case lastModifiedAt
        case name
        case provisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioning = self.provisioning {
            try encodeContainer.encode(provisioning.rawValue, forKey: .provisioning)
        }
        if let recommendedVersion = self.recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let provisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .provisioning)
        provisioning = provisioningDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), provisioning: \(Swift.String(describing: provisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The environment template data.
    public struct EnvironmentTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the environment template.
        public var description: Swift.String?
        /// The name of the environment template as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The time when the environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the environment template.
        /// This member is required.
        public var name: Swift.String?
        /// When included, indicates that the environment template is for customer provisioned and managed infrastructure.
        public var provisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the environment template.
        public var recommendedVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.provisioning = provisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case schema
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = self.recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateVersion(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The environment template version data.
    public struct EnvironmentTemplateVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of an environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the minor version of an environment template.
        public var description: Swift.String?
        /// The time when the version of an environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of an environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of an environment template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the environment template.
        public var recommendedMinorVersion: Swift.String?
        /// The schema of the version of an environment template.
        public var schema: Swift.String?
        /// The status of the version of an environment template.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// The status message of the version of an environment template.
        public var statusMessage: Swift.String?
        /// The name of the version of an environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            schema: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.EnvironmentTemplateVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = self.recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension ProtonClientTypes.EnvironmentTemplateVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentTemplateVersionSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// A summary of the version of an environment template detail data.
    public struct EnvironmentTemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of an environment template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of an environment template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of an environment template.
        public var description: Swift.String?
        /// The time when the version of an environment template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of an environment template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The version of an environment template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the environment template.
        public var recommendedMinorVersion: Swift.String?
        /// The status of the version of an environment template.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// The status message of the version of an environment template.
        public var statusMessage: Swift.String?
        /// The name of the environment template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension GetAccountSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct GetAccountSettingsOutput: Swift.Equatable {
    /// The Proton pipeline service role detail data that's returned by Proton.
    public var accountSettings: ProtonClientTypes.AccountSettings?

    public init(
        accountSettings: ProtonClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputBody: Swift.Equatable {
    let accountSettings: ProtonClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

enum GetAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The name of the component that you want to get the detailed data for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetComponentInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct GetComponentOutput: Swift.Equatable {
    /// The detailed data of the requested component.
    public var component: ProtonClientTypes.Component?

    public init(
        component: ProtonClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct GetComponentOutputBody: Swift.Equatable {
    let component: ProtonClientTypes.Component?
}

extension GetComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum GetComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case environmentName
        case id
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The name of a component that you want to get the detailed data for.
    public var componentName: Swift.String?
    /// The name of a environment that you want to get the detailed data for.
    public var environmentName: Swift.String?
    /// The ID of the deployment that you want to get the detailed data for.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the service instance associated with the given deployment ID. serviceName must be specified to identify the service instance.
    public var serviceInstanceName: Swift.String?
    /// The name of the service associated with the given deployment ID.
    public var serviceName: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.environmentName = environmentName
        self.id = id
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
    let id: Swift.String?
    let environmentName: Swift.String?
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let componentName: Swift.String?
}

extension GetDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case environmentName
        case id
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployment = output.deployment
        } else {
            self.deployment = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// The detailed data of the requested deployment.
    public var deployment: ProtonClientTypes.Deployment?

    public init(
        deployment: ProtonClientTypes.Deployment? = nil
    )
    {
        self.deployment = deployment
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let deployment: ProtonClientTypes.Deployment?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Deployment.self, forKey: .deployment)
        deployment = deploymentDecoded
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection that you want to get the detailed data for.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct GetEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The detailed data of the requested environment account connection.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct GetEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension GetEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum GetEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The name of the environment that you want to get the detailed data for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The detailed data of the requested environment.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init(
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let environment: ProtonClientTypes.Environment?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetEnvironmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEnvironmentTemplateInput: Swift.Equatable {
    /// The name of the environment template that you want to get the detailed data for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetEnvironmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct GetEnvironmentTemplateOutput: Swift.Equatable {
    /// The detailed data of the requested environment template.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init(
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct GetEnvironmentTemplateOutputBody: Swift.Equatable {
    let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension GetEnvironmentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

enum GetEnvironmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension GetEnvironmentTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEnvironmentTemplateVersionInput: Swift.Equatable {
    /// To get environment template major version detail data, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To get environment template minor version detail data, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the environment template a version of which you want to get detailed data for.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct GetEnvironmentTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
}

extension GetEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension GetEnvironmentTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct GetEnvironmentTemplateVersionOutput: Swift.Equatable {
    /// The detailed data of the requested environment template version.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init(
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct GetEnvironmentTemplateVersionOutputBody: Swift.Equatable {
    let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension GetEnvironmentTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

enum GetEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }
}

extension GetRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRepositoryInput: Swift.Equatable {
    /// The repository name, for example myrepos/myrepo.
    /// This member is required.
    public var name: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var provider: ProtonClientTypes.RepositoryProvider?

    public init(
        name: Swift.String? = nil,
        provider: ProtonClientTypes.RepositoryProvider? = nil
    )
    {
        self.name = name
        self.provider = provider
    }
}

struct GetRepositoryInputBody: Swift.Equatable {
    let provider: ProtonClientTypes.RepositoryProvider?
    let name: Swift.String?
}

extension GetRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case provider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct GetRepositoryOutput: Swift.Equatable {
    /// The repository link's detail data that's returned by Proton.
    /// This member is required.
    public var repository: ProtonClientTypes.Repository?

    public init(
        repository: ProtonClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct GetRepositoryOutputBody: Swift.Equatable {
    let repository: ProtonClientTypes.Repository?
}

extension GetRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum GetRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositorySyncStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let syncType = self.syncType {
            try encodeContainer.encode(syncType.rawValue, forKey: .syncType)
        }
    }
}

extension GetRepositorySyncStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRepositorySyncStatusInput: Swift.Equatable {
    /// The repository branch.
    /// This member is required.
    public var branch: Swift.String?
    /// The repository name.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The repository sync type.
    /// This member is required.
    public var syncType: ProtonClientTypes.SyncType?

    public init(
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        syncType: ProtonClientTypes.SyncType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.syncType = syncType
    }
}

struct GetRepositorySyncStatusInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let branch: Swift.String?
    let syncType: ProtonClientTypes.SyncType?
}

extension GetRepositorySyncStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SyncType.self, forKey: .syncType)
        syncType = syncTypeDecoded
    }
}

extension GetRepositorySyncStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositorySyncStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.latestSync = output.latestSync
        } else {
            self.latestSync = nil
        }
    }
}

public struct GetRepositorySyncStatusOutput: Swift.Equatable {
    /// The repository sync status detail data that's returned by Proton.
    public var latestSync: ProtonClientTypes.RepositorySyncAttempt?

    public init(
        latestSync: ProtonClientTypes.RepositorySyncAttempt? = nil
    )
    {
        self.latestSync = latestSync
    }
}

struct GetRepositorySyncStatusOutputBody: Swift.Equatable {
    let latestSync: ProtonClientTypes.RepositorySyncAttempt?
}

extension GetRepositorySyncStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestSync
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositorySyncAttempt.self, forKey: .latestSync)
        latestSync = latestSyncDecoded
    }
}

enum GetRepositorySyncStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcesSummaryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetResourcesSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourcesSummaryInput: Swift.Equatable {

    public init() { }
}

struct GetResourcesSummaryInputBody: Swift.Equatable {
}

extension GetResourcesSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcesSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcesSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.counts = output.counts
        } else {
            self.counts = nil
        }
    }
}

public struct GetResourcesSummaryOutput: Swift.Equatable {
    /// Summary counts of each Proton resource type.
    /// This member is required.
    public var counts: ProtonClientTypes.CountsSummary?

    public init(
        counts: ProtonClientTypes.CountsSummary? = nil
    )
    {
        self.counts = counts
    }
}

struct GetResourcesSummaryOutputBody: Swift.Equatable {
    let counts: ProtonClientTypes.CountsSummary?
}

extension GetResourcesSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case counts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.CountsSummary.self, forKey: .counts)
        counts = countsDecoded
    }
}

enum GetResourcesSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The name of the service that you want to get the detailed data for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetServiceInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetServiceInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension GetServiceInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceInstanceInput: Swift.Equatable {
    /// The name of a service instance that you want to get the detailed data for.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service that you want the service instance input for.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.name = name
        self.serviceName = serviceName
    }
}

struct GetServiceInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let serviceName: Swift.String?
}

extension GetServiceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension GetServiceInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct GetServiceInstanceOutput: Swift.Equatable {
    /// The detailed data of the requested service instance.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init(
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct GetServiceInstanceOutputBody: Swift.Equatable {
    let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension GetServiceInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

enum GetServiceInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceInstanceSyncStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension GetServiceInstanceSyncStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceInstanceSyncStatusInput: Swift.Equatable {
    /// The name of the service instance that you want the sync status input for.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that the service instance belongs to.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct GetServiceInstanceSyncStatusInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
}

extension GetServiceInstanceSyncStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
    }
}

extension GetServiceInstanceSyncStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceInstanceSyncStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.desiredState = output.desiredState
            self.latestSuccessfulSync = output.latestSuccessfulSync
            self.latestSync = output.latestSync
        } else {
            self.desiredState = nil
            self.latestSuccessfulSync = nil
            self.latestSync = nil
        }
    }
}

public struct GetServiceInstanceSyncStatusOutput: Swift.Equatable {
    /// The service instance sync desired state that's returned by Proton
    public var desiredState: ProtonClientTypes.Revision?
    /// The detailed data of the latest successful sync with the service instance.
    public var latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    /// The detailed data of the latest sync with the service instance.
    public var latestSync: ProtonClientTypes.ResourceSyncAttempt?

    public init(
        desiredState: ProtonClientTypes.Revision? = nil,
        latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt? = nil,
        latestSync: ProtonClientTypes.ResourceSyncAttempt? = nil
    )
    {
        self.desiredState = desiredState
        self.latestSuccessfulSync = latestSuccessfulSync
        self.latestSync = latestSync
    }
}

struct GetServiceInstanceSyncStatusOutputBody: Swift.Equatable {
    let latestSync: ProtonClientTypes.ResourceSyncAttempt?
    let latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    let desiredState: ProtonClientTypes.Revision?
}

extension GetServiceInstanceSyncStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case latestSuccessfulSync
        case latestSync
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSync)
        latestSync = latestSyncDecoded
        let latestSuccessfulSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSuccessfulSync)
        latestSuccessfulSync = latestSuccessfulSyncDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

enum GetServiceInstanceSyncStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutput: Swift.Equatable {
    /// The detailed data of the requested service.
    public var service: ProtonClientTypes.Service?

    public init(
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputBody: Swift.Equatable {
    let service: ProtonClientTypes.Service?
}

extension GetServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

enum GetServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceSyncBlockerSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension GetServiceSyncBlockerSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceSyncBlockerSummaryInput: Swift.Equatable {
    /// The name of the service instance that you want to get the service sync blocker summary for. If given bothe the instance name and the service name, only the instance is blocked.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that you want to get the service sync blocker summary for. If given only the service name, all instances are blocked.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct GetServiceSyncBlockerSummaryInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
}

extension GetServiceSyncBlockerSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
    }
}

extension GetServiceSyncBlockerSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceSyncBlockerSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSyncBlockerSummary = output.serviceSyncBlockerSummary
        } else {
            self.serviceSyncBlockerSummary = nil
        }
    }
}

public struct GetServiceSyncBlockerSummaryOutput: Swift.Equatable {
    /// The detailed data of the requested service sync blocker summary.
    public var serviceSyncBlockerSummary: ProtonClientTypes.ServiceSyncBlockerSummary?

    public init(
        serviceSyncBlockerSummary: ProtonClientTypes.ServiceSyncBlockerSummary? = nil
    )
    {
        self.serviceSyncBlockerSummary = serviceSyncBlockerSummary
    }
}

struct GetServiceSyncBlockerSummaryOutputBody: Swift.Equatable {
    let serviceSyncBlockerSummary: ProtonClientTypes.ServiceSyncBlockerSummary?
}

extension GetServiceSyncBlockerSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSyncBlockerSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSyncBlockerSummaryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceSyncBlockerSummary.self, forKey: .serviceSyncBlockerSummary)
        serviceSyncBlockerSummary = serviceSyncBlockerSummaryDecoded
    }
}

enum GetServiceSyncBlockerSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension GetServiceSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceSyncConfigInput: Swift.Equatable {
    /// The name of the service that you want to get the service sync configuration for.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        serviceName: Swift.String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

struct GetServiceSyncConfigInputBody: Swift.Equatable {
    let serviceName: Swift.String?
}

extension GetServiceSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension GetServiceSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSyncConfig = output.serviceSyncConfig
        } else {
            self.serviceSyncConfig = nil
        }
    }
}

public struct GetServiceSyncConfigOutput: Swift.Equatable {
    /// The detailed data of the requested service sync configuration.
    public var serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?

    public init(
        serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig? = nil
    )
    {
        self.serviceSyncConfig = serviceSyncConfig
    }
}

struct GetServiceSyncConfigOutputBody: Swift.Equatable {
    let serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?
}

extension GetServiceSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceSyncConfig.self, forKey: .serviceSyncConfig)
        serviceSyncConfig = serviceSyncConfigDecoded
    }
}

enum GetServiceSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetServiceTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceTemplateInput: Swift.Equatable {
    /// The name of the service template that you want to get detailed data for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetServiceTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetServiceTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct GetServiceTemplateOutput: Swift.Equatable {
    /// The detailed data of the requested service template.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init(
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct GetServiceTemplateOutputBody: Swift.Equatable {
    let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension GetServiceTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

enum GetServiceTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension GetServiceTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceTemplateVersionInput: Swift.Equatable {
    /// To get service template major version detail data, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To get service template minor version detail data, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The name of the service template a version of which you want to get detailed data for.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.templateName = templateName
    }
}

struct GetServiceTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
}

extension GetServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case minorVersion
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
    }
}

extension GetServiceTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct GetServiceTemplateVersionOutput: Swift.Equatable {
    /// The detailed data of the requested service template version.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init(
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct GetServiceTemplateVersionOutputBody: Swift.Equatable {
    let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension GetServiceTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

enum GetServiceTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension GetTemplateSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTemplateSyncConfigInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init(
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct GetTemplateSyncConfigInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateType: ProtonClientTypes.TemplateType?
}

extension GetTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
    }
}

extension GetTemplateSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct GetTemplateSyncConfigOutput: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init(
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct GetTemplateSyncConfigOutputBody: Swift.Equatable {
    let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension GetTemplateSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

enum GetTemplateSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateSyncStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
        case templateVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let templateVersion = self.templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }
}

extension GetTemplateSyncStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTemplateSyncStatusInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?
    /// The template major version.
    /// This member is required.
    public var templateVersion: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.templateType = templateType
        self.templateVersion = templateVersion
    }
}

struct GetTemplateSyncStatusInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateType: ProtonClientTypes.TemplateType?
    let templateVersion: Swift.String?
}

extension GetTemplateSyncStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
        case templateType
        case templateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension GetTemplateSyncStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateSyncStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.desiredState = output.desiredState
            self.latestSuccessfulSync = output.latestSuccessfulSync
            self.latestSync = output.latestSync
        } else {
            self.desiredState = nil
            self.latestSuccessfulSync = nil
            self.latestSync = nil
        }
    }
}

public struct GetTemplateSyncStatusOutput: Swift.Equatable {
    /// The template sync desired state that's returned by Proton.
    public var desiredState: ProtonClientTypes.Revision?
    /// The details of the last successful sync that's returned by Proton.
    public var latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    /// The details of the last sync that's returned by Proton.
    public var latestSync: ProtonClientTypes.ResourceSyncAttempt?

    public init(
        desiredState: ProtonClientTypes.Revision? = nil,
        latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt? = nil,
        latestSync: ProtonClientTypes.ResourceSyncAttempt? = nil
    )
    {
        self.desiredState = desiredState
        self.latestSuccessfulSync = latestSuccessfulSync
        self.latestSync = latestSync
    }
}

struct GetTemplateSyncStatusOutputBody: Swift.Equatable {
    let latestSync: ProtonClientTypes.ResourceSyncAttempt?
    let latestSuccessfulSync: ProtonClientTypes.ResourceSyncAttempt?
    let desiredState: ProtonClientTypes.Revision?
}

extension GetTemplateSyncStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState
        case latestSuccessfulSync
        case latestSync
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSync)
        latestSync = latestSyncDecoded
        let latestSuccessfulSyncDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncAttempt.self, forKey: .latestSuccessfulSync)
        latestSuccessfulSync = latestSuccessfulSyncDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

enum GetTemplateSyncStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \"CONTENT_REDACTED\")"}
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed to register with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListComponentOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case deploymentId
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComponentOutputsInput: Swift.Equatable {
    /// The name of the component whose outputs you want.
    /// This member is required.
    public var componentName: Swift.String?
    /// The ID of the deployment whose outputs you want.
    public var deploymentId: Swift.String?
    /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.deploymentId = deploymentId
        self.nextToken = nextToken
    }
}

struct ListComponentOutputsInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let nextToken: Swift.String?
    let deploymentId: Swift.String?
}

extension ListComponentOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case deploymentId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension ListComponentOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListComponentOutputsOutput: Swift.Equatable {
    /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?
    /// An array of component Infrastructure as Code (IaC) outputs.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init(
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListComponentOutputsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let outputs: [ProtonClientTypes.Output]?
}

extension ListComponentOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum ListComponentOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentProvisionedResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentProvisionedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComponentProvisionedResourcesInput: Swift.Equatable {
    /// The name of the component whose provisioned resources you want.
    /// This member is required.
    public var componentName: Swift.String?
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
    public var nextToken: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.nextToken = nextToken
    }
}

struct ListComponentProvisionedResourcesInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let nextToken: Swift.String?
}

extension ListComponentProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentProvisionedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentProvisionedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListComponentProvisionedResourcesOutput: Swift.Equatable {
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
    public var nextToken: Swift.String?
    /// An array of provisioned resources for a component.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListComponentProvisionedResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListComponentProvisionedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

enum ListComponentProvisionedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The name of an environment for result list filtering. Proton returns components associated with the environment or attached to service instances running in it.
    public var environmentName: Swift.String?
    /// The maximum number of components to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next component in the array of components, after the list of components that was previously requested.
    public var nextToken: Swift.String?
    /// The name of a service instance for result list filtering. Proton returns the component attached to the service instance, if any.
    public var serviceInstanceName: Swift.String?
    /// The name of a service for result list filtering. Proton returns components attached to service instances of the service.
    public var serviceName: Swift.String?

    public init(
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let environmentName: Swift.String?
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// An array of components with summary data.
    /// This member is required.
    public var components: [ProtonClientTypes.ComponentSummary]?
    /// A token that indicates the location of the next component in the array of components, after the current requested list of components.
    public var nextToken: Swift.String?

    public init(
        components: [ProtonClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let components: [ProtonClientTypes.ComponentSummary]?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ComponentSummary?].self, forKey: .components)
        var componentsDecoded0:[ProtonClientTypes.ComponentSummary]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ProtonClientTypes.ComponentSummary]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case environmentName
        case maxResults
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The name of a component for result list filtering. Proton returns deployments associated with that component.
    public var componentName: Swift.String?
    /// The name of an environment for result list filtering. Proton returns deployments associated with the environment.
    public var environmentName: Swift.String?
    /// The maximum number of deployments to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next deployment in the array of deployment, after the list of deployment that was previously requested.
    public var nextToken: Swift.String?
    /// The name of a service instance for result list filtering. Proton returns the deployments associated with the service instance.
    public var serviceInstanceName: Swift.String?
    /// The name of a service for result list filtering. Proton returns deployments associated with service instances of the service.
    public var serviceName: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let environmentName: Swift.String?
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let componentName: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case environmentName
        case maxResults
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// An array of deployment with summary data.
    /// This member is required.
    public var deployments: [ProtonClientTypes.DeploymentSummary]?
    /// A token that indicates the location of the next deployment in the array of deployment, after the current requested list of deployment.
    public var nextToken: Swift.String?

    public init(
        deployments: [ProtonClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let deployments: [ProtonClientTypes.DeploymentSummary]?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deploymentsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.DeploymentSummary?].self, forKey: .deployments)
        var deploymentsDecoded0:[ProtonClientTypes.DeploymentSummary]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [ProtonClientTypes.DeploymentSummary]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentAccountConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case requestedBy
        case statuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let requestedBy = self.requestedBy {
            try encodeContainer.encode(requestedBy.rawValue, forKey: .requestedBy)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for environmentaccountconnectionstatus0 in statuses {
                try statusesContainer.encode(environmentaccountconnectionstatus0.rawValue)
            }
        }
    }
}

extension ListEnvironmentAccountConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentAccountConnectionsInput: Swift.Equatable {
    /// The environment name that's associated with each listed environment account connection.
    public var environmentName: Swift.String?
    /// The maximum number of environment account connections to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next environment account connection in the array of environment account connections, after the list of environment account connections that was previously requested.
    public var nextToken: Swift.String?
    /// The type of account making the ListEnvironmentAccountConnections request.
    /// This member is required.
    public var requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType?
    /// The status details for each listed environment account connection.
    public var statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]?

    public init(
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType? = nil,
        statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]? = nil
    )
    {
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestedBy = requestedBy
        self.statuses = statuses
    }
}

struct ListEnvironmentAccountConnectionsInputBody: Swift.Equatable {
    let requestedBy: ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType?
    let environmentName: Swift.String?
    let statuses: [ProtonClientTypes.EnvironmentAccountConnectionStatus]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnvironmentAccountConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case maxResults
        case nextToken
        case requestedBy
        case statuses
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedByDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnectionRequesterAccountType.self, forKey: .requestedBy)
        requestedBy = requestedByDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let statusesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentAccountConnectionStatus?].self, forKey: .statuses)
        var statusesDecoded0:[ProtonClientTypes.EnvironmentAccountConnectionStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [ProtonClientTypes.EnvironmentAccountConnectionStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentAccountConnectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentAccountConnectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnections = output.environmentAccountConnections
            self.nextToken = output.nextToken
        } else {
            self.environmentAccountConnections = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentAccountConnectionsOutput: Swift.Equatable {
    /// An array of environment account connections with details that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]?
    /// A token that indicates the location of the next environment account connection in the array of environment account connections, after the current requested list of environment account connections.
    public var nextToken: Swift.String?

    public init(
        environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentAccountConnections = environmentAccountConnections
        self.nextToken = nextToken
    }
}

struct ListEnvironmentAccountConnectionsOutputBody: Swift.Equatable {
    let environmentAccountConnections: [ProtonClientTypes.EnvironmentAccountConnectionSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentAccountConnectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnections
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentAccountConnectionSummary?].self, forKey: .environmentAccountConnections)
        var environmentAccountConnectionsDecoded0:[ProtonClientTypes.EnvironmentAccountConnectionSummary]? = nil
        if let environmentAccountConnectionsContainer = environmentAccountConnectionsContainer {
            environmentAccountConnectionsDecoded0 = [ProtonClientTypes.EnvironmentAccountConnectionSummary]()
            for structure0 in environmentAccountConnectionsContainer {
                if let structure0 = structure0 {
                    environmentAccountConnectionsDecoded0?.append(structure0)
                }
            }
        }
        environmentAccountConnections = environmentAccountConnectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentAccountConnectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case environmentName
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnvironmentOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentOutputsInput: Swift.Equatable {
    /// The ID of the deployment whose outputs you want.
    public var deploymentId: Swift.String?
    /// The environment name.
    /// This member is required.
    public var environmentName: Swift.String?
    /// A token that indicates the location of the next environment output in the array of environment outputs, after the list of environment outputs that was previously requested.
    public var nextToken: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ListEnvironmentOutputsInputBody: Swift.Equatable {
    let environmentName: Swift.String?
    let nextToken: Swift.String?
    let deploymentId: Swift.String?
}

extension ListEnvironmentOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case environmentName
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension ListEnvironmentOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListEnvironmentOutputsOutput: Swift.Equatable {
    /// A token that indicates the location of the next environment output in the array of environment outputs, after the current requested list of environment outputs.
    public var nextToken: Swift.String?
    /// An array of environment outputs with detail data.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init(
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListEnvironmentOutputsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let outputs: [ProtonClientTypes.Output]?
}

extension ListEnvironmentOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum ListEnvironmentOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentProvisionedResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnvironmentProvisionedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentProvisionedResourcesInput: Swift.Equatable {
    /// The environment name.
    /// This member is required.
    public var environmentName: Swift.String?
    /// A token that indicates the location of the next environment provisioned resource in the array of environment provisioned resources, after the list of environment provisioned resources that was previously requested.
    public var nextToken: Swift.String?

    public init(
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ListEnvironmentProvisionedResourcesInputBody: Swift.Equatable {
    let environmentName: Swift.String?
    let nextToken: Swift.String?
}

extension ListEnvironmentProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentProvisionedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentProvisionedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListEnvironmentProvisionedResourcesOutput: Swift.Equatable {
    /// A token that indicates the location of the next environment provisioned resource in the array of provisioned resources, after the current requested list of environment provisioned resources.
    public var nextToken: Swift.String?
    /// An array of environment provisioned resources.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListEnvironmentProvisionedResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListEnvironmentProvisionedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

enum ListEnvironmentProvisionedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentTemplateVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension ListEnvironmentTemplateVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentTemplateVersionsInput: Swift.Equatable {
    /// To view a list of minor of versions under a major version of an environment template, include major Version. To view a list of major versions of an environment template, exclude major Version.
    public var majorVersion: Swift.String?
    /// The maximum number of major or minor versions of an environment template to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListEnvironmentTemplateVersionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let templateName: Swift.String?
    let majorVersion: Swift.String?
}

extension ListEnvironmentTemplateVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ListEnvironmentTemplateVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentTemplateVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateVersions = output.templateVersions
        } else {
            self.nextToken = nil
            self.templateVersions = nil
        }
    }
}

public struct ListEnvironmentTemplateVersionsOutput: Swift.Equatable {
    /// A token that indicates the location of the next major or minor version in the array of major or minor versions of an environment template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// An array of major or minor versions of an environment template detail data.
    /// This member is required.
    public var templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateVersions = templateVersions
    }
}

struct ListEnvironmentTemplateVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateVersions: [ProtonClientTypes.EnvironmentTemplateVersionSummary]?
}

extension ListEnvironmentTemplateVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateVersionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateVersionSummary?].self, forKey: .templateVersions)
        var templateVersionsDecoded0:[ProtonClientTypes.EnvironmentTemplateVersionSummary]? = nil
        if let templateVersionsContainer = templateVersionsContainer {
            templateVersionsDecoded0 = [ProtonClientTypes.EnvironmentTemplateVersionSummary]()
            for structure0 in templateVersionsContainer {
                if let structure0 = structure0 {
                    templateVersionsDecoded0?.append(structure0)
                }
            }
        }
        templateVersions = templateVersionsDecoded0
    }
}

enum ListEnvironmentTemplateVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnvironmentTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentTemplatesInput: Swift.Equatable {
    /// The maximum number of environment templates to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next environment template in the array of environment templates, after the list of environment templates that was previously requested.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnvironmentTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListEnvironmentTemplatesOutput: Swift.Equatable {
    /// A token that indicates the location of the next environment template in the array of environment templates, after the current requested list of environment templates.
    public var nextToken: Swift.String?
    /// An array of environment templates with detail data.
    /// This member is required.
    public var templates: [ProtonClientTypes.EnvironmentTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [ProtonClientTypes.EnvironmentTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListEnvironmentTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templates: [ProtonClientTypes.EnvironmentTemplateSummary]?
}

extension ListEnvironmentTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ProtonClientTypes.EnvironmentTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ProtonClientTypes.EnvironmentTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
    }
}

enum ListEnvironmentTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplates
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentTemplates = environmentTemplates {
            var environmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentTemplates)
            for environmenttemplatefilter0 in environmentTemplates {
                try environmentTemplatesContainer.encode(environmenttemplatefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// An array of the versions of the environment template.
    public var environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]?
    /// The maximum number of environments to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next environment in the array of environments, after the list of environments that was previously requested.
    public var nextToken: Swift.String?

    public init(
        environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentTemplates = environmentTemplates
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let environmentTemplates: [ProtonClientTypes.EnvironmentTemplateFilter]?
}

extension ListEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplates
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let environmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentTemplateFilter?].self, forKey: .environmentTemplates)
        var environmentTemplatesDecoded0:[ProtonClientTypes.EnvironmentTemplateFilter]? = nil
        if let environmentTemplatesContainer = environmentTemplatesContainer {
            environmentTemplatesDecoded0 = [ProtonClientTypes.EnvironmentTemplateFilter]()
            for structure0 in environmentTemplatesContainer {
                if let structure0 = structure0 {
                    environmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        environmentTemplates = environmentTemplatesDecoded0
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// An array of environment detail data summaries.
    /// This member is required.
    public var environments: [ProtonClientTypes.EnvironmentSummary]?
    /// A token that indicates the location of the next environment in the array of environments, after the current requested list of environments.
    public var nextToken: Swift.String?

    public init(
        environments: [ProtonClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let environments: [ProtonClientTypes.EnvironmentSummary]?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.EnvironmentSummary?].self, forKey: .environments)
        var environmentsDecoded0:[ProtonClientTypes.EnvironmentSummary]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [ProtonClientTypes.EnvironmentSummary]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRepositoriesInput: Swift.Equatable {
    /// The maximum number of repositories to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next repository in the array of repositories, after the list of repositories previously requested.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutput: Swift.Equatable {
    /// A token that indicates the location of the next repository in the array of repositories, after the current requested list of repositories.
    public var nextToken: Swift.String?
    /// An array of repository links.
    /// This member is required.
    public var repositories: [ProtonClientTypes.RepositorySummary]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [ProtonClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let repositories: [ProtonClientTypes.RepositorySummary]?
}

extension ListRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[ProtonClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [ProtonClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
    }
}

enum ListRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositorySyncDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let syncType = self.syncType {
            try encodeContainer.encode(syncType.rawValue, forKey: .syncType)
        }
    }
}

extension ListRepositorySyncDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRepositorySyncDefinitionsInput: Swift.Equatable {
    /// A token that indicates the location of the next repository sync definition in the array of repository sync definitions, after the list of repository sync definitions previously requested.
    public var nextToken: Swift.String?
    /// The repository name.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The sync type. The only supported value is TEMPLATE_SYNC.
    /// This member is required.
    public var syncType: ProtonClientTypes.SyncType?

    public init(
        nextToken: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        syncType: ProtonClientTypes.SyncType? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.syncType = syncType
    }
}

struct ListRepositorySyncDefinitionsInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let syncType: ProtonClientTypes.SyncType?
    let nextToken: Swift.String?
}

extension ListRepositorySyncDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositoryName
        case repositoryProvider
        case syncType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SyncType.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositorySyncDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositorySyncDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncDefinitions = output.syncDefinitions
        } else {
            self.nextToken = nil
            self.syncDefinitions = nil
        }
    }
}

public struct ListRepositorySyncDefinitionsOutput: Swift.Equatable {
    /// A token that indicates the location of the next repository sync definition in the array of repository sync definitions, after the current requested list of repository sync definitions.
    public var nextToken: Swift.String?
    /// An array of repository sync definitions.
    /// This member is required.
    public var syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncDefinitions = syncDefinitions
    }
}

struct ListRepositorySyncDefinitionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let syncDefinitions: [ProtonClientTypes.RepositorySyncDefinition]?
}

extension ListRepositorySyncDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncDefinitions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let syncDefinitionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySyncDefinition?].self, forKey: .syncDefinitions)
        var syncDefinitionsDecoded0:[ProtonClientTypes.RepositorySyncDefinition]? = nil
        if let syncDefinitionsContainer = syncDefinitionsContainer {
            syncDefinitionsDecoded0 = [ProtonClientTypes.RepositorySyncDefinition]()
            for structure0 in syncDefinitionsContainer {
                if let structure0 = structure0 {
                    syncDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        syncDefinitions = syncDefinitionsDecoded0
    }
}

enum ListRepositorySyncDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceInstanceOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListServiceInstanceOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceInstanceOutputsInput: Swift.Equatable {
    /// The ID of the deployment whose outputs you want.
    public var deploymentId: Swift.String?
    /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service instance whose outputs you want.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that serviceInstanceName is associated to.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListServiceInstanceOutputsInputBody: Swift.Equatable {
    let serviceInstanceName: Swift.String?
    let serviceName: Swift.String?
    let nextToken: Swift.String?
    let deploymentId: Swift.String?
}

extension ListServiceInstanceOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension ListServiceInstanceOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceInstanceOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListServiceInstanceOutputsOutput: Swift.Equatable {
    /// A token that indicates the location of the next output in the array of outputs, after the current requested list of outputs.
    public var nextToken: Swift.String?
    /// An array of service instance Infrastructure as Code (IaC) outputs.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init(
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListServiceInstanceOutputsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let outputs: [ProtonClientTypes.Output]?
}

extension ListServiceInstanceOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum ListServiceInstanceOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceInstanceProvisionedResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListServiceInstanceProvisionedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceInstanceProvisionedResourcesInput: Swift.Equatable {
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service instance whose provisioned resources you want.
    /// This member is required.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that serviceInstanceName is associated to.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
    }
}

struct ListServiceInstanceProvisionedResourcesInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let nextToken: Swift.String?
}

extension ListServiceInstanceProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstanceName
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceInstanceProvisionedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceInstanceProvisionedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListServiceInstanceProvisionedResourcesOutput: Swift.Equatable {
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
    public var nextToken: Swift.String?
    /// An array of provisioned resources for a service instance.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListServiceInstanceProvisionedResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListServiceInstanceProvisionedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

enum ListServiceInstanceProvisionedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.ListServiceInstancesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ListServiceInstancesFilterBy.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProtonClientTypes {
    /// A filtering criterion to scope down the result list of the [ListServiceInstances] action.
    public struct ListServiceInstancesFilter: Swift.Equatable {
        /// The name of a filtering criterion.
        public var key: ProtonClientTypes.ListServiceInstancesFilterBy?
        /// A value to filter by. With the date/time keys (*At{Before,After}), the value is a valid [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339.html) string with no UTC offset and with an optional fractional precision (for example, 1985-04-12T23:20:50.52Z).
        public var value: Swift.String?

        public init(
            key: ProtonClientTypes.ListServiceInstancesFilterBy? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ProtonClientTypes {
    public enum ListServiceInstancesFilterBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdAtAfter
        case createdAtBefore
        case deployedTemplateVersionStatus
        case deploymentStatus
        case environmentName
        case lastDeploymentAttemptedAtAfter
        case lastDeploymentAttemptedAtBefore
        case name
        case serviceName
        case templateName
        case sdkUnknown(Swift.String)

        public static var allCases: [ListServiceInstancesFilterBy] {
            return [
                .createdAtAfter,
                .createdAtBefore,
                .deployedTemplateVersionStatus,
                .deploymentStatus,
                .environmentName,
                .lastDeploymentAttemptedAtAfter,
                .lastDeploymentAttemptedAtBefore,
                .name,
                .serviceName,
                .templateName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdAtAfter: return "createdAtAfter"
            case .createdAtBefore: return "createdAtBefore"
            case .deployedTemplateVersionStatus: return "deployedTemplateVersionStatus"
            case .deploymentStatus: return "deploymentStatus"
            case .environmentName: return "environmentName"
            case .lastDeploymentAttemptedAtAfter: return "lastDeploymentAttemptedAtAfter"
            case .lastDeploymentAttemptedAtBefore: return "lastDeploymentAttemptedAtBefore"
            case .name: return "name"
            case .serviceName: return "serviceName"
            case .templateName: return "templateName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListServiceInstancesFilterBy(rawValue: rawValue) ?? ListServiceInstancesFilterBy.sdkUnknown(rawValue)
        }
    }
}

extension ListServiceInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case serviceName
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listserviceinstancesfilter0 in filters {
                try filtersContainer.encode(listserviceinstancesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListServiceInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceInstancesInput: Swift.Equatable {
    /// An array of filtering criteria that scope down the result list. By default, all service instances in the Amazon Web Services account are returned.
    public var filters: [ProtonClientTypes.ListServiceInstancesFilter]?
    /// The maximum number of service instances to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next service in the array of service instances, after the list of service instances that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service that the service instance belongs to.
    public var serviceName: Swift.String?
    /// The field that the result list is sorted by. When you choose to sort by serviceName, service instances within each service are sorted by service instance name. Default: serviceName
    public var sortBy: ProtonClientTypes.ListServiceInstancesSortBy?
    /// Result list sort order. Default: ASCENDING
    public var sortOrder: ProtonClientTypes.SortOrder?

    public init(
        filters: [ProtonClientTypes.ListServiceInstancesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        sortBy: ProtonClientTypes.ListServiceInstancesSortBy? = nil,
        sortOrder: ProtonClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceName = serviceName
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListServiceInstancesInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ProtonClientTypes.ListServiceInstancesFilter]?
    let sortBy: ProtonClientTypes.ListServiceInstancesSortBy?
    let sortOrder: ProtonClientTypes.SortOrder?
}

extension ListServiceInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case serviceName
        case sortBy
        case sortOrder
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ListServiceInstancesFilter?].self, forKey: .filters)
        var filtersDecoded0:[ProtonClientTypes.ListServiceInstancesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ProtonClientTypes.ListServiceInstancesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ListServiceInstancesSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListServiceInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceInstances = output.serviceInstances
        } else {
            self.nextToken = nil
            self.serviceInstances = nil
        }
    }
}

public struct ListServiceInstancesOutput: Swift.Equatable {
    /// A token that indicates the location of the next service instance in the array of service instances, after the current requested list of service instances.
    public var nextToken: Swift.String?
    /// An array of service instances with summary data.
    /// This member is required.
    public var serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceInstances = serviceInstances
    }
}

struct ListServiceInstancesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serviceInstances: [ProtonClientTypes.ServiceInstanceSummary]?
}

extension ListServiceInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceInstances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceInstancesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceInstanceSummary?].self, forKey: .serviceInstances)
        var serviceInstancesDecoded0:[ProtonClientTypes.ServiceInstanceSummary]? = nil
        if let serviceInstancesContainer = serviceInstancesContainer {
            serviceInstancesDecoded0 = [ProtonClientTypes.ServiceInstanceSummary]()
            for structure0 in serviceInstancesContainer {
                if let structure0 = structure0 {
                    serviceInstancesDecoded0?.append(structure0)
                }
            }
        }
        serviceInstances = serviceInstancesDecoded0
    }
}

enum ListServiceInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes {
    public enum ListServiceInstancesSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdAt
        case deploymentStatus
        case environmentName
        case lastDeploymentAttemptedAt
        case name
        case serviceName
        case templateName
        case sdkUnknown(Swift.String)

        public static var allCases: [ListServiceInstancesSortBy] {
            return [
                .createdAt,
                .deploymentStatus,
                .environmentName,
                .lastDeploymentAttemptedAt,
                .name,
                .serviceName,
                .templateName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdAt: return "createdAt"
            case .deploymentStatus: return "deploymentStatus"
            case .environmentName: return "environmentName"
            case .lastDeploymentAttemptedAt: return "lastDeploymentAttemptedAt"
            case .name: return "name"
            case .serviceName: return "serviceName"
            case .templateName: return "templateName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListServiceInstancesSortBy(rawValue: rawValue) ?? ListServiceInstancesSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ListServicePipelineOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case nextToken
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListServicePipelineOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicePipelineOutputsInput: Swift.Equatable {
    /// The ID of the deployment you want the outputs for.
    public var deploymentId: Swift.String?
    /// A token that indicates the location of the next output in the array of outputs, after the list of outputs that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service whose pipeline's outputs you want.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServicePipelineOutputsInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let nextToken: Swift.String?
    let deploymentId: Swift.String?
}

extension ListServicePipelineOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case nextToken
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension ListServicePipelineOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicePipelineOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outputs = output.outputs
        } else {
            self.nextToken = nil
            self.outputs = nil
        }
    }
}

public struct ListServicePipelineOutputsOutput: Swift.Equatable {
    /// A token that indicates the location of the next output in the array of outputs, after the current requested list of outputs.
    public var nextToken: Swift.String?
    /// An array of service pipeline Infrastructure as Code (IaC) outputs.
    /// This member is required.
    public var outputs: [ProtonClientTypes.Output]?

    public init(
        nextToken: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil
    )
    {
        self.nextToken = nextToken
        self.outputs = outputs
    }
}

struct ListServicePipelineOutputsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let outputs: [ProtonClientTypes.Output]?
}

extension ListServicePipelineOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

enum ListServicePipelineOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicePipelineProvisionedResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension ListServicePipelineProvisionedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicePipelineProvisionedResourcesInput: Swift.Equatable {
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the list of provisioned resources that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service whose pipeline's provisioned resources you want.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServicePipelineProvisionedResourcesInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let nextToken: Swift.String?
}

extension ListServicePipelineProvisionedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicePipelineProvisionedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicePipelineProvisionedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedResources = output.provisionedResources
        } else {
            self.nextToken = nil
            self.provisionedResources = nil
        }
    }
}

public struct ListServicePipelineProvisionedResourcesOutput: Swift.Equatable {
    /// A token that indicates the location of the next provisioned resource in the array of provisioned resources, after the current requested list of provisioned resources.
    public var nextToken: Swift.String?
    /// An array of provisioned resources for a service and pipeline.
    /// This member is required.
    public var provisionedResources: [ProtonClientTypes.ProvisionedResource]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedResources: [ProtonClientTypes.ProvisionedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedResources = provisionedResources
    }
}

struct ListServicePipelineProvisionedResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let provisionedResources: [ProtonClientTypes.ProvisionedResource]?
}

extension ListServicePipelineProvisionedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedResourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ProvisionedResource?].self, forKey: .provisionedResources)
        var provisionedResourcesDecoded0:[ProtonClientTypes.ProvisionedResource]? = nil
        if let provisionedResourcesContainer = provisionedResourcesContainer {
            provisionedResourcesDecoded0 = [ProtonClientTypes.ProvisionedResource]()
            for structure0 in provisionedResourcesContainer {
                if let structure0 = structure0 {
                    provisionedResourcesDecoded0?.append(structure0)
                }
            }
        }
        provisionedResources = provisionedResourcesDecoded0
    }
}

enum ListServicePipelineProvisionedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceTemplateVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension ListServiceTemplateVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceTemplateVersionsInput: Swift.Equatable {
    /// To view a list of minor of versions under a major version of a service template, include major Version. To view a list of major versions of a service template, exclude major Version.
    public var majorVersion: Swift.String?
    /// The maximum number of major or minor versions of a service template to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next major or minor version in the array of major or minor versions of a service template, after the list of major or minor versions that was previously requested.
    public var nextToken: Swift.String?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        majorVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.majorVersion = majorVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListServiceTemplateVersionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let templateName: Swift.String?
    let majorVersion: Swift.String?
}

extension ListServiceTemplateVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case majorVersion
        case maxResults
        case nextToken
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
    }
}

extension ListServiceTemplateVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceTemplateVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateVersions = output.templateVersions
        } else {
            self.nextToken = nil
            self.templateVersions = nil
        }
    }
}

public struct ListServiceTemplateVersionsOutput: Swift.Equatable {
    /// A token that indicates the location of the next major or minor version in the array of major or minor versions of a service template, after the current requested list of service major or minor versions.
    public var nextToken: Swift.String?
    /// An array of major or minor versions of a service template with detail data.
    /// This member is required.
    public var templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateVersions = templateVersions
    }
}

struct ListServiceTemplateVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templateVersions: [ProtonClientTypes.ServiceTemplateVersionSummary]?
}

extension ListServiceTemplateVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templateVersionsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateVersionSummary?].self, forKey: .templateVersions)
        var templateVersionsDecoded0:[ProtonClientTypes.ServiceTemplateVersionSummary]? = nil
        if let templateVersionsContainer = templateVersionsContainer {
            templateVersionsDecoded0 = [ProtonClientTypes.ServiceTemplateVersionSummary]()
            for structure0 in templateVersionsContainer {
                if let structure0 = structure0 {
                    templateVersionsDecoded0?.append(structure0)
                }
            }
        }
        templateVersions = templateVersionsDecoded0
    }
}

enum ListServiceTemplateVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServiceTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceTemplatesInput: Swift.Equatable {
    /// The maximum number of service templates to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next service template in the array of service templates, after the list of service templates previously requested.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServiceTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListServiceTemplatesOutput: Swift.Equatable {
    /// A token that indicates the location of the next service template in the array of service templates, after the current requested list of service templates.
    public var nextToken: Swift.String?
    /// An array of service templates with detail data.
    /// This member is required.
    public var templates: [ProtonClientTypes.ServiceTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [ProtonClientTypes.ServiceTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListServiceTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let templates: [ProtonClientTypes.ServiceTemplateSummary]?
}

extension ListServiceTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let templatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ProtonClientTypes.ServiceTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ProtonClientTypes.ServiceTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
    }
}

enum ListServiceTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of services to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next service in the array of services, after the list of services that was previously requested.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutput: Swift.Equatable {
    /// A token that indicates the location of the next service in the array of services, after the current requested list of services.
    public var nextToken: Swift.String?
    /// An array of services with summaries of detail data.
    /// This member is required.
    public var services: [ProtonClientTypes.ServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ProtonClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let services: [ProtonClientTypes.ServiceSummary]?
}

extension ListServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case services
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ProtonClientTypes.ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ProtonClientTypes.ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

enum ListServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags to list.
    public var maxResults: Swift.Int?
    /// A token that indicates the location of the next resource tag in the array of resource tags, after the list of resource tags that was previously requested.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for the listed tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A token that indicates the location of the next resource tag in the array of resource tags, after the current requested list of resource tags.
    public var nextToken: Swift.String?
    /// A list of resource tags with detail data.
    /// This member is required.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ProtonClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotifyResourceDeploymentStatusChangeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyResourceDeploymentStatusChangeInput(deploymentId: \(Swift.String(describing: deploymentId)), outputs: \(Swift.String(describing: outputs)), resourceArn: \(Swift.String(describing: resourceArn)), status: \(Swift.String(describing: status)), statusMessage: \"CONTENT_REDACTED\")"}
}

extension NotifyResourceDeploymentStatusChangeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case outputs
        case resourceArn
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }
}

extension NotifyResourceDeploymentStatusChangeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyResourceDeploymentStatusChangeInput: Swift.Equatable {
    /// The deployment ID for your provisioned resource.
    public var deploymentId: Swift.String?
    /// The provisioned resource state change detail data that's returned by Proton.
    public var outputs: [ProtonClientTypes.Output]?
    /// The provisioned resource Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The status of your provisioned resource.
    public var status: ProtonClientTypes.ResourceDeploymentStatus?
    /// The deployment status message for your provisioned resource.
    public var statusMessage: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        outputs: [ProtonClientTypes.Output]? = nil,
        resourceArn: Swift.String? = nil,
        status: ProtonClientTypes.ResourceDeploymentStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.outputs = outputs
        self.resourceArn = resourceArn
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct NotifyResourceDeploymentStatusChangeInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let status: ProtonClientTypes.ResourceDeploymentStatus?
    let outputs: [ProtonClientTypes.Output]?
    let deploymentId: Swift.String?
    let statusMessage: Swift.String?
}

extension NotifyResourceDeploymentStatusChangeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case outputs
        case resourceArn
        case status
        case statusMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceDeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[ProtonClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ProtonClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension NotifyResourceDeploymentStatusChangeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyResourceDeploymentStatusChangeOutput: Swift.Equatable {

    public init() { }
}

enum NotifyResourceDeploymentStatusChangeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case valueString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let valueString = self.valueString {
            try encodeContainer.encode(valueString, forKey: .valueString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueString)
        valueString = valueStringDecoded
    }
}

extension ProtonClientTypes.Output: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension ProtonClientTypes {
    /// An infrastructure as code defined resource output.
    public struct Output: Swift.Equatable {
        /// The output key.
        public var key: Swift.String?
        /// The output value.
        public var valueString: Swift.String?

        public init(
            key: Swift.String? = nil,
            valueString: Swift.String? = nil
        )
        {
            self.key = key
            self.valueString = valueString
        }
    }

}

extension ProtonClientTypes.ProvisionedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case name
        case provisioningEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningEngine = self.provisioningEngine {
            try encodeContainer.encode(provisioningEngine.rawValue, forKey: .provisioningEngine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let provisioningEngineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ProvisionedResourceEngine.self, forKey: .provisioningEngine)
        provisioningEngine = provisioningEngineDecoded
    }
}

extension ProtonClientTypes {
    /// Detail data for a provisioned resource.
    public struct ProvisionedResource: Swift.Equatable {
        /// The provisioned resource identifier.
        public var identifier: Swift.String?
        /// The provisioned resource name.
        public var name: Swift.String?
        /// The resource provisioning engine. At this time, CLOUDFORMATION can be used for Amazon Web Services-managed provisioning, and TERRAFORM can be used for self-managed provisioning. For more information, see [Self-managed provisioning](https://docs.aws.amazon.com/proton/latest/userguide/ag-works-prov-methods.html#ag-works-prov-methods-self) in the Proton User Guide.
        public var provisioningEngine: ProtonClientTypes.ProvisionedResourceEngine?

        public init(
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningEngine: ProtonClientTypes.ProvisionedResourceEngine? = nil
        )
        {
            self.identifier = identifier
            self.name = name
            self.provisioningEngine = provisioningEngine
        }
    }

}

extension ProtonClientTypes {
    /// List of provisioning engines
    public enum ProvisionedResourceEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case terraform
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedResourceEngine] {
            return [
                .cloudformation,
                .terraform,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case .terraform: return "TERRAFORM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedResourceEngine(rawValue: rawValue) ?? ProvisionedResourceEngine.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes {
    public enum Provisioning: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [Provisioning] {
            return [
                .customerManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Provisioning(rawValue: rawValue) ?? Provisioning.sdkUnknown(rawValue)
        }
    }
}

extension RejectEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension RejectEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The ID of the environment account connection to reject.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RejectEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension RejectEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension RejectEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct RejectEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The environment connection account detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct RejectEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension RejectEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum RejectEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.Repository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectionArn
        case encryptionKey
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ProtonClientTypes {
    /// Detailed data of a linked repositorya repository that has been registered with Proton.
    public struct Repository: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the linked repository.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of your AWS CodeStar connection that connects Proton to your repository provider account.
        /// This member is required.
        public var connectionArn: Swift.String?
        /// Your customer Amazon Web Services KMS encryption key.
        public var encryptionKey: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init(
            arn: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.connectionArn = connectionArn
            self.encryptionKey = encryptionKey
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositoryBranch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case branch
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes {
    /// Detail data for a linked repository branch.
    public struct RepositoryBranch: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the linked repository.
        /// This member is required.
        public var arn: Swift.String?
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init(
            arn: Swift.String? = nil,
            branch: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.branch = branch
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositoryBranchInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes {
    /// Detail input data for a linked repository branch.
    public struct RepositoryBranchInput: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init(
            branch: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.branch = branch
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes {
    public enum RepositoryProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bitbucket
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryProvider] {
            return [
                .bitbucket,
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "BITBUCKET"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryProvider(rawValue: rawValue) ?? RepositoryProvider.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.RepositorySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectionArn
        case name
        case provider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let providerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .provider)
        provider = providerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension ProtonClientTypes {
    /// Summary data of a linked repositorya repository that has been registered with Proton.
    public struct RepositorySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the linked repository.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the of your connection that connects Proton to your repository.
        /// This member is required.
        public var connectionArn: Swift.String?
        /// The repository name.
        /// This member is required.
        public var name: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var provider: ProtonClientTypes.RepositoryProvider?

        public init(
            arn: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            provider: ProtonClientTypes.RepositoryProvider? = nil
        )
        {
            self.arn = arn
            self.connectionArn = connectionArn
            self.name = name
            self.provider = provider
        }
    }

}

extension ProtonClientTypes.RepositorySyncAttempt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case startedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for repositorysyncevent0 in events {
                try eventsContainer.encode(repositorysyncevent0)
            }
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositorySyncStatus.self, forKey: .status)
        status = statusDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.RepositorySyncEvent?].self, forKey: .events)
        var eventsDecoded0:[ProtonClientTypes.RepositorySyncEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ProtonClientTypes.RepositorySyncEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension ProtonClientTypes {
    /// Detail data for a repository sync attempt activated by a push to a repository.
    public struct RepositorySyncAttempt: Swift.Equatable {
        /// Detail data for sync attempt events.
        /// This member is required.
        public var events: [ProtonClientTypes.RepositorySyncEvent]?
        /// The time when the sync attempt started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The sync attempt status.
        /// This member is required.
        public var status: ProtonClientTypes.RepositorySyncStatus?

        public init(
            events: [ProtonClientTypes.RepositorySyncEvent]? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: ProtonClientTypes.RepositorySyncStatus? = nil
        )
        {
            self.events = events
            self.startedAt = startedAt
            self.status = status
        }
    }

}

extension ProtonClientTypes.RepositorySyncDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case directory
        case parent
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let directory = self.directory {
            try encodeContainer.encode(directory, forKey: .directory)
        }
        if let parent = self.parent {
            try encodeContainer.encode(parent, forKey: .parent)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let parentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parent)
        parent = parentDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let directoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directory)
        directory = directoryDecoded
    }
}

extension ProtonClientTypes {
    /// A repository sync definition.
    public struct RepositorySyncDefinition: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The directory in the repository.
        /// This member is required.
        public var directory: Swift.String?
        /// The resource that is synced from.
        /// This member is required.
        public var parent: Swift.String?
        /// The resource that is synced to.
        /// This member is required.
        public var target: Swift.String?

        public init(
            branch: Swift.String? = nil,
            directory: Swift.String? = nil,
            parent: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.branch = branch
            self.directory = directory
            self.parent = parent
            self.target = target
        }
    }

}

extension ProtonClientTypes.RepositorySyncEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case externalId
        case time
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension ProtonClientTypes {
    /// Repository sync event detail data for a sync attempt.
    public struct RepositorySyncEvent: Swift.Equatable {
        /// Event detail for a repository sync attempt.
        /// This member is required.
        public var event: Swift.String?
        /// The external ID of the sync event.
        public var externalId: Swift.String?
        /// The time that the sync event occurred.
        /// This member is required.
        public var time: ClientRuntime.Date?
        /// The type of event.
        /// This member is required.
        public var type: Swift.String?

        public init(
            event: Swift.String? = nil,
            externalId: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }
    }

}

extension ProtonClientTypes {
    public enum RepositorySyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The repository sync attempt has failed.
        case failed
        /// A repository sync attempt has been created and will begin soon.
        case initiated
        /// A repository sync attempt has started and work is being done to reconcile the branch.
        case inProgress
        /// The repository sync attempt didn't execute and was queued.
        case queued
        /// The repository sync attempt has completed successfully.
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositorySyncStatus] {
            return [
                .failed,
                .initiated,
                .inProgress,
                .queued,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositorySyncStatus(rawValue: rawValue) ?? RepositorySyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.ResourceCountsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behindMajor
        case behindMinor
        case failed
        case total
        case upToDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behindMajor = self.behindMajor {
            try encodeContainer.encode(behindMajor, forKey: .behindMajor)
        }
        if let behindMinor = self.behindMinor {
            try encodeContainer.encode(behindMinor, forKey: .behindMinor)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let upToDate = self.upToDate {
            try encodeContainer.encode(upToDate, forKey: .upToDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
        let upToDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .upToDate)
        upToDate = upToDateDecoded
        let behindMajorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .behindMajor)
        behindMajor = behindMajorDecoded
        let behindMinorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .behindMinor)
        behindMinor = behindMinorDecoded
    }
}

extension ProtonClientTypes {
    /// Summary counts of each Proton resource types.
    public struct ResourceCountsSummary: Swift.Equatable {
        /// The number of resources of this type in the Amazon Web Services account that need a major template version update.
        public var behindMajor: Swift.Int?
        /// The number of resources of this type in the Amazon Web Services account that need a minor template version update.
        public var behindMinor: Swift.Int?
        /// The number of resources of this type in the Amazon Web Services account that failed to deploy.
        public var failed: Swift.Int?
        /// The total number of resources of this type in the Amazon Web Services account.
        /// This member is required.
        public var total: Swift.Int?
        /// The number of resources of this type in the Amazon Web Services account that are up-to-date with their template.
        public var upToDate: Swift.Int?

        public init(
            behindMajor: Swift.Int? = nil,
            behindMinor: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            total: Swift.Int? = nil,
            upToDate: Swift.Int? = nil
        )
        {
            self.behindMajor = behindMajor
            self.behindMinor = behindMinor
            self.failed = failed
            self.total = total
            self.upToDate = upToDate
        }
    }

}

extension ProtonClientTypes {
    /// The state that a PR-based deployment can be updated to.
    public enum ResourceDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceDeploymentStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceDeploymentStatus(rawValue: rawValue) ?? ResourceDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \"CONTENT_REDACTED\")"}
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes.ResourceSyncAttempt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case initialRevision
        case startedAt
        case status
        case target
        case targetRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for resourcesyncevent0 in events {
                try eventsContainer.encode(resourcesyncevent0)
            }
        }
        if let initialRevision = self.initialRevision {
            try encodeContainer.encode(initialRevision, forKey: .initialRevision)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetRevision = self.targetRevision {
            try encodeContainer.encode(targetRevision, forKey: .targetRevision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialRevisionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .initialRevision)
        initialRevision = initialRevisionDecoded
        let targetRevisionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Revision.self, forKey: .targetRevision)
        targetRevision = targetRevisionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ResourceSyncStatus.self, forKey: .status)
        status = statusDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ResourceSyncEvent?].self, forKey: .events)
        var eventsDecoded0:[ProtonClientTypes.ResourceSyncEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ProtonClientTypes.ResourceSyncEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension ProtonClientTypes {
    /// Detail data for a resource sync attempt activated by a push to a repository.
    public struct ResourceSyncAttempt: Swift.Equatable {
        /// An array of events with detail data.
        /// This member is required.
        public var events: [ProtonClientTypes.ResourceSyncEvent]?
        /// Detail data for the initial repository commit, path and push.
        /// This member is required.
        public var initialRevision: ProtonClientTypes.Revision?
        /// The time when the sync attempt started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The status of the sync attempt.
        /// This member is required.
        public var status: ProtonClientTypes.ResourceSyncStatus?
        /// The resource that is synced to.
        /// This member is required.
        public var target: Swift.String?
        /// Detail data for the target revision.
        /// This member is required.
        public var targetRevision: ProtonClientTypes.Revision?

        public init(
            events: [ProtonClientTypes.ResourceSyncEvent]? = nil,
            initialRevision: ProtonClientTypes.Revision? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: ProtonClientTypes.ResourceSyncStatus? = nil,
            target: Swift.String? = nil,
            targetRevision: ProtonClientTypes.Revision? = nil
        )
        {
            self.events = events
            self.initialRevision = initialRevision
            self.startedAt = startedAt
            self.status = status
            self.target = target
            self.targetRevision = targetRevision
        }
    }

}

extension ProtonClientTypes.ResourceSyncEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case externalId
        case time
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
    }
}

extension ProtonClientTypes {
    /// Detail data for a resource sync event.
    public struct ResourceSyncEvent: Swift.Equatable {
        /// A resource sync event.
        /// This member is required.
        public var event: Swift.String?
        /// The external ID for the event.
        public var externalId: Swift.String?
        /// The time when the event occurred.
        /// This member is required.
        public var time: ClientRuntime.Date?
        /// The type of event.
        /// This member is required.
        public var type: Swift.String?

        public init(
            event: Swift.String? = nil,
            externalId: Swift.String? = nil,
            time: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.event = event
            self.externalId = externalId
            self.time = time
            self.type = type
        }
    }

}

extension ProtonClientTypes {
    public enum ResourceSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Syncing has failed.
        case failed
        /// A sync attempt has been created and will begin soon.
        case initiated
        /// Syncing has started and work is being done to reconcile state.
        case inProgress
        /// Syncing has completed successfully.
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSyncStatus] {
            return [
                .failed,
                .initiated,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSyncStatus(rawValue: rawValue) ?? ResourceSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Revision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case directory
        case repositoryName
        case repositoryProvider
        case sha
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let directory = self.directory {
            try encodeContainer.encode(directory, forKey: .directory)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let sha = self.sha {
            try encodeContainer.encode(sha, forKey: .sha)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let shaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha)
        sha = shaDecoded
        let directoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directory)
        directory = directoryDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension ProtonClientTypes {
    /// Revision detail data for a commit and push that activates a sync attempt
    public struct Revision: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository directory changed by a commit and push that activated the sync attempt.
        /// This member is required.
        public var directory: Swift.String?
        /// The repository name.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
        /// The secure hash algorithm (SHA) hash for the revision.
        /// This member is required.
        public var sha: Swift.String?

        public init(
            branch: Swift.String? = nil,
            directory: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
            sha: Swift.String? = nil
        )
        {
            self.branch = branch
            self.directory = directory
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.sha = sha
        }
    }

}

extension ProtonClientTypes.S3ObjectSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension ProtonClientTypes {
    /// Template bundle S3 bucket data.
    public struct S3ObjectSource: Swift.Equatable {
        /// The name of the S3 bucket that contains a template bundle.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path to the S3 bucket that contains a template bundle.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension ProtonClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case branchName
        case createdAt
        case description
        case lastModifiedAt
        case name
        case pipeline
        case repositoryConnectionArn
        case repositoryId
        case spec
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipeline = self.pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
        if let repositoryConnectionArn = self.repositoryConnectionArn {
            try encodeContainer.encode(repositoryConnectionArn, forKey: .repositoryConnectionArn)
        }
        if let repositoryId = self.repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let repositoryConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryConnectionArn)
        repositoryConnectionArn = repositoryConnectionArnDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension ProtonClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(arn: \(Swift.String(describing: arn)), branchName: \(Swift.String(describing: branchName)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipeline: \(Swift.String(describing: pipeline)), repositoryConnectionArn: \(Swift.String(describing: repositoryConnectionArn)), repositoryId: \(Swift.String(describing: repositoryId)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton service resource.
    public struct Service: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the code repository branch that holds the code that's deployed in Proton.
        public var branchName: Swift.String?
        /// The time when the service was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service.
        public var description: Swift.String?
        /// The time when the service was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service.
        /// This member is required.
        public var name: Swift.String?
        /// The service pipeline detail data.
        public var pipeline: ProtonClientTypes.ServicePipeline?
        /// The Amazon Resource Name (ARN) of the repository connection. For more information, see [Setting up an AWS CodeStar connection](https://docs.aws.amazon.com/proton/latest/userguide/setting-up-for-service.html#setting-up-vcontrol) in the Proton User Guide.
        public var repositoryConnectionArn: Swift.String?
        /// The ID of the source code repository.
        public var repositoryId: Swift.String?
        /// The formatted specification that defines the service.
        /// This member is required.
        public var spec: Swift.String?
        /// The status of the service.
        /// This member is required.
        public var status: ProtonClientTypes.ServiceStatus?
        /// A service status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            branchName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipeline: ProtonClientTypes.ServicePipeline? = nil,
            repositoryConnectionArn: Swift.String? = nil,
            repositoryId: Swift.String? = nil,
            spec: Swift.String? = nil,
            status: ProtonClientTypes.ServiceStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.branchName = branchName
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipeline = pipeline
            self.repositoryConnectionArn = repositoryConnectionArn
            self.repositoryId = repositoryId
            self.spec = spec
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case lastAttemptedDeploymentId
        case lastClientRequestToken
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastSucceededDeploymentId
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastClientRequestToken = self.lastClientRequestToken {
            try encodeContainer.encode(lastClientRequestToken, forKey: .lastClientRequestToken)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let lastClientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastClientRequestToken)
        lastClientRequestToken = lastClientRequestTokenDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.ServiceInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInstance(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentName: \(Swift.String(describing: environmentName)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastClientRequestToken: \(Swift.String(describing: lastClientRequestToken)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), deploymentStatusMessage: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton service instance resource.
    public struct ServiceInstance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service instance.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The service instance deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// The message associated with the service instance deployment status.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the environment that the service instance was deployed into.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the last attempted deployment of this service instance.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The last client request token received.
        public var lastClientRequestToken: Swift.String?
        /// The time when a deployment of the service instance was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service instance was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this service instance.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the service instance.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service that the service instance belongs to.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The service spec that was used to create the service instance.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service instance.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service instance.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service instance.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastClientRequestToken: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastClientRequestToken = lastClientRequestToken
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceName = serviceName
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceInstanceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastSuccessfulComponentDeploymentIds
        case lastSuccessfulEnvironmentDeploymentId
        case lastSuccessfulServicePipelineDeploymentId
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastSuccessfulComponentDeploymentIds = lastSuccessfulComponentDeploymentIds {
            var lastSuccessfulComponentDeploymentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastSuccessfulComponentDeploymentIds)
            for deploymentid0 in lastSuccessfulComponentDeploymentIds {
                try lastSuccessfulComponentDeploymentIdsContainer.encode(deploymentid0)
            }
        }
        if let lastSuccessfulEnvironmentDeploymentId = self.lastSuccessfulEnvironmentDeploymentId {
            try encodeContainer.encode(lastSuccessfulEnvironmentDeploymentId, forKey: .lastSuccessfulEnvironmentDeploymentId)
        }
        if let lastSuccessfulServicePipelineDeploymentId = self.lastSuccessfulServicePipelineDeploymentId {
            try encodeContainer.encode(lastSuccessfulServicePipelineDeploymentId, forKey: .lastSuccessfulServicePipelineDeploymentId)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let lastSuccessfulComponentDeploymentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lastSuccessfulComponentDeploymentIds)
        var lastSuccessfulComponentDeploymentIdsDecoded0:[Swift.String]? = nil
        if let lastSuccessfulComponentDeploymentIdsContainer = lastSuccessfulComponentDeploymentIdsContainer {
            lastSuccessfulComponentDeploymentIdsDecoded0 = [Swift.String]()
            for string0 in lastSuccessfulComponentDeploymentIdsContainer {
                if let string0 = string0 {
                    lastSuccessfulComponentDeploymentIdsDecoded0?.append(string0)
                }
            }
        }
        lastSuccessfulComponentDeploymentIds = lastSuccessfulComponentDeploymentIdsDecoded0
        let lastSuccessfulEnvironmentDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulEnvironmentDeploymentId)
        lastSuccessfulEnvironmentDeploymentId = lastSuccessfulEnvironmentDeploymentIdDecoded
        let lastSuccessfulServicePipelineDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulServicePipelineDeploymentId)
        lastSuccessfulServicePipelineDeploymentId = lastSuccessfulServicePipelineDeploymentIdDecoded
    }
}

extension ProtonClientTypes.ServiceInstanceState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInstanceState(lastSuccessfulComponentDeploymentIds: \(Swift.String(describing: lastSuccessfulComponentDeploymentIds)), lastSuccessfulEnvironmentDeploymentId: \(Swift.String(describing: lastSuccessfulEnvironmentDeploymentId)), lastSuccessfulServicePipelineDeploymentId: \(Swift.String(describing: lastSuccessfulServicePipelineDeploymentId)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The detailed data about the current state of this service instance.
    public struct ServiceInstanceState: Swift.Equatable {
        /// The IDs for the last successful components deployed for this service instance.
        public var lastSuccessfulComponentDeploymentIds: [Swift.String]?
        /// The ID for the last successful environment deployed for this service instance.
        public var lastSuccessfulEnvironmentDeploymentId: Swift.String?
        /// The ID for the last successful service pipeline deployed for this service instance.
        public var lastSuccessfulServicePipelineDeploymentId: Swift.String?
        /// The service spec that was used to create the service instance.
        /// This member is required.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service instance.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            lastSuccessfulComponentDeploymentIds: [Swift.String]? = nil,
            lastSuccessfulEnvironmentDeploymentId: Swift.String? = nil,
            lastSuccessfulServicePipelineDeploymentId: Swift.String? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.lastSuccessfulComponentDeploymentIds = lastSuccessfulComponentDeploymentIds
            self.lastSuccessfulEnvironmentDeploymentId = lastSuccessfulEnvironmentDeploymentId
            self.lastSuccessfulServicePipelineDeploymentId = lastSuccessfulServicePipelineDeploymentId
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case environmentName
        case lastAttemptedDeploymentId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastSucceededDeploymentId
        case name
        case serviceName
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.ServiceInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInstanceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), environmentName: \(Swift.String(describing: environmentName)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), deploymentStatusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton service instance resource.
    public struct ServiceInstanceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service instance.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service instance was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The service instance deployment status.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// A service instance deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The name of the environment that the service instance was deployed into.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the last attempted deployment of this service instance.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The time when a deployment of the service was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this service instance.
        public var lastSucceededDeploymentId: Swift.String?
        /// The name of the service instance.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the service that the service instance belongs to.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The service instance template major version.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The service instance template minor version.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            name: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.environmentName = environmentName
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.name = name
            self.serviceName = serviceName
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServicePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentStatus
        case deploymentStatusMessage
        case lastAttemptedDeploymentId
        case lastDeploymentAttemptedAt
        case lastDeploymentSucceededAt
        case lastSucceededDeploymentId
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let lastAttemptedDeploymentId = self.lastAttemptedDeploymentId {
            try encodeContainer.encode(lastAttemptedDeploymentId, forKey: .lastAttemptedDeploymentId)
        }
        if let lastDeploymentAttemptedAt = self.lastDeploymentAttemptedAt {
            try encodeContainer.encodeTimestamp(lastDeploymentAttemptedAt, format: .epochSeconds, forKey: .lastDeploymentAttemptedAt)
        }
        if let lastDeploymentSucceededAt = self.lastDeploymentSucceededAt {
            try encodeContainer.encodeTimestamp(lastDeploymentSucceededAt, format: .epochSeconds, forKey: .lastDeploymentSucceededAt)
        }
        if let lastSucceededDeploymentId = self.lastSucceededDeploymentId {
            try encodeContainer.encode(lastSucceededDeploymentId, forKey: .lastSucceededDeploymentId)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentAttemptedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentAttemptedAt)
        lastDeploymentAttemptedAt = lastDeploymentAttemptedAtDecoded
        let lastDeploymentSucceededAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentSucceededAt)
        lastDeploymentSucceededAt = lastDeploymentSucceededAtDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let lastAttemptedDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastAttemptedDeploymentId)
        lastAttemptedDeploymentId = lastAttemptedDeploymentIdDecoded
        let lastSucceededDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSucceededDeploymentId)
        lastSucceededDeploymentId = lastSucceededDeploymentIdDecoded
    }
}

extension ProtonClientTypes.ServicePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServicePipeline(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), lastAttemptedDeploymentId: \(Swift.String(describing: lastAttemptedDeploymentId)), lastDeploymentAttemptedAt: \(Swift.String(describing: lastDeploymentAttemptedAt)), lastDeploymentSucceededAt: \(Swift.String(describing: lastDeploymentSucceededAt)), lastSucceededDeploymentId: \(Swift.String(describing: lastSucceededDeploymentId)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), deploymentStatusMessage: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton service instance pipeline resource.
    public struct ServicePipeline: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service pipeline.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service pipeline was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The deployment status of the service pipeline.
        /// This member is required.
        public var deploymentStatus: ProtonClientTypes.DeploymentStatus?
        /// A service pipeline deployment status message.
        public var deploymentStatusMessage: Swift.String?
        /// The ID of the last attempted deployment of this service pipeline.
        public var lastAttemptedDeploymentId: Swift.String?
        /// The time when a deployment of the service pipeline was last attempted.
        /// This member is required.
        public var lastDeploymentAttemptedAt: ClientRuntime.Date?
        /// The time when the service pipeline was last deployed successfully.
        /// This member is required.
        public var lastDeploymentSucceededAt: ClientRuntime.Date?
        /// The ID of the last successful deployment of this service pipeline.
        public var lastSucceededDeploymentId: Swift.String?
        /// The service spec that was used to create the service pipeline.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentStatus: ProtonClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            lastAttemptedDeploymentId: Swift.String? = nil,
            lastDeploymentAttemptedAt: ClientRuntime.Date? = nil,
            lastDeploymentSucceededAt: ClientRuntime.Date? = nil,
            lastSucceededDeploymentId: Swift.String? = nil,
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.lastAttemptedDeploymentId = lastAttemptedDeploymentId
            self.lastDeploymentAttemptedAt = lastDeploymentAttemptedAt
            self.lastDeploymentSucceededAt = lastDeploymentSucceededAt
            self.lastSucceededDeploymentId = lastSucceededDeploymentId
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServicePipelineState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spec
        case templateMajorVersion
        case templateMinorVersion
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
    }
}

extension ProtonClientTypes.ServicePipelineState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServicePipelineState(templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), templateName: \(Swift.String(describing: templateName)), spec: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// The detailed data about the current state of the service pipeline.
    public struct ServicePipelineState: Swift.Equatable {
        /// The service spec that was used to create the service pipeline.
        public var spec: Swift.String?
        /// The major version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMajorVersion: Swift.String?
        /// The minor version of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateMinorVersion: Swift.String?
        /// The name of the service template that was used to create the service pipeline.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            spec: Swift.String? = nil,
            templateMajorVersion: Swift.String? = nil,
            templateMinorVersion: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.spec = spec
            self.templateMajorVersion = templateMajorVersion
            self.templateMinorVersion = templateMinorVersion
            self.templateName = templateName
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \"CONTENT_REDACTED\")"}
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A quota was exceeded. For more information, see [Proton Quotas](https://docs.aws.amazon.com/proton/latest/userguide/ag-limits.html) in the Proton User Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProtonClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createFailedCleanupComplete
        case createFailedCleanupFailed
        case createFailedCleanupInProgress
        case createInProgress
        case deleteFailed
        case deleteInProgress
        case updateCompleteCleanupFailed
        case updateFailed
        case updateFailedCleanupComplete
        case updateFailedCleanupFailed
        case updateFailedCleanupInProgress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createFailedCleanupComplete,
                .createFailedCleanupFailed,
                .createFailedCleanupInProgress,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateCompleteCleanupFailed,
                .updateFailed,
                .updateFailedCleanupComplete,
                .updateFailedCleanupFailed,
                .updateFailedCleanupInProgress,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createFailedCleanupComplete: return "CREATE_FAILED_CLEANUP_COMPLETE"
            case .createFailedCleanupFailed: return "CREATE_FAILED_CLEANUP_FAILED"
            case .createFailedCleanupInProgress: return "CREATE_FAILED_CLEANUP_IN_PROGRESS"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateCompleteCleanupFailed: return "UPDATE_COMPLETE_CLEANUP_FAILED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateFailedCleanupComplete: return "UPDATE_FAILED_CLEANUP_COMPLETE"
            case .updateFailedCleanupFailed: return "UPDATE_FAILED_CLEANUP_FAILED"
            case .updateFailedCleanupInProgress: return "UPDATE_FAILED_CLEANUP_IN_PROGRESS"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case name
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ProtonClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton service resource.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service.
        public var description: Swift.String?
        /// The time when the service was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the service.
        /// This member is required.
        public var status: ProtonClientTypes.ServiceStatus?
        /// A service status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: ProtonClientTypes.ServiceStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceSyncBlockerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestBlockers
        case serviceInstanceName
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestBlockers = latestBlockers {
            var latestBlockersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .latestBlockers)
            for syncblocker0 in latestBlockers {
                try latestBlockersContainer.encode(syncblocker0)
            }
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let latestBlockersContainer = try containerValues.decodeIfPresent([ProtonClientTypes.SyncBlocker?].self, forKey: .latestBlockers)
        var latestBlockersDecoded0:[ProtonClientTypes.SyncBlocker]? = nil
        if let latestBlockersContainer = latestBlockersContainer {
            latestBlockersDecoded0 = [ProtonClientTypes.SyncBlocker]()
            for structure0 in latestBlockersContainer {
                if let structure0 = structure0 {
                    latestBlockersDecoded0?.append(structure0)
                }
            }
        }
        latestBlockers = latestBlockersDecoded0
    }
}

extension ProtonClientTypes {
    /// If a service instance is manually updated, Proton wants to prevent accidentally overriding a manual change. A blocker is created because of the manual update or deletion of a service instance. The summary describes the blocker as being active or resolved.
    public struct ServiceSyncBlockerSummary: Swift.Equatable {
        /// The latest active blockers for the synced service.
        public var latestBlockers: [ProtonClientTypes.SyncBlocker]?
        /// The name of the service instance that you want sync your service configuration with.
        public var serviceInstanceName: Swift.String?
        /// The name of the service that you want to get the sync blocker summary for. If given a service instance name and a service name, it will return the blockers only applying to the instance that is blocked. If given only a service name, it will return the blockers that apply to all of the instances. In order to get the blockers for a single instance, you will need to make two distinct calls, one to get the sync blocker summary for the service and the other to get the sync blocker for the service instance.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            latestBlockers: [ProtonClientTypes.SyncBlocker]? = nil,
            serviceInstanceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.latestBlockers = latestBlockers
            self.serviceInstanceName = serviceInstanceName
            self.serviceName = serviceName
        }
    }

}

extension ProtonClientTypes.ServiceSyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case filePath
        case repositoryName
        case repositoryProvider
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension ProtonClientTypes {
    /// Detailed data of the service sync configuration.
    public struct ServiceSyncConfig: Swift.Equatable {
        /// The name of the code repository branch that holds the service code Proton will sync with.
        /// This member is required.
        public var branch: Swift.String?
        /// The file path to the service sync configuration file.
        /// This member is required.
        public var filePath: Swift.String?
        /// The name of the code repository that holds the service code Proton will sync with.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The name of the repository provider that holds the repository Proton will sync with.
        /// This member is required.
        public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
        /// The name of the service that the service instance is added to.
        /// This member is required.
        public var serviceName: Swift.String?

        public init(
            branch: Swift.String? = nil,
            filePath: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.branch = branch
            self.filePath = filePath
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.serviceName = serviceName
        }
    }

}

extension ProtonClientTypes.ServiceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case encryptionKey
        case lastModifiedAt
        case name
        case pipelineProvisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = self.pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let recommendedVersion = self.recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
    }
}

extension ProtonClientTypes.ServiceTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplate(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), encryptionKey: \(Swift.String(describing: encryptionKey)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton service template resource.
    public struct ServiceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service template.
        public var description: Swift.String?
        /// The service template name as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The customer provided service template encryption key that's used to encrypt data.
        public var encryptionKey: Swift.String?
        /// The time when the service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service template.
        /// This member is required.
        public var name: Swift.String?
        /// If pipelineProvisioning is true, a service pipeline is included in the service template. Otherwise, a service pipeline isn't included in the service template.
        public var pipelineProvisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the service template.
        public var recommendedVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionKey = encryptionKey
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes.ServiceTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case displayName
        case lastModifiedAt
        case name
        case pipelineProvisioning
        case recommendedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineProvisioning = self.pipelineProvisioning {
            try encodeContainer.encode(pipelineProvisioning.rawValue, forKey: .pipelineProvisioning)
        }
        if let recommendedVersion = self.recommendedVersion {
            try encodeContainer.encode(recommendedVersion, forKey: .recommendedVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedVersion)
        recommendedVersion = recommendedVersionDecoded
        let pipelineProvisioningDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Provisioning.self, forKey: .pipelineProvisioning)
        pipelineProvisioning = pipelineProvisioningDecoded
    }
}

extension ProtonClientTypes.ServiceTemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), name: \(Swift.String(describing: name)), pipelineProvisioning: \(Swift.String(describing: pipelineProvisioning)), recommendedVersion: \(Swift.String(describing: recommendedVersion)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton service template resource.
    public struct ServiceTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the service template.
        public var description: Swift.String?
        /// The service template name as displayed in the developer interface.
        public var displayName: Swift.String?
        /// The time when the service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The name of the service template.
        /// This member is required.
        public var name: Swift.String?
        /// If pipelineProvisioning is true, a service pipeline is included in the service template, otherwise a service pipeline isn't included in the service template.
        public var pipelineProvisioning: ProtonClientTypes.Provisioning?
        /// The recommended version of the service template.
        public var recommendedVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pipelineProvisioning: ProtonClientTypes.Provisioning? = nil,
            recommendedVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.pipelineProvisioning = pipelineProvisioning
            self.recommendedVersion = recommendedVersion
        }
    }

}

extension ProtonClientTypes {
    public enum ServiceTemplateSupportedComponentSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directlyDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceTemplateSupportedComponentSourceType] {
            return [
                .directlyDefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directlyDefined: return "DIRECTLY_DEFINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceTemplateSupportedComponentSourceType(rawValue: rawValue) ?? ServiceTemplateSupportedComponentSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.ServiceTemplateVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case compatibleEnvironmentTemplates
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case schema
        case status
        case statusMessage
        case supportedComponentSources
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplate0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplate0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = self.recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let supportedComponentSources = supportedComponentSources {
            var supportedComponentSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedComponentSources)
            for servicetemplatesupportedcomponentsourcetype0 in supportedComponentSources {
                try supportedComponentSourcesContainer.encode(servicetemplatesupportedcomponentsourcetype0.rawValue)
            }
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplate?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplate]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplate]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let supportedComponentSourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateSupportedComponentSourceType?].self, forKey: .supportedComponentSources)
        var supportedComponentSourcesDecoded0:[ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil
        if let supportedComponentSourcesContainer = supportedComponentSourcesContainer {
            supportedComponentSourcesDecoded0 = [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]()
            for string0 in supportedComponentSourcesContainer {
                if let string0 = string0 {
                    supportedComponentSourcesDecoded0?.append(string0)
                }
            }
        }
        supportedComponentSources = supportedComponentSourcesDecoded0
    }
}

extension ProtonClientTypes.ServiceTemplateVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateVersion(arn: \(Swift.String(describing: arn)), compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), supportedComponentSources: \(Swift.String(describing: supportedComponentSources)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Detailed data of an Proton service template version resource.
    public struct ServiceTemplateVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        /// This member is required.
        public var arn: Swift.String?
        /// An array of compatible environment template names for the major version of a service template.
        /// This member is required.
        public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplate]?
        /// The time when the version of a service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of a service template.
        public var description: Swift.String?
        /// The time when the version of a service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of a service template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of a service template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the service template.
        public var recommendedMinorVersion: Swift.String?
        /// The schema of the version of a service template.
        public var schema: Swift.String?
        /// The service template version status.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// A service template version status message.
        public var statusMessage: Swift.String?
        /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
        public var supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]?
        /// The name of the version of a service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplate]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            schema: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.schema = schema
            self.status = status
            self.statusMessage = statusMessage
            self.supportedComponentSources = supportedComponentSources
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes.ServiceTemplateVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case description
        case lastModifiedAt
        case majorVersion
        case minorVersion
        case recommendedMinorVersion
        case status
        case statusMessage
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let recommendedMinorVersion = self.recommendedMinorVersion {
            try encodeContainer.encode(recommendedMinorVersion, forKey: .recommendedMinorVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let recommendedMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedMinorVersion)
        recommendedMinorVersion = recommendedMinorVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension ProtonClientTypes.ServiceTemplateVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceTemplateVersionSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), recommendedMinorVersion: \(Swift.String(describing: recommendedMinorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\", statusMessage: \"CONTENT_REDACTED\")"}
}

extension ProtonClientTypes {
    /// Summary data of an Proton service template version resource.
    public struct ServiceTemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the version of a service template.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the version of a service template was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the version of a service template.
        public var description: Swift.String?
        /// The time when the version of a service template was last modified.
        /// This member is required.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The latest major version that's associated with the version of a service template.
        /// This member is required.
        public var majorVersion: Swift.String?
        /// The minor version of a service template.
        /// This member is required.
        public var minorVersion: Swift.String?
        /// The recommended minor version of the service template.
        public var recommendedMinorVersion: Swift.String?
        /// The service template minor version status.
        /// This member is required.
        public var status: ProtonClientTypes.TemplateVersionStatus?
        /// A service template minor version status message.
        public var statusMessage: Swift.String?
        /// The name of the service template.
        /// This member is required.
        public var templateName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            majorVersion: Swift.String? = nil,
            minorVersion: Swift.String? = nil,
            recommendedMinorVersion: Swift.String? = nil,
            status: ProtonClientTypes.TemplateVersionStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.lastModifiedAt = lastModifiedAt
            self.majorVersion = majorVersion
            self.minorVersion = minorVersion
            self.recommendedMinorVersion = recommendedMinorVersion
            self.status = status
            self.statusMessage = statusMessage
            self.templateName = templateName
        }
    }

}

extension ProtonClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.SyncBlocker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contexts
        case createdAt
        case createdReason
        case id
        case resolvedAt
        case resolvedReason
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contexts = contexts {
            var contextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contexts)
            for syncblockercontext0 in contexts {
                try contextsContainer.encode(syncblockercontext0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdReason = self.createdReason {
            try encodeContainer.encode(createdReason, forKey: .createdReason)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resolvedAt = self.resolvedAt {
            try encodeContainer.encodeTimestamp(resolvedAt, format: .epochSeconds, forKey: .resolvedAt)
        }
        if let resolvedReason = self.resolvedReason {
            try encodeContainer.encode(resolvedReason, forKey: .resolvedReason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.BlockerType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.BlockerStatus.self, forKey: .status)
        status = statusDecoded
        let createdReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdReason)
        createdReason = createdReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let contextsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.SyncBlockerContext?].self, forKey: .contexts)
        var contextsDecoded0:[ProtonClientTypes.SyncBlockerContext]? = nil
        if let contextsContainer = contextsContainer {
            contextsDecoded0 = [ProtonClientTypes.SyncBlockerContext]()
            for structure0 in contextsContainer {
                if let structure0 = structure0 {
                    contextsDecoded0?.append(structure0)
                }
            }
        }
        contexts = contextsDecoded0
        let resolvedReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedReason)
        resolvedReason = resolvedReasonDecoded
        let resolvedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resolvedAt)
        resolvedAt = resolvedAtDecoded
    }
}

extension ProtonClientTypes {
    /// Detailed data of the sync blocker.
    public struct SyncBlocker: Swift.Equatable {
        /// The contexts for the sync blocker.
        public var contexts: [ProtonClientTypes.SyncBlockerContext]?
        /// The time when the sync blocker was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The reason why the sync blocker was created.
        /// This member is required.
        public var createdReason: Swift.String?
        /// The ID of the sync blocker.
        /// This member is required.
        public var id: Swift.String?
        /// The time the sync blocker was resolved.
        public var resolvedAt: ClientRuntime.Date?
        /// The reason the sync blocker was resolved.
        public var resolvedReason: Swift.String?
        /// The status of the sync blocker.
        /// This member is required.
        public var status: ProtonClientTypes.BlockerStatus?
        /// The type of the sync blocker.
        /// This member is required.
        public var type: ProtonClientTypes.BlockerType?

        public init(
            contexts: [ProtonClientTypes.SyncBlockerContext]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdReason: Swift.String? = nil,
            id: Swift.String? = nil,
            resolvedAt: ClientRuntime.Date? = nil,
            resolvedReason: Swift.String? = nil,
            status: ProtonClientTypes.BlockerStatus? = nil,
            type: ProtonClientTypes.BlockerType? = nil
        )
        {
            self.contexts = contexts
            self.createdAt = createdAt
            self.createdReason = createdReason
            self.id = id
            self.resolvedAt = resolvedAt
            self.resolvedReason = resolvedReason
            self.status = status
            self.type = type
        }
    }

}

extension ProtonClientTypes.SyncBlockerContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProtonClientTypes {
    /// Detailed data of the context of the sync blocker.
    public struct SyncBlockerContext: Swift.Equatable {
        /// The key for the sync blocker context.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the sync blocker context.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ProtonClientTypes {
    public enum SyncType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Syncs services and service instances to Proton.
        case serviceSync
        /// Syncs environment and service templates to Proton.
        case templateSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncType] {
            return [
                .serviceSync,
                .templateSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .serviceSync: return "SERVICE_SYNC"
            case .templateSync: return "TEMPLATE_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncType(rawValue: rawValue) ?? SyncType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProtonClientTypes {
    /// A description of a resource tag.
    public struct Tag: Swift.Equatable {
        /// The key of the resource tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the resource tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Proton resource to apply customer tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of customer tags to apply to the Proton resource.
    /// This member is required.
    public var tags: [ProtonClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ProtonClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [ProtonClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ProtonClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ProtonClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ProtonClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProtonClientTypes.TemplateSyncConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = self.subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension ProtonClientTypes {
    /// The detail data for a template sync configuration.
    public struct TemplateSyncConfig: Swift.Equatable {
        /// The repository branch.
        /// This member is required.
        public var branch: Swift.String?
        /// The repository name (for example, myrepos/myrepo).
        /// This member is required.
        public var repositoryName: Swift.String?
        /// The repository provider.
        /// This member is required.
        public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
        /// A subdirectory path to your template bundle version.
        public var subdirectory: Swift.String?
        /// The template name.
        /// This member is required.
        public var templateName: Swift.String?
        /// The template type.
        /// This member is required.
        public var templateType: ProtonClientTypes.TemplateType?

        public init(
            branch: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
            subdirectory: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: ProtonClientTypes.TemplateType? = nil
        )
        {
            self.branch = branch
            self.repositoryName = repositoryName
            self.repositoryProvider = repositoryProvider
            self.subdirectory = subdirectory
            self.templateName = templateName
            self.templateType = templateType
        }
    }

}

extension ProtonClientTypes {
    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case environment
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .environment,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .environment: return "ENVIRONMENT"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
        }
    }
}

extension ProtonClientTypes.TemplateVersionSourceInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(ProtonClientTypes.S3ObjectSource.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ProtonClientTypes {
    /// Template version source data.
    public enum TemplateVersionSourceInput: Swift.Equatable {
        /// An S3 source object that includes the template bundle S3 path and name for a template minor version.
        case s3(ProtonClientTypes.S3ObjectSource)
        case sdkUnknown(Swift.String)
    }

}

extension ProtonClientTypes {
    public enum TemplateVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case published
        case registrationFailed
        case registrationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateVersionStatus] {
            return [
                .draft,
                .published,
                .registrationFailed,
                .registrationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case .registrationFailed: return "REGISTRATION_FAILED"
            case .registrationInProgress: return "REGISTRATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateVersionStatus(rawValue: rawValue) ?? TemplateVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \"CONTENT_REDACTED\")"}
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove customer tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of customer tag keys that indicate the customer tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletePipelineProvisioningRepository
        case pipelineCodebuildRoleArn
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletePipelineProvisioningRepository = self.deletePipelineProvisioningRepository {
            try encodeContainer.encode(deletePipelineProvisioningRepository, forKey: .deletePipelineProvisioningRepository)
        }
        if let pipelineCodebuildRoleArn = self.pipelineCodebuildRoleArn {
            try encodeContainer.encode(pipelineCodebuildRoleArn, forKey: .pipelineCodebuildRoleArn)
        }
        if let pipelineProvisioningRepository = self.pipelineProvisioningRepository {
            try encodeContainer.encode(pipelineProvisioningRepository, forKey: .pipelineProvisioningRepository)
        }
        if let pipelineServiceRoleArn = self.pipelineServiceRoleArn {
            try encodeContainer.encode(pipelineServiceRoleArn, forKey: .pipelineServiceRoleArn)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// Set to true to remove a configured pipeline repository from the account settings. Don't set this field if you are updating the configured pipeline repository.
    public var deletePipelineProvisioningRepository: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Proton assumes this role for CodeBuild-based provisioning.
    public var pipelineCodebuildRoleArn: Swift.String?
    /// A linked repository for pipeline provisioning. Specify it if you have environments configured for self-managed provisioning with services that include pipelines. A linked repository is a repository that has been registered with Proton. For more information, see [CreateRepository]. To remove a previously configured repository, set deletePipelineProvisioningRepository to true, and don't set pipelineProvisioningRepository.
    public var pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// The Amazon Resource Name (ARN) of the service role you want to use for provisioning pipelines. Assumed by Proton for Amazon Web Services-managed provisioning, and by customer-owned automation for self-managed provisioning. To remove a previously configured ARN, specify an empty string.
    public var pipelineServiceRoleArn: Swift.String?

    public init(
        deletePipelineProvisioningRepository: Swift.Bool? = nil,
        pipelineCodebuildRoleArn: Swift.String? = nil,
        pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        pipelineServiceRoleArn: Swift.String? = nil
    )
    {
        self.deletePipelineProvisioningRepository = deletePipelineProvisioningRepository
        self.pipelineCodebuildRoleArn = pipelineCodebuildRoleArn
        self.pipelineProvisioningRepository = pipelineProvisioningRepository
        self.pipelineServiceRoleArn = pipelineServiceRoleArn
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let pipelineServiceRoleArn: Swift.String?
    let pipelineProvisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    let deletePipelineProvisioningRepository: Swift.Bool?
    let pipelineCodebuildRoleArn: Swift.String?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletePipelineProvisioningRepository
        case pipelineCodebuildRoleArn
        case pipelineProvisioningRepository
        case pipelineServiceRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineServiceRoleArn)
        pipelineServiceRoleArn = pipelineServiceRoleArnDecoded
        let pipelineProvisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .pipelineProvisioningRepository)
        pipelineProvisioningRepository = pipelineProvisioningRepositoryDecoded
        let deletePipelineProvisioningRepositoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletePipelineProvisioningRepository)
        deletePipelineProvisioningRepository = deletePipelineProvisioningRepositoryDecoded
        let pipelineCodebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineCodebuildRoleArn)
        pipelineCodebuildRoleArn = pipelineCodebuildRoleArnDecoded
    }
}

extension UpdateAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct UpdateAccountSettingsOutput: Swift.Equatable {
    /// The Proton pipeline service role and repository data shared across the Amazon Web Services account.
    /// This member is required.
    public var accountSettings: ProtonClientTypes.AccountSettings?

    public init(
        accountSettings: ProtonClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct UpdateAccountSettingsOutputBody: Swift.Equatable {
    let accountSettings: ProtonClientTypes.AccountSettings?
}

extension UpdateAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

enum UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateComponentInput(clientToken: \(Swift.String(describing: clientToken)), deploymentType: \(Swift.String(describing: deploymentType)), name: \(Swift.String(describing: name)), serviceInstanceName: \(Swift.String(describing: serviceInstanceName)), serviceName: \(Swift.String(describing: serviceName)), description: \"CONTENT_REDACTED\", serviceSpec: \"CONTENT_REDACTED\", templateFile: \"CONTENT_REDACTED\")"}
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deploymentType
        case description
        case name
        case serviceInstanceName
        case serviceName
        case serviceSpec
        case templateFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceInstanceName = self.serviceInstanceName {
            try encodeContainer.encode(serviceInstanceName, forKey: .serviceInstanceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceSpec = self.serviceSpec {
            try encodeContainer.encode(serviceSpec, forKey: .serviceSpec)
        }
        if let templateFile = self.templateFile {
            try encodeContainer.encode(templateFile, forKey: .templateFile)
        }
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The client token for the updated component.
    public var clientToken: Swift.String?
    /// The deployment type. It defines the mode for updating a component, as follows: NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. You can only specify description in this mode. CURRENT_VERSION In this mode, the component is deployed and updated with the new serviceSpec, templateSource, and/or type that you provide. Only requested parameters are updated.
    /// This member is required.
    public var deploymentType: ProtonClientTypes.ComponentDeploymentUpdateType?
    /// An optional customer-provided description of the component.
    public var description: Swift.String?
    /// The name of the component to update.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both serviceInstanceName and serviceName or for neither of them.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that serviceInstanceName is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both serviceInstanceName and serviceName or for neither of them.
    public var serviceName: Swift.String?
    /// The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.
    public var serviceSpec: Swift.String?
    /// A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions. Components support a single IaC file, even if you use Terraform as your template language.
    public var templateFile: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deploymentType: ProtonClientTypes.ComponentDeploymentUpdateType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceSpec: Swift.String? = nil,
        templateFile: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deploymentType = deploymentType
        self.description = description
        self.name = name
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
        self.serviceSpec = serviceSpec
        self.templateFile = templateFile
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let deploymentType: ProtonClientTypes.ComponentDeploymentUpdateType?
    let description: Swift.String?
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let serviceSpec: Swift.String?
    let templateFile: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deploymentType
        case description
        case name
        case serviceInstanceName
        case serviceName
        case serviceSpec
        case templateFile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ComponentDeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceSpec)
        serviceSpec = serviceSpecDecoded
        let templateFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateFile)
        templateFile = templateFileDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
        } else {
            self.component = nil
        }
    }
}

public struct UpdateComponentOutput: Swift.Equatable {
    /// The detailed data of the updated component.
    /// This member is required.
    public var component: ProtonClientTypes.Component?

    public init(
        component: ProtonClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct UpdateComponentOutputBody: Swift.Equatable {
    let component: ProtonClientTypes.Component?
}

extension UpdateComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum UpdateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentAccountConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case id
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateEnvironmentAccountConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentAccountConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM service role in the environment account. Proton uses this role to provision infrastructure resources using CodeBuild-based provisioning in the associated environment account.
    public var codebuildRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in the associated environment account. It determines the scope of infrastructure that a component can provision in the account. The environment account connection must have a componentRoleArn to allow directly defined components to be associated with any environments running in the account. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var componentRoleArn: Swift.String?
    /// The ID of the environment account connection to update.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that's associated with the environment account connection to update.
    public var roleArn: Swift.String?

    public init(
        codebuildRoleArn: Swift.String? = nil,
        componentRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.codebuildRoleArn = codebuildRoleArn
        self.componentRoleArn = componentRoleArn
        self.id = id
        self.roleArn = roleArn
    }
}

struct UpdateEnvironmentAccountConnectionInputBody: Swift.Equatable {
    let id: Swift.String?
    let roleArn: Swift.String?
    let componentRoleArn: Swift.String?
    let codebuildRoleArn: Swift.String?
}

extension UpdateEnvironmentAccountConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case id
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
    }
}

extension UpdateEnvironmentAccountConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentAccountConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentAccountConnection = output.environmentAccountConnection
        } else {
            self.environmentAccountConnection = nil
        }
    }
}

public struct UpdateEnvironmentAccountConnectionOutput: Swift.Equatable {
    /// The environment account connection detail data that's returned by Proton.
    /// This member is required.
    public var environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?

    public init(
        environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection? = nil
    )
    {
        self.environmentAccountConnection = environmentAccountConnection
    }
}

struct UpdateEnvironmentAccountConnectionOutputBody: Swift.Equatable {
    let environmentAccountConnection: ProtonClientTypes.EnvironmentAccountConnection?
}

extension UpdateEnvironmentAccountConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentAccountConnection
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentAccountConnectionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentAccountConnection.self, forKey: .environmentAccountConnection)
        environmentAccountConnection = environmentAccountConnectionDecoded
    }
}

enum UpdateEnvironmentAccountConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(codebuildRoleArn: \(Swift.String(describing: codebuildRoleArn)), componentRoleArn: \(Swift.String(describing: componentRoleArn)), deploymentType: \(Swift.String(describing: deploymentType)), environmentAccountConnectionId: \(Swift.String(describing: environmentAccountConnectionId)), name: \(Swift.String(describing: name)), protonServiceRoleArn: \(Swift.String(describing: protonServiceRoleArn)), provisioningRepository: \(Swift.String(describing: provisioningRepository)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case deploymentType
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codebuildRoleArn = self.codebuildRoleArn {
            try encodeContainer.encode(codebuildRoleArn, forKey: .codebuildRoleArn)
        }
        if let componentRoleArn = self.componentRoleArn {
            try encodeContainer.encode(componentRoleArn, forKey: .componentRoleArn)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentAccountConnectionId = self.environmentAccountConnectionId {
            try encodeContainer.encode(environmentAccountConnectionId, forKey: .environmentAccountConnectionId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protonServiceRoleArn = self.protonServiceRoleArn {
            try encodeContainer.encode(protonServiceRoleArn, forKey: .protonServiceRoleArn)
        }
        if let provisioningRepository = self.provisioningRepository {
            try encodeContainer.encode(provisioningRepository, forKey: .provisioningRepository)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM service role that allows Proton to provision infrastructure using CodeBuild-based provisioning on your behalf.
    public var codebuildRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM service role that Proton uses when provisioning directly defined components in this environment. It determines the scope of infrastructure that a component can provision. The environment must have a componentRoleArn to allow directly defined components to be associated with the environment. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var componentRoleArn: Swift.String?
    /// There are four modes for updating an environment. The deploymentType field defines the mode. NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the environment is deployed and updated with the new spec that you provide. Only requested parameters are updated. Dont include major or minor version parameters when you use this deployment-type. MINOR_VERSION In this mode, the environment is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the environment is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can also specify a different major version that is higher than the major version in use and a minor version (optional).
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// A description of the environment update.
    public var description: Swift.String?
    /// The ID of the environment account connection. You can only update to a new environment account connection if it was created in the same environment account that the current environment account connection was created in and is associated with the current environment.
    public var environmentAccountConnectionId: Swift.String?
    /// The name of the environment to update.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Proton service role that allows Proton to make API calls to other services your behalf.
    public var protonServiceRoleArn: Swift.String?
    /// The linked repository that you use to host your rendered infrastructure templates for self-managed provisioning. A linked repository is a repository that has been registered with Proton. For more information, see [CreateRepository].
    public var provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    /// The formatted specification that defines the update.
    public var spec: Swift.String?
    /// The major version of the environment to update.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the environment to update.
    public var templateMinorVersion: Swift.String?

    public init(
        codebuildRoleArn: Swift.String? = nil,
        componentRoleArn: Swift.String? = nil,
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        description: Swift.String? = nil,
        environmentAccountConnectionId: Swift.String? = nil,
        name: Swift.String? = nil,
        protonServiceRoleArn: Swift.String? = nil,
        provisioningRepository: ProtonClientTypes.RepositoryBranchInput? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.codebuildRoleArn = codebuildRoleArn
        self.componentRoleArn = componentRoleArn
        self.deploymentType = deploymentType
        self.description = description
        self.environmentAccountConnectionId = environmentAccountConnectionId
        self.name = name
        self.protonServiceRoleArn = protonServiceRoleArn
        self.provisioningRepository = provisioningRepository
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let spec: Swift.String?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
    let protonServiceRoleArn: Swift.String?
    let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    let environmentAccountConnectionId: Swift.String?
    let provisioningRepository: ProtonClientTypes.RepositoryBranchInput?
    let componentRoleArn: Swift.String?
    let codebuildRoleArn: Swift.String?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codebuildRoleArn
        case componentRoleArn
        case deploymentType
        case description
        case environmentAccountConnectionId
        case name
        case protonServiceRoleArn
        case provisioningRepository
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let protonServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protonServiceRoleArn)
        protonServiceRoleArn = protonServiceRoleArnDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let environmentAccountConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentAccountConnectionId)
        environmentAccountConnectionId = environmentAccountConnectionIdDecoded
        let provisioningRepositoryDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryBranchInput.self, forKey: .provisioningRepository)
        provisioningRepository = provisioningRepositoryDecoded
        let componentRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentRoleArn)
        componentRoleArn = componentRoleArnDecoded
        let codebuildRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codebuildRoleArn)
        codebuildRoleArn = codebuildRoleArnDecoded
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// The environment detail data that's returned by Proton.
    /// This member is required.
    public var environment: ProtonClientTypes.Environment?

    public init(
        environment: ProtonClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let environment: ProtonClientTypes.Environment?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateInput(name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentTemplateInput: Swift.Equatable {
    /// A description of the environment template update.
    public var description: Swift.String?
    /// The name of the environment template to update as displayed in the developer interface.
    public var displayName: Swift.String?
    /// The name of the environment template to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

struct UpdateEnvironmentTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension UpdateEnvironmentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateEnvironmentTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplate = output.environmentTemplate
        } else {
            self.environmentTemplate = nil
        }
    }
}

public struct UpdateEnvironmentTemplateOutput: Swift.Equatable {
    /// The environment template detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplate: ProtonClientTypes.EnvironmentTemplate?

    public init(
        environmentTemplate: ProtonClientTypes.EnvironmentTemplate? = nil
    )
    {
        self.environmentTemplate = environmentTemplate
    }
}

struct UpdateEnvironmentTemplateOutputBody: Swift.Equatable {
    let environmentTemplate: ProtonClientTypes.EnvironmentTemplate?
}

extension UpdateEnvironmentTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplate.self, forKey: .environmentTemplate)
        environmentTemplate = environmentTemplateDecoded
    }
}

enum UpdateEnvironmentTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentTemplateVersionInput(majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), status: \(Swift.String(describing: status)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension UpdateEnvironmentTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentTemplateVersionInput: Swift.Equatable {
    /// A description of environment template version to update.
    public var description: Swift.String?
    /// To update a major version of an environment template, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To update a minor version of an environment template, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The status of the environment template minor version to update.
    public var status: ProtonClientTypes.TemplateVersionStatus?
    /// The name of the environment template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        status: ProtonClientTypes.TemplateVersionStatus? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.description = description
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.status = status
        self.templateName = templateName
    }
}

struct UpdateEnvironmentTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
    let description: Swift.String?
    let status: ProtonClientTypes.TemplateVersionStatus?
}

extension UpdateEnvironmentTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case majorVersion
        case minorVersion
        case status
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateEnvironmentTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentTemplateVersion = output.environmentTemplateVersion
        } else {
            self.environmentTemplateVersion = nil
        }
    }
}

public struct UpdateEnvironmentTemplateVersionOutput: Swift.Equatable {
    /// The environment template version detail data that's returned by Proton.
    /// This member is required.
    public var environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?

    public init(
        environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion? = nil
    )
    {
        self.environmentTemplateVersion = environmentTemplateVersion
    }
}

struct UpdateEnvironmentTemplateVersionOutputBody: Swift.Equatable {
    let environmentTemplateVersion: ProtonClientTypes.EnvironmentTemplateVersion?
}

extension UpdateEnvironmentTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.EnvironmentTemplateVersion.self, forKey: .environmentTemplateVersion)
        environmentTemplateVersion = environmentTemplateVersionDecoded
    }
}

enum UpdateEnvironmentTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\", spec: \"CONTENT_REDACTED\")"}
}

extension UpdateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case spec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

extension UpdateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The edited service description.
    public var description: Swift.String?
    /// The name of the service to edit.
    /// This member is required.
    public var name: Swift.String?
    /// Lists the service instances to add and the existing service instances to remain. Omit the existing service instances to delete from the list. Don't include edits to the existing service instances or pipeline. For more information, see [Edit a service](https://docs.aws.amazon.com/proton/latest/userguide/ag-svc-update.html) in the Proton User Guide.
    public var spec: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        spec: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.spec = spec
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let spec: Swift.String?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case spec
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
    }
}

extension UpdateServiceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInstanceInput(clientToken: \(Swift.String(describing: clientToken)), deploymentType: \(Swift.String(describing: deploymentType)), name: \(Swift.String(describing: name)), serviceName: \(Swift.String(describing: serviceName)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), spec: \"CONTENT_REDACTED\")"}
}

extension UpdateServiceInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deploymentType
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

extension UpdateServiceInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceInstanceInput: Swift.Equatable {
    /// The client token of the service instance to update.
    public var clientToken: Swift.String?
    /// The deployment type. It defines the mode for updating a service instance, as follows: NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the service instance is deployed and updated with the new spec that you provide. Only requested parameters are updated. Dont include major or minor version parameters when you use this deployment type. MINOR_VERSION In this mode, the service instance is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can also specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the service instance is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can specify a different major version that's higher than the major version in use and a minor version.
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// The name of the service instance to update.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the service that the service instance belongs to.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The formatted specification that defines the service instance update.
    public var spec: Swift.String?
    /// The major version of the service template to update.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template to update.
    public var templateMinorVersion: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        name: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deploymentType = deploymentType
        self.name = name
        self.serviceName = serviceName
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateServiceInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let serviceName: Swift.String?
    let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    let spec: Swift.String?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateServiceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deploymentType
        case name
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateServiceInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstance = output.serviceInstance
        } else {
            self.serviceInstance = nil
        }
    }
}

public struct UpdateServiceInstanceOutput: Swift.Equatable {
    /// The service instance summary data that's returned by Proton.
    /// This member is required.
    public var serviceInstance: ProtonClientTypes.ServiceInstance?

    public init(
        serviceInstance: ProtonClientTypes.ServiceInstance? = nil
    )
    {
        self.serviceInstance = serviceInstance
    }
}

struct UpdateServiceInstanceOutputBody: Swift.Equatable {
    let serviceInstance: ProtonClientTypes.ServiceInstance?
}

extension UpdateServiceInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstance
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceInstanceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceInstance.self, forKey: .serviceInstance)
        serviceInstance = serviceInstanceDecoded
    }
}

enum UpdateServiceInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct UpdateServiceOutput: Swift.Equatable {
    /// The service detail data that's returned by Proton.
    /// This member is required.
    public var service: ProtonClientTypes.Service?

    public init(
        service: ProtonClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct UpdateServiceOutputBody: Swift.Equatable {
    let service: ProtonClientTypes.Service?
}

extension UpdateServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

enum UpdateServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServicePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServicePipelineInput(deploymentType: \(Swift.String(describing: deploymentType)), serviceName: \(Swift.String(describing: serviceName)), templateMajorVersion: \(Swift.String(describing: templateMajorVersion)), templateMinorVersion: \(Swift.String(describing: templateMinorVersion)), spec: \"CONTENT_REDACTED\")"}
}

extension UpdateServicePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let spec = self.spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let templateMajorVersion = self.templateMajorVersion {
            try encodeContainer.encode(templateMajorVersion, forKey: .templateMajorVersion)
        }
        if let templateMinorVersion = self.templateMinorVersion {
            try encodeContainer.encode(templateMinorVersion, forKey: .templateMinorVersion)
        }
    }
}

extension UpdateServicePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServicePipelineInput: Swift.Equatable {
    /// The deployment type. There are four modes for updating a service pipeline. The deploymentType field defines the mode. NONE In this mode, a deployment doesn't occur. Only the requested metadata parameters are updated. CURRENT_VERSION In this mode, the service pipeline is deployed and updated with the new spec that you provide. Only requested parameters are updated. Dont include major or minor version parameters when you use this deployment-type. MINOR_VERSION In this mode, the service pipeline is deployed and updated with the published, recommended (latest) minor version of the current major version in use, by default. You can specify a different minor version of the current major version in use. MAJOR_VERSION In this mode, the service pipeline is deployed and updated with the published, recommended (latest) major and minor version of the current template, by default. You can specify a different major version that's higher than the major version in use and a minor version.
    /// This member is required.
    public var deploymentType: ProtonClientTypes.DeploymentUpdateType?
    /// The name of the service to that the pipeline is associated with.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The spec for the service pipeline to update.
    /// This member is required.
    public var spec: Swift.String?
    /// The major version of the service template that was used to create the service that the pipeline is associated with.
    public var templateMajorVersion: Swift.String?
    /// The minor version of the service template that was used to create the service that the pipeline is associated with.
    public var templateMinorVersion: Swift.String?

    public init(
        deploymentType: ProtonClientTypes.DeploymentUpdateType? = nil,
        serviceName: Swift.String? = nil,
        spec: Swift.String? = nil,
        templateMajorVersion: Swift.String? = nil,
        templateMinorVersion: Swift.String? = nil
    )
    {
        self.deploymentType = deploymentType
        self.serviceName = serviceName
        self.spec = spec
        self.templateMajorVersion = templateMajorVersion
        self.templateMinorVersion = templateMinorVersion
    }
}

struct UpdateServicePipelineInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let spec: Swift.String?
    let deploymentType: ProtonClientTypes.DeploymentUpdateType?
    let templateMajorVersion: Swift.String?
    let templateMinorVersion: Swift.String?
}

extension UpdateServicePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType
        case serviceName
        case spec
        case templateMajorVersion
        case templateMinorVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spec)
        spec = specDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.DeploymentUpdateType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let templateMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMajorVersion)
        templateMajorVersion = templateMajorVersionDecoded
        let templateMinorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateMinorVersion)
        templateMinorVersion = templateMinorVersionDecoded
    }
}

extension UpdateServicePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServicePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct UpdateServicePipelineOutput: Swift.Equatable {
    /// The pipeline details that are returned by Proton.
    /// This member is required.
    public var pipeline: ProtonClientTypes.ServicePipeline?

    public init(
        pipeline: ProtonClientTypes.ServicePipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdateServicePipelineOutputBody: Swift.Equatable {
    let pipeline: ProtonClientTypes.ServicePipeline?
}

extension UpdateServicePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServicePipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

enum UpdateServicePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceSyncBlockerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case resolvedReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resolvedReason = self.resolvedReason {
            try encodeContainer.encode(resolvedReason, forKey: .resolvedReason)
        }
    }
}

extension UpdateServiceSyncBlockerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSyncBlockerInput: Swift.Equatable {
    /// The ID of the service sync blocker.
    /// This member is required.
    public var id: Swift.String?
    /// The reason the service sync blocker was resolved.
    /// This member is required.
    public var resolvedReason: Swift.String?

    public init(
        id: Swift.String? = nil,
        resolvedReason: Swift.String? = nil
    )
    {
        self.id = id
        self.resolvedReason = resolvedReason
    }
}

struct UpdateServiceSyncBlockerInputBody: Swift.Equatable {
    let id: Swift.String?
    let resolvedReason: Swift.String?
}

extension UpdateServiceSyncBlockerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case resolvedReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resolvedReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedReason)
        resolvedReason = resolvedReasonDecoded
    }
}

extension UpdateServiceSyncBlockerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceSyncBlockerOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceInstanceName = output.serviceInstanceName
            self.serviceName = output.serviceName
            self.serviceSyncBlocker = output.serviceSyncBlocker
        } else {
            self.serviceInstanceName = nil
            self.serviceName = nil
            self.serviceSyncBlocker = nil
        }
    }
}

public struct UpdateServiceSyncBlockerOutput: Swift.Equatable {
    /// The name of the service instance that you want to update the service sync blocker for.
    public var serviceInstanceName: Swift.String?
    /// The name of the service that you want to update the service sync blocker for.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The detailed data on the service sync blocker that was updated.
    /// This member is required.
    public var serviceSyncBlocker: ProtonClientTypes.SyncBlocker?

    public init(
        serviceInstanceName: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceSyncBlocker: ProtonClientTypes.SyncBlocker? = nil
    )
    {
        self.serviceInstanceName = serviceInstanceName
        self.serviceName = serviceName
        self.serviceSyncBlocker = serviceSyncBlocker
    }
}

struct UpdateServiceSyncBlockerOutputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let serviceInstanceName: Swift.String?
    let serviceSyncBlocker: ProtonClientTypes.SyncBlocker?
}

extension UpdateServiceSyncBlockerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceInstanceName
        case serviceName
        case serviceSyncBlocker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceInstanceName)
        serviceInstanceName = serviceInstanceNameDecoded
        let serviceSyncBlockerDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.SyncBlocker.self, forKey: .serviceSyncBlocker)
        serviceSyncBlocker = serviceSyncBlockerDecoded
    }
}

enum UpdateServiceSyncBlockerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case filePath
        case repositoryName
        case repositoryProvider
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

extension UpdateServiceSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSyncConfigInput: Swift.Equatable {
    /// The name of the code repository branch where the Proton Ops file is found.
    /// This member is required.
    public var branch: Swift.String?
    /// The path to the Proton Ops file.
    /// This member is required.
    public var filePath: Swift.String?
    /// The name of the repository where the Proton Ops file is found.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The name of the repository provider where the Proton Ops file is found.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// The name of the service the Proton Ops file is for.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        branch: Swift.String? = nil,
        filePath: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.branch = branch
        self.filePath = filePath
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.serviceName = serviceName
    }
}

struct UpdateServiceSyncConfigInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let repositoryName: Swift.String?
    let branch: Swift.String?
    let filePath: Swift.String?
}

extension UpdateServiceSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case filePath
        case repositoryName
        case repositoryProvider
        case serviceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension UpdateServiceSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceSyncConfig = output.serviceSyncConfig
        } else {
            self.serviceSyncConfig = nil
        }
    }
}

public struct UpdateServiceSyncConfigOutput: Swift.Equatable {
    /// The detailed data of the Proton Ops file.
    public var serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?

    public init(
        serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig? = nil
    )
    {
        self.serviceSyncConfig = serviceSyncConfig
    }
}

struct UpdateServiceSyncConfigOutputBody: Swift.Equatable {
    let serviceSyncConfig: ProtonClientTypes.ServiceSyncConfig?
}

extension UpdateServiceSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceSyncConfig.self, forKey: .serviceSyncConfig)
        serviceSyncConfig = serviceSyncConfigDecoded
    }
}

enum UpdateServiceSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateInput(name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension UpdateServiceTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateServiceTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceTemplateInput: Swift.Equatable {
    /// A description of the service template update.
    public var description: Swift.String?
    /// The name of the service template to update that's displayed in the developer interface.
    public var displayName: Swift.String?
    /// The name of the service template to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

struct UpdateServiceTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension UpdateServiceTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateServiceTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplate = output.serviceTemplate
        } else {
            self.serviceTemplate = nil
        }
    }
}

public struct UpdateServiceTemplateOutput: Swift.Equatable {
    /// The service template detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplate: ProtonClientTypes.ServiceTemplate?

    public init(
        serviceTemplate: ProtonClientTypes.ServiceTemplate? = nil
    )
    {
        self.serviceTemplate = serviceTemplate
    }
}

struct UpdateServiceTemplateOutputBody: Swift.Equatable {
    let serviceTemplate: ProtonClientTypes.ServiceTemplate?
}

extension UpdateServiceTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplate.self, forKey: .serviceTemplate)
        serviceTemplate = serviceTemplateDecoded
    }
}

enum UpdateServiceTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceTemplateVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceTemplateVersionInput(compatibleEnvironmentTemplates: \(Swift.String(describing: compatibleEnvironmentTemplates)), majorVersion: \(Swift.String(describing: majorVersion)), minorVersion: \(Swift.String(describing: minorVersion)), status: \(Swift.String(describing: status)), supportedComponentSources: \(Swift.String(describing: supportedComponentSources)), templateName: \(Swift.String(describing: templateName)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateServiceTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case minorVersion
        case status
        case supportedComponentSources
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleEnvironmentTemplates = compatibleEnvironmentTemplates {
            var compatibleEnvironmentTemplatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleEnvironmentTemplates)
            for compatibleenvironmenttemplateinput0 in compatibleEnvironmentTemplates {
                try compatibleEnvironmentTemplatesContainer.encode(compatibleenvironmenttemplateinput0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let majorVersion = self.majorVersion {
            try encodeContainer.encode(majorVersion, forKey: .majorVersion)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let supportedComponentSources = supportedComponentSources {
            var supportedComponentSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedComponentSources)
            for servicetemplatesupportedcomponentsourcetype0 in supportedComponentSources {
                try supportedComponentSourcesContainer.encode(servicetemplatesupportedcomponentsourcetype0.rawValue)
            }
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension UpdateServiceTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceTemplateVersionInput: Swift.Equatable {
    /// An array of environment template objects that are compatible with this service template version. A service instance based on this service template version can run in environments based on compatible templates.
    public var compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    /// A description of a service template version to update.
    public var description: Swift.String?
    /// To update a major version of a service template, include major Version.
    /// This member is required.
    public var majorVersion: Swift.String?
    /// To update a minor version of a service template, include minorVersion.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The status of the service template minor version to update.
    public var status: ProtonClientTypes.TemplateVersionStatus?
    /// An array of supported component sources. Components with supported sources can be attached to service instances based on this service template version. A change to supportedComponentSources doesn't impact existing component attachments to instances based on this template version. A change only affects later associations. For more information about components, see [Proton components](https://docs.aws.amazon.com/proton/latest/userguide/ag-components.html) in the Proton User Guide.
    public var supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]?
    /// The name of the service template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil,
        description: Swift.String? = nil,
        majorVersion: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        status: ProtonClientTypes.TemplateVersionStatus? = nil,
        supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.compatibleEnvironmentTemplates = compatibleEnvironmentTemplates
        self.description = description
        self.majorVersion = majorVersion
        self.minorVersion = minorVersion
        self.status = status
        self.supportedComponentSources = supportedComponentSources
        self.templateName = templateName
    }
}

struct UpdateServiceTemplateVersionInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let majorVersion: Swift.String?
    let minorVersion: Swift.String?
    let description: Swift.String?
    let status: ProtonClientTypes.TemplateVersionStatus?
    let compatibleEnvironmentTemplates: [ProtonClientTypes.CompatibleEnvironmentTemplateInput]?
    let supportedComponentSources: [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]?
}

extension UpdateServiceTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleEnvironmentTemplates
        case description
        case majorVersion
        case minorVersion
        case status
        case supportedComponentSources
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let majorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersion)
        majorVersion = majorVersionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateVersionStatus.self, forKey: .status)
        status = statusDecoded
        let compatibleEnvironmentTemplatesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.CompatibleEnvironmentTemplateInput?].self, forKey: .compatibleEnvironmentTemplates)
        var compatibleEnvironmentTemplatesDecoded0:[ProtonClientTypes.CompatibleEnvironmentTemplateInput]? = nil
        if let compatibleEnvironmentTemplatesContainer = compatibleEnvironmentTemplatesContainer {
            compatibleEnvironmentTemplatesDecoded0 = [ProtonClientTypes.CompatibleEnvironmentTemplateInput]()
            for structure0 in compatibleEnvironmentTemplatesContainer {
                if let structure0 = structure0 {
                    compatibleEnvironmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        compatibleEnvironmentTemplates = compatibleEnvironmentTemplatesDecoded0
        let supportedComponentSourcesContainer = try containerValues.decodeIfPresent([ProtonClientTypes.ServiceTemplateSupportedComponentSourceType?].self, forKey: .supportedComponentSources)
        var supportedComponentSourcesDecoded0:[ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]? = nil
        if let supportedComponentSourcesContainer = supportedComponentSourcesContainer {
            supportedComponentSourcesDecoded0 = [ProtonClientTypes.ServiceTemplateSupportedComponentSourceType]()
            for string0 in supportedComponentSourcesContainer {
                if let string0 = string0 {
                    supportedComponentSourcesDecoded0?.append(string0)
                }
            }
        }
        supportedComponentSources = supportedComponentSourcesDecoded0
    }
}

extension UpdateServiceTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceTemplateVersion = output.serviceTemplateVersion
        } else {
            self.serviceTemplateVersion = nil
        }
    }
}

public struct UpdateServiceTemplateVersionOutput: Swift.Equatable {
    /// The service template version detail data that's returned by Proton.
    /// This member is required.
    public var serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?

    public init(
        serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion? = nil
    )
    {
        self.serviceTemplateVersion = serviceTemplateVersion
    }
}

struct UpdateServiceTemplateVersionOutputBody: Swift.Equatable {
    let serviceTemplateVersion: ProtonClientTypes.ServiceTemplateVersion?
}

extension UpdateServiceTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceTemplateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTemplateVersionDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.ServiceTemplateVersion.self, forKey: .serviceTemplateVersion)
        serviceTemplateVersion = serviceTemplateVersionDecoded
    }
}

enum UpdateServiceTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTemplateSyncConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryProvider = self.repositoryProvider {
            try encodeContainer.encode(repositoryProvider.rawValue, forKey: .repositoryProvider)
        }
        if let subdirectory = self.subdirectory {
            try encodeContainer.encode(subdirectory, forKey: .subdirectory)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension UpdateTemplateSyncConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTemplateSyncConfigInput: Swift.Equatable {
    /// The repository branch for your template.
    /// This member is required.
    public var branch: Swift.String?
    /// The repository name (for example, myrepos/myrepo).
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The repository provider.
    /// This member is required.
    public var repositoryProvider: ProtonClientTypes.RepositoryProvider?
    /// A subdirectory path to your template bundle version. When included, limits the template bundle search to this repository directory.
    public var subdirectory: Swift.String?
    /// The synced template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The synced template type.
    /// This member is required.
    public var templateType: ProtonClientTypes.TemplateType?

    public init(
        branch: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        repositoryProvider: ProtonClientTypes.RepositoryProvider? = nil,
        subdirectory: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateType: ProtonClientTypes.TemplateType? = nil
    )
    {
        self.branch = branch
        self.repositoryName = repositoryName
        self.repositoryProvider = repositoryProvider
        self.subdirectory = subdirectory
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct UpdateTemplateSyncConfigInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateType: ProtonClientTypes.TemplateType?
    let repositoryProvider: ProtonClientTypes.RepositoryProvider?
    let repositoryName: Swift.String?
    let branch: Swift.String?
    let subdirectory: Swift.String?
}

extension UpdateTemplateSyncConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repositoryName
        case repositoryProvider
        case subdirectory
        case templateName
        case templateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let repositoryProviderDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.RepositoryProvider.self, forKey: .repositoryProvider)
        repositoryProvider = repositoryProviderDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let subdirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdirectory)
        subdirectory = subdirectoryDecoded
    }
}

extension UpdateTemplateSyncConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTemplateSyncConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateSyncConfig = output.templateSyncConfig
        } else {
            self.templateSyncConfig = nil
        }
    }
}

public struct UpdateTemplateSyncConfigOutput: Swift.Equatable {
    /// The template sync configuration detail data that's returned by Proton.
    public var templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?

    public init(
        templateSyncConfig: ProtonClientTypes.TemplateSyncConfig? = nil
    )
    {
        self.templateSyncConfig = templateSyncConfig
    }
}

struct UpdateTemplateSyncConfigOutputBody: Swift.Equatable {
    let templateSyncConfig: ProtonClientTypes.TemplateSyncConfig?
}

extension UpdateTemplateSyncConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateSyncConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSyncConfigDecoded = try containerValues.decodeIfPresent(ProtonClientTypes.TemplateSyncConfig.self, forKey: .templateSyncConfig)
        templateSyncConfig = templateSyncConfigDecoded
    }
}

enum UpdateTemplateSyncConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \"CONTENT_REDACTED\")"}
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input is invalid or an out-of-range value was supplied for the input parameter.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
