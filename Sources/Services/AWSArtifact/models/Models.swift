// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ArtifactClientTypes {
    public enum AcceptanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Require explicit click-through acceptance of the Term associated with this Report.
        case explicit
        /// Do not require explicit click-through acceptance of the Term associated with this Report.
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptanceType] {
            return [
                .explicit,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .explicit: return "EXPLICIT"
            case .passthrough: return "PASSTHROUGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptanceType(rawValue: rawValue) ?? AcceptanceType.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ArtifactClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSubscriptionStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationSubscriptionStatus = self.notificationSubscriptionStatus {
            try encodeContainer.encode(notificationSubscriptionStatus.rawValue, forKey: .notificationSubscriptionStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSubscriptionStatusDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.NotificationSubscriptionStatus.self, forKey: .notificationSubscriptionStatus)
        notificationSubscriptionStatus = notificationSubscriptionStatusDecoded
    }
}

extension ArtifactClientTypes {
    /// Account settings for the customer.
    public struct AccountSettings {
        /// Notification subscription status of the customer.
        public var notificationSubscriptionStatus: ArtifactClientTypes.NotificationSubscriptionStatus?

        public init(
            notificationSubscriptionStatus: ArtifactClientTypes.NotificationSubscriptionStatus? = nil
        )
        {
            self.notificationSubscriptionStatus = notificationSubscriptionStatus
        }
    }

}

public enum ArtifactClientTypes {}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request to create/modify content would result in a conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the affected resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        return "/v1/account-settings/get"
    }
}

public struct GetAccountSettingsInput {

    public init() { }
}

struct GetAccountSettingsInputBody {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct GetAccountSettingsOutput {
    /// Account settings for the customer.
    public var accountSettings: ArtifactClientTypes.AccountSettings?

    public init(
        accountSettings: ArtifactClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputBody {
    let accountSettings: ArtifactClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

enum GetAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReportInput {

    static func queryItemProvider(_ value: GetReportInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let reportVersion = value.reportVersion {
            let reportVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportVersion".urlPercentEncoding(), value: Swift.String(reportVersion).urlPercentEncoding())
            items.append(reportVersionQueryItem)
        }
        guard let reportId = value.reportId else {
            let message = "Creating a URL Query Item failed. reportId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let reportIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportId".urlPercentEncoding(), value: Swift.String(reportId).urlPercentEncoding())
        items.append(reportIdQueryItem)
        guard let termToken = value.termToken else {
            let message = "Creating a URL Query Item failed. termToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let termTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "termToken".urlPercentEncoding(), value: Swift.String(termToken).urlPercentEncoding())
        items.append(termTokenQueryItem)
        return items
    }
}

extension GetReportInput {

    static func urlPathProvider(_ value: GetReportInput) -> Swift.String? {
        return "/v1/report/get"
    }
}

public struct GetReportInput {
    /// Unique resource ID for the report resource.
    /// This member is required.
    public var reportId: Swift.String?
    /// Version for the report resource.
    public var reportVersion: Swift.Int?
    /// Unique download token provided by GetTermForReport API.
    /// This member is required.
    public var termToken: Swift.String?

    public init(
        reportId: Swift.String? = nil,
        reportVersion: Swift.Int? = nil,
        termToken: Swift.String? = nil
    )
    {
        self.reportId = reportId
        self.reportVersion = reportVersion
        self.termToken = termToken
    }
}

struct GetReportInputBody {
}

extension GetReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReportMetadataInput {

    static func queryItemProvider(_ value: GetReportMetadataInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let reportVersion = value.reportVersion {
            let reportVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportVersion".urlPercentEncoding(), value: Swift.String(reportVersion).urlPercentEncoding())
            items.append(reportVersionQueryItem)
        }
        guard let reportId = value.reportId else {
            let message = "Creating a URL Query Item failed. reportId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let reportIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportId".urlPercentEncoding(), value: Swift.String(reportId).urlPercentEncoding())
        items.append(reportIdQueryItem)
        return items
    }
}

extension GetReportMetadataInput {

    static func urlPathProvider(_ value: GetReportMetadataInput) -> Swift.String? {
        return "/v1/report/getMetadata"
    }
}

public struct GetReportMetadataInput {
    /// Unique resource ID for the report resource.
    /// This member is required.
    public var reportId: Swift.String?
    /// Version for the report resource.
    public var reportVersion: Swift.Int?

    public init(
        reportId: Swift.String? = nil,
        reportVersion: Swift.Int? = nil
    )
    {
        self.reportId = reportId
        self.reportVersion = reportVersion
    }
}

struct GetReportMetadataInputBody {
}

extension GetReportMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReportMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReportMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportDetails = output.reportDetails
        } else {
            self.reportDetails = nil
        }
    }
}

public struct GetReportMetadataOutput {
    /// Report resource detail.
    public var reportDetails: ArtifactClientTypes.ReportDetail?

    public init(
        reportDetails: ArtifactClientTypes.ReportDetail? = nil
    )
    {
        self.reportDetails = reportDetails
    }
}

struct GetReportMetadataOutputBody {
    let reportDetails: ArtifactClientTypes.ReportDetail?
}

extension GetReportMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDetailsDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.ReportDetail.self, forKey: .reportDetails)
        reportDetails = reportDetailsDecoded
    }
}

enum GetReportMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.documentPresignedUrl = output.documentPresignedUrl
        } else {
            self.documentPresignedUrl = nil
        }
    }
}

public struct GetReportOutput {
    /// Presigned S3 url to access the report content.
    public var documentPresignedUrl: Swift.String?

    public init(
        documentPresignedUrl: Swift.String? = nil
    )
    {
        self.documentPresignedUrl = documentPresignedUrl
    }
}

struct GetReportOutputBody {
    let documentPresignedUrl: Swift.String?
}

extension GetReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentPresignedUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentPresignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentPresignedUrl)
        documentPresignedUrl = documentPresignedUrlDecoded
    }
}

enum GetReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTermForReportInput {

    static func queryItemProvider(_ value: GetTermForReportInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let reportVersion = value.reportVersion {
            let reportVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportVersion".urlPercentEncoding(), value: Swift.String(reportVersion).urlPercentEncoding())
            items.append(reportVersionQueryItem)
        }
        guard let reportId = value.reportId else {
            let message = "Creating a URL Query Item failed. reportId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let reportIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "reportId".urlPercentEncoding(), value: Swift.String(reportId).urlPercentEncoding())
        items.append(reportIdQueryItem)
        return items
    }
}

extension GetTermForReportInput {

    static func urlPathProvider(_ value: GetTermForReportInput) -> Swift.String? {
        return "/v1/report/getTermForReport"
    }
}

public struct GetTermForReportInput {
    /// Unique resource ID for the report resource.
    /// This member is required.
    public var reportId: Swift.String?
    /// Version for the report resource.
    public var reportVersion: Swift.Int?

    public init(
        reportId: Swift.String? = nil,
        reportVersion: Swift.Int? = nil
    )
    {
        self.reportId = reportId
        self.reportVersion = reportVersion
    }
}

struct GetTermForReportInputBody {
}

extension GetTermForReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTermForReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTermForReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.documentPresignedUrl = output.documentPresignedUrl
            self.termToken = output.termToken
        } else {
            self.documentPresignedUrl = nil
            self.termToken = nil
        }
    }
}

public struct GetTermForReportOutput {
    /// Presigned S3 url to access the term content.
    public var documentPresignedUrl: Swift.String?
    /// Unique token representing this request event.
    public var termToken: Swift.String?

    public init(
        documentPresignedUrl: Swift.String? = nil,
        termToken: Swift.String? = nil
    )
    {
        self.documentPresignedUrl = documentPresignedUrl
        self.termToken = termToken
    }
}

struct GetTermForReportOutputBody {
    let documentPresignedUrl: Swift.String?
    let termToken: Swift.String?
}

extension GetTermForReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentPresignedUrl
        case termToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentPresignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentPresignedUrl)
        documentPresignedUrl = documentPresignedUrlDecoded
        let termTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .termToken)
        termToken = termTokenDecoded
    }
}

enum GetTermForReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unknown server exception has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds in which the caller can retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListReportsInput {

    static func queryItemProvider(_ value: ListReportsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListReportsInput {

    static func urlPathProvider(_ value: ListReportsInput) -> Swift.String? {
        return "/v1/report/list"
    }
}

public struct ListReportsInput {
    /// Maximum number of resources to return in the paginated response.
    public var maxResults: Swift.Int?
    /// Pagination token to request the next page of resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportsInputBody {
}

extension ListReportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reports = output.reports
        } else {
            self.nextToken = nil
            self.reports = nil
        }
    }
}

public struct ListReportsOutput {
    /// Pagination token to request the next page of resources.
    public var nextToken: Swift.String?
    /// List of report resources.
    public var reports: [ArtifactClientTypes.ReportSummary]?

    public init(
        nextToken: Swift.String? = nil,
        reports: [ArtifactClientTypes.ReportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reports = reports
    }
}

struct ListReportsOutputBody {
    let reports: [ArtifactClientTypes.ReportSummary]?
    let nextToken: Swift.String?
}

extension ListReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reports
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportsContainer = try containerValues.decodeIfPresent([ArtifactClientTypes.ReportSummary?].self, forKey: .reports)
        var reportsDecoded0:[ArtifactClientTypes.ReportSummary]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [ArtifactClientTypes.ReportSummary]()
            for structure0 in reportsContainer {
                if let structure0 = structure0 {
                    reportsDecoded0?.append(structure0)
                }
            }
        }
        reports = reportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ArtifactClientTypes {
    public enum NotificationSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The account is not subscribed for notification.
        case notSubscribed
        /// The account is subscribed for notification.
        case subscribed
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationSubscriptionStatus] {
            return [
                .notSubscribed,
                .subscribed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notSubscribed: return "NOT_SUBSCRIBED"
            case .subscribed: return "SUBSCRIBED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationSubscriptionStatus(rawValue: rawValue) ?? NotificationSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ArtifactClientTypes {
    public enum PublishedState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The resource is published for consumption.
        case published
        /// The resource is not published for consumption.
        case unpublished
        case sdkUnknown(Swift.String)

        public static var allCases: [PublishedState] {
            return [
                .published,
                .unpublished,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .unpublished: return "UNPUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PublishedState(rawValue: rawValue) ?? PublishedState.sdkUnknown(rawValue)
        }
    }
}

extension PutAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSubscriptionStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationSubscriptionStatus = self.notificationSubscriptionStatus {
            try encodeContainer.encode(notificationSubscriptionStatus.rawValue, forKey: .notificationSubscriptionStatus)
        }
    }
}

extension PutAccountSettingsInput {

    static func urlPathProvider(_ value: PutAccountSettingsInput) -> Swift.String? {
        return "/v1/account-settings/put"
    }
}

public struct PutAccountSettingsInput {
    /// Desired notification subscription status.
    public var notificationSubscriptionStatus: ArtifactClientTypes.NotificationSubscriptionStatus?

    public init(
        notificationSubscriptionStatus: ArtifactClientTypes.NotificationSubscriptionStatus? = nil
    )
    {
        self.notificationSubscriptionStatus = notificationSubscriptionStatus
    }
}

struct PutAccountSettingsInputBody {
    let notificationSubscriptionStatus: ArtifactClientTypes.NotificationSubscriptionStatus?
}

extension PutAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationSubscriptionStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSubscriptionStatusDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.NotificationSubscriptionStatus.self, forKey: .notificationSubscriptionStatus)
        notificationSubscriptionStatus = notificationSubscriptionStatusDecoded
    }
}

extension PutAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct PutAccountSettingsOutput {
    /// Account settings for the customer.
    public var accountSettings: ArtifactClientTypes.AccountSettings?

    public init(
        accountSettings: ArtifactClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct PutAccountSettingsOutputBody {
    let accountSettings: ArtifactClientTypes.AccountSettings?
}

extension PutAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

enum PutAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ArtifactClientTypes.ReportDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceType
        case arn
        case category
        case companyName
        case createdAt
        case deletedAt
        case description
        case id
        case lastModifiedAt
        case name
        case periodEnd
        case periodStart
        case productName
        case sequenceNumber
        case series
        case state
        case statusMessage
        case termArn
        case uploadState
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceType = self.acceptanceType {
            try encodeContainer.encode(acceptanceType.rawValue, forKey: .acceptanceType)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let companyName = self.companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .dateTime, forKey: .deletedAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .dateTime, forKey: .lastModifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let periodEnd = self.periodEnd {
            try encodeContainer.encodeTimestamp(periodEnd, format: .dateTime, forKey: .periodEnd)
        }
        if let periodStart = self.periodStart {
            try encodeContainer.encodeTimestamp(periodStart, format: .dateTime, forKey: .periodStart)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let sequenceNumber = self.sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let series = self.series {
            try encodeContainer.encode(series, forKey: .series)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let termArn = self.termArn {
            try encodeContainer.encode(termArn, forKey: .termArn)
        }
        if let uploadState = self.uploadState {
            try encodeContainer.encode(uploadState.rawValue, forKey: .uploadState)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let periodStartDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .periodStart)
        periodStart = periodStartDecoded
        let periodEndDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .periodEnd)
        periodEnd = periodEndDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.PublishedState.self, forKey: .state)
        state = stateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let seriesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .series)
        series = seriesDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let termArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .termArn)
        termArn = termArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let acceptanceTypeDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.AcceptanceType.self, forKey: .acceptanceType)
        acceptanceType = acceptanceTypeDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let uploadStateDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.UploadState.self, forKey: .uploadState)
        uploadState = uploadStateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ArtifactClientTypes {
    /// Full detail for report resource metadata.
    public struct ReportDetail {
        /// Acceptance type for report.
        public var acceptanceType: ArtifactClientTypes.AcceptanceType?
        /// ARN for the report resource.
        public var arn: Swift.String?
        /// Category for the report resource.
        public var category: Swift.String?
        /// Associated company name for the report resource.
        public var companyName: Swift.String?
        /// Timestamp indicating when the report resource was created.
        public var createdAt: ClientRuntime.Date?
        /// Timestamp indicating when the report resource was deleted.
        public var deletedAt: ClientRuntime.Date?
        /// Description for the report resource.
        public var description: Swift.String?
        /// Unique resource ID for the report resource.
        public var id: Swift.String?
        /// Timestamp indicating when the report resource was last modified.
        public var lastModifiedAt: ClientRuntime.Date?
        /// Name for the report resource.
        public var name: Swift.String?
        /// Timestamp indicating the report resource effective end.
        public var periodEnd: ClientRuntime.Date?
        /// Timestamp indicating the report resource effective start.
        public var periodStart: ClientRuntime.Date?
        /// Associated product name for the report resource.
        public var productName: Swift.String?
        /// Sequence number to enforce optimistic locking.
        public var sequenceNumber: Swift.Int?
        /// Series for the report resource.
        public var series: Swift.String?
        /// Current state of the report resource
        public var state: ArtifactClientTypes.PublishedState?
        /// The message associated with the current upload state.
        public var statusMessage: Swift.String?
        /// Unique resource ARN for term resource.
        public var termArn: Swift.String?
        /// The current state of the document upload.
        public var uploadState: ArtifactClientTypes.UploadState?
        /// Version for the report resource.
        public var version: Swift.Int?

        public init(
            acceptanceType: ArtifactClientTypes.AcceptanceType? = nil,
            arn: Swift.String? = nil,
            category: Swift.String? = nil,
            companyName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            periodEnd: ClientRuntime.Date? = nil,
            periodStart: ClientRuntime.Date? = nil,
            productName: Swift.String? = nil,
            sequenceNumber: Swift.Int? = nil,
            series: Swift.String? = nil,
            state: ArtifactClientTypes.PublishedState? = nil,
            statusMessage: Swift.String? = nil,
            termArn: Swift.String? = nil,
            uploadState: ArtifactClientTypes.UploadState? = nil,
            version: Swift.Int? = nil
        )
        {
            self.acceptanceType = acceptanceType
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.description = description
            self.id = id
            self.lastModifiedAt = lastModifiedAt
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.sequenceNumber = sequenceNumber
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.termArn = termArn
            self.uploadState = uploadState
            self.version = version
        }
    }

}

extension ArtifactClientTypes.ReportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case category
        case companyName
        case description
        case id
        case name
        case periodEnd
        case periodStart
        case productName
        case series
        case state
        case statusMessage
        case uploadState
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let companyName = self.companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let periodEnd = self.periodEnd {
            try encodeContainer.encodeTimestamp(periodEnd, format: .dateTime, forKey: .periodEnd)
        }
        if let periodStart = self.periodStart {
            try encodeContainer.encodeTimestamp(periodStart, format: .dateTime, forKey: .periodStart)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let series = self.series {
            try encodeContainer.encode(series, forKey: .series)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let uploadState = self.uploadState {
            try encodeContainer.encode(uploadState.rawValue, forKey: .uploadState)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.PublishedState.self, forKey: .state)
        state = stateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let uploadStateDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.UploadState.self, forKey: .uploadState)
        uploadState = uploadStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let periodStartDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .periodStart)
        periodStart = periodStartDecoded
        let periodEndDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .periodEnd)
        periodEnd = periodEndDecoded
        let seriesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .series)
        series = seriesDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ArtifactClientTypes {
    /// Summary for report resource.
    public struct ReportSummary {
        /// ARN for the report resource.
        public var arn: Swift.String?
        /// Category for the report resource.
        public var category: Swift.String?
        /// Associated company name for the report resource.
        public var companyName: Swift.String?
        /// Description for the report resource.
        public var description: Swift.String?
        /// Unique resource ID for the report resource.
        public var id: Swift.String?
        /// Name for the report resource.
        public var name: Swift.String?
        /// Timestamp indicating the report resource effective end.
        public var periodEnd: ClientRuntime.Date?
        /// Timestamp indicating the report resource effective start.
        public var periodStart: ClientRuntime.Date?
        /// Associated product name for the report resource.
        public var productName: Swift.String?
        /// Series for the report resource.
        public var series: Swift.String?
        /// Current state of the report resource.
        public var state: ArtifactClientTypes.PublishedState?
        /// The message associated with the current upload state.
        public var statusMessage: Swift.String?
        /// The current state of the document upload.
        public var uploadState: ArtifactClientTypes.UploadState?
        /// Version for the report resource.
        public var version: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            category: Swift.String? = nil,
            companyName: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            periodEnd: ClientRuntime.Date? = nil,
            periodStart: ClientRuntime.Date? = nil,
            productName: Swift.String? = nil,
            series: Swift.String? = nil,
            state: ArtifactClientTypes.PublishedState? = nil,
            statusMessage: Swift.String? = nil,
            uploadState: ArtifactClientTypes.UploadState? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.category = category
            self.companyName = companyName
            self.description = description
            self.id = id
            self.name = name
            self.periodEnd = periodEnd
            self.periodStart = periodStart
            self.productName = productName
            self.series = series
            self.state = state
            self.statusMessage = statusMessage
            self.uploadState = uploadState
            self.version = version
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the affected resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Code for the affected quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the affected resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Code for the affected service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Code for the affected quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Number of seconds in which the caller can retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Code for the affected service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ArtifactClientTypes {
    public enum UploadState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case fault
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadState] {
            return [
                .complete,
                .failed,
                .fault,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .fault: return "FAULT"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadState(rawValue: rawValue) ?? UploadState.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [ArtifactClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: ArtifactClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [ArtifactClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ArtifactClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let reason: ArtifactClientTypes.ValidationExceptionReason?
    let fieldList: [ArtifactClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ArtifactClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([ArtifactClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[ArtifactClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [ArtifactClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension ArtifactClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ArtifactClientTypes {
    /// Validation exception message and name.
    public struct ValidationExceptionField {
        /// Message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// Name of validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension ArtifactClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case invalidToken
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .invalidToken,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidToken: return "invalidToken"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
