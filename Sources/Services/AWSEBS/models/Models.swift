// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: EBSClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: EBSClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EBSClientTypes.AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EBSClientTypes.AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EBSClientTypes {
    public enum AccessDeniedExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyAccessDenied
        case unauthorizedAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .dependencyAccessDenied,
                .unauthorizedAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDenied: return "DEPENDENCY_ACCESS_DENIED"
            case .unauthorizedAccount: return "UNAUTHORIZED_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension EBSClientTypes.Block: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockIndex = "BlockIndex"
        case blockToken = "BlockToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = self.blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let blockToken = self.blockToken {
            try encodeContainer.encode(blockToken, forKey: .blockToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let blockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockToken)
        blockToken = blockTokenDecoded
    }
}

extension EBSClientTypes {
    /// A block of data in an Amazon Elastic Block Store snapshot.
    public struct Block: Swift.Equatable {
        /// The block index.
        public var blockIndex: Swift.Int?
        /// The block token for the block index.
        public var blockToken: Swift.String?

        public init(
            blockIndex: Swift.Int? = nil,
            blockToken: Swift.String? = nil
        )
        {
            self.blockIndex = blockIndex
            self.blockToken = blockToken
        }
    }

}

extension EBSClientTypes.ChangedBlock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockIndex = "BlockIndex"
        case firstBlockToken = "FirstBlockToken"
        case secondBlockToken = "SecondBlockToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = self.blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let firstBlockToken = self.firstBlockToken {
            try encodeContainer.encode(firstBlockToken, forKey: .firstBlockToken)
        }
        if let secondBlockToken = self.secondBlockToken {
            try encodeContainer.encode(secondBlockToken, forKey: .secondBlockToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let firstBlockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstBlockToken)
        firstBlockToken = firstBlockTokenDecoded
        let secondBlockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondBlockToken)
        secondBlockToken = secondBlockTokenDecoded
    }
}

extension EBSClientTypes.ChangedBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension EBSClientTypes {
    /// A block of data in an Amazon Elastic Block Store snapshot that is different from another snapshot of the same volume/snapshot lineage.
    public struct ChangedBlock: Swift.Equatable {
        /// The block index.
        public var blockIndex: Swift.Int?
        /// The block token for the block index of the FirstSnapshotId specified in the ListChangedBlocks operation. This value is absent if the first snapshot does not have the changed block that is on the second snapshot.
        public var firstBlockToken: Swift.String?
        /// The block token for the block index of the SecondSnapshotId specified in the ListChangedBlocks operation.
        public var secondBlockToken: Swift.String?

        public init(
            blockIndex: Swift.Int? = nil,
            firstBlockToken: Swift.String? = nil,
            secondBlockToken: Swift.String? = nil
        )
        {
            self.blockIndex = blockIndex
            self.firstBlockToken = firstBlockToken
            self.secondBlockToken = secondBlockToken
        }
    }

}

extension EBSClientTypes {
    public enum ChecksumAggregationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checksumAggregationLinear
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumAggregationMethod] {
            return [
                .checksumAggregationLinear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checksumAggregationLinear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChecksumAggregationMethod(rawValue: rawValue) ?? ChecksumAggregationMethod.sdkUnknown(rawValue)
        }
    }
}

extension EBSClientTypes {
    public enum ChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checksumAlgorithmSha256
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumAlgorithm] {
            return [
                .checksumAlgorithmSha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checksumAlgorithmSha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChecksumAlgorithm(rawValue: rawValue) ?? ChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension CompleteSnapshotInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let changedBlocksCount = changedBlocksCount {
            items.add(Header(name: "x-amz-ChangedBlocksCount", value: Swift.String(changedBlocksCount)))
        }
        if let checksum = checksum {
            items.add(Header(name: "x-amz-Checksum", value: Swift.String(checksum)))
        }
        if let checksumAggregationMethod = checksumAggregationMethod {
            items.add(Header(name: "x-amz-Checksum-Aggregation-Method", value: Swift.String(checksumAggregationMethod.rawValue)))
        }
        if let checksumAlgorithm = checksumAlgorithm {
            items.add(Header(name: "x-amz-Checksum-Algorithm", value: Swift.String(checksumAlgorithm.rawValue)))
        }
        return items
    }
}

extension CompleteSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/snapshots/completion/\(snapshotId.urlPercentEncoding())"
    }
}

public struct CompleteSnapshotInput: Swift.Equatable {
    /// The number of blocks that were written to the snapshot.
    /// This member is required.
    public var changedBlocksCount: Swift.Int?
    /// An aggregated Base-64 SHA256 checksum based on the checksums of each written block. To generate the aggregated checksum using the linear aggregation method, arrange the checksums for each written block in ascending order of their block index, concatenate them to form a single string, and then generate the checksum on the entire string using the SHA256 algorithm.
    public var checksum: Swift.String?
    /// The aggregation method used to generate the checksum. Currently, the only supported aggregation method is LINEAR.
    public var checksumAggregationMethod: EBSClientTypes.ChecksumAggregationMethod?
    /// The algorithm used to generate the checksum. Currently, the only supported algorithm is SHA256.
    public var checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm?
    /// The ID of the snapshot.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        changedBlocksCount: Swift.Int? = nil,
        checksum: Swift.String? = nil,
        checksumAggregationMethod: EBSClientTypes.ChecksumAggregationMethod? = nil,
        checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.changedBlocksCount = changedBlocksCount
        self.checksum = checksum
        self.checksumAggregationMethod = checksumAggregationMethod
        self.checksumAlgorithm = checksumAlgorithm
        self.snapshotId = snapshotId
    }
}

struct CompleteSnapshotInputBody: Swift.Equatable {
}

extension CompleteSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CompleteSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CompleteSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CompleteSnapshotOutput: Swift.Equatable {
    /// The status of the snapshot.
    public var status: EBSClientTypes.Status?

    public init(
        status: EBSClientTypes.Status? = nil
    )
    {
        self.status = status
    }
}

struct CompleteSnapshotOutputBody: Swift.Equatable {
    let status: EBSClientTypes.Status?
}

extension CompleteSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EBSClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum CompleteSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConcurrentLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the limit for concurrent API requests. For more information, see [Optimizing performance of the EBS direct APIs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapi-performance) in the Amazon Elastic Compute Cloud User Guide.
public struct ConcurrentLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request uses the same client token as a previous, but non-identical request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetSnapshotBlockInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let blockToken = blockToken else {
                let message = "Creating a URL Query Item failed. blockToken is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let blockTokenQueryItem = ClientRuntime.URLQueryItem(name: "blockToken".urlPercentEncoding(), value: Swift.String(blockToken).urlPercentEncoding())
            items.append(blockTokenQueryItem)
            return items
        }
    }
}

extension GetSnapshotBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotId = snapshotId else {
            return nil
        }
        guard let blockIndex = blockIndex else {
            return nil
        }
        return "/snapshots/\(snapshotId.urlPercentEncoding())/blocks/\(blockIndex)"
    }
}

public struct GetSnapshotBlockInput: Swift.Equatable {
    /// The block index of the block in which to read the data. A block index is a logical index in units of 512 KiB blocks. To identify the block index, divide the logical offset of the data in the logical volume by the block size (logical offset of data/524288). The logical offset of the data must be 512 KiB aligned.
    /// This member is required.
    public var blockIndex: Swift.Int?
    /// The block token of the block from which to get data. You can obtain the BlockToken by running the ListChangedBlocks or ListSnapshotBlocks operations.
    /// This member is required.
    public var blockToken: Swift.String?
    /// The ID of the snapshot containing the block from which to get data. If the specified snapshot is encrypted, you must have permission to use the KMS key that was used to encrypt the snapshot. For more information, see [ Using encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapis-using-encryption.html) in the Amazon Elastic Compute Cloud User Guide.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        blockIndex: Swift.Int? = nil,
        blockToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.blockIndex = blockIndex
        self.blockToken = blockToken
        self.snapshotId = snapshotId
    }
}

struct GetSnapshotBlockInputBody: Swift.Equatable {
}

extension GetSnapshotBlockInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSnapshotBlockOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSnapshotBlockOutput(checksum: \(Swift.String(describing: checksum)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)), dataLength: \(Swift.String(describing: dataLength)), blockData: \"CONTENT_REDACTED\")"}
}

extension GetSnapshotBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = EBSClientTypes.ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
        if let dataLengthHeaderValue = httpResponse.headers.value(for: "x-amz-Data-Length") {
            self.dataLength = Swift.Int(dataLengthHeaderValue) ?? 0
        } else {
            self.dataLength = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.blockData = .data(data)
        case .stream(let stream):
            self.blockData = .stream(stream)
        case .none:
            self.blockData = nil
        }
    }
}

public struct GetSnapshotBlockOutput: Swift.Equatable {
    /// The data content of the block.
    public var blockData: ClientRuntime.ByteStream?
    /// The checksum generated for the block, which is Base64 encoded.
    public var checksum: Swift.String?
    /// The algorithm used to generate the checksum for the block, such as SHA256.
    public var checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm?
    /// The size of the data in the block.
    public var dataLength: Swift.Int?

    public init(
        blockData: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm? = nil,
        dataLength: Swift.Int? = nil
    )
    {
        self.blockData = blockData
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
    }
}

struct GetSnapshotBlockOutputBody: Swift.Equatable {
    let blockData: ClientRuntime.ByteStream?
}

extension GetSnapshotBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

enum GetSnapshotBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred. For more information see [Error retries](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/error-retries.html).
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangedBlocksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let firstSnapshotId = firstSnapshotId {
                let firstSnapshotIdQueryItem = ClientRuntime.URLQueryItem(name: "firstSnapshotId".urlPercentEncoding(), value: Swift.String(firstSnapshotId).urlPercentEncoding())
                items.append(firstSnapshotIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "pageToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let startingBlockIndex = startingBlockIndex {
                let startingBlockIndexQueryItem = ClientRuntime.URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: Swift.String(startingBlockIndex).urlPercentEncoding())
                items.append(startingBlockIndexQueryItem)
            }
            return items
        }
    }
}

extension ListChangedBlocksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let secondSnapshotId = secondSnapshotId else {
            return nil
        }
        return "/snapshots/\(secondSnapshotId.urlPercentEncoding())/changedblocks"
    }
}

public struct ListChangedBlocksInput: Swift.Equatable {
    /// The ID of the first snapshot to use for the comparison. The FirstSnapshotID parameter must be specified with a SecondSnapshotId parameter; otherwise, an error occurs.
    public var firstSnapshotId: Swift.String?
    /// The maximum number of blocks to be returned by the request. Even if additional blocks can be retrieved from the snapshot, the request can return less blocks than MaxResults or an empty array of blocks. To retrieve the next set of blocks from the snapshot, make another request with the returned NextToken value. The value of NextToken is null when there are no more blocks to return.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results. If you specify NextToken, then StartingBlockIndex is ignored.
    public var nextToken: Swift.String?
    /// The ID of the second snapshot to use for the comparison. The SecondSnapshotId parameter must be specified with a FirstSnapshotID parameter; otherwise, an error occurs.
    /// This member is required.
    public var secondSnapshotId: Swift.String?
    /// The block index from which the comparison should start. The list in the response will start from this block index or the next valid block index in the snapshots. If you specify NextToken, then StartingBlockIndex is ignored.
    public var startingBlockIndex: Swift.Int?

    public init(
        firstSnapshotId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        secondSnapshotId: Swift.String? = nil,
        startingBlockIndex: Swift.Int? = nil
    )
    {
        self.firstSnapshotId = firstSnapshotId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secondSnapshotId = secondSnapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListChangedBlocksInputBody: Swift.Equatable {
}

extension ListChangedBlocksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChangedBlocksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChangedBlocksOutputBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.changedBlocks = output.changedBlocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.changedBlocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListChangedBlocksOutput: Swift.Equatable {
    /// The size of the blocks in the snapshot, in bytes.
    public var blockSize: Swift.Int?
    /// An array of objects containing information about the changed blocks.
    public var changedBlocks: [EBSClientTypes.ChangedBlock]?
    /// The time when the BlockToken expires.
    public var expiryTime: ClientRuntime.Date?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The size of the volume in GB.
    public var volumeSize: Swift.Int?

    public init(
        blockSize: Swift.Int? = nil,
        changedBlocks: [EBSClientTypes.ChangedBlock]? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.changedBlocks = changedBlocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListChangedBlocksOutputBody: Swift.Equatable {
    let changedBlocks: [EBSClientTypes.ChangedBlock]?
    let expiryTime: ClientRuntime.Date?
    let volumeSize: Swift.Int?
    let blockSize: Swift.Int?
    let nextToken: Swift.String?
}

extension ListChangedBlocksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case changedBlocks = "ChangedBlocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changedBlocksContainer = try containerValues.decodeIfPresent([EBSClientTypes.ChangedBlock?].self, forKey: .changedBlocks)
        var changedBlocksDecoded0:[EBSClientTypes.ChangedBlock]? = nil
        if let changedBlocksContainer = changedBlocksContainer {
            changedBlocksDecoded0 = [EBSClientTypes.ChangedBlock]()
            for structure0 in changedBlocksContainer {
                if let structure0 = structure0 {
                    changedBlocksDecoded0?.append(structure0)
                }
            }
        }
        changedBlocks = changedBlocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChangedBlocksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSnapshotBlocksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "pageToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let startingBlockIndex = startingBlockIndex {
                let startingBlockIndexQueryItem = ClientRuntime.URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: Swift.String(startingBlockIndex).urlPercentEncoding())
                items.append(startingBlockIndexQueryItem)
            }
            return items
        }
    }
}

extension ListSnapshotBlocksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotId = snapshotId else {
            return nil
        }
        return "/snapshots/\(snapshotId.urlPercentEncoding())/blocks"
    }
}

public struct ListSnapshotBlocksInput: Swift.Equatable {
    /// The maximum number of blocks to be returned by the request. Even if additional blocks can be retrieved from the snapshot, the request can return less blocks than MaxResults or an empty array of blocks. To retrieve the next set of blocks from the snapshot, make another request with the returned NextToken value. The value of NextToken is null when there are no more blocks to return.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results. If you specify NextToken, then StartingBlockIndex is ignored.
    public var nextToken: Swift.String?
    /// The ID of the snapshot from which to get block indexes and block tokens.
    /// This member is required.
    public var snapshotId: Swift.String?
    /// The block index from which the list should start. The list in the response will start from this block index or the next valid block index in the snapshot. If you specify NextToken, then StartingBlockIndex is ignored.
    public var startingBlockIndex: Swift.Int?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        startingBlockIndex: Swift.Int? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotId = snapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListSnapshotBlocksInputBody: Swift.Equatable {
}

extension ListSnapshotBlocksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSnapshotBlocksOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSnapshotBlocksOutput(blockSize: \(Swift.String(describing: blockSize)), expiryTime: \(Swift.String(describing: expiryTime)), nextToken: \(Swift.String(describing: nextToken)), volumeSize: \(Swift.String(describing: volumeSize)), blocks: \"CONTENT_REDACTED\")"}
}

extension ListSnapshotBlocksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSnapshotBlocksOutputBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.blocks = output.blocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.blocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListSnapshotBlocksOutput: Swift.Equatable {
    /// The size of the blocks in the snapshot, in bytes.
    public var blockSize: Swift.Int?
    /// An array of objects containing information about the blocks.
    public var blocks: [EBSClientTypes.Block]?
    /// The time when the BlockToken expires.
    public var expiryTime: ClientRuntime.Date?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The size of the volume in GB.
    public var volumeSize: Swift.Int?

    public init(
        blockSize: Swift.Int? = nil,
        blocks: [EBSClientTypes.Block]? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.blocks = blocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListSnapshotBlocksOutputBody: Swift.Equatable {
    let blocks: [EBSClientTypes.Block]?
    let expiryTime: ClientRuntime.Date?
    let volumeSize: Swift.Int?
    let blockSize: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSnapshotBlocksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case blocks = "Blocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blocksContainer = try containerValues.decodeIfPresent([EBSClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[EBSClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [EBSClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSnapshotBlocksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct PutSnapshotBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSnapshotBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutSnapshotBlockOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let blockData = input.operationInput.blockData {
            let blockDataBody = ClientRuntime.HttpBody(byteStream: blockData)
            input.builder.withBody(blockDataBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSnapshotBlockOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutSnapshotBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSnapshotBlockInput(blockIndex: \(Swift.String(describing: blockIndex)), checksum: \(Swift.String(describing: checksum)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)), dataLength: \(Swift.String(describing: dataLength)), progress: \(Swift.String(describing: progress)), snapshotId: \(Swift.String(describing: snapshotId)), blockData: \"CONTENT_REDACTED\")"}
}

extension PutSnapshotBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockData = self.blockData {
            try encodeContainer.encode(blockData, forKey: .blockData)
        }
    }
}

extension PutSnapshotBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let checksum = checksum {
            items.add(Header(name: "x-amz-Checksum", value: Swift.String(checksum)))
        }
        if let checksumAlgorithm = checksumAlgorithm {
            items.add(Header(name: "x-amz-Checksum-Algorithm", value: Swift.String(checksumAlgorithm.rawValue)))
        }
        if let dataLength = dataLength {
            items.add(Header(name: "x-amz-Data-Length", value: Swift.String(dataLength)))
        }
        if let progress = progress {
            items.add(Header(name: "x-amz-Progress", value: Swift.String(progress)))
        }
        return items
    }
}

extension PutSnapshotBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotId = snapshotId else {
            return nil
        }
        guard let blockIndex = blockIndex else {
            return nil
        }
        return "/snapshots/\(snapshotId.urlPercentEncoding())/blocks/\(blockIndex)"
    }
}

public struct PutSnapshotBlockInput: Swift.Equatable {
    /// The data to write to the block. The block data is not signed as part of the Signature Version 4 signing process. As a result, you must generate and provide a Base64-encoded SHA256 checksum for the block data using the x-amz-Checksum header. Also, you must specify the checksum algorithm using the x-amz-Checksum-Algorithm header. The checksum that you provide is part of the Signature Version 4 signing process. It is validated against a checksum generated by Amazon EBS to ensure the validity and authenticity of the data. If the checksums do not correspond, the request fails. For more information, see [ Using checksums with the EBS direct APIs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapis-using-checksums) in the Amazon Elastic Compute Cloud User Guide.
    /// This member is required.
    public var blockData: ClientRuntime.ByteStream?
    /// The block index of the block in which to write the data. A block index is a logical index in units of 512 KiB blocks. To identify the block index, divide the logical offset of the data in the logical volume by the block size (logical offset of data/524288). The logical offset of the data must be 512 KiB aligned.
    /// This member is required.
    public var blockIndex: Swift.Int?
    /// A Base64-encoded SHA256 checksum of the data. Only SHA256 checksums are supported.
    /// This member is required.
    public var checksum: Swift.String?
    /// The algorithm used to generate the checksum. Currently, the only supported algorithm is SHA256.
    /// This member is required.
    public var checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm?
    /// The size of the data to write to the block, in bytes. Currently, the only supported size is 524288 bytes. Valid values: 524288
    /// This member is required.
    public var dataLength: Swift.Int?
    /// The progress of the write process, as a percentage.
    public var progress: Swift.Int?
    /// The ID of the snapshot. If the specified snapshot is encrypted, you must have permission to use the KMS key that was used to encrypt the snapshot. For more information, see [ Using encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapis-using-encryption.html) in the Amazon Elastic Compute Cloud User Guide..
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        blockData: ClientRuntime.ByteStream? = nil,
        blockIndex: Swift.Int? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm? = nil,
        dataLength: Swift.Int? = nil,
        progress: Swift.Int? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.blockData = blockData
        self.blockIndex = blockIndex
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
        self.progress = progress
        self.snapshotId = snapshotId
    }
}

struct PutSnapshotBlockInputBody: Swift.Equatable {
    let blockData: ClientRuntime.ByteStream?
}

extension PutSnapshotBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

extension PutSnapshotBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = EBSClientTypes.ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
    }
}

public struct PutSnapshotBlockOutput: Swift.Equatable {
    /// The SHA256 checksum generated for the block data by Amazon EBS.
    public var checksum: Swift.String?
    /// The algorithm used by Amazon EBS to generate the checksum.
    public var checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm?

    public init(
        checksum: Swift.String? = nil,
        checksumAlgorithm: EBSClientTypes.ChecksumAlgorithm? = nil
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
    }
}

enum PutSnapshotBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of API requests has exceeded the maximum allowed API request throttling limit for the snapshot. For more information see [Error retries](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/error-retries.html).
public struct RequestThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: EBSClientTypes.RequestThrottledExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestThrottledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: EBSClientTypes.RequestThrottledExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct RequestThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EBSClientTypes.RequestThrottledExceptionReason?
}

extension RequestThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EBSClientTypes.RequestThrottledExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EBSClientTypes {
    public enum RequestThrottledExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountThrottled
        case dependencyRequestThrottled
        case resourceLevelThrottle
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestThrottledExceptionReason] {
            return [
                .accountThrottled,
                .dependencyRequestThrottled,
                .resourceLevelThrottle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountThrottled: return "ACCOUNT_THROTTLED"
            case .dependencyRequestThrottled: return "DEPENDENCY_REQUEST_THROTTLED"
            case .resourceLevelThrottle: return "RESOURCE_LEVEL_THROTTLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestThrottledExceptionReason(rawValue: rawValue) ?? RequestThrottledExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: EBSClientTypes.ResourceNotFoundExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: EBSClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EBSClientTypes.ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EBSClientTypes.ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EBSClientTypes {
    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyResourceNotFound
        case grantNotFound
        case imageNotFound
        case snapshotNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .dependencyResourceNotFound,
                .grantNotFound,
                .imageNotFound,
                .snapshotNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyResourceNotFound: return "DEPENDENCY_RESOURCE_NOT_FOUND"
            case .grantNotFound: return "GRANT_NOT_FOUND"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .snapshotNotFound: return "SNAPSHOT_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension EBSClientTypes {
    public enum SSEType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sseEbs
        case sseKms
        case sdkUnknown(Swift.String)

        public static var allCases: [SSEType] {
            return [
                .none,
                .sseEbs,
                .sseKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .sseEbs: return "sse-ebs"
            case .sseKms: return "sse-kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSEType(rawValue: rawValue) ?? SSEType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your current service quotas do not allow you to perform this action.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: EBSClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: EBSClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EBSClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EBSClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EBSClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyServiceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .dependencyServiceQuotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyServiceQuotaExceeded: return "DEPENDENCY_SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension StartSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSnapshotInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), encrypted: \(Swift.String(describing: encrypted)), parentSnapshotId: \(Swift.String(describing: parentSnapshotId)), tags: \(Swift.String(describing: tags)), timeout: \(Swift.String(describing: timeout)), volumeSize: \(Swift.String(describing: volumeSize)), kmsKeyArn: \"CONTENT_REDACTED\")"}
}

extension StartSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let parentSnapshotId = self.parentSnapshotId {
            try encodeContainer.encode(parentSnapshotId, forKey: .parentSnapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }
}

extension StartSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/snapshots"
    }
}

public struct StartSnapshotInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully. The subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK. For more information, see [ Idempotency for StartSnapshot API](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-direct-api-idempotency.html) in the Amazon Elastic Compute Cloud User Guide.
    public var clientToken: Swift.String?
    /// A description for the snapshot.
    public var description: Swift.String?
    /// Indicates whether to encrypt the snapshot. You can't specify Encrypted and ParentSnapshotId in the same request. If you specify both parameters, the request fails with ValidationException. The encryption status of the snapshot depends on the values that you specify for Encrypted, KmsKeyArn, and ParentSnapshotId, and whether your Amazon Web Services account is enabled for [ encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default). For more information, see [ Using encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapis-using-encryption.html) in the Amazon Elastic Compute Cloud User Guide. To create an encrypted snapshot, you must have permission to use the KMS key. For more information, see [ Permissions to use Key Management Service keys](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapi-permissions.html#ebsapi-kms-permissions) in the Amazon Elastic Compute Cloud User Guide.
    public var encrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key to be used to encrypt the snapshot. The encryption status of the snapshot depends on the values that you specify for Encrypted, KmsKeyArn, and ParentSnapshotId, and whether your Amazon Web Services account is enabled for [ encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default). For more information, see [ Using encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapis-using-encryption.html) in the Amazon Elastic Compute Cloud User Guide. To create an encrypted snapshot, you must have permission to use the KMS key. For more information, see [ Permissions to use Key Management Service keys](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapi-permissions.html#ebsapi-kms-permissions) in the Amazon Elastic Compute Cloud User Guide.
    public var kmsKeyArn: Swift.String?
    /// The ID of the parent snapshot. If there is no parent snapshot, or if you are creating the first snapshot for an on-premises volume, omit this parameter. You can't specify ParentSnapshotId and Encrypted in the same request. If you specify both parameters, the request fails with ValidationException. The encryption status of the snapshot depends on the values that you specify for Encrypted, KmsKeyArn, and ParentSnapshotId, and whether your Amazon Web Services account is enabled for [ encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default). For more information, see [ Using encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapis-using-encryption.html) in the Amazon Elastic Compute Cloud User Guide. If you specify an encrypted parent snapshot, you must have permission to use the KMS key that was used to encrypt the parent snapshot. For more information, see [ Permissions to use Key Management Service keys](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebsapi-permissions.html#ebsapi-kms-permissions) in the Amazon Elastic Compute Cloud User Guide.
    public var parentSnapshotId: Swift.String?
    /// The tags to apply to the snapshot.
    public var tags: [EBSClientTypes.Tag]?
    /// The amount of time (in minutes) after which the snapshot is automatically cancelled if:
    ///
    /// * No blocks are written to the snapshot.
    ///
    /// * The snapshot is not completed after writing the last block of data.
    ///
    ///
    /// If no value is specified, the timeout defaults to 60 minutes.
    public var timeout: Swift.Int?
    /// The size of the volume, in GiB. The maximum size is 65536 GiB (64 TiB).
    /// This member is required.
    public var volumeSize: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        kmsKeyArn: Swift.String? = nil,
        parentSnapshotId: Swift.String? = nil,
        tags: [EBSClientTypes.Tag]? = nil,
        timeout: Swift.Int? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyArn = kmsKeyArn
        self.parentSnapshotId = parentSnapshotId
        self.tags = tags
        self.timeout = timeout
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotInputBody: Swift.Equatable {
    let volumeSize: Swift.Int?
    let parentSnapshotId: Swift.String?
    let tags: [EBSClientTypes.Tag]?
    let description: Swift.String?
    let clientToken: Swift.String?
    let encrypted: Swift.Bool?
    let kmsKeyArn: Swift.String?
    let timeout: Swift.Int?
}

extension StartSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EBSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EBSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EBSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension StartSnapshotOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSnapshotOutput(blockSize: \(Swift.String(describing: blockSize)), description: \(Swift.String(describing: description)), ownerId: \(Swift.String(describing: ownerId)), parentSnapshotId: \(Swift.String(describing: parentSnapshotId)), snapshotId: \(Swift.String(describing: snapshotId)), sseType: \(Swift.String(describing: sseType)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), volumeSize: \(Swift.String(describing: volumeSize)), kmsKeyArn: \"CONTENT_REDACTED\")"}
}

extension StartSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.description = output.description
            self.kmsKeyArn = output.kmsKeyArn
            self.ownerId = output.ownerId
            self.parentSnapshotId = output.parentSnapshotId
            self.snapshotId = output.snapshotId
            self.sseType = output.sseType
            self.startTime = output.startTime
            self.status = output.status
            self.tags = output.tags
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.description = nil
            self.kmsKeyArn = nil
            self.ownerId = nil
            self.parentSnapshotId = nil
            self.snapshotId = nil
            self.sseType = nil
            self.startTime = nil
            self.status = nil
            self.tags = nil
            self.volumeSize = nil
        }
    }
}

public struct StartSnapshotOutput: Swift.Equatable {
    /// The size of the blocks in the snapshot, in bytes.
    public var blockSize: Swift.Int?
    /// The description of the snapshot.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the snapshot.
    public var kmsKeyArn: Swift.String?
    /// The Amazon Web Services account ID of the snapshot owner.
    public var ownerId: Swift.String?
    /// The ID of the parent snapshot.
    public var parentSnapshotId: Swift.String?
    /// The ID of the snapshot.
    public var snapshotId: Swift.String?
    /// Reserved for future use.
    public var sseType: EBSClientTypes.SSEType?
    /// The timestamp when the snapshot was created.
    public var startTime: ClientRuntime.Date?
    /// The status of the snapshot.
    public var status: EBSClientTypes.Status?
    /// The tags applied to the snapshot. You can specify up to 50 tags per snapshot. For more information, see [ Tagging your Amazon EC2 resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html) in the Amazon Elastic Compute Cloud User Guide.
    public var tags: [EBSClientTypes.Tag]?
    /// The size of the volume, in GiB.
    public var volumeSize: Swift.Int?

    public init(
        blockSize: Swift.Int? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        parentSnapshotId: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        sseType: EBSClientTypes.SSEType? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EBSClientTypes.Status? = nil,
        tags: [EBSClientTypes.Tag]? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.ownerId = ownerId
        self.parentSnapshotId = parentSnapshotId
        self.snapshotId = snapshotId
        self.sseType = sseType
        self.startTime = startTime
        self.status = status
        self.tags = tags
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotOutputBody: Swift.Equatable {
    let description: Swift.String?
    let snapshotId: Swift.String?
    let ownerId: Swift.String?
    let status: EBSClientTypes.Status?
    let startTime: ClientRuntime.Date?
    let volumeSize: Swift.Int?
    let blockSize: Swift.Int?
    let tags: [EBSClientTypes.Tag]?
    let parentSnapshotId: Swift.String?
    let kmsKeyArn: Swift.String?
    let sseType: EBSClientTypes.SSEType?
}

extension StartSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case description = "Description"
        case kmsKeyArn = "KmsKeyArn"
        case ownerId = "OwnerId"
        case parentSnapshotId = "ParentSnapshotId"
        case snapshotId = "SnapshotId"
        case sseType = "SseType"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
        case volumeSize = "VolumeSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EBSClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EBSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EBSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EBSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let sseTypeDecoded = try containerValues.decodeIfPresent(EBSClientTypes.SSEType.self, forKey: .sseType)
        sseType = sseTypeDecoded
    }
}

enum StartSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentLimitExceededException": return try await ConcurrentLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EBSClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .error: return "error"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension EBSClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EBSClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints of the EBS direct APIs.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: EBSClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: EBSClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: EBSClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EBSClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EBSClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conflictingBlockUpdate
        case invalidBlock
        case invalidBlockToken
        case invalidContentEncoding
        case invalidCustomerKey
        case invalidDependencyRequest
        case invalidGrantToken
        case invalidImageId
        case invalidPageToken
        case invalidParameterValue
        case invalidSnapshotId
        case invalidTag
        case invalidVolumeSize
        case unrelatedSnapshots
        case writeRequestTimeout
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .conflictingBlockUpdate,
                .invalidBlock,
                .invalidBlockToken,
                .invalidContentEncoding,
                .invalidCustomerKey,
                .invalidDependencyRequest,
                .invalidGrantToken,
                .invalidImageId,
                .invalidPageToken,
                .invalidParameterValue,
                .invalidSnapshotId,
                .invalidTag,
                .invalidVolumeSize,
                .unrelatedSnapshots,
                .writeRequestTimeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conflictingBlockUpdate: return "CONFLICTING_BLOCK_UPDATE"
            case .invalidBlock: return "INVALID_BLOCK"
            case .invalidBlockToken: return "INVALID_BLOCK_TOKEN"
            case .invalidContentEncoding: return "INVALID_CONTENT_ENCODING"
            case .invalidCustomerKey: return "INVALID_CUSTOMER_KEY"
            case .invalidDependencyRequest: return "INVALID_DEPENDENCY_REQUEST"
            case .invalidGrantToken: return "INVALID_GRANT_TOKEN"
            case .invalidImageId: return "INVALID_IMAGE_ID"
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case .invalidSnapshotId: return "INVALID_SNAPSHOT_ID"
            case .invalidTag: return "INVALID_TAG"
            case .invalidVolumeSize: return "INVALID_VOLUME_SIZE"
            case .unrelatedSnapshots: return "UNRELATED_SNAPSHOTS"
            case .writeRequestTimeout: return "WRITE_REQUEST_TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
