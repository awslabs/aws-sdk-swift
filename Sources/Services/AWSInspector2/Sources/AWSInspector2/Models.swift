//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action. For Enable, you receive this error if you attempt to use a feature in an unsupported Amazon Web Services Region.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Inspector2ClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case suspended
        case suspending
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .suspended,
                .suspending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .suspended: return "SUSPENDED"
            case .suspending: return "SUSPENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details the status of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceStatus {
        /// The status of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for Amazon Web Services Lambda function.
        public var lambda: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for custom application code for Amazon Web Services Lambda functions.
        public var lambdaCode: Inspector2ClientTypes.Status?

        public init(
            ec2: Inspector2ClientTypes.Status? = nil,
            ecr: Inspector2ClientTypes.Status? = nil,
            lambda: Inspector2ClientTypes.Status? = nil,
            lambdaCode: Inspector2ClientTypes.Status? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes {
    /// An Amazon Web Services account within your environment that Amazon Inspector has been enabled for.
    public struct Account {
        /// The ID of the Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Details of the status of Amazon Inspector scans by resource type.
        /// This member is required.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init(
            accountId: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {

    public enum AggregationFindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case codeVulnerability
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFindingType] {
            return [
                .codeVulnerability,
                .networkReachability,
                .packageVulnerability
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .codeVulnerability: return "CODE_VULNERABILITY"
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum AggregationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsLambdaFunction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum AccountSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about an aggregation response based on Amazon Web Services accounts.
    public struct AccountAggregation {
        /// The type of finding.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The type of resource.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AccountSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.AccountSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {
    /// An object that contains the counts of aggregated finding per severity.
    public struct SeverityCounts {
        /// The total count of findings from all severities.
        public var all: Swift.Int?
        /// The total count of critical severity findings.
        public var critical: Swift.Int?
        /// The total count of high severity findings.
        public var high: Swift.Int?
        /// The total count of medium severity findings.
        public var medium: Swift.Int?

        public init(
            all: Swift.Int? = nil,
            critical: Swift.Int? = nil,
            high: Swift.Int? = nil,
            medium: Swift.Int? = nil
        )
        {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }
    }

}

extension Inspector2ClientTypes {
    /// An aggregation of findings by Amazon Web Services account ID.
    public struct AccountAggregationResponse {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The number of findings that have an exploit available.
        public var exploitAvailableCount: Swift.Int?
        /// Details about the number of fixes.
        public var fixAvailableCount: Swift.Int?
        /// The number of findings by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            exploitAvailableCount: Swift.Int? = nil,
            fixAvailableCount: Swift.Int? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.exploitAvailableCount = exploitAvailableCount
            self.fixAvailableCount = fixAvailableCount
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [CisStringComparison] {
            return [
                .equals,
                .notEquals,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS string filter.
    public struct CisStringFilter {
        /// The comparison value of the CIS string filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisStringComparison?
        /// The value of the CIS string filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.CisStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case accountIsIsolated
        case alreadyEnabled
        case disableInProgress
        case disassociateAllMembers
        case ec2SsmAssociationVersionLimitExceeded
        case ec2SsmResourceDataSyncLimitExceeded
        case enableInProgress
        case eventbridgeThrottled
        case eventbridgeUnavailable
        case internalError
        case resourceNotFound
        case resourceScanNotDisabled
        case ssmThrottled
        case ssmUnavailable
        case suspendInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .accountIsIsolated,
                .alreadyEnabled,
                .disableInProgress,
                .disassociateAllMembers,
                .ec2SsmAssociationVersionLimitExceeded,
                .ec2SsmResourceDataSyncLimitExceeded,
                .enableInProgress,
                .eventbridgeThrottled,
                .eventbridgeUnavailable,
                .internalError,
                .resourceNotFound,
                .resourceScanNotDisabled,
                .ssmThrottled,
                .ssmUnavailable,
                .suspendInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .accountIsIsolated: return "ACCOUNT_IS_ISOLATED"
            case .alreadyEnabled: return "ALREADY_ENABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .disassociateAllMembers: return "DISASSOCIATE_ALL_MEMBERS"
            case .ec2SsmAssociationVersionLimitExceeded: return "EC2_SSM_ASSOCIATION_VERSION_LIMIT_EXCEEDED"
            case .ec2SsmResourceDataSyncLimitExceeded: return "EC2_SSM_RESOURCE_DATA_SYNC_LIMIT_EXCEEDED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case .eventbridgeThrottled: return "EVENTBRIDGE_THROTTLED"
            case .eventbridgeUnavailable: return "EVENTBRIDGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .resourceScanNotDisabled: return "RESOURCE_SCAN_NOT_DISABLED"
            case .ssmThrottled: return "SSM_THROTTLED"
            case .ssmUnavailable: return "SSM_UNAVAILABLE"
            case .suspendInProgress: return "SUSPEND_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that described the state of Amazon Inspector scans for an account.
    public struct State {
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init(
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    /// Details the state of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceState {
        /// An object detailing the state of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.State?
        /// An object detailing the state of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.State?
        /// An object that described the state of Amazon Inspector scans for an account.
        public var lambda: Inspector2ClientTypes.State?
        /// An object that described the state of Amazon Inspector scans for an account.
        public var lambdaCode: Inspector2ClientTypes.State?

        public init(
            ec2: Inspector2ClientTypes.State? = nil,
            ecr: Inspector2ClientTypes.State? = nil,
            lambda: Inspector2ClientTypes.State? = nil,
            lambdaCode: Inspector2ClientTypes.State? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes {
    /// An object with details the status of an Amazon Web Services account within your Amazon Inspector environment.
    public struct AccountState {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        /// This member is required.
        public var resourceState: Inspector2ClientTypes.ResourceState?
        /// An object detailing the status of Amazon Inspector for the account.
        /// This member is required.
        public var state: Inspector2ClientTypes.State?

        public init(
            accountId: Swift.String? = nil,
            resourceState: Inspector2ClientTypes.ResourceState? = nil,
            state: Inspector2ClientTypes.State? = nil
        )
        {
            self.accountId = accountId
            self.resourceState = resourceState
            self.state = state
        }
    }

}

extension Inspector2ClientTypes {

    public enum StringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [StringComparison] {
            return [
                .equals,
                .notEquals,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a string filter.
    public struct StringFilter {
        /// The operator to use when comparing values in the filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.StringComparison?
        /// The value to filter on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.StringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum AmiSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case affectedInstances
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiSortBy] {
            return [
                .affectedInstances,
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .affectedInstances: return "AFFECTED_INSTANCES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon machine images (AMIs).
    public struct AmiAggregation {
        /// The IDs of AMIs to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.AmiSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AmiSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum AwsEcrContainerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsEcrContainerSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregation {
        /// The architecture of the containers.
        public var architectures: [Inspector2ClientTypes.StringFilter]?
        /// The image SHA values.
        public var imageShas: [Inspector2ClientTypes.StringFilter]?
        /// The image tags.
        public var imageTags: [Inspector2ClientTypes.StringFilter]?
        /// The container repositories.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The container resource IDs.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            architectures: [Inspector2ClientTypes.StringFilter]? = nil,
            imageShas: [Inspector2ClientTypes.StringFilter]? = nil,
            imageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.architectures = architectures
            self.imageShas = imageShas
            self.imageTags = imageTags
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum MapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [MapComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that describes details of a map filter.
    public struct MapFilter {
        /// The operator to use when comparing values in the filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.MapComparison?
        /// The tag key used in the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value used in the filter.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.MapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum Ec2InstanceSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case networkFindings
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2InstanceSortBy] {
            return [
                .all,
                .critical,
                .high,
                .networkFindings
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .networkFindings: return "NETWORK_FINDINGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon EC2 instances.
    public struct Ec2InstanceAggregation {
        /// The AMI IDs associated with the Amazon EC2 instances to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance IDs to aggregate findings for.
        public var instanceIds: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance tags to aggregate findings for.
        public var instanceTags: [Inspector2ClientTypes.MapFilter]?
        /// The operating system types to aggregate findings for. Valid values must be uppercase and underscore separated, examples are ORACLE_LINUX_7 and ALPINE_LINUX_3_8.
        public var operatingSystems: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.Ec2InstanceSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            operatingSystems: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.Ec2InstanceSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.instanceIds = instanceIds
            self.instanceTags = instanceTags
            self.operatingSystems = operatingSystems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum FindingTypeSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingTypeSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding type.
    public struct FindingTypeAggregation {
        /// The finding type to aggregate.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The resource type to aggregate.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.FindingTypeSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.FindingTypeSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum ImageLayerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageLayerSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on container image layers.
    public struct ImageLayerAggregation {
        /// The hashes associated with the layers.
        public var layerHashes: [Inspector2ClientTypes.StringFilter]?
        /// The repository associated with the container image hosting the layers.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The ID of the container image layer.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.ImageLayerSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            layerHashes: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.ImageLayerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.layerHashes = layerHashes
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum LambdaFunctionSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaFunctionSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define a findings aggregation based on Amazon Web Services Lambda functions.
    public struct LambdaFunctionAggregation {
        /// The Amazon Web Services Lambda function names to include in the aggregation results.
        public var functionNames: [Inspector2ClientTypes.StringFilter]?
        /// The tags to include in the aggregation results.
        public var functionTags: [Inspector2ClientTypes.MapFilter]?
        /// The resource IDs to include in the aggregation results.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// Returns findings aggregated by Amazon Web Services Lambda function runtime environments.
        public var runtimes: [Inspector2ClientTypes.StringFilter]?
        /// The finding severity to use for sorting the results.
        public var sortBy: Inspector2ClientTypes.LambdaFunctionSortBy?
        /// The order to use for sorting the results.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            functionNames: [Inspector2ClientTypes.StringFilter]? = nil,
            functionTags: [Inspector2ClientTypes.MapFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            runtimes: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.LambdaFunctionSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.functionNames = functionNames
            self.functionTags = functionTags
            self.resourceIds = resourceIds
            self.runtimes = runtimes
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum LambdaLayerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaLayerSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define a findings aggregation based on an Amazon Web Services Lambda function's layers.
    public struct LambdaLayerAggregation {
        /// The names of the Amazon Web Services Lambda functions associated with the layers.
        public var functionNames: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Lambda function layer.
        public var layerArns: [Inspector2ClientTypes.StringFilter]?
        /// The resource IDs for the Amazon Web Services Lambda function layers.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The finding severity to use for sorting the results.
        public var sortBy: Inspector2ClientTypes.LambdaLayerSortBy?
        /// The order to use for sorting the results.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            functionNames: [Inspector2ClientTypes.StringFilter]? = nil,
            layerArns: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.LambdaLayerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.functionNames = functionNames
            self.layerArns = layerArns
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum PackageSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on operating system package type.
    public struct PackageAggregation {
        /// The names of packages to aggregate findings on.
        public var packageNames: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.PackageSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            packageNames: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.PackageSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.packageNames = packageNames
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum RepositorySortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case affectedImages
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositorySortBy] {
            return [
                .affectedImages,
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .affectedImages: return "AFFECTED_IMAGES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on repository.
    public struct RepositoryAggregation {
        /// The names of repositories to aggregate findings on.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.RepositorySortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.RepositorySortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.repositories = repositories
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {

    public enum TitleSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [TitleSortBy] {
            return [
                .all,
                .critical,
                .high
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding title.
    public struct TitleAggregation {
        /// The type of finding to aggregate on.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The resource type to aggregate on.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.TitleSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?
        /// The finding titles to aggregate on.
        public var titles: [Inspector2ClientTypes.StringFilter]?
        /// The vulnerability IDs of the findings.
        public var vulnerabilityIds: [Inspector2ClientTypes.StringFilter]?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.TitleSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil,
            titles: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityIds: [Inspector2ClientTypes.StringFilter]? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.titles = titles
            self.vulnerabilityIds = vulnerabilityIds
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains details about an aggregation request.
    public enum AggregationRequest {
        /// An object that contains details about an aggregation request based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregation)
        /// An object that contains details about an aggregation request based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregation)
        /// An object that contains details about an aggregation request based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregation)
        /// An object that contains details about an aggregation request based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregation)
        /// An object that contains details about an aggregation request based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregation)
        /// An object that contains details about an aggregation request based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregation)
        /// An object that contains details about an aggregation request based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregation)
        /// Returns an object with findings aggregated by Amazon Web Services Lambda layer.
        case lambdalayeraggregation(Inspector2ClientTypes.LambdaLayerAggregation)
        /// Returns an object with findings aggregated by Amazon Web Services Lambda function.
        case lambdafunctionaggregation(Inspector2ClientTypes.LambdaFunctionAggregation)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by AMI.
    public struct AmiAggregationResponse {
        /// The Amazon Web Services account ID for the AMI.
        public var accountId: Swift.String?
        /// The IDs of Amazon EC2 instances using this AMI.
        public var affectedInstances: Swift.Int?
        /// The ID of the AMI that findings were aggregated for.
        /// This member is required.
        public var ami: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            affectedInstances: Swift.Int? = nil,
            ami: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedInstances = affectedInstances
            self.ami = ami
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregationResponse {
        /// The Amazon Web Services account ID of the account that owns the container.
        public var accountId: Swift.String?
        /// The architecture of the container.
        public var architecture: Swift.String?
        /// The SHA value of the container image.
        public var imageSha: Swift.String?
        /// The container image stags.
        public var imageTags: [Swift.String]?
        /// The container repository.
        public var repository: Swift.String?
        /// The resource ID of the container.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The number of finding by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            architecture: Swift.String? = nil,
            imageSha: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.architecture = architecture
            self.imageSha = imageSha
            self.imageTags = imageTags
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by Amazon EC2 instance.
    public struct Ec2InstanceAggregationResponse {
        /// The Amazon Web Services account for the Amazon EC2 instance.
        public var accountId: Swift.String?
        /// The Amazon Machine Image (AMI) of the Amazon EC2 instance.
        public var ami: Swift.String?
        /// The Amazon EC2 instance ID.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The tags attached to the instance.
        public var instanceTags: [Swift.String: Swift.String]?
        /// The number of network findings for the Amazon EC2 instance.
        public var networkFindings: Swift.Int?
        /// The operating system of the Amazon EC2 instance.
        public var operatingSystem: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            ami: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceTags: [Swift.String: Swift.String]? = nil,
            networkFindings: Swift.Int? = nil,
            operatingSystem: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.ami = ami
            self.instanceId = instanceId
            self.instanceTags = instanceTags
            self.networkFindings = networkFindings
            self.operatingSystem = operatingSystem
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding type aggregation.
    public struct FindingTypeAggregationResponse {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The number of findings that have an exploit available.
        public var exploitAvailableCount: Swift.Int?
        /// Details about the number of fixes.
        public var fixAvailableCount: Swift.Int?
        /// The value to sort results by.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            exploitAvailableCount: Swift.Int? = nil,
            fixAvailableCount: Swift.Int? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.exploitAvailableCount = exploitAvailableCount
            self.fixAvailableCount = fixAvailableCount
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct ImageLayerAggregationResponse {
        /// The ID of the Amazon Web Services account that owns the container image hosting the layer image.
        /// This member is required.
        public var accountId: Swift.String?
        /// The layer hash.
        /// This member is required.
        public var layerHash: Swift.String?
        /// The repository the layer resides in.
        /// This member is required.
        public var repository: Swift.String?
        /// The resource ID of the container image layer.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that represents the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            layerHash: Swift.String? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.layerHash = layerHash
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of an Amazon Web Services Lambda function finding aggregation.
    public struct LambdaFunctionAggregationResponse {
        /// The ID of the Amazon Web Services account that owns the Amazon Web Services Lambda function.
        public var accountId: Swift.String?
        /// The Amazon Web Services Lambda function names included in the aggregation results.
        public var functionName: Swift.String?
        /// The tags included in the aggregation results.
        public var lambdaTags: [Swift.String: Swift.String]?
        /// The date that the Amazon Web Services Lambda function included in the aggregation results was last changed.
        public var lastModifiedAt: Foundation.Date?
        /// The resource IDs included in the aggregation results.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The runtimes included in the aggregation results.
        public var runtime: Swift.String?
        /// An object that contains the counts of aggregated finding per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            functionName: Swift.String? = nil,
            lambdaTags: [Swift.String: Swift.String]? = nil,
            lastModifiedAt: Foundation.Date? = nil,
            resourceId: Swift.String? = nil,
            runtime: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.functionName = functionName
            self.lambdaTags = lambdaTags
            self.lastModifiedAt = lastModifiedAt
            self.resourceId = resourceId
            self.runtime = runtime
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of an Amazon Web Services Lambda function layer finding aggregation.
    public struct LambdaLayerAggregationResponse {
        /// The account ID of the Amazon Web Services Lambda function layer.
        /// This member is required.
        public var accountId: Swift.String?
        /// The names of the Amazon Web Services Lambda functions associated with the layers.
        /// This member is required.
        public var functionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Lambda function layer.
        /// This member is required.
        public var layerArn: Swift.String?
        /// The Resource ID of the Amazon Web Services Lambda function layer.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that contains the counts of aggregated finding per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            functionName: Swift.String? = nil,
            layerArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.functionName = functionName
            self.layerArn = layerArn
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct PackageAggregationResponse {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The name of the operating system package.
        /// This member is required.
        public var packageName: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.packageName = packageName
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by repository.
    public struct RepositoryAggregationResponse {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The number of container images impacted by the findings.
        public var affectedImages: Swift.Int?
        /// The name of the repository associated with the findings.
        /// This member is required.
        public var repository: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            affectedImages: Swift.Int? = nil,
            repository: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedImages = affectedImages
            self.repository = repository
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by title.
    public struct TitleAggregationResponse {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?
        /// The title that the findings were aggregated on.
        /// This member is required.
        public var title: Swift.String?
        /// The vulnerability ID of the finding.
        public var vulnerabilityId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil,
            title: Swift.String? = nil,
            vulnerabilityId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
            self.title = title
            self.vulnerabilityId = vulnerabilityId
        }
    }

}

extension Inspector2ClientTypes {
    /// A structure that contains details about the results of an aggregation type.
    public enum AggregationResponse {
        /// An object that contains details about an aggregation response based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregationResponse)
        /// An object that contains details about an aggregation response based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregationResponse)
        /// An object that contains details about an aggregation response based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregationResponse)
        /// An object that contains details about an aggregation response based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregationResponse)
        /// An object that contains details about an aggregation response based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregationResponse)
        /// An aggregation of findings by Amazon Web Services Lambda layer.
        case lambdalayeraggregation(Inspector2ClientTypes.LambdaLayerAggregationResponse)
        /// An aggregation of findings by Amazon Web Services Lambda function.
        case lambdafunctionaggregation(Inspector2ClientTypes.LambdaFunctionAggregationResponse)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {

    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case ami
        case awsEc2Instance
        case awsEcrContainer
        case awsLambdaFunction
        case findingType
        case imageLayer
        case lambdaLayer
        case package
        case repository
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .account,
                .ami,
                .awsEc2Instance,
                .awsEcrContainer,
                .awsLambdaFunction,
                .findingType,
                .imageLayer,
                .lambdaLayer,
                .package,
                .repository,
                .title
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .ami: return "AMI"
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainer: return "AWS_ECR_CONTAINER"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case .findingType: return "FINDING_TYPE"
            case .imageLayer: return "IMAGE_LAYER"
            case .lambdaLayer: return "LAMBDA_LAYER"
            case .package: return "PACKAGE"
            case .repository: return "REPOSITORY"
            case .title: return "TITLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request has failed due to an internal failure of the Amazon Inspector service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension Inspector2ClientTypes {
    /// An object that describes a validation exception.
    public struct ValidationExceptionField {
        /// The validation exception message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Inspector2ClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request has failed validation due to missing required fields or having invalid inputs.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that failed validation.
        public internal(set) var fields: [Inspector2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: Inspector2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [Inspector2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Inspector2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateMemberInput {
    /// The Amazon Web Services account ID of the member account to be associated.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

public struct AssociateMemberOutput {
    /// The Amazon Web Services account ID of the successfully associated member account.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension Inspector2ClientTypes {
    /// The Amazon Web Services Threat Intel Group (ATIG) details for a specific vulnerability.
    public struct AtigData {
        /// The date and time this vulnerability was first observed.
        public var firstSeen: Foundation.Date?
        /// The date and time this vulnerability was last observed.
        public var lastSeen: Foundation.Date?
        /// The commercial sectors this vulnerability targets.
        public var targets: [Swift.String]?
        /// The [MITRE ATT&CK](https://attack.mitre.org/) tactics, techniques, and procedures (TTPs) associated with vulnerability.
        public var ttps: [Swift.String]?

        public init(
            firstSeen: Foundation.Date? = nil,
            lastSeen: Foundation.Date? = nil,
            targets: [Swift.String]? = nil,
            ttps: [Swift.String]? = nil
        )
        {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.targets = targets
            self.ttps = ttps
        }
    }

}

extension Inspector2ClientTypes {
    /// Represents which scan types are automatically enabled for new members of your Amazon Inspector organization.
    public struct AutoEnable {
        /// Represents whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ec2: Swift.Bool?
        /// Represents whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ecr: Swift.Bool?
        /// Represents whether Amazon Web Services Lambda standard scans are automatically enabled for new members of your Amazon Inspector organization.
        public var lambda: Swift.Bool?
        /// Represents whether Lambda code scans are automatically enabled for new members of your Amazon Inspector organization.
        public var lambdaCode: Swift.Bool?

        public init(
            ec2: Swift.Bool? = nil,
            ecr: Swift.Bool? = nil,
            lambda: Swift.Bool? = nil,
            lambdaCode: Swift.Bool? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes {
    /// Details of the Amazon EC2 instance involved in a finding.
    public struct AwsEc2InstanceDetails {
        /// The IAM instance profile ARN of the Amazon EC2 instance.
        public var iamInstanceProfileArn: Swift.String?
        /// The image ID of the Amazon EC2 instance.
        public var imageId: Swift.String?
        /// The IPv4 addresses of the Amazon EC2 instance.
        public var ipV4Addresses: [Swift.String]?
        /// The IPv6 addresses of the Amazon EC2 instance.
        public var ipV6Addresses: [Swift.String]?
        /// The name of the key pair used to launch the Amazon EC2 instance.
        public var keyName: Swift.String?
        /// The date and time the Amazon EC2 instance was launched at.
        public var launchedAt: Foundation.Date?
        /// The platform of the Amazon EC2 instance.
        public var platform: Swift.String?
        /// The subnet ID of the Amazon EC2 instance.
        public var subnetId: Swift.String?
        /// The type of the Amazon EC2 instance.
        public var type: Swift.String?
        /// The VPC ID of the Amazon EC2 instance.
        public var vpcId: Swift.String?

        public init(
            iamInstanceProfileArn: Swift.String? = nil,
            imageId: Swift.String? = nil,
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil,
            keyName: Swift.String? = nil,
            launchedAt: Foundation.Date? = nil,
            platform: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            type: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.platform = platform
            self.subnetId = subnetId
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension Inspector2ClientTypes {
    /// The image details of the Amazon ECR container image.
    public struct AwsEcrContainerImageDetails {
        /// The architecture of the Amazon ECR container image.
        public var architecture: Swift.String?
        /// The image author of the Amazon ECR container image.
        public var author: Swift.String?
        /// The image hash of the Amazon ECR container image.
        /// This member is required.
        public var imageHash: Swift.String?
        /// The image tags attached to the Amazon ECR container image.
        public var imageTags: [Swift.String]?
        /// The platform of the Amazon ECR container image.
        public var platform: Swift.String?
        /// The date and time the Amazon ECR container image was pushed.
        public var pushedAt: Foundation.Date?
        /// The registry for the Amazon ECR container image.
        /// This member is required.
        public var registry: Swift.String?
        /// The name of the repository the Amazon ECR container image resides in.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            author: Swift.String? = nil,
            imageHash: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            platform: Swift.String? = nil,
            pushedAt: Foundation.Date? = nil,
            registry: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }
    }

}

extension Inspector2ClientTypes {

    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case go1X
        case java11
        case java17
        case java8
        case java8Al2
        case nodejs
        case nodejs12X
        case nodejs14X
        case nodejs16X
        case nodejs18X
        case python310
        case python37
        case python38
        case python39
        case unsupported
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .go1X,
                .java11,
                .java17,
                .java8,
                .java8Al2,
                .nodejs,
                .nodejs12X,
                .nodejs14X,
                .nodejs16X,
                .nodejs18X,
                .python310,
                .python37,
                .python38,
                .python39,
                .unsupported
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .go1X: return "GO_1_X"
            case .java11: return "JAVA_11"
            case .java17: return "JAVA_17"
            case .java8: return "JAVA_8"
            case .java8Al2: return "JAVA_8_AL2"
            case .nodejs: return "NODEJS"
            case .nodejs12X: return "NODEJS_12_X"
            case .nodejs14X: return "NODEJS_14_X"
            case .nodejs16X: return "NODEJS_16_X"
            case .nodejs18X: return "NODEJS_18_X"
            case .python310: return "PYTHON_3_10"
            case .python37: return "PYTHON_3_7"
            case .python38: return "PYTHON_3_8"
            case .python39: return "PYTHON_3_9"
            case .unsupported: return "UNSUPPORTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The VPC security groups and subnets that are attached to an Amazon Web Services Lambda function. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct LambdaVpcConfig {
        /// The VPC security groups and subnets that are attached to an Amazon Web Services Lambda function. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension Inspector2ClientTypes {
    /// A summary of information about the Amazon Web Services Lambda function.
    public struct AwsLambdaFunctionDetails {
        /// The instruction set architecture that the Amazon Web Services Lambda function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [Inspector2ClientTypes.Architecture]?
        /// The SHA256 hash of the Amazon Web Services Lambda function's deployment package.
        /// This member is required.
        public var codeSha256: Swift.String?
        /// The Amazon Web Services Lambda function's execution role.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The name of the Amazon Web Services Lambda function.
        /// This member is required.
        public var functionName: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html)
        public var lastModifiedAt: Foundation.Date?
        /// The Amazon Web Services Lambda function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). A Lambda function can have up to five layers.
        public var layers: [Swift.String]?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: Inspector2ClientTypes.PackageType?
        /// The runtime environment for the Amazon Web Services Lambda function.
        /// This member is required.
        public var runtime: Inspector2ClientTypes.Runtime?
        /// The version of the Amazon Web Services Lambda function.
        /// This member is required.
        public var version: Swift.String?
        /// The Amazon Web Services Lambda function's networking configuration.
        public var vpcConfig: Inspector2ClientTypes.LambdaVpcConfig?

        public init(
            architectures: [Inspector2ClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            lastModifiedAt: Foundation.Date? = nil,
            layers: [Swift.String]? = nil,
            packageType: Inspector2ClientTypes.PackageType? = nil,
            runtime: Inspector2ClientTypes.Runtime? = nil,
            version: Swift.String? = nil,
            vpcConfig: Inspector2ClientTypes.LambdaVpcConfig? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.executionRoleArn = executionRoleArn
            self.functionName = functionName
            self.lastModifiedAt = lastModifiedAt
            self.layers = layers
            self.packageType = packageType
            self.runtime = runtime
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

/// One or more tags submitted as part of the request is not valid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation tried to access an invalid resource. Make sure the resource is specified correctly.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetAccountStatusInput {
    /// The 12-digit Amazon Web Services account IDs of the accounts to retrieve Amazon Inspector status for.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

extension Inspector2ClientTypes {
    /// An object with details on why an account failed to enable Amazon Inspector.
    public struct FailedAccount {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        public var status: Inspector2ClientTypes.Status?

        public init(
            accountId: Swift.String? = nil,
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

public struct BatchGetAccountStatusOutput {
    /// An array of objects that provide details on the status of Amazon Inspector for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.AccountState]?
    /// An array of objects detailing any accounts that failed to enable Amazon Inspector and why.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.AccountState]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

public struct BatchGetCodeSnippetInput {
    /// An array of finding ARNs for the findings you want to retrieve code snippets from.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        findingArns: [Swift.String]? = nil
    )
    {
        self.findingArns = findingArns
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the lines of code associated with a code snippet.
    public struct CodeLine {
        /// The content of a line of code
        /// This member is required.
        public var content: Swift.String?
        /// The line number that a section of code is located at.
        /// This member is required.
        public var lineNumber: Swift.Int?

        public init(
            content: Swift.String? = nil,
            lineNumber: Swift.Int? = nil
        )
        {
            self.content = content
            self.lineNumber = lineNumber
        }
    }

}

extension Inspector2ClientTypes {
    /// A suggested fix for a vulnerability in your Lambda function code.
    public struct SuggestedFix {
        /// The fix's code.
        public var code: Swift.String?
        /// The fix's description.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains information on a code snippet retrieved by Amazon Inspector from a code vulnerability finding.
    public struct CodeSnippetResult {
        /// Contains information on the retrieved code snippet.
        public var codeSnippet: [Inspector2ClientTypes.CodeLine]?
        /// The line number of the last line of a code snippet.
        public var endLine: Swift.Int?
        /// The ARN of a finding that the code snippet is associated with.
        public var findingArn: Swift.String?
        /// The line number of the first line of a code snippet.
        public var startLine: Swift.Int?
        /// Details of a suggested code fix.
        public var suggestedFixes: [Inspector2ClientTypes.SuggestedFix]?

        public init(
            codeSnippet: [Inspector2ClientTypes.CodeLine]? = nil,
            endLine: Swift.Int? = nil,
            findingArn: Swift.String? = nil,
            startLine: Swift.Int? = nil,
            suggestedFixes: [Inspector2ClientTypes.SuggestedFix]? = nil
        )
        {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.findingArn = findingArn
            self.startLine = startLine
            self.suggestedFixes = suggestedFixes
        }
    }

}

extension Inspector2ClientTypes {

    public enum CodeSnippetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case codeSnippetNotFound
        case internalError
        case invalidInput
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSnippetErrorCode] {
            return [
                .accessDenied,
                .codeSnippetNotFound,
                .internalError,
                .invalidInput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .codeSnippetNotFound: return "CODE_SNIPPET_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInput: return "INVALID_INPUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains information about any errors encountered while trying to retrieve a code snippet.
    public struct CodeSnippetError {
        /// The error code for the error that prevented a code snippet from being retrieved.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.CodeSnippetErrorCode?
        /// The error message received when Amazon Inspector failed to retrieve a code snippet.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The ARN of the finding that a code snippet couldn't be retrieved for.
        /// This member is required.
        public var findingArn: Swift.String?

        public init(
            errorCode: Inspector2ClientTypes.CodeSnippetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            findingArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }
    }

}

public struct BatchGetCodeSnippetOutput {
    /// The retrieved code snippets associated with the provided finding ARNs.
    public var codeSnippetResults: [Inspector2ClientTypes.CodeSnippetResult]?
    /// Any errors Amazon Inspector encountered while trying to retrieve the requested code snippets.
    public var errors: [Inspector2ClientTypes.CodeSnippetError]?

    public init(
        codeSnippetResults: [Inspector2ClientTypes.CodeSnippetResult]? = nil,
        errors: [Inspector2ClientTypes.CodeSnippetError]? = nil
    )
    {
        self.codeSnippetResults = codeSnippetResults
        self.errors = errors
    }
}

public struct BatchGetFindingDetailsInput {
    /// A list of finding ARNs.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        findingArns: [Swift.String]? = nil
    )
    {
        self.findingArns = findingArns
    }
}

extension Inspector2ClientTypes {

    public enum FindingDetailsErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case findingDetailsNotFound
        case internalError
        case invalidInput
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingDetailsErrorCode] {
            return [
                .accessDenied,
                .findingDetailsNotFound,
                .internalError,
                .invalidInput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .findingDetailsNotFound: return "FINDING_DETAILS_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInput: return "INVALID_INPUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about an error encountered when trying to return vulnerability data for a finding.
    public struct FindingDetailsError {
        /// The error code.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.FindingDetailsErrorCode?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The finding ARN that returned an error.
        /// This member is required.
        public var findingArn: Swift.String?

        public init(
            errorCode: Inspector2ClientTypes.FindingDetailsErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            findingArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }
    }

}

extension Inspector2ClientTypes {
    /// The Cybersecurity and Infrastructure Security Agency (CISA) details for a specific vulnerability.
    public struct CisaData {
        /// The remediation action recommended by CISA for this vulnerability.
        public var action: Swift.String?
        /// The date and time CISA added this vulnerability to their catalogue.
        public var dateAdded: Foundation.Date?
        /// The date and time CISA expects a fix to have been provided vulnerability.
        public var dateDue: Foundation.Date?

        public init(
            action: Swift.String? = nil,
            dateAdded: Foundation.Date? = nil,
            dateDue: Foundation.Date? = nil
        )
        {
            self.action = action
            self.dateAdded = dateAdded
            self.dateDue = dateDue
        }
    }

}

extension Inspector2ClientTypes {
    /// Details of the evidence for a vulnerability identified in a finding.
    public struct Evidence {
        /// The evidence details.
        public var evidenceDetail: Swift.String?
        /// The evidence rule.
        public var evidenceRule: Swift.String?
        /// The evidence severity.
        public var severity: Swift.String?

        public init(
            evidenceDetail: Swift.String? = nil,
            evidenceRule: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.evidenceDetail = evidenceDetail
            self.evidenceRule = evidenceRule
            self.severity = severity
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains information on when this exploit was observed.
    public struct ExploitObserved {
        /// The date an time when the exploit was first seen.
        public var firstSeen: Foundation.Date?
        /// The date an time when the exploit was last seen.
        public var lastSeen: Foundation.Date?

        public init(
            firstSeen: Foundation.Date? = nil,
            lastSeen: Foundation.Date? = nil
        )
        {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }
    }

}

extension Inspector2ClientTypes {
    /// Details of the vulnerability identified in a finding.
    public struct FindingDetail {
        /// The Cybersecurity and Infrastructure Security Agency (CISA) details for a specific vulnerability.
        public var cisaData: Inspector2ClientTypes.CisaData?
        /// The Common Weakness Enumerations (CWEs) associated with the vulnerability.
        public var cwes: [Swift.String]?
        /// The Exploit Prediction Scoring System (EPSS) score of the vulnerability.
        public var epssScore: Swift.Double?
        /// Information on the evidence of the vulnerability.
        public var evidences: [Inspector2ClientTypes.Evidence]?
        /// Contains information on when this exploit was observed.
        public var exploitObserved: Inspector2ClientTypes.ExploitObserved?
        /// The finding ARN that the vulnerability details are associated with.
        public var findingArn: Swift.String?
        /// The reference URLs for the vulnerability data.
        public var referenceUrls: [Swift.String]?
        /// The risk score of the vulnerability.
        public var riskScore: Swift.Int?
        /// The known malware tools or kits that can exploit the vulnerability.
        public var tools: [Swift.String]?
        /// The MITRE adversary tactics, techniques, or procedures (TTPs) associated with the vulnerability.
        public var ttps: [Swift.String]?

        public init(
            cisaData: Inspector2ClientTypes.CisaData? = nil,
            cwes: [Swift.String]? = nil,
            epssScore: Swift.Double? = nil,
            evidences: [Inspector2ClientTypes.Evidence]? = nil,
            exploitObserved: Inspector2ClientTypes.ExploitObserved? = nil,
            findingArn: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            riskScore: Swift.Int? = nil,
            tools: [Swift.String]? = nil,
            ttps: [Swift.String]? = nil
        )
        {
            self.cisaData = cisaData
            self.cwes = cwes
            self.epssScore = epssScore
            self.evidences = evidences
            self.exploitObserved = exploitObserved
            self.findingArn = findingArn
            self.referenceUrls = referenceUrls
            self.riskScore = riskScore
            self.tools = tools
            self.ttps = ttps
        }
    }

}

public struct BatchGetFindingDetailsOutput {
    /// Error information for findings that details could not be returned for.
    public var errors: [Inspector2ClientTypes.FindingDetailsError]?
    /// A finding's vulnerability details.
    public var findingDetails: [Inspector2ClientTypes.FindingDetail]?

    public init(
        errors: [Inspector2ClientTypes.FindingDetailsError]? = nil,
        findingDetails: [Inspector2ClientTypes.FindingDetail]? = nil
    )
    {
        self.errors = errors
        self.findingDetails = findingDetails
    }
}

public struct BatchGetFreeTrialInfoInput {
    /// The account IDs to get free trial status for.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

extension Inspector2ClientTypes {

    public enum FreeTrialStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum FreeTrialType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case lambdaCode
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialType] {
            return [
                .ec2,
                .ecr,
                .lambda,
                .lambdaCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case .lambdaCode: return "LAMBDA_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that contains information about the Amazon Inspector free trial for an account.
    public struct FreeTrialInfo {
        /// The date and time that the Amazon Inspector free trail ends for a given account.
        /// This member is required.
        public var end: Foundation.Date?
        /// The date and time that the Amazon Inspector free trail started for a given account.
        /// This member is required.
        public var start: Foundation.Date?
        /// The order to sort results by.
        /// This member is required.
        public var status: Inspector2ClientTypes.FreeTrialStatus?
        /// The type of scan covered by the Amazon Inspector free trail.
        /// This member is required.
        public var type: Inspector2ClientTypes.FreeTrialType?

        public init(
            end: Foundation.Date? = nil,
            start: Foundation.Date? = nil,
            status: Inspector2ClientTypes.FreeTrialStatus? = nil,
            type: Inspector2ClientTypes.FreeTrialType? = nil
        )
        {
            self.end = end
            self.start = start
            self.status = status
            self.type = type
        }
    }

}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector free trial for an account.
    public struct FreeTrialAccountInfo {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information about the Amazon Inspector free trial for an account.
        /// This member is required.
        public var freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]?

        public init(
            accountId: Swift.String? = nil,
            freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]? = nil
        )
        {
            self.accountId = accountId
            self.freeTrialInfo = freeTrialInfo
        }
    }

}

extension Inspector2ClientTypes {

    public enum FreeTrialInfoErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialInfoErrorCode] {
            return [
                .accessDenied,
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Information about an error received while accessing free trail data for an account.
    public struct FreeTrialInfoError {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: Inspector2ClientTypes.FreeTrialInfoErrorCode?
        /// The error message returned.
        /// This member is required.
        public var message: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            code: Inspector2ClientTypes.FreeTrialInfoErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.code = code
            self.message = message
        }
    }

}

public struct BatchGetFreeTrialInfoOutput {
    /// An array of objects that provide Amazon Inspector free trial details for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]?
    /// An array of objects detailing any accounts that free trial data could not be returned for.
    /// This member is required.
    public var failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]?

    public init(
        accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]? = nil,
        failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

public struct BatchGetMemberEc2DeepInspectionStatusInput {
    /// The unique identifiers for the Amazon Web Services accounts to retrieve Amazon Inspector deep inspection activation status for.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

extension Inspector2ClientTypes {

    public enum Ec2DeepInspectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deactivated
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2DeepInspectionStatus] {
            return [
                .activated,
                .deactivated,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the state of Amazon Inspector deep inspection for a member account.
    public struct MemberAccountEc2DeepInspectionStatusState {
        /// The unique identifier for the Amazon Web Services account of the organization member
        /// This member is required.
        public var accountId: Swift.String?
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public var errorMessage: Swift.String?
        /// The state of Amazon Inspector deep inspection in the member account.
        public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

        public init(
            accountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
        )
        {
            self.accountId = accountId
            self.errorMessage = errorMessage
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    /// An object that contains details about a member account in your organization that failed to activate Amazon Inspector deep inspection.
    public struct FailedMemberAccountEc2DeepInspectionStatusState {
        /// The unique identifier for the Amazon Web Services account of the organization member that failed to activate Amazon Inspector deep inspection.
        /// This member is required.
        public var accountId: Swift.String?
        /// The status of EC2 scanning in the account that failed to activate Amazon Inspector deep inspection.
        public var ec2ScanStatus: Inspector2ClientTypes.Status?
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public var errorMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            ec2ScanStatus: Inspector2ClientTypes.Status? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.ec2ScanStatus = ec2ScanStatus
            self.errorMessage = errorMessage
        }
    }

}

public struct BatchGetMemberEc2DeepInspectionStatusOutput {
    /// An array of objects that provide details on the activation status of Amazon Inspector deep inspection for each of the requested accounts.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    /// An array of objects that provide details on any accounts that failed to activate Amazon Inspector deep inspection and why.
    public var failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil,
        failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
    )
    {
        self.accountIds = accountIds
        self.failedAccountIds = failedAccountIds
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the status of Amazon Inspector deep inspection for a member account in your organization.
    public struct MemberAccountEc2DeepInspectionStatus {
        /// The unique identifier for the Amazon Web Services account of the organization member.
        /// This member is required.
        public var accountId: Swift.String?
        /// Whether Amazon Inspector deep inspection is active in the account. If TRUE Amazon Inspector deep inspection is active, if FALSE it is not active.
        /// This member is required.
        public var activateDeepInspection: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            activateDeepInspection: Swift.Bool? = nil
        )
        {
            self.accountId = accountId
            self.activateDeepInspection = activateDeepInspection
        }
    }

}

public struct BatchUpdateMemberEc2DeepInspectionStatusInput {
    /// The unique identifiers for the Amazon Web Services accounts to change Amazon Inspector deep inspection status for.
    /// This member is required.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct BatchUpdateMemberEc2DeepInspectionStatusOutput {
    /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status was successfully changed for.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status could not be successfully changed for.
    public var failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil,
        failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
    )
    {
        self.accountIds = accountIds
        self.failedAccountIds = failedAccountIds
    }
}

public struct CancelFindingsReportInput {
    /// The ID of the report to be canceled.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

public struct CancelFindingsReportOutput {
    /// The ID of the canceled report.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

public struct CancelSbomExportInput {
    /// The report ID of the SBOM export to cancel.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

public struct CancelSbomExportOutput {
    /// The report ID of the canceled SBOM export.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

extension Inspector2ClientTypes {

    public enum CisSecurityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case level1
        case level2
        case sdkUnknown(Swift.String)

        public static var allCases: [CisSecurityLevel] {
            return [
                .level1,
                .level2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .level1: return "LEVEL_1"
            case .level2: return "LEVEL_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The status counts.
    public struct StatusCounts {
        /// The number of checks that failed.
        public var failed: Swift.Int?
        /// The number of checks that passed.
        public var passed: Swift.Int?
        /// The number of checks that were skipped.
        public var skipped: Swift.Int?

        public init(
            failed: Swift.Int? = nil,
            passed: Swift.Int? = nil,
            skipped: Swift.Int? = nil
        )
        {
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
        }
    }

}

extension Inspector2ClientTypes {
    /// A CIS check.
    public struct CisCheckAggregation {
        /// The account ID for the CIS check.
        public var accountId: Swift.String?
        /// The description for the CIS check.
        public var checkDescription: Swift.String?
        /// The check ID for the CIS check.
        public var checkId: Swift.String?
        /// The CIS check level.
        public var level: Inspector2ClientTypes.CisSecurityLevel?
        /// The CIS check platform.
        public var platform: Swift.String?
        /// The scan ARN for the CIS check scan ARN.
        /// This member is required.
        public var scanArn: Swift.String?
        /// The CIS check status counts.
        public var statusCounts: Inspector2ClientTypes.StatusCounts?
        /// The CIS check title.
        public var title: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            checkDescription: Swift.String? = nil,
            checkId: Swift.String? = nil,
            level: Inspector2ClientTypes.CisSecurityLevel? = nil,
            platform: Swift.String? = nil,
            scanArn: Swift.String? = nil,
            statusCounts: Inspector2ClientTypes.StatusCounts? = nil,
            title: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.checkDescription = checkDescription
            self.checkId = checkId
            self.level = level
            self.platform = platform
            self.scanArn = scanArn
            self.statusCounts = statusCounts
            self.title = title
        }
    }

}

extension Inspector2ClientTypes {
    /// The CIS date filter.
    public struct CisDateFilter {
        /// The CIS date filter's earliest scan start time.
        public var earliestScanStartTime: Foundation.Date?
        /// The CIS date filter's latest scan start time.
        public var latestScanStartTime: Foundation.Date?

        public init(
            earliestScanStartTime: Foundation.Date? = nil,
            latestScanStartTime: Foundation.Date? = nil
        )
        {
            self.earliestScanStartTime = earliestScanStartTime
            self.latestScanStartTime = latestScanStartTime
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisFindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case passed
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [CisFindingStatus] {
            return [
                .failed,
                .passed,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisFindingStatusComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CisFindingStatusComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS finding status filter.
    public struct CisFindingStatusFilter {
        /// The comparison value of the CIS finding status filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisFindingStatusComparison?
        /// The value of the CIS finding status filter.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisFindingStatus?

        public init(
            comparison: Inspector2ClientTypes.CisFindingStatusComparison? = nil,
            value: Inspector2ClientTypes.CisFindingStatus? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// The CIS number filter.
    public struct CisNumberFilter {
        /// The CIS number filter's lower inclusive.
        public var lowerInclusive: Swift.Int?
        /// The CIS number filter's upper inclusive.
        public var upperInclusive: Swift.Int?

        public init(
            lowerInclusive: Swift.Int? = nil,
            upperInclusive: Swift.Int? = nil
        )
        {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [CisReportFormat] {
            return [
                .csv,
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CisReportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case passed
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [CisResultStatus] {
            return [
                .failed,
                .passed,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisResultStatusComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CisResultStatusComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS result status filter.
    public struct CisResultStatusFilter {
        /// The comparison value of the CIS result status filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisResultStatusComparison?
        /// The value of the CIS result status filter.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisResultStatus?

        public init(
            comparison: Inspector2ClientTypes.CisResultStatusComparison? = nil,
            value: Inspector2ClientTypes.CisResultStatus? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case failed
        case informational
        case notApplicable
        case notEvaluated
        case passed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CisRuleStatus] {
            return [
                .error,
                .failed,
                .informational,
                .notApplicable,
                .notEvaluated,
                .passed,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .informational: return "INFORMATIONAL"
            case .notApplicable: return "NOT_APPLICABLE"
            case .notEvaluated: return "NOT_EVALUATED"
            case .passed: return "PASSED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS targets.
    public struct CisTargets {
        /// The CIS target account ids.
        public var accountIds: [Swift.String]?
        /// The CIS target resource tags.
        public var targetResourceTags: [Swift.String: [Swift.String]]?

        public init(
            accountIds: [Swift.String]? = nil,
            targetResourceTags: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }
    }

}

extension Inspector2ClientTypes {
    /// The CIS scan.
    public struct CisScan {
        /// The CIS scan's failed checks.
        public var failedChecks: Swift.Int?
        /// The CIS scan's ARN.
        /// This member is required.
        public var scanArn: Swift.String?
        /// The CIS scan's configuration ARN.
        /// This member is required.
        public var scanConfigurationArn: Swift.String?
        /// The CIS scan's date.
        public var scanDate: Foundation.Date?
        /// The the name of the scan configuration that's associated with this scan.
        public var scanName: Swift.String?
        /// The account or organization that schedules the CIS scan.
        public var scheduledBy: Swift.String?
        /// The security level for the CIS scan. Security level refers to the Benchmark levels that CIS assigns to a profile.
        public var securityLevel: Inspector2ClientTypes.CisSecurityLevel?
        /// The CIS scan's status.
        public var status: Inspector2ClientTypes.CisScanStatus?
        /// The CIS scan's targets.
        public var targets: Inspector2ClientTypes.CisTargets?
        /// The CIS scan's total checks.
        public var totalChecks: Swift.Int?

        public init(
            failedChecks: Swift.Int? = nil,
            scanArn: Swift.String? = nil,
            scanConfigurationArn: Swift.String? = nil,
            scanDate: Foundation.Date? = nil,
            scanName: Swift.String? = nil,
            scheduledBy: Swift.String? = nil,
            securityLevel: Inspector2ClientTypes.CisSecurityLevel? = nil,
            status: Inspector2ClientTypes.CisScanStatus? = nil,
            targets: Inspector2ClientTypes.CisTargets? = nil,
            totalChecks: Swift.Int? = nil
        )
        {
            self.failedChecks = failedChecks
            self.scanArn = scanArn
            self.scanConfigurationArn = scanConfigurationArn
            self.scanDate = scanDate
            self.scanName = scanName
            self.scheduledBy = scheduledBy
            self.securityLevel = securityLevel
            self.status = status
            self.targets = targets
            self.totalChecks = totalChecks
        }
    }

}

extension Inspector2ClientTypes {
    /// The time.
    public struct Time {
        /// The time of day in 24-hour format (00:00).
        /// This member is required.
        public var timeOfDay: Swift.String?
        /// The timezone.
        /// This member is required.
        public var timezone: Swift.String?

        public init(
            timeOfDay: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.timeOfDay = timeOfDay
            self.timezone = timezone
        }
    }

}

extension Inspector2ClientTypes {
    /// A daily schedule.
    public struct DailySchedule {
        /// The schedule start time.
        /// This member is required.
        public var startTime: Inspector2ClientTypes.Time?

        public init(
            startTime: Inspector2ClientTypes.Time? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension Inspector2ClientTypes {

    public enum Day: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fri
        case mon
        case sat
        case sun
        case thu
        case tue
        case wed
        case sdkUnknown(Swift.String)

        public static var allCases: [Day] {
            return [
                .fri,
                .mon,
                .sat,
                .sun,
                .thu,
                .tue,
                .wed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fri: return "FRI"
            case .mon: return "MON"
            case .sat: return "SAT"
            case .sun: return "SUN"
            case .thu: return "THU"
            case .tue: return "TUE"
            case .wed: return "WED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// A monthly schedule.
    public struct MonthlySchedule {
        /// The monthly schedule's day.
        /// This member is required.
        public var day: Inspector2ClientTypes.Day?
        /// The monthly schedule's start time.
        /// This member is required.
        public var startTime: Inspector2ClientTypes.Time?

        public init(
            day: Inspector2ClientTypes.Day? = nil,
            startTime: Inspector2ClientTypes.Time? = nil
        )
        {
            self.day = day
            self.startTime = startTime
        }
    }

}

extension Inspector2ClientTypes {
    /// A one time schedule.
    public struct OneTimeSchedule {

        public init() { }
    }

}

extension Inspector2ClientTypes {
    /// A weekly schedule.
    public struct WeeklySchedule {
        /// The weekly schedule's days.
        /// This member is required.
        public var days: [Inspector2ClientTypes.Day]?
        /// The weekly schedule's start time.
        /// This member is required.
        public var startTime: Inspector2ClientTypes.Time?

        public init(
            days: [Inspector2ClientTypes.Day]? = nil,
            startTime: Inspector2ClientTypes.Time? = nil
        )
        {
            self.days = days
            self.startTime = startTime
        }
    }

}

extension Inspector2ClientTypes {
    /// A schedule.
    public enum Schedule {
        /// The schedule's one time.
        case onetime(Inspector2ClientTypes.OneTimeSchedule)
        /// The schedule's daily.
        case daily(Inspector2ClientTypes.DailySchedule)
        /// The schedule's weekly.
        case weekly(Inspector2ClientTypes.WeeklySchedule)
        /// The schedule's monthly.
        case monthly(Inspector2ClientTypes.MonthlySchedule)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    /// The CIS scan configuration.
    public struct CisScanConfiguration {
        /// The CIS scan configuration's owner ID.
        public var ownerId: Swift.String?
        /// The CIS scan configuration's scan configuration ARN.
        /// This member is required.
        public var scanConfigurationArn: Swift.String?
        /// The name of the CIS scan configuration.
        public var scanName: Swift.String?
        /// The CIS scan configuration's schedule.
        public var schedule: Inspector2ClientTypes.Schedule?
        /// The CIS scan configuration's security level.
        public var securityLevel: Inspector2ClientTypes.CisSecurityLevel?
        /// The CIS scan configuration's tags.
        public var tags: [Swift.String: Swift.String]?
        /// The CIS scan configuration's targets.
        public var targets: Inspector2ClientTypes.CisTargets?

        public init(
            ownerId: Swift.String? = nil,
            scanConfigurationArn: Swift.String? = nil,
            scanName: Swift.String? = nil,
            schedule: Inspector2ClientTypes.Schedule? = nil,
            securityLevel: Inspector2ClientTypes.CisSecurityLevel? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targets: Inspector2ClientTypes.CisTargets? = nil
        )
        {
            self.ownerId = ownerId
            self.scanConfigurationArn = scanConfigurationArn
            self.scanName = scanName
            self.schedule = schedule
            self.securityLevel = securityLevel
            self.tags = tags
            self.targets = targets
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisScanConfigurationsSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case scanConfigurationArn
        case scanName
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanConfigurationsSortBy] {
            return [
                .scanConfigurationArn,
                .scanName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .scanConfigurationArn: return "SCAN_CONFIGURATION_ARN"
            case .scanName: return "SCAN_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS scan result details.
    public struct CisScanResultDetails {
        /// The CIS scan result details' account ID.
        public var accountId: Swift.String?
        /// The account ID that's associated with the CIS scan result details.
        public var checkDescription: Swift.String?
        /// The CIS scan result details' check ID.
        public var checkId: Swift.String?
        /// The CIS scan result details' finding ARN.
        public var findingArn: Swift.String?
        /// The CIS scan result details' level.
        public var level: Inspector2ClientTypes.CisSecurityLevel?
        /// The CIS scan result details' platform.
        public var platform: Swift.String?
        /// The CIS scan result details' remediation.
        public var remediation: Swift.String?
        /// The CIS scan result details' scan ARN.
        /// This member is required.
        public var scanArn: Swift.String?
        /// The CIS scan result details' status.
        public var status: Inspector2ClientTypes.CisFindingStatus?
        /// The CIS scan result details' status reason.
        public var statusReason: Swift.String?
        /// The CIS scan result details' target resource ID.
        public var targetResourceId: Swift.String?
        /// The CIS scan result details' title.
        public var title: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            checkDescription: Swift.String? = nil,
            checkId: Swift.String? = nil,
            findingArn: Swift.String? = nil,
            level: Inspector2ClientTypes.CisSecurityLevel? = nil,
            platform: Swift.String? = nil,
            remediation: Swift.String? = nil,
            scanArn: Swift.String? = nil,
            status: Inspector2ClientTypes.CisFindingStatus? = nil,
            statusReason: Swift.String? = nil,
            targetResourceId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.checkDescription = checkDescription
            self.checkId = checkId
            self.findingArn = findingArn
            self.level = level
            self.platform = platform
            self.remediation = remediation
            self.scanArn = scanArn
            self.status = status
            self.statusReason = statusReason
            self.targetResourceId = targetResourceId
            self.title = title
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisSecurityLevelComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CisSecurityLevelComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS security level filter. Security level refers to the Benchmark levels that CIS assigns to a profile.
    public struct CisSecurityLevelFilter {
        /// The CIS security filter comparison value.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisSecurityLevelComparison?
        /// The CIS security filter value.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisSecurityLevel?

        public init(
            comparison: Inspector2ClientTypes.CisSecurityLevelComparison? = nil,
            value: Inspector2ClientTypes.CisSecurityLevel? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// The CIS scan result details filter criteria.
    public struct CisScanResultDetailsFilterCriteria {
        /// The criteria's check ID filters.
        public var checkIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's finding ARN filters.
        public var findingArnFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's finding status filters.
        public var findingStatusFilters: [Inspector2ClientTypes.CisFindingStatusFilter]?
        /// The criteria's security level filters. . Security level refers to the Benchmark levels that CIS assigns to a profile.
        public var securityLevelFilters: [Inspector2ClientTypes.CisSecurityLevelFilter]?
        /// The criteria's title filters.
        public var titleFilters: [Inspector2ClientTypes.CisStringFilter]?

        public init(
            checkIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            findingArnFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            findingStatusFilters: [Inspector2ClientTypes.CisFindingStatusFilter]? = nil,
            securityLevelFilters: [Inspector2ClientTypes.CisSecurityLevelFilter]? = nil,
            titleFilters: [Inspector2ClientTypes.CisStringFilter]? = nil
        )
        {
            self.checkIdFilters = checkIdFilters
            self.findingArnFilters = findingArnFilters
            self.findingStatusFilters = findingStatusFilters
            self.securityLevelFilters = securityLevelFilters
            self.titleFilters = titleFilters
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisScanResultDetailsSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case checkId
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanResultDetailsSortBy] {
            return [
                .checkId,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .checkId: return "CHECK_ID"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The scan results aggregated by checks filter criteria.
    public struct CisScanResultsAggregatedByChecksFilterCriteria {
        /// The criteria's account ID filters.
        public var accountIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's check ID filters.
        public var checkIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's failed resources filters.
        public var failedResourcesFilters: [Inspector2ClientTypes.CisNumberFilter]?
        /// The criteria's platform filters.
        public var platformFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's security level filters.
        public var securityLevelFilters: [Inspector2ClientTypes.CisSecurityLevelFilter]?
        /// The criteria's title filters.
        public var titleFilters: [Inspector2ClientTypes.CisStringFilter]?

        public init(
            accountIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            checkIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            failedResourcesFilters: [Inspector2ClientTypes.CisNumberFilter]? = nil,
            platformFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            securityLevelFilters: [Inspector2ClientTypes.CisSecurityLevelFilter]? = nil,
            titleFilters: [Inspector2ClientTypes.CisStringFilter]? = nil
        )
        {
            self.accountIdFilters = accountIdFilters
            self.checkIdFilters = checkIdFilters
            self.failedResourcesFilters = failedResourcesFilters
            self.platformFilters = platformFilters
            self.securityLevelFilters = securityLevelFilters
            self.titleFilters = titleFilters
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisScanResultsAggregatedByChecksSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case checkId
        case failedCounts
        case platform
        case securityLevel
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanResultsAggregatedByChecksSortBy] {
            return [
                .checkId,
                .failedCounts,
                .platform,
                .securityLevel,
                .title
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .checkId: return "CHECK_ID"
            case .failedCounts: return "FAILED_COUNTS"
            case .platform: return "PLATFORM"
            case .securityLevel: return "SECURITY_LEVEL"
            case .title: return "TITLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum TagComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [TagComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The tag filter.
    public struct TagFilter {
        /// The tag filter comparison value.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.TagComparison?
        /// The tag filter key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag filter value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.TagComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisTargetStatusComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CisTargetStatusComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CisTargetStatus] {
            return [
                .cancelled,
                .completed,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS target status filter.
    public struct CisTargetStatusFilter {
        /// The comparison value of the CIS target status filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisTargetStatusComparison?
        /// The value of the CIS target status filter.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisTargetStatus?

        public init(
            comparison: Inspector2ClientTypes.CisTargetStatusComparison? = nil,
            value: Inspector2ClientTypes.CisTargetStatus? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisTargetStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case scanInProgress
        case ssmUnmanaged
        case unsupportedOs
        case sdkUnknown(Swift.String)

        public static var allCases: [CisTargetStatusReason] {
            return [
                .scanInProgress,
                .ssmUnmanaged,
                .unsupportedOs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .scanInProgress: return "SCAN_IN_PROGRESS"
            case .ssmUnmanaged: return "SSM_UNMANAGED"
            case .unsupportedOs: return "UNSUPPORTED_OS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS target status reason filter.
    public struct CisTargetStatusReasonFilter {
        /// The comparison value of the CIS target status reason filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisTargetStatusComparison?
        /// The value of the CIS target status reason filter.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisTargetStatusReason?

        public init(
            comparison: Inspector2ClientTypes.CisTargetStatusComparison? = nil,
            value: Inspector2ClientTypes.CisTargetStatusReason? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// The scan results aggregated by target resource filter criteria.
    public struct CisScanResultsAggregatedByTargetResourceFilterCriteria {
        /// The criteria's account ID filters.
        public var accountIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's check ID filters.
        public var checkIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's failed checks filters.
        public var failedChecksFilters: [Inspector2ClientTypes.CisNumberFilter]?
        /// The criteria's platform filters.
        public var platformFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's status filter.
        public var statusFilters: [Inspector2ClientTypes.CisResultStatusFilter]?
        /// The criteria's target resource ID filters.
        public var targetResourceIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The criteria's target resource tag filters.
        public var targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]?
        /// The criteria's target status filters.
        public var targetStatusFilters: [Inspector2ClientTypes.CisTargetStatusFilter]?
        /// The criteria's target status reason filters.
        public var targetStatusReasonFilters: [Inspector2ClientTypes.CisTargetStatusReasonFilter]?

        public init(
            accountIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            checkIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            failedChecksFilters: [Inspector2ClientTypes.CisNumberFilter]? = nil,
            platformFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            statusFilters: [Inspector2ClientTypes.CisResultStatusFilter]? = nil,
            targetResourceIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]? = nil,
            targetStatusFilters: [Inspector2ClientTypes.CisTargetStatusFilter]? = nil,
            targetStatusReasonFilters: [Inspector2ClientTypes.CisTargetStatusReasonFilter]? = nil
        )
        {
            self.accountIdFilters = accountIdFilters
            self.checkIdFilters = checkIdFilters
            self.failedChecksFilters = failedChecksFilters
            self.platformFilters = platformFilters
            self.statusFilters = statusFilters
            self.targetResourceIdFilters = targetResourceIdFilters
            self.targetResourceTagFilters = targetResourceTagFilters
            self.targetStatusFilters = targetStatusFilters
            self.targetStatusReasonFilters = targetStatusReasonFilters
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisScanResultsAggregatedByTargetResourceSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case failedCounts
        case platform
        case resourceId
        case targetStatus
        case targetStatusReason
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanResultsAggregatedByTargetResourceSortBy] {
            return [
                .accountId,
                .failedCounts,
                .platform,
                .resourceId,
                .targetStatus,
                .targetStatusReason
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .failedCounts: return "FAILED_COUNTS"
            case .platform: return "PLATFORM"
            case .resourceId: return "RESOURCE_ID"
            case .targetStatus: return "TARGET_STATUS"
            case .targetStatusReason: return "TARGET_STATUS_REASON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum CisScanStatusComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CisScanStatusComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS scan status filter.
    public struct CisScanStatusFilter {
        /// The filter comparison value.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CisScanStatusComparison?
        /// The filter value.
        /// This member is required.
        public var value: Inspector2ClientTypes.CisScanStatus?

        public init(
            comparison: Inspector2ClientTypes.CisScanStatusComparison? = nil,
            value: Inspector2ClientTypes.CisScanStatus? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// The CIS session message.
    public struct CisSessionMessage {
        /// The CIS rule details for the CIS session message.
        /// This member is required.
        public var cisRuleDetails: Foundation.Data?
        /// The rule ID for the CIS session message.
        /// This member is required.
        public var ruleId: Swift.String?
        /// The status of the CIS session message.
        /// This member is required.
        public var status: Inspector2ClientTypes.CisRuleStatus?

        public init(
            cisRuleDetails: Foundation.Data? = nil,
            ruleId: Swift.String? = nil,
            status: Inspector2ClientTypes.CisRuleStatus? = nil
        )
        {
            self.cisRuleDetails = cisRuleDetails
            self.ruleId = ruleId
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {

    public enum CisSortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [CisSortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The CIS target resource aggregation.
    public struct CisTargetResourceAggregation {
        /// The account ID for the CIS target resource.
        public var accountId: Swift.String?
        /// The platform for the CIS target resource.
        public var platform: Swift.String?
        /// The scan ARN for the CIS target resource.
        /// This member is required.
        public var scanArn: Swift.String?
        /// The target resource status counts.
        public var statusCounts: Inspector2ClientTypes.StatusCounts?
        /// The ID of the target resource.
        public var targetResourceId: Swift.String?
        /// The tag for the target resource.
        public var targetResourceTags: [Swift.String: [Swift.String]]?
        /// The status of the target resource.
        public var targetStatus: Inspector2ClientTypes.CisTargetStatus?
        /// The reason for the target resource.
        public var targetStatusReason: Inspector2ClientTypes.CisTargetStatusReason?

        public init(
            accountId: Swift.String? = nil,
            platform: Swift.String? = nil,
            scanArn: Swift.String? = nil,
            statusCounts: Inspector2ClientTypes.StatusCounts? = nil,
            targetResourceId: Swift.String? = nil,
            targetResourceTags: [Swift.String: [Swift.String]]? = nil,
            targetStatus: Inspector2ClientTypes.CisTargetStatus? = nil,
            targetStatusReason: Inspector2ClientTypes.CisTargetStatusReason? = nil
        )
        {
            self.accountId = accountId
            self.platform = platform
            self.scanArn = scanArn
            self.statusCounts = statusCounts
            self.targetResourceId = targetResourceId
            self.targetResourceTags = targetResourceTags
            self.targetStatus = targetStatus
            self.targetStatusReason = targetStatusReason
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains information on where a code vulnerability is located in your Lambda function.
    public struct CodeFilePath {
        /// The line number of the last line of code that a vulnerability was found in.
        /// This member is required.
        public var endLine: Swift.Int?
        /// The name of the file the code vulnerability was found in.
        /// This member is required.
        public var fileName: Swift.String?
        /// The file path to the code that a vulnerability was found in.
        /// This member is required.
        public var filePath: Swift.String?
        /// The line number of the first line of code that a vulnerability was found in.
        /// This member is required.
        public var startLine: Swift.Int?

        public init(
            endLine: Swift.Int? = nil,
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.fileName = fileName
            self.filePath = filePath
            self.startLine = startLine
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains information on the code vulnerability identified in your Lambda function.
    public struct CodeVulnerabilityDetails {
        /// The Common Weakness Enumeration (CWE) item associated with the detected vulnerability.
        /// This member is required.
        public var cwes: [Swift.String]?
        /// The ID for the Amazon CodeGuru detector associated with the finding. For more information on detectors see [Amazon CodeGuru Detector Library](https://docs.aws.amazon.com/codeguru/detector-library).
        /// This member is required.
        public var detectorId: Swift.String?
        /// The name of the detector used to identify the code vulnerability. For more information on detectors see [CodeGuru Detector Library](https://docs.aws.amazon.com/codeguru/detector-library).
        /// This member is required.
        public var detectorName: Swift.String?
        /// The detector tag associated with the vulnerability. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see [Java tags](https://docs.aws.amazon.com/codeguru/detector-library/java/tags/), or [Python tags](https://docs.aws.amazon.com/codeguru/detector-library/python/tags/).
        public var detectorTags: [Swift.String]?
        /// Contains information on where the code vulnerability is located in your code.
        /// This member is required.
        public var filePath: Inspector2ClientTypes.CodeFilePath?
        /// A URL containing supporting documentation about the code vulnerability detected.
        public var referenceUrls: [Swift.String]?
        /// The identifier for a rule that was used to detect the code vulnerability.
        public var ruleId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Lambda layer that the code vulnerability was detected in.
        public var sourceLambdaLayerArn: Swift.String?

        public init(
            cwes: [Swift.String]? = nil,
            detectorId: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorTags: [Swift.String]? = nil,
            filePath: Inspector2ClientTypes.CodeFilePath? = nil,
            referenceUrls: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            sourceLambdaLayerArn: Swift.String? = nil
        )
        {
            self.cwes = cwes
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.filePath = filePath
            self.referenceUrls = referenceUrls
            self.ruleId = ruleId
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
        }
    }

}

extension Inspector2ClientTypes {
    /// A compute platform.
    public struct ComputePlatform {
        /// The compute platform product.
        public var product: Swift.String?
        /// The compute platform vendor.
        public var vendor: Swift.String?
        /// The compute platform version.
        public var version: Swift.String?

        public init(
            product: Swift.String? = nil,
            vendor: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.product = product
            self.vendor = vendor
            self.version = version
        }
    }

}

/// A conflict occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension Inspector2ClientTypes {

    public enum GroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case ecrRepositoryName
        case resourceType
        case scanStatusCode
        case scanStatusReason
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupKey] {
            return [
                .accountId,
                .ecrRepositoryName,
                .resourceType,
                .scanStatusCode,
                .scanStatusReason
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .ecrRepositoryName: return "ECR_REPOSITORY_NAME"
            case .resourceType: return "RESOURCE_TYPE"
            case .scanStatusCode: return "SCAN_STATUS_CODE"
            case .scanStatusReason: return "SCAN_STATUS_REASON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// a structure that contains information on the count of resources within a group.
    public struct Counts {
        /// The number of resources.
        public var count: Swift.Int
        /// The key associated with this group
        public var groupKey: Inspector2ClientTypes.GroupKey?

        public init(
            count: Swift.Int = 0,
            groupKey: Inspector2ClientTypes.GroupKey? = nil
        )
        {
            self.count = count
            self.groupKey = groupKey
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains details of a coverage date filter.
    public struct CoverageDateFilter {
        /// A timestamp representing the end of the time period to filter results by.
        public var endInclusive: Foundation.Date?
        /// A timestamp representing the start of the time period to filter results by.
        public var startInclusive: Foundation.Date?

        public init(
            endInclusive: Foundation.Date? = nil,
            startInclusive: Foundation.Date? = nil
        )
        {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }
    }

}

extension Inspector2ClientTypes {

    public enum CoverageStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageStringComparison] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage string filter.
    public struct CoverageStringFilter {
        /// The operator to compare strings on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageStringComparison?
        /// The value to compare strings on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.CoverageStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum CoverageMapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageMapComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage map filter.
    public struct CoverageMapFilter {
        /// The operator to compare coverage on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageMapComparison?
        /// The tag key associated with the coverage map filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value associated with the coverage map filter.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.CoverageMapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// A structure that identifies filter criteria for GetCoverageStatistics.
    public struct CoverageFilterCriteria {
        /// An array of Amazon Web Services account IDs to return coverage statistics for.
        public var accountId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon EC2 instance tags to filter on.
        public var ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]?
        /// The Amazon ECR image tags to filter on.
        public var ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon ECR repository name to filter on.
        public var ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The date an image was last pulled at.
        public var imagePulledAt: [Inspector2ClientTypes.CoverageDateFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by function names.
        public var lambdaFunctionName: [Inspector2ClientTypes.CoverageStringFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by runtime.
        public var lambdaFunctionRuntime: [Inspector2ClientTypes.CoverageStringFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by tag.
        public var lambdaFunctionTags: [Inspector2ClientTypes.CoverageMapFilter]?
        /// Filters Amazon Web Services resources based on whether Amazon Inspector has checked them for vulnerabilities within the specified time range.
        public var lastScannedAt: [Inspector2ClientTypes.CoverageDateFilter]?
        /// An array of Amazon Web Services resource IDs to return coverage statistics for.
        public var resourceId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Web Services resource types to return coverage statistics for. The values can be AWS_EC2_INSTANCE, AWS_LAMBDA_FUNCTION, AWS_ECR_CONTAINER_IMAGE, AWS_ECR_REPOSITORY or AWS_ACCOUNT.
        public var resourceType: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The filter to search for Amazon EC2 instance coverage by scan mode. Valid values are EC2_SSM_AGENT_BASED and EC2_HYBRID.
        public var scanMode: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status code to filter on. Valid values are: ValidationException, InternalServerException, ResourceNotFoundException, BadRequestException, and ThrottlingException.
        public var scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status reason to filter on.
        public var scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Inspector scan types to return coverage statistics for.
        public var scanType: [Inspector2ClientTypes.CoverageStringFilter]?

        public init(
            accountId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            imagePulledAt: [Inspector2ClientTypes.CoverageDateFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            lambdaFunctionRuntime: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            lambdaFunctionTags: [Inspector2ClientTypes.CoverageMapFilter]? = nil,
            lastScannedAt: [Inspector2ClientTypes.CoverageDateFilter]? = nil,
            resourceId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            resourceType: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanMode: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanType: [Inspector2ClientTypes.CoverageStringFilter]? = nil
        )
        {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.imagePulledAt = imagePulledAt
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lambdaFunctionTags = lambdaFunctionTags
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.scanMode = scanMode
            self.scanStatusCode = scanStatusCode
            self.scanStatusReason = scanStatusReason
            self.scanType = scanType
        }
    }

}

extension Inspector2ClientTypes {

    public enum CoverageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .awsLambdaFunction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum Ec2Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case macos
        case unknown
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2Platform] {
            return [
                .linux,
                .macos,
                .unknown,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .macos: return "MACOS"
            case .unknown: return "UNKNOWN"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Meta data details of an Amazon EC2 instance.
    public struct Ec2Metadata {
        /// The ID of the Amazon Machine Image (AMI) used to launch the instance.
        public var amiId: Swift.String?
        /// The platform of the instance.
        public var platform: Inspector2ClientTypes.Ec2Platform?
        /// The tags attached to the instance.
        public var tags: [Swift.String: Swift.String]?

        public init(
            amiId: Swift.String? = nil,
            platform: Inspector2ClientTypes.Ec2Platform? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.amiId = amiId
            self.platform = platform
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR image metadata associated with a finding.
    public struct EcrContainerImageMetadata {
        /// The date an image was last pulled at.
        public var imagePulledAt: Foundation.Date?
        /// Tags associated with the Amazon ECR image metadata.
        public var tags: [Swift.String]?

        public init(
            imagePulledAt: Foundation.Date? = nil,
            tags: [Swift.String]? = nil
        )
        {
            self.imagePulledAt = imagePulledAt
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes {

    public enum EcrScanFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuousScan
        case manual
        case scanOnPush
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrScanFrequency] {
            return [
                .continuousScan,
                .manual,
                .scanOnPush
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuousScan: return "CONTINUOUS_SCAN"
            case .manual: return "MANUAL"
            case .scanOnPush: return "SCAN_ON_PUSH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR repository metadata associated with a finding.
    public struct EcrRepositoryMetadata {
        /// The name of the Amazon ECR repository.
        public var name: Swift.String?
        /// The frequency of scans.
        public var scanFrequency: Inspector2ClientTypes.EcrScanFrequency?

        public init(
            name: Swift.String? = nil,
            scanFrequency: Inspector2ClientTypes.EcrScanFrequency? = nil
        )
        {
            self.name = name
            self.scanFrequency = scanFrequency
        }
    }

}

extension Inspector2ClientTypes {
    /// The Amazon Web Services Lambda function metadata.
    public struct LambdaFunctionMetadata {
        /// The name of a function.
        public var functionName: Swift.String?
        /// The resource tags on an Amazon Web Services Lambda function.
        public var functionTags: [Swift.String: Swift.String]?
        /// The layers for an Amazon Web Services Lambda function. A Lambda function can have up to five layers.
        public var layers: [Swift.String]?
        /// An Amazon Web Services Lambda function's runtime.
        public var runtime: Inspector2ClientTypes.Runtime?

        public init(
            functionName: Swift.String? = nil,
            functionTags: [Swift.String: Swift.String]? = nil,
            layers: [Swift.String]? = nil,
            runtime: Inspector2ClientTypes.Runtime? = nil
        )
        {
            self.functionName = functionName
            self.functionTags = functionTags
            self.layers = layers
            self.runtime = runtime
        }
    }

}

extension Inspector2ClientTypes {
    /// An object that contains details about the metadata for an Amazon ECR resource.
    public struct ResourceScanMetadata {
        /// An object that contains metadata details for an Amazon EC2 instance.
        public var ec2: Inspector2ClientTypes.Ec2Metadata?
        /// An object that contains details about the container metadata for an Amazon ECR image.
        public var ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata?
        /// An object that contains details about the repository an Amazon ECR image resides in.
        public var ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata?
        /// An object that contains metadata details for an Amazon Web Services Lambda function.
        public var lambdaFunction: Inspector2ClientTypes.LambdaFunctionMetadata?

        public init(
            ec2: Inspector2ClientTypes.Ec2Metadata? = nil,
            ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata? = nil,
            ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata? = nil,
            lambdaFunction: Inspector2ClientTypes.LambdaFunctionMetadata? = nil
        )
        {
            self.ec2 = ec2
            self.ecrImage = ecrImage
            self.ecrRepository = ecrRepository
            self.lambdaFunction = lambdaFunction
        }
    }

}

extension Inspector2ClientTypes {

    public enum ScanMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2Agentless
        case ec2SsmAgentBased
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanMode] {
            return [
                .ec2Agentless,
                .ec2SsmAgentBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2Agentless: return "EC2_AGENTLESS"
            case .ec2SsmAgentBased: return "EC2_SSM_AGENT_BASED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum ScanStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case agentlessInstanceCollectionTimeLimitExceeded
        case agentlessInstanceStorageLimitExceeded
        case deepInspectionCollectionTimeLimitExceeded
        case deepInspectionDailySsmInventoryLimitExceeded
        case deepInspectionNoInventory
        case deepInspectionPackageCollectionLimitExceeded
        case ec2InstanceStopped
        case excludedByTag
        case imageSizeExceeded
        case internalError
        case noInventory
        case noResourcesFound
        case pendingDisable
        case pendingInitialScan
        case resourceTerminated
        case scanEligibilityExpired
        case scanFrequencyManual
        case scanFrequencyScanOnPush
        case staleInventory
        case successful
        case unmanagedEc2Instance
        case unsupportedConfigFile
        case unsupportedMediaType
        case unsupportedOs
        case unsupportedRuntime
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusReason] {
            return [
                .accessDenied,
                .agentlessInstanceCollectionTimeLimitExceeded,
                .agentlessInstanceStorageLimitExceeded,
                .deepInspectionCollectionTimeLimitExceeded,
                .deepInspectionDailySsmInventoryLimitExceeded,
                .deepInspectionNoInventory,
                .deepInspectionPackageCollectionLimitExceeded,
                .ec2InstanceStopped,
                .excludedByTag,
                .imageSizeExceeded,
                .internalError,
                .noInventory,
                .noResourcesFound,
                .pendingDisable,
                .pendingInitialScan,
                .resourceTerminated,
                .scanEligibilityExpired,
                .scanFrequencyManual,
                .scanFrequencyScanOnPush,
                .staleInventory,
                .successful,
                .unmanagedEc2Instance,
                .unsupportedConfigFile,
                .unsupportedMediaType,
                .unsupportedOs,
                .unsupportedRuntime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .agentlessInstanceCollectionTimeLimitExceeded: return "AGENTLESS_INSTANCE_COLLECTION_TIME_LIMIT_EXCEEDED"
            case .agentlessInstanceStorageLimitExceeded: return "AGENTLESS_INSTANCE_STORAGE_LIMIT_EXCEEDED"
            case .deepInspectionCollectionTimeLimitExceeded: return "DEEP_INSPECTION_COLLECTION_TIME_LIMIT_EXCEEDED"
            case .deepInspectionDailySsmInventoryLimitExceeded: return "DEEP_INSPECTION_DAILY_SSM_INVENTORY_LIMIT_EXCEEDED"
            case .deepInspectionNoInventory: return "DEEP_INSPECTION_NO_INVENTORY"
            case .deepInspectionPackageCollectionLimitExceeded: return "DEEP_INSPECTION_PACKAGE_COLLECTION_LIMIT_EXCEEDED"
            case .ec2InstanceStopped: return "EC2_INSTANCE_STOPPED"
            case .excludedByTag: return "EXCLUDED_BY_TAG"
            case .imageSizeExceeded: return "IMAGE_SIZE_EXCEEDED"
            case .internalError: return "INTERNAL_ERROR"
            case .noInventory: return "NO_INVENTORY"
            case .noResourcesFound: return "NO_RESOURCES_FOUND"
            case .pendingDisable: return "PENDING_DISABLE"
            case .pendingInitialScan: return "PENDING_INITIAL_SCAN"
            case .resourceTerminated: return "RESOURCE_TERMINATED"
            case .scanEligibilityExpired: return "SCAN_ELIGIBILITY_EXPIRED"
            case .scanFrequencyManual: return "SCAN_FREQUENCY_MANUAL"
            case .scanFrequencyScanOnPush: return "SCAN_FREQUENCY_SCAN_ON_PUSH"
            case .staleInventory: return "STALE_INVENTORY"
            case .successful: return "SUCCESSFUL"
            case .unmanagedEc2Instance: return "UNMANAGED_EC2_INSTANCE"
            case .unsupportedConfigFile: return "UNSUPPORTED_CONFIG_FILE"
            case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
            case .unsupportedOs: return "UNSUPPORTED_OS"
            case .unsupportedRuntime: return "UNSUPPORTED_RUNTIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum ScanStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusCode] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The status of the scan.
    public struct ScanStatus {
        /// The scan status. Possible return values and descriptions are: PENDING_INITIAL_SCAN - This resource has been identified for scanning, results will be available soon. ACCESS_DENIED - Resource access policy restricting Amazon Inspector access. Please update the IAM policy. INTERNAL_ERROR - Amazon Inspector has encountered an internal error for this resource. Amazon Inspector service will automatically resolve the issue and resume the scanning. No action required from the user. UNMANAGED_EC2_INSTANCE - The EC2 instance is not managed by SSM, please use the following SSM automation to remediate the issue: [https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/automation-awssupport-troubleshoot-managed-instance.html](https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/automation-awssupport-troubleshoot-managed-instance.html). Once the instance becomes managed by SSM, Inspector will automatically begin scanning this instance. UNSUPPORTED_OS - Amazon Inspector does not support this OS, architecture, or image manifest type at this time. To see a complete list of supported operating systems see: [https://docs.aws.amazon.com/inspector/latest/user/supported.html](https://docs.aws.amazon.com/inspector/latest/user/supported.html). SCAN_ELIGIBILITY_EXPIRED - The configured scan duration has lapsed for this image. RESOURCE_TERMINATED - This resource has been terminated. The findings and coverage associated with this resource are in the process of being cleaned up. SUCCESSFUL - The scan was successful. NO_RESOURCES_FOUND - Reserved for future use. IMAGE_SIZE_EXCEEDED - Reserved for future use. SCAN_FREQUENCY_MANUAL - This image will not be covered by Amazon Inspector due to the repository scan frequency configuration. SCAN_FREQUENCY_SCAN_ON_PUSH - This image will be scanned one time and will not new findings because of the scan frequency configuration. EC2_INSTANCE_STOPPED - This EC2 instance is in a stopped state, therefore, Amazon Inspector will pause scanning. The existing findings will continue to exist until the instance is terminated. Once the instance is re-started, Inspector will automatically start scanning the instance again. Please note that you will not be charged for this instance while it’s in a stopped state. PENDING_DISABLE - This resource is pending cleanup during disablement. The customer will not be billed while a resource is in the pending disable status. NO INVENTORY - Amazon Inspector couldn’t find software application inventory to scan for vulnerabilities. This might be caused due to required Amazon Inspector associations being deleted or failing to run on your resource. Please verify the status of InspectorInventoryCollection-do-not-delete association in the SSM console for the resource. Additionally, you can verify the instance’s inventory in the SSM Fleet Manager console. STALE_INVENTORY - Amazon Inspector wasn’t able to collect an updated software application inventory in the last 7 days. Please confirm the required Amazon Inspector associations still exist and you can still see an updated inventory in the SSM console. EXCLUDED_BY_TAG - This resource was not scanned because it has been excluded by a tag. UNSUPPORTED_RUNTIME - The function was not scanned because it has an unsupported runtime. To see a complete list of supported runtimes see: [https://docs.aws.amazon.com/inspector/latest/user/supported.html](https://docs.aws.amazon.com/inspector/latest/user/supported.html). UNSUPPORTED_MEDIA_TYPE - The ECR image has an unsupported media type. UNSUPPORTED_CONFIG_FILE - Reserved for future use. DEEP_INSPECTION_PACKAGE_COLLECTION_LIMIT_EXCEEDED - The instance has exceeded the 5000 package limit for Amazon Inspector Deep inspection. To resume Deep inspection for this instance you can try to adjust the custom paths associated with the account. DEEP_INSPECTION_DAILY_SSM_INVENTORY_LIMIT_EXCEEDED - The SSM agent couldn't send inventory to Amazon Inspector because the SSM quota for Inventory data collected per instance per day has already been reached for this instance. DEEP_INSPECTION_COLLECTION_TIME_LIMIT_EXCEEDED - Amazon Inspector failed to extract the package inventory because the package collection time exceeding the maximum threshold of 15 minutes. DEEP_INSPECTION_NO_INVENTORY The Amazon Inspector plugin hasn't yet been able to collect an inventory of packages for this instance. This is usually the result of a pending scan, however, if this status persists after 6 hours, use SSM to ensure that the required Amazon Inspector associations exist and are running for the instance.
        /// This member is required.
        public var reason: Inspector2ClientTypes.ScanStatusReason?
        /// The status code of the scan.
        /// This member is required.
        public var statusCode: Inspector2ClientTypes.ScanStatusCode?

        public init(
            reason: Inspector2ClientTypes.ScanStatusReason? = nil,
            statusCode: Inspector2ClientTypes.ScanStatusCode? = nil
        )
        {
            self.reason = reason
            self.statusCode = statusCode
        }
    }

}

extension Inspector2ClientTypes {

    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case code
        case network
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .code,
                .network,
                .package
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .code: return "CODE"
            case .network: return "NETWORK"
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about a resource covered by Amazon Inspector.
    public struct CoveredResource {
        /// The Amazon Web Services account ID of the covered resource.
        /// This member is required.
        public var accountId: Swift.String?
        /// The date and time the resource was last checked for vulnerabilities.
        public var lastScannedAt: Foundation.Date?
        /// The ID of the covered resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that contains details about the metadata.
        public var resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata?
        /// The type of the covered resource.
        /// This member is required.
        public var resourceType: Inspector2ClientTypes.CoverageResourceType?
        /// The scan method that is applied to the instance.
        public var scanMode: Inspector2ClientTypes.ScanMode?
        /// The status of the scan covering the resource.
        public var scanStatus: Inspector2ClientTypes.ScanStatus?
        /// The Amazon Inspector scan type covering the resource.
        /// This member is required.
        public var scanType: Inspector2ClientTypes.ScanType?

        public init(
            accountId: Swift.String? = nil,
            lastScannedAt: Foundation.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata? = nil,
            resourceType: Inspector2ClientTypes.CoverageResourceType? = nil,
            scanMode: Inspector2ClientTypes.ScanMode? = nil,
            scanStatus: Inspector2ClientTypes.ScanStatus? = nil,
            scanType: Inspector2ClientTypes.ScanType? = nil
        )
        {
            self.accountId = accountId
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceMetadata = resourceMetadata
            self.resourceType = resourceType
            self.scanMode = scanMode
            self.scanStatus = scanStatus
            self.scanType = scanType
        }
    }

}

extension Inspector2ClientTypes {
    /// Creates CIS targets.
    public struct CreateCisTargets {
        /// The CIS target account ids.
        /// This member is required.
        public var accountIds: [Swift.String]?
        /// The CIS target resource tags.
        /// This member is required.
        public var targetResourceTags: [Swift.String: [Swift.String]]?

        public init(
            accountIds: [Swift.String]? = nil,
            targetResourceTags: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }
    }

}

public struct CreateCisScanConfigurationInput {
    /// The scan name for the CIS scan configuration.
    /// This member is required.
    public var scanName: Swift.String?
    /// The schedule for the CIS scan configuration.
    /// This member is required.
    public var schedule: Inspector2ClientTypes.Schedule?
    /// The security level for the CIS scan configuration. Security level refers to the Benchmark levels that CIS assigns to a profile.
    /// This member is required.
    public var securityLevel: Inspector2ClientTypes.CisSecurityLevel?
    /// The tags for the CIS scan configuration.
    public var tags: [Swift.String: Swift.String]?
    /// The targets for the CIS scan configuration.
    /// This member is required.
    public var targets: Inspector2ClientTypes.CreateCisTargets?

    public init(
        scanName: Swift.String? = nil,
        schedule: Inspector2ClientTypes.Schedule? = nil,
        securityLevel: Inspector2ClientTypes.CisSecurityLevel? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: Inspector2ClientTypes.CreateCisTargets? = nil
    )
    {
        self.scanName = scanName
        self.schedule = schedule
        self.securityLevel = securityLevel
        self.tags = tags
        self.targets = targets
    }
}

public struct CreateCisScanConfigurationOutput {
    /// The scan configuration ARN for the CIS scan configuration.
    public var scanConfigurationArn: Swift.String?

    public init(
        scanConfigurationArn: Swift.String? = nil
    )
    {
        self.scanConfigurationArn = scanConfigurationArn
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that exceeds a service quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

extension Inspector2ClientTypes {

    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .none,
                .suppress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains details on the time range used to filter findings.
    public struct DateFilter {
        /// A timestamp representing the end of the time period filtered on.
        public var endInclusive: Foundation.Date?
        /// A timestamp representing the start of the time period filtered on.
        public var startInclusive: Foundation.Date?

        public init(
            endInclusive: Foundation.Date? = nil,
            startInclusive: Foundation.Date? = nil
        )
        {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }
    }

}

extension Inspector2ClientTypes {
    /// An object that describes the details of a number filter.
    public struct NumberFilter {
        /// The lowest number to be included in the filter.
        public var lowerInclusive: Swift.Double?
        /// The highest number to be included in the filter.
        public var upperInclusive: Swift.Double?

        public init(
            lowerInclusive: Swift.Double? = nil,
            upperInclusive: Swift.Double? = nil
        )
        {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }
    }

}

extension Inspector2ClientTypes {
    /// An object that describes the details of a port range filter.
    public struct PortRangeFilter {
        /// The port number the port range begins at.
        public var beginInclusive: Swift.Int?
        /// The port number the port range ends at.
        public var endInclusive: Swift.Int?

        public init(
            beginInclusive: Swift.Int? = nil,
            endInclusive: Swift.Int? = nil
        )
        {
            self.beginInclusive = beginInclusive
            self.endInclusive = endInclusive
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains information on the details of a package filter.
    public struct PackageFilter {
        /// An object that contains details on the package architecture type to filter on.
        public var architecture: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package epoch to filter on.
        public var epoch: Inspector2ClientTypes.NumberFilter?
        /// An object that contains details on the name of the package to filter on.
        public var name: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package release to filter on.
        public var release: Inspector2ClientTypes.StringFilter?
        /// An object that describes the details of a string filter.
        public var sourceLambdaLayerArn: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the source layer hash to filter on.
        public var sourceLayerHash: Inspector2ClientTypes.StringFilter?
        /// The package version to filter on.
        public var version: Inspector2ClientTypes.StringFilter?

        public init(
            architecture: Inspector2ClientTypes.StringFilter? = nil,
            epoch: Inspector2ClientTypes.NumberFilter? = nil,
            name: Inspector2ClientTypes.StringFilter? = nil,
            release: Inspector2ClientTypes.StringFilter? = nil,
            sourceLambdaLayerArn: Inspector2ClientTypes.StringFilter? = nil,
            sourceLayerHash: Inspector2ClientTypes.StringFilter? = nil,
            version: Inspector2ClientTypes.StringFilter? = nil
        )
        {
            self.architecture = architecture
            self.epoch = epoch
            self.name = name
            self.release = release
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {
    /// Details on the criteria used to define the filter.
    public struct FilterCriteria {
        /// Details of the Amazon Web Services account IDs used to filter findings.
        public var awsAccountId: [Inspector2ClientTypes.StringFilter]?
        /// The name of the detector used to identify a code vulnerability in a Lambda function used to filter findings.
        public var codeVulnerabilityDetectorName: [Inspector2ClientTypes.StringFilter]?
        /// The detector type tag associated with the vulnerability used to filter findings. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see [Java tags](https://docs.aws.amazon.com/codeguru/detector-library/java/tags/), or [Python tags](https://docs.aws.amazon.com/codeguru/detector-library/python/tags/).
        public var codeVulnerabilityDetectorTags: [Inspector2ClientTypes.StringFilter]?
        /// The file path to the file in a Lambda function that contains a code vulnerability used to filter findings.
        public var codeVulnerabilityFilePath: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component IDs used to filter findings.
        public var componentId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component types used to filter findings.
        public var componentType: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance image IDs used to filter findings.
        public var ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance subnet IDs used to filter findings.
        public var ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance VPC IDs used to filter findings.
        public var ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image architecture types used to filter findings.
        public var ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image hashes used to filter findings.
        public var ecrImageHash: [Inspector2ClientTypes.StringFilter]?
        /// Details on the Amazon ECR image push date and time used to filter findings.
        public var ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the Amazon ECR registry used to filter findings.
        public var ecrImageRegistry: [Inspector2ClientTypes.StringFilter]?
        /// Details on the name of the Amazon ECR repository used to filter findings.
        public var ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]?
        /// The tags attached to the Amazon ECR container image.
        public var ecrImageTags: [Inspector2ClientTypes.StringFilter]?
        /// The EPSS score used to filter findings.
        public var epssScore: [Inspector2ClientTypes.NumberFilter]?
        /// Filters the list of Amazon Web Services Lambda findings by the availability of exploits.
        public var exploitAvailable: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding ARNs used to filter findings.
        public var findingArn: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding status types used to filter findings.
        public var findingStatus: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding types used to filter findings.
        public var findingType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was first seen used to filter findings.
        public var firstObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL. A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public var fixAvailable: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon Inspector score to filter on.
        public var inspectorScore: [Inspector2ClientTypes.NumberFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by execution role.
        public var lambdaFunctionExecutionRoleArn: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html)
        public var lambdaFunctionLastModifiedAt: [Inspector2ClientTypes.DateFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). A Lambda function can have up to five layers.
        public var lambdaFunctionLayers: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the name of the function.
        public var lambdaFunctionName: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the runtime environment for the Lambda function.
        public var lambdaFunctionRuntime: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was last seen used to filter findings.
        public var lastObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on network protocol used to filter findings.
        public var networkProtocol: [Inspector2ClientTypes.StringFilter]?
        /// Details on the port ranges used to filter findings.
        public var portRange: [Inspector2ClientTypes.PortRangeFilter]?
        /// Details on the related vulnerabilities used to filter findings.
        public var relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource IDs used to filter findings.
        public var resourceId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource tags used to filter findings.
        public var resourceTags: [Inspector2ClientTypes.MapFilter]?
        /// Details on the resource types used to filter findings.
        public var resourceType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the severity used to filter findings.
        public var severity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding title used to filter findings.
        public var title: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was last updated at used to filter findings.
        public var updatedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the vendor severity used to filter findings.
        public var vendorSeverity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability ID used to filter findings.
        public var vulnerabilityId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability type used to filter findings.
        public var vulnerabilitySource: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerable packages used to filter findings.
        public var vulnerablePackages: [Inspector2ClientTypes.PackageFilter]?

        public init(
            awsAccountId: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityDetectorName: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityDetectorTags: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityFilePath: [Inspector2ClientTypes.StringFilter]? = nil,
            componentId: [Inspector2ClientTypes.StringFilter]? = nil,
            componentType: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageHash: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            ecrImageRegistry: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            epssScore: [Inspector2ClientTypes.NumberFilter]? = nil,
            exploitAvailable: [Inspector2ClientTypes.StringFilter]? = nil,
            findingArn: [Inspector2ClientTypes.StringFilter]? = nil,
            findingStatus: [Inspector2ClientTypes.StringFilter]? = nil,
            findingType: [Inspector2ClientTypes.StringFilter]? = nil,
            firstObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            fixAvailable: [Inspector2ClientTypes.StringFilter]? = nil,
            inspectorScore: [Inspector2ClientTypes.NumberFilter]? = nil,
            lambdaFunctionExecutionRoleArn: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionLastModifiedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            lambdaFunctionLayers: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionRuntime: [Inspector2ClientTypes.StringFilter]? = nil,
            lastObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            networkProtocol: [Inspector2ClientTypes.StringFilter]? = nil,
            portRange: [Inspector2ClientTypes.PortRangeFilter]? = nil,
            relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceId: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            resourceType: [Inspector2ClientTypes.StringFilter]? = nil,
            severity: [Inspector2ClientTypes.StringFilter]? = nil,
            title: [Inspector2ClientTypes.StringFilter]? = nil,
            updatedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            vendorSeverity: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityId: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilitySource: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerablePackages: [Inspector2ClientTypes.PackageFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetectorName = codeVulnerabilityDetectorName
            self.codeVulnerabilityDetectorTags = codeVulnerabilityDetectorTags
            self.codeVulnerabilityFilePath = codeVulnerabilityFilePath
            self.componentId = componentId
            self.componentType = componentType
            self.ec2InstanceImageId = ec2InstanceImageId
            self.ec2InstanceSubnetId = ec2InstanceSubnetId
            self.ec2InstanceVpcId = ec2InstanceVpcId
            self.ecrImageArchitecture = ecrImageArchitecture
            self.ecrImageHash = ecrImageHash
            self.ecrImagePushedAt = ecrImagePushedAt
            self.ecrImageRegistry = ecrImageRegistry
            self.ecrImageRepositoryName = ecrImageRepositoryName
            self.ecrImageTags = ecrImageTags
            self.epssScore = epssScore
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.findingStatus = findingStatus
            self.findingType = findingType
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArn
            self.lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAt
            self.lambdaFunctionLayers = lambdaFunctionLayers
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lastObservedAt = lastObservedAt
            self.networkProtocol = networkProtocol
            self.portRange = portRange
            self.relatedVulnerabilities = relatedVulnerabilities
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.vendorSeverity = vendorSeverity
            self.vulnerabilityId = vulnerabilityId
            self.vulnerabilitySource = vulnerabilitySource
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

public struct CreateFilterInput {
    /// Defines the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// Defines the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
    /// This member is required.
    public var name: Swift.String?
    /// The reason for creating the filter.
    public var reason: Swift.String?
    /// A list of tags for the filter.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil,
        reason: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterCriteria = filterCriteria
        self.name = name
        self.reason = reason
        self.tags = tags
    }
}

public struct CreateFilterOutput {
    /// The Amazon Resource Number (ARN) of the successfully created filter.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension Inspector2ClientTypes {

    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    public struct Destination {
        /// The name of the Amazon S3 bucket to export findings to.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The prefix that the findings will be written under.
        public var keyPrefix: Swift.String?
        /// The ARN of the KMS key used to encrypt data when exporting findings.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

public struct CreateFindingsReportInput {
    /// The filter criteria to apply to the results of the finding report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The format to generate the report in.
    /// This member is required.
    public var reportFormat: Inspector2ClientTypes.ReportFormat?
    /// The Amazon S3 export destination for the report.
    /// This member is required.
    public var s3Destination: Inspector2ClientTypes.Destination?

    public init(
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportFormat: Inspector2ClientTypes.ReportFormat? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.reportFormat = reportFormat
        self.s3Destination = s3Destination
    }
}

public struct CreateFindingsReportOutput {
    /// The ID of the report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

extension Inspector2ClientTypes {

    public enum SbomReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cyclonedx14
        case spdx23
        case sdkUnknown(Swift.String)

        public static var allCases: [SbomReportFormat] {
            return [
                .cyclonedx14,
                .spdx23
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cyclonedx14: return "CYCLONEDX_1_4"
            case .spdx23: return "SPDX_2_3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum ResourceStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStringComparison] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// A resource string filter for a software bill of materials report.
    public struct ResourceStringFilter {
        /// The filter's comparison.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.ResourceStringComparison?
        /// The filter's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.ResourceStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {

    public enum ResourceMapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceMapComparison] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// A resource map filter for a software bill of material report.
    public struct ResourceMapFilter {
        /// The filter's comparison.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.ResourceMapComparison?
        /// The filter's key.
        /// This member is required.
        public var key: Swift.String?
        /// The filter's value.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.ResourceMapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    /// The resource filter criteria for a Software bill of materials (SBOM) report.
    public struct ResourceFilterCriteria {
        /// The account IDs used as resource filter criteria.
        public var accountId: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The EC2 instance tags used as resource filter criteria.
        public var ec2InstanceTags: [Inspector2ClientTypes.ResourceMapFilter]?
        /// The ECR image tags used as resource filter criteria.
        public var ecrImageTags: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The ECR repository names used as resource filter criteria.
        public var ecrRepositoryName: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The Amazon Web Services Lambda function name used as resource filter criteria.
        public var lambdaFunctionName: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The Amazon Web Services Lambda function tags used as resource filter criteria.
        public var lambdaFunctionTags: [Inspector2ClientTypes.ResourceMapFilter]?
        /// The resource IDs used as resource filter criteria.
        public var resourceId: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The resource types used as resource filter criteria.
        public var resourceType: [Inspector2ClientTypes.ResourceStringFilter]?

        public init(
            accountId: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            ec2InstanceTags: [Inspector2ClientTypes.ResourceMapFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            ecrRepositoryName: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            lambdaFunctionTags: [Inspector2ClientTypes.ResourceMapFilter]? = nil,
            resourceId: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            resourceType: [Inspector2ClientTypes.ResourceStringFilter]? = nil
        )
        {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionTags = lambdaFunctionTags
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

public struct CreateSbomExportInput {
    /// The output format for the software bill of materials (SBOM) report.
    /// This member is required.
    public var reportFormat: Inspector2ClientTypes.SbomReportFormat?
    /// The resource filter criteria for the software bill of materials (SBOM) report.
    public var resourceFilterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    /// This member is required.
    public var s3Destination: Inspector2ClientTypes.Destination?

    public init(
        reportFormat: Inspector2ClientTypes.SbomReportFormat? = nil,
        resourceFilterCriteria: Inspector2ClientTypes.ResourceFilterCriteria? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil
    )
    {
        self.reportFormat = reportFormat
        self.resourceFilterCriteria = resourceFilterCriteria
        self.s3Destination = s3Destination
    }
}

public struct CreateSbomExportOutput {
    /// The report ID for the software bill of materials (SBOM) report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

extension Inspector2ClientTypes {

    public enum Currency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [Currency] {
            return [
                .usd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The Common Vulnerability Scoring System (CVSS) version 2 details for the vulnerability.
    public struct Cvss2 {
        /// The CVSS v2 base score for the vulnerability.
        public var baseScore: Swift.Double
        /// The scoring vector associated with the CVSS v2 score.
        public var scoringVector: Swift.String?

        public init(
            baseScore: Swift.Double = 0.0,
            scoringVector: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }
    }

}

extension Inspector2ClientTypes {
    /// The Common Vulnerability Scoring System (CVSS) version 3 details for the vulnerability.
    public struct Cvss3 {
        /// The CVSS v3 base score for the vulnerability.
        public var baseScore: Swift.Double
        /// The scoring vector associated with the CVSS v3 score.
        public var scoringVector: Swift.String?

        public init(
            baseScore: Swift.Double = 0.0,
            scoringVector: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }
    }

}

extension Inspector2ClientTypes {
    /// The CVSS score for a finding.
    public struct CvssScore {
        /// The base CVSS score used for the finding.
        /// This member is required.
        public var baseScore: Swift.Double?
        /// The vector string of the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        /// This member is required.
        public var source: Swift.String?
        /// The version of CVSS used for the score.
        /// This member is required.
        public var version: Swift.String?

        public init(
            baseScore: Swift.Double? = nil,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {
    /// Details on adjustments Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment {
        /// The metric used to adjust the CVSS score.
        /// This member is required.
        public var metric: Swift.String?
        /// The reason the CVSS score has been adjustment.
        /// This member is required.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension Inspector2ClientTypes {
    /// Information about the CVSS score.
    public struct CvssScoreDetails {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public var adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]?
        /// The source of the CVSS data.
        public var cvssSource: Swift.String?
        /// The CVSS score.
        /// This member is required.
        public var score: Swift.Double?
        /// The source for the CVSS score.
        /// This member is required.
        public var scoreSource: Swift.String?
        /// The vector for the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The CVSS version used in scoring.
        /// This member is required.
        public var version: Swift.String?

        public init(
            adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]? = nil,
            cvssSource: Swift.String? = nil,
            score: Swift.Double? = nil,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {

    public enum RelationshipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountSuspended
        case cannotCreateDetectorInOrgMaster
        case created
        case deleted
        case disabled
        case emailVerificationFailed
        case emailVerificationInProgress
        case enabled
        case invited
        case regionDisabled
        case removed
        case resigned
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipStatus] {
            return [
                .accountSuspended,
                .cannotCreateDetectorInOrgMaster,
                .created,
                .deleted,
                .disabled,
                .emailVerificationFailed,
                .emailVerificationInProgress,
                .enabled,
                .invited,
                .regionDisabled,
                .removed,
                .resigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountSuspended: return "ACCOUNT_SUSPENDED"
            case .cannotCreateDetectorInOrgMaster: return "CANNOT_CREATE_DETECTOR_IN_ORG_MASTER"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .emailVerificationFailed: return "EMAIL_VERIFICATION_FAILED"
            case .emailVerificationInProgress: return "EMAIL_VERIFICATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .invited: return "INVITED"
            case .regionDisabled: return "REGION_DISABLED"
            case .removed: return "REMOVED"
            case .resigned: return "RESIGNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdmin {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?

        public init(
            accountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil
        )
        {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension Inspector2ClientTypes {

    public enum DelegatedAdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegatedAdminStatus] {
            return [
                .disableInProgress,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdminAccount {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var status: Inspector2ClientTypes.DelegatedAdminStatus?

        public init(
            accountId: Swift.String? = nil,
            status: Inspector2ClientTypes.DelegatedAdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

public struct DeleteCisScanConfigurationInput {
    /// The ARN of the CIS scan configuration.
    /// This member is required.
    public var scanConfigurationArn: Swift.String?

    public init(
        scanConfigurationArn: Swift.String? = nil
    )
    {
        self.scanConfigurationArn = scanConfigurationArn
    }
}

public struct DeleteCisScanConfigurationOutput {
    /// The ARN of the CIS scan configuration.
    /// This member is required.
    public var scanConfigurationArn: Swift.String?

    public init(
        scanConfigurationArn: Swift.String? = nil
    )
    {
        self.scanConfigurationArn = scanConfigurationArn
    }
}

public struct DeleteFilterInput {
    /// The Amazon Resource Number (ARN) of the filter to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteFilterOutput {
    /// The Amazon Resource Number (ARN) of the filter that has been deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DescribeOrganizationConfigurationInput {

    public init() { }
}

public struct DescribeOrganizationConfigurationOutput {
    /// The scan types are automatically enabled for new members of your organization.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?
    /// Represents whether your organization has reached the maximum Amazon Web Services account limit for Amazon Inspector.
    public var maxAccountLimitReached: Swift.Bool?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil,
        maxAccountLimitReached: Swift.Bool? = nil
    )
    {
        self.autoEnable = autoEnable
        self.maxAccountLimitReached = maxAccountLimitReached
    }
}

extension Inspector2ClientTypes {

    public enum ResourceScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case lambdaCode
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceScanType] {
            return [
                .ec2,
                .ecr,
                .lambda,
                .lambdaCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case .lambdaCode: return "LAMBDA_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DisableInput {
    /// An array of account IDs you want to disable Amazon Inspector scans for.
    public var accountIds: [Swift.String]?
    /// The resource scan types you want to disable.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init(
        accountIds: [Swift.String]? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.resourceTypes = resourceTypes
    }
}

public struct DisableOutput {
    /// Information on the accounts that have had Amazon Inspector scans successfully disabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be disabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

public struct DisableDelegatedAdminAccountInput {
    /// The Amazon Web Services account ID of the current Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

public struct DisableDelegatedAdminAccountOutput {
    /// The Amazon Web Services account ID of the successfully disabled delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

public struct DisassociateMemberInput {
    /// The Amazon Web Services account ID of the member account to disassociate.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

public struct DisassociateMemberOutput {
    /// The Amazon Web Services account ID of the successfully disassociated member.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension Inspector2ClientTypes {

    public enum Ec2ScanMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2Hybrid
        case ec2SsmAgentBased
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2ScanMode] {
            return [
                .ec2Hybrid,
                .ec2SsmAgentBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2Hybrid: return "EC2_HYBRID"
            case .ec2SsmAgentBased: return "EC2_SSM_AGENT_BASED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Enables agent-based scanning, which scans instances that are not managed by SSM.
    public struct Ec2Configuration {
        /// The scan method that is applied to the instance.
        /// This member is required.
        public var scanMode: Inspector2ClientTypes.Ec2ScanMode?

        public init(
            scanMode: Inspector2ClientTypes.Ec2ScanMode? = nil
        )
        {
            self.scanMode = scanMode
        }
    }

}

extension Inspector2ClientTypes {

    public enum Ec2ScanModeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2ScanModeStatus] {
            return [
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The state of your Amazon EC2 scan mode configuration.
    public struct Ec2ScanModeState {
        /// The scan method that is applied to the instance.
        public var scanMode: Inspector2ClientTypes.Ec2ScanMode?
        /// The status of the Amazon EC2 scan mode setting.
        public var scanModeStatus: Inspector2ClientTypes.Ec2ScanModeStatus?

        public init(
            scanMode: Inspector2ClientTypes.Ec2ScanMode? = nil,
            scanModeStatus: Inspector2ClientTypes.Ec2ScanModeStatus? = nil
        )
        {
            self.scanMode = scanMode
            self.scanModeStatus = scanModeStatus
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the state of the EC2 scan configuration for your environment.
    public struct Ec2ConfigurationState {
        /// An object that contains details about the state of the Amazon EC2 scan mode.
        public var scanModeState: Inspector2ClientTypes.Ec2ScanModeState?

        public init(
            scanModeState: Inspector2ClientTypes.Ec2ScanModeState? = nil
        )
        {
            self.scanModeState = scanModeState
        }
    }

}

extension Inspector2ClientTypes {

    public enum EcrPullDateRescanDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days14
        case days180
        case days30
        case days60
        case days90
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrPullDateRescanDuration] {
            return [
                .days14,
                .days180,
                .days30,
                .days60,
                .days90
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days14: return "DAYS_14"
            case .days180: return "DAYS_180"
            case .days30: return "DAYS_30"
            case .days60: return "DAYS_60"
            case .days90: return "DAYS_90"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum EcrRescanDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days14
        case days180
        case days30
        case days60
        case days90
        case lifetime
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrRescanDuration] {
            return [
                .days14,
                .days180,
                .days30,
                .days60,
                .days90,
                .lifetime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days14: return "DAYS_14"
            case .days180: return "DAYS_180"
            case .days30: return "DAYS_30"
            case .days60: return "DAYS_60"
            case .days90: return "DAYS_90"
            case .lifetime: return "LIFETIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about the ECR automated re-scan duration setting for your environment.
    public struct EcrConfiguration {
        /// The rescan duration configured for image pull date.
        public var pullDateRescanDuration: Inspector2ClientTypes.EcrPullDateRescanDuration?
        /// The rescan duration configured for image push date.
        /// This member is required.
        public var rescanDuration: Inspector2ClientTypes.EcrRescanDuration?

        public init(
            pullDateRescanDuration: Inspector2ClientTypes.EcrPullDateRescanDuration? = nil,
            rescanDuration: Inspector2ClientTypes.EcrRescanDuration? = nil
        )
        {
            self.pullDateRescanDuration = pullDateRescanDuration
            self.rescanDuration = rescanDuration
        }
    }

}

extension Inspector2ClientTypes {

    public enum EcrRescanDurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrRescanDurationStatus] {
            return [
                .failed,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about the state of your ECR re-scan duration settings. The ECR re-scan duration defines how long an ECR image will be actively scanned by Amazon Inspector. When the number of days since an image was last pushed exceeds the duration configured for image pull date, and the duration configured for image pull date, the monitoring state of that image becomes inactive and all associated findings are scheduled for closure.
    public struct EcrRescanDurationState {
        /// The rescan duration configured for image pull date.
        public var pullDateRescanDuration: Inspector2ClientTypes.EcrPullDateRescanDuration?
        /// The rescan duration configured for image push date.
        public var rescanDuration: Inspector2ClientTypes.EcrRescanDuration?
        /// The status of changes to the ECR automated re-scan duration.
        public var status: Inspector2ClientTypes.EcrRescanDurationStatus?
        /// A timestamp representing when the last time the ECR scan duration setting was changed.
        public var updatedAt: Foundation.Date?

        public init(
            pullDateRescanDuration: Inspector2ClientTypes.EcrPullDateRescanDuration? = nil,
            rescanDuration: Inspector2ClientTypes.EcrRescanDuration? = nil,
            status: Inspector2ClientTypes.EcrRescanDurationStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.pullDateRescanDuration = pullDateRescanDuration
            self.rescanDuration = rescanDuration
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the state of the ECR scans for your environment.
    public struct EcrConfigurationState {
        /// An object that contains details about the state of the ECR re-scan settings.
        public var rescanDurationState: Inspector2ClientTypes.EcrRescanDurationState?

        public init(
            rescanDurationState: Inspector2ClientTypes.EcrRescanDurationState? = nil
        )
        {
            self.rescanDurationState = rescanDurationState
        }
    }

}

public struct EnableInput {
    /// A list of account IDs you want to enable Amazon Inspector scans for.
    public var accountIds: [Swift.String]?
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The resource scan types you want to enable.
    /// This member is required.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init(
        accountIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.clientToken = clientToken
        self.resourceTypes = resourceTypes
    }
}

public struct EnableOutput {
    /// Information on the accounts that have had Amazon Inspector scans successfully enabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be enabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

public struct EnableDelegatedAdminAccountInput {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

public struct EnableDelegatedAdminAccountOutput {
    /// The Amazon Web Services account ID of the successfully Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

extension Inspector2ClientTypes {
    /// Details about the Exploit Prediction Scoring System (EPSS) score.
    public struct Epss {
        /// The Exploit Prediction Scoring System (EPSS) score.
        public var score: Swift.Double

        public init(
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the Exploit Prediction Scoring System (EPSS) score for a finding.
    public struct EpssDetails {
        /// The EPSS score.
        public var score: Swift.Double

        public init(
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension Inspector2ClientTypes {
    /// The details of an exploit available for a finding discovered in your environment.
    public struct ExploitabilityDetails {
        /// The date and time of the last exploit associated with a finding discovered in your environment.
        public var lastKnownExploitAt: Foundation.Date?

        public init(
            lastKnownExploitAt: Foundation.Date? = nil
        )
        {
            self.lastKnownExploitAt = lastKnownExploitAt
        }
    }

}

extension Inspector2ClientTypes {

    public enum ExploitAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [ExploitAvailable] {
            return [
                .no,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum ExternalReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalReportStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about a filter.
    public struct Filter {
        /// The action that is to be applied to the findings that match the filter.
        /// This member is required.
        public var action: Inspector2ClientTypes.FilterAction?
        /// The Amazon Resource Number (ARN) associated with this filter.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time this filter was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Details on the filter criteria associated with this filter.
        /// This member is required.
        public var criteria: Inspector2ClientTypes.FilterCriteria?
        /// A description of the filter.
        public var description: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the account that created the filter.
        /// This member is required.
        public var ownerId: Swift.String?
        /// The reason for the filter.
        public var reason: Swift.String?
        /// The tags attached to the filter.
        public var tags: [Swift.String: Swift.String]?
        /// The date and time the filter was last updated at.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            action: Inspector2ClientTypes.FilterAction? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            criteria: Inspector2ClientTypes.FilterCriteria? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            reason: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.criteria = criteria
            self.description = description
            self.name = name
            self.ownerId = ownerId
            self.reason = reason
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {

    public enum FixAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case partial
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [FixAvailable] {
            return [
                .no,
                .partial,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .partial: return "PARTIAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector score given to a finding.
    public struct InspectorScoreDetails {
        /// An object that contains details about the CVSS score given to a finding.
        public var adjustedCvss: Inspector2ClientTypes.CvssScoreDetails?

        public init(
            adjustedCvss: Inspector2ClientTypes.CvssScoreDetails? = nil
        )
        {
            self.adjustedCvss = adjustedCvss
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the step associated with a finding.
    public struct Step {
        /// The component ID.
        /// This member is required.
        public var componentId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?

        public init(
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.componentType = componentType
        }
    }

}

extension Inspector2ClientTypes {
    /// Information on the network path associated with a finding.
    public struct NetworkPath {
        /// The details on the steps in the network path.
        public var steps: [Inspector2ClientTypes.Step]?

        public init(
            steps: [Inspector2ClientTypes.Step]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the port range associated with a finding.
    public struct PortRange {
        /// The beginning port in a port range.
        /// This member is required.
        public var begin: Swift.Int?
        /// The ending port in a port range.
        /// This member is required.
        public var end: Swift.Int?

        public init(
            begin: Swift.Int? = nil,
            end: Swift.Int? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension Inspector2ClientTypes {

    public enum NetworkProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProtocol] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains the details of a network reachability finding.
    public struct NetworkReachabilityDetails {
        /// An object that contains details about a network path associated with a finding.
        /// This member is required.
        public var networkPath: Inspector2ClientTypes.NetworkPath?
        /// An object that contains details about the open port range associated with a finding.
        /// This member is required.
        public var openPortRange: Inspector2ClientTypes.PortRange?
        /// The protocol associated with a finding.
        /// This member is required.
        public var `protocol`: Inspector2ClientTypes.NetworkProtocol?

        public init(
            networkPath: Inspector2ClientTypes.NetworkPath? = nil,
            openPortRange: Inspector2ClientTypes.PortRange? = nil,
            `protocol`: Inspector2ClientTypes.NetworkProtocol? = nil
        )
        {
            self.networkPath = networkPath
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
        }
    }

}

extension Inspector2ClientTypes {

    public enum PackageManager: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bundler
        case cargo
        case composer
        case gemspec
        case gobinary
        case gomod
        case jar
        case nodepkg
        case npm
        case nuget
        case os
        case pip
        case pipenv
        case poetry
        case pom
        case pythonpkg
        case yarn
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageManager] {
            return [
                .bundler,
                .cargo,
                .composer,
                .gemspec,
                .gobinary,
                .gomod,
                .jar,
                .nodepkg,
                .npm,
                .nuget,
                .os,
                .pip,
                .pipenv,
                .poetry,
                .pom,
                .pythonpkg,
                .yarn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bundler: return "BUNDLER"
            case .cargo: return "CARGO"
            case .composer: return "COMPOSER"
            case .gemspec: return "GEMSPEC"
            case .gobinary: return "GOBINARY"
            case .gomod: return "GOMOD"
            case .jar: return "JAR"
            case .nodepkg: return "NODEPKG"
            case .npm: return "NPM"
            case .nuget: return "NUGET"
            case .os: return "OS"
            case .pip: return "PIP"
            case .pipenv: return "PIPENV"
            case .poetry: return "POETRY"
            case .pom: return "POM"
            case .pythonpkg: return "PYTHONPKG"
            case .yarn: return "YARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Information on the vulnerable package identified by a finding.
    public struct VulnerablePackage {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The version of the package that contains the vulnerability fix.
        public var fixedInVersion: Swift.String?
        /// The name of the vulnerable package.
        /// This member is required.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Inspector2ClientTypes.PackageManager?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The code to run in your environment to update packages with a fix available.
        public var remediation: Swift.String?
        /// The Amazon Resource Number (ARN) of the Amazon Web Services Lambda function affected by a finding.
        public var sourceLambdaLayerArn: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arch: Swift.String? = nil,
            epoch: Swift.Int = 0,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Inspector2ClientTypes.PackageManager? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLambdaLayerArn: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {
    /// Information about a package vulnerability finding.
    public struct PackageVulnerabilityDetails {
        /// An object that contains details about the CVSS score of a finding.
        public var cvss: [Inspector2ClientTypes.CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        /// This member is required.
        public var source: Swift.String?
        /// A URL to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: Foundation.Date?
        /// The severity the vendor has given to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: Foundation.Date?
        /// The ID given to this vulnerability.
        /// This member is required.
        public var vulnerabilityId: Swift.String?
        /// The packages impacted by this vulnerability.
        public var vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]?

        public init(
            cvss: [Inspector2ClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: Foundation.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: Foundation.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension Inspector2ClientTypes {
    /// Details about the recommended course of action to remediate the finding.
    public struct Recommendation {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the CVE remediation recommendations.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension Inspector2ClientTypes {
    /// Information on how to remediate a finding.
    public struct Remediation {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: Inspector2ClientTypes.Recommendation?

        public init(
            recommendation: Inspector2ClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension Inspector2ClientTypes {
    /// Contains details about the resource involved in the finding.
    public struct ResourceDetails {
        /// An object that contains details about the Amazon EC2 instance involved in the finding.
        public var awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails?
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public var awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails?
        /// A summary of the information about an Amazon Web Services Lambda function affected by a finding.
        public var awsLambdaFunction: Inspector2ClientTypes.AwsLambdaFunctionDetails?

        public init(
            awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails? = nil,
            awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails? = nil,
            awsLambdaFunction: Inspector2ClientTypes.AwsLambdaFunctionDetails? = nil
        )
        {
            self.awsEc2Instance = awsEc2Instance
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsLambdaFunction = awsLambdaFunction
        }
    }

}

extension Inspector2ClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .awsLambdaFunction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about the resource involved in a finding.
    public struct Resource {
        /// An object that contains details about the resource involved in a finding.
        public var details: Inspector2ClientTypes.ResourceDetails?
        /// The ID of the resource.
        /// This member is required.
        public var id: Swift.String?
        /// The partition of the resource.
        public var partition: Swift.String?
        /// The Amazon Web Services Region the impacted resource is located in.
        public var region: Swift.String?
        /// The tags attached to the resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of resource.
        /// This member is required.
        public var type: Inspector2ClientTypes.ResourceType?

        public init(
            details: Inspector2ClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: Inspector2ClientTypes.ResourceType? = nil
        )
        {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.type = type
        }
    }

}

extension Inspector2ClientTypes {

    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case untriaged
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .untriaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .untriaged: return "UNTRIAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum FindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case closed
        case suppressed
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .closed,
                .suppressed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .suppressed: return "SUPPRESSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {

    public enum FindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case codeVulnerability
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingType] {
            return [
                .codeVulnerability,
                .networkReachability,
                .packageVulnerability
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .codeVulnerability: return "CODE_VULNERABILITY"
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about an Amazon Inspector finding.
    public struct Finding {
        /// The Amazon Web Services account ID associated with the finding.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// Details about the code vulnerability identified in a Lambda function used to filter findings.
        public var codeVulnerabilityDetails: Inspector2ClientTypes.CodeVulnerabilityDetails?
        /// The description of the finding.
        /// This member is required.
        public var description: Swift.String?
        /// The finding's EPSS score.
        public var epss: Inspector2ClientTypes.EpssDetails?
        /// If a finding discovered in your environment has an exploit available.
        public var exploitAvailable: Inspector2ClientTypes.ExploitAvailable?
        /// The details of an exploit available for a finding discovered in your environment.
        public var exploitabilityDetails: Inspector2ClientTypes.ExploitabilityDetails?
        /// The Amazon Resource Number (ARN) of the finding.
        /// This member is required.
        public var findingArn: Swift.String?
        /// The date and time that the finding was first observed.
        /// This member is required.
        public var firstObservedAt: Foundation.Date?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL. A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public var fixAvailable: Inspector2ClientTypes.FixAvailable?
        /// The Amazon Inspector score given to the finding.
        public var inspectorScore: Swift.Double?
        /// An object that contains details of the Amazon Inspector score.
        public var inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails?
        /// The date and time the finding was last observed. This timestamp for this field remains unchanged until a finding is updated.
        /// This member is required.
        public var lastObservedAt: Foundation.Date?
        /// An object that contains the details of a network reachability finding.
        public var networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        /// This member is required.
        public var remediation: Inspector2ClientTypes.Remediation?
        /// Contains information on the resources involved in a finding. The resource value determines the valid values for type in your request. For more information, see [Finding types](https://docs.aws.amazon.com/inspector/latest/user/findings-types.html) in the Amazon Inspector user guide.
        /// This member is required.
        public var resources: [Inspector2ClientTypes.Resource]?
        /// The severity of the finding. UNTRIAGED applies to PACKAGE_VULNERABILITY type findings that the vendor has not assigned a severity yet. For more information, see [Severity levels for findings](https://docs.aws.amazon.com/inspector/latest/user/findings-understanding-severity.html) in the Amazon Inspector user guide.
        /// This member is required.
        public var severity: Inspector2ClientTypes.Severity?
        /// The status of the finding.
        /// This member is required.
        public var status: Inspector2ClientTypes.FindingStatus?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding. The type value determines the valid values for resource in your request. For more information, see [Finding types](https://docs.aws.amazon.com/inspector/latest/user/findings-types.html) in the Amazon Inspector user guide.
        /// This member is required.
        public var type: Inspector2ClientTypes.FindingType?
        /// The date and time the finding was last updated at.
        public var updatedAt: Foundation.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            codeVulnerabilityDetails: Inspector2ClientTypes.CodeVulnerabilityDetails? = nil,
            description: Swift.String? = nil,
            epss: Inspector2ClientTypes.EpssDetails? = nil,
            exploitAvailable: Inspector2ClientTypes.ExploitAvailable? = nil,
            exploitabilityDetails: Inspector2ClientTypes.ExploitabilityDetails? = nil,
            findingArn: Swift.String? = nil,
            firstObservedAt: Foundation.Date? = nil,
            fixAvailable: Inspector2ClientTypes.FixAvailable? = nil,
            inspectorScore: Swift.Double? = nil,
            inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails? = nil,
            lastObservedAt: Foundation.Date? = nil,
            networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails? = nil,
            packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: Inspector2ClientTypes.Remediation? = nil,
            resources: [Inspector2ClientTypes.Resource]? = nil,
            severity: Inspector2ClientTypes.Severity? = nil,
            status: Inspector2ClientTypes.FindingStatus? = nil,
            title: Swift.String? = nil,
            type: Inspector2ClientTypes.FindingType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetails = codeVulnerabilityDetails
            self.description = description
            self.epss = epss
            self.exploitAvailable = exploitAvailable
            self.exploitabilityDetails = exploitabilityDetails
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.lastObservedAt = lastObservedAt
            self.networkReachabilityDetails = networkReachabilityDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

public struct GetCisScanReportInput {
    /// The format of the report. Valid values are PDF and CSV. If no value is specified, the report format defaults to PDF.
    public var reportFormat: Inspector2ClientTypes.CisReportFormat?
    /// The scan ARN.
    /// This member is required.
    public var scanArn: Swift.String?
    /// The target accounts.
    public var targetAccounts: [Swift.String]?

    public init(
        reportFormat: Inspector2ClientTypes.CisReportFormat? = nil,
        scanArn: Swift.String? = nil,
        targetAccounts: [Swift.String]? = nil
    )
    {
        self.reportFormat = reportFormat
        self.scanArn = scanArn
        self.targetAccounts = targetAccounts
    }
}

public struct GetCisScanReportOutput {
    /// The status.
    public var status: Inspector2ClientTypes.CisReportStatus?
    /// The URL where a PDF or CSV of the CIS scan report can be downloaded.
    public var url: Swift.String?

    public init(
        status: Inspector2ClientTypes.CisReportStatus? = nil,
        url: Swift.String? = nil
    )
    {
        self.status = status
        self.url = url
    }
}

public struct GetCisScanResultDetailsInput {
    /// The account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The filter criteria.
    public var filterCriteria: Inspector2ClientTypes.CisScanResultDetailsFilterCriteria?
    /// The maximum number of CIS scan result details to be returned in a single page of results.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The scan ARN.
    /// This member is required.
    public var scanArn: Swift.String?
    /// The sort by order.
    public var sortBy: Inspector2ClientTypes.CisScanResultDetailsSortBy?
    /// The sort order.
    public var sortOrder: Inspector2ClientTypes.CisSortOrder?
    /// The target resource ID.
    /// This member is required.
    public var targetResourceId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.CisScanResultDetailsFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanArn: Swift.String? = nil,
        sortBy: Inspector2ClientTypes.CisScanResultDetailsSortBy? = nil,
        sortOrder: Inspector2ClientTypes.CisSortOrder? = nil,
        targetResourceId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanArn = scanArn
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.targetResourceId = targetResourceId
    }
}

public struct GetCisScanResultDetailsOutput {
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The scan result details.
    public var scanResultDetails: [Inspector2ClientTypes.CisScanResultDetails]?

    public init(
        nextToken: Swift.String? = nil,
        scanResultDetails: [Inspector2ClientTypes.CisScanResultDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.scanResultDetails = scanResultDetails
    }
}

public struct GetConfigurationInput {

    public init() { }
}

public struct GetConfigurationOutput {
    /// Specifies how the Amazon EC2 automated scan mode is currently configured for your environment.
    public var ec2Configuration: Inspector2ClientTypes.Ec2ConfigurationState?
    /// Specifies how the ECR automated re-scan duration is currently configured for your environment.
    public var ecrConfiguration: Inspector2ClientTypes.EcrConfigurationState?

    public init(
        ec2Configuration: Inspector2ClientTypes.Ec2ConfigurationState? = nil,
        ecrConfiguration: Inspector2ClientTypes.EcrConfigurationState? = nil
    )
    {
        self.ec2Configuration = ec2Configuration
        self.ecrConfiguration = ecrConfiguration
    }
}

public struct GetDelegatedAdminAccountInput {

    public init() { }
}

public struct GetDelegatedAdminAccountOutput {
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    public var delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin?

    public init(
        delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin? = nil
    )
    {
        self.delegatedAdmin = delegatedAdmin
    }
}

public struct GetEc2DeepInspectionConfigurationInput {

    public init() { }
}

public struct GetEc2DeepInspectionConfigurationOutput {
    /// An error message explaining why Amazon Inspector deep inspection configurations could not be retrieved for your account.
    public var errorMessage: Swift.String?
    /// The Amazon Inspector deep inspection custom paths for your organization.
    public var orgPackagePaths: [Swift.String]?
    /// The Amazon Inspector deep inspection custom paths for your account.
    public var packagePaths: [Swift.String]?
    /// The activation status of Amazon Inspector deep inspection in your account.
    public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

    public init(
        errorMessage: Swift.String? = nil,
        orgPackagePaths: [Swift.String]? = nil,
        packagePaths: [Swift.String]? = nil,
        status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.orgPackagePaths = orgPackagePaths
        self.packagePaths = packagePaths
        self.status = status
    }
}

public struct GetEncryptionKeyInput {
    /// The resource type the key encrypts.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type the key encrypts.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

public struct GetEncryptionKeyOutput {
    /// A kms key ID.
    /// This member is required.
    public var kmsKeyId: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
    }
}

public struct GetFindingsReportStatusInput {
    /// The ID of the report to retrieve the status of.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

extension Inspector2ClientTypes {

    public enum ReportingErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bucketNotFound
        case incompatibleBucketRegion
        case internalError
        case invalidPermissions
        case malformedKmsKey
        case noFindingsFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportingErrorCode] {
            return [
                .bucketNotFound,
                .incompatibleBucketRegion,
                .internalError,
                .invalidPermissions,
                .malformedKmsKey,
                .noFindingsFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bucketNotFound: return "BUCKET_NOT_FOUND"
            case .incompatibleBucketRegion: return "INCOMPATIBLE_BUCKET_REGION"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidPermissions: return "INVALID_PERMISSIONS"
            case .malformedKmsKey: return "MALFORMED_KMS_KEY"
            case .noFindingsFound: return "NO_FINDINGS_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFindingsReportStatusOutput {
    /// The destination of the report.
    public var destination: Inspector2ClientTypes.Destination?
    /// The error code of the report.
    public var errorCode: Inspector2ClientTypes.ReportingErrorCode?
    /// The error message of the report.
    public var errorMessage: Swift.String?
    /// The filter criteria associated with the report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The ID of the report.
    public var reportId: Swift.String?
    /// The status of the report.
    public var status: Inspector2ClientTypes.ExternalReportStatus?

    public init(
        destination: Inspector2ClientTypes.Destination? = nil,
        errorCode: Inspector2ClientTypes.ReportingErrorCode? = nil,
        errorMessage: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportId: Swift.String? = nil,
        status: Inspector2ClientTypes.ExternalReportStatus? = nil
    )
    {
        self.destination = destination
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.filterCriteria = filterCriteria
        self.reportId = reportId
        self.status = status
    }
}

public struct GetMemberInput {
    /// The Amazon Web Services account ID of the member account to retrieve information on.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension Inspector2ClientTypes {
    /// Details on a member account in your organization.
    public struct Member {
        /// The Amazon Web Services account ID of the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.
        public var delegatedAdminAccountId: Swift.String?
        /// The status of the member account.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?
        /// A timestamp showing when the status of this member was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            delegatedAdminAccountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.accountId = accountId
            self.delegatedAdminAccountId = delegatedAdminAccountId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

public struct GetMemberOutput {
    /// Details of the retrieved member account.
    public var member: Inspector2ClientTypes.Member?

    public init(
        member: Inspector2ClientTypes.Member? = nil
    )
    {
        self.member = member
    }
}

public struct GetSbomExportInput {
    /// The report ID of the SBOM export to get details for.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

public struct GetSbomExportOutput {
    /// An error code.
    public var errorCode: Inspector2ClientTypes.ReportingErrorCode?
    /// An error message.
    public var errorMessage: Swift.String?
    /// Contains details about the resource filter criteria used for the software bill of materials (SBOM) report.
    public var filterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
    /// The format of the software bill of materials (SBOM) report.
    public var format: Inspector2ClientTypes.SbomReportFormat?
    /// The report ID of the software bill of materials (SBOM) report.
    public var reportId: Swift.String?
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    public var s3Destination: Inspector2ClientTypes.Destination?
    /// The status of the software bill of materials (SBOM) report.
    public var status: Inspector2ClientTypes.ExternalReportStatus?

    public init(
        errorCode: Inspector2ClientTypes.ReportingErrorCode? = nil,
        errorMessage: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.ResourceFilterCriteria? = nil,
        format: Inspector2ClientTypes.SbomReportFormat? = nil,
        reportId: Swift.String? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil,
        status: Inspector2ClientTypes.ExternalReportStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.filterCriteria = filterCriteria
        self.format = format
        self.reportId = reportId
        self.s3Destination = s3Destination
        self.status = status
    }
}

extension Inspector2ClientTypes {

    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .ec2,
                .ecr,
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAccountPermissionsInput {
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The service scan type to check permissions for.
    public var service: Inspector2ClientTypes.Service?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        service: Inspector2ClientTypes.Service? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.service = service
    }
}

extension Inspector2ClientTypes {

    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disableRepository
        case disableScanning
        case enableRepository
        case enableScanning
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .disableRepository,
                .disableScanning,
                .enableRepository,
                .enableScanning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disableRepository: return "DISABLE_REPOSITORY"
            case .disableScanning: return "DISABLE_SCANNING"
            case .enableRepository: return "ENABLE_REPOSITORY"
            case .enableScanning: return "ENABLE_SCANNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the permissions an account has within Amazon Inspector.
    public struct Permission {
        /// The operations that can be performed with the given permissions.
        /// This member is required.
        public var operation: Inspector2ClientTypes.Operation?
        /// The services that the permissions allow an account to perform the given operations for.
        /// This member is required.
        public var service: Inspector2ClientTypes.Service?

        public init(
            operation: Inspector2ClientTypes.Operation? = nil,
            service: Inspector2ClientTypes.Service? = nil
        )
        {
            self.operation = operation
            self.service = service
        }
    }

}

public struct ListAccountPermissionsOutput {
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Contains details on the permissions an account has to configure Amazon Inspector.
    /// This member is required.
    public var permissions: [Inspector2ClientTypes.Permission]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [Inspector2ClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

extension Inspector2ClientTypes {
    /// A list of CIS scan configurations filter criteria.
    public struct ListCisScanConfigurationsFilterCriteria {
        /// The list of scan configuration ARN filters.
        public var scanConfigurationArnFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of scan name filters.
        public var scanNameFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of target resource tag filters.
        public var targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]?

        public init(
            scanConfigurationArnFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            scanNameFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]? = nil
        )
        {
            self.scanConfigurationArnFilters = scanConfigurationArnFilters
            self.scanNameFilters = scanNameFilters
            self.targetResourceTagFilters = targetResourceTagFilters
        }
    }

}

public struct ListCisScanConfigurationsInput {
    /// The CIS scan configuration filter criteria.
    public var filterCriteria: Inspector2ClientTypes.ListCisScanConfigurationsFilterCriteria?
    /// The maximum number of CIS scan configurations to be returned in a single page of results.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The CIS scan configuration sort by order.
    public var sortBy: Inspector2ClientTypes.CisScanConfigurationsSortBy?
    /// The CIS scan configuration sort order order.
    public var sortOrder: Inspector2ClientTypes.CisSortOrder?

    public init(
        filterCriteria: Inspector2ClientTypes.ListCisScanConfigurationsFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Inspector2ClientTypes.CisScanConfigurationsSortBy? = nil,
        sortOrder: Inspector2ClientTypes.CisSortOrder? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListCisScanConfigurationsOutput {
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The CIS scan configuration scan configurations.
    public var scanConfigurations: [Inspector2ClientTypes.CisScanConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        scanConfigurations: [Inspector2ClientTypes.CisScanConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.scanConfigurations = scanConfigurations
    }
}

public struct ListCisScanResultsAggregatedByChecksInput {
    /// The filter criteria.
    public var filterCriteria: Inspector2ClientTypes.CisScanResultsAggregatedByChecksFilterCriteria?
    /// The maximum number of scan results aggregated by checks to be returned in a single page of results.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The scan ARN.
    /// This member is required.
    public var scanArn: Swift.String?
    /// The sort by order.
    public var sortBy: Inspector2ClientTypes.CisScanResultsAggregatedByChecksSortBy?
    /// The sort order.
    public var sortOrder: Inspector2ClientTypes.CisSortOrder?

    public init(
        filterCriteria: Inspector2ClientTypes.CisScanResultsAggregatedByChecksFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanArn: Swift.String? = nil,
        sortBy: Inspector2ClientTypes.CisScanResultsAggregatedByChecksSortBy? = nil,
        sortOrder: Inspector2ClientTypes.CisSortOrder? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanArn = scanArn
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListCisScanResultsAggregatedByChecksOutput {
    /// The check aggregations.
    public var checkAggregations: [Inspector2ClientTypes.CisCheckAggregation]?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        checkAggregations: [Inspector2ClientTypes.CisCheckAggregation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkAggregations = checkAggregations
        self.nextToken = nextToken
    }
}

public struct ListCisScanResultsAggregatedByTargetResourceInput {
    /// The filter criteria.
    public var filterCriteria: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceFilterCriteria?
    /// The maximum number of scan results aggregated by a target resource to be returned in a single page of results.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The scan ARN.
    /// This member is required.
    public var scanArn: Swift.String?
    /// The sort by order.
    public var sortBy: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceSortBy?
    /// The sort order.
    public var sortOrder: Inspector2ClientTypes.CisSortOrder?

    public init(
        filterCriteria: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanArn: Swift.String? = nil,
        sortBy: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceSortBy? = nil,
        sortOrder: Inspector2ClientTypes.CisSortOrder? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanArn = scanArn
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListCisScanResultsAggregatedByTargetResourceOutput {
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The resource aggregations.
    public var targetResourceAggregations: [Inspector2ClientTypes.CisTargetResourceAggregation]?

    public init(
        nextToken: Swift.String? = nil,
        targetResourceAggregations: [Inspector2ClientTypes.CisTargetResourceAggregation]? = nil
    )
    {
        self.nextToken = nextToken
        self.targetResourceAggregations = targetResourceAggregations
    }
}

extension Inspector2ClientTypes {

    public enum ListCisScansDetailLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case member
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [ListCisScansDetailLevel] {
            return [
                .member,
                .organization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .member: return "MEMBER"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// A list of CIS scans filter criteria.
    public struct ListCisScansFilterCriteria {
        /// The list of failed checks filters.
        public var failedChecksFilters: [Inspector2ClientTypes.CisNumberFilter]?
        /// The list of scan ARN filters.
        public var scanArnFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of scan at filters.
        public var scanAtFilters: [Inspector2ClientTypes.CisDateFilter]?
        /// The list of scan configuration ARN filters.
        public var scanConfigurationArnFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of scan name filters.
        public var scanNameFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of scan status filters.
        public var scanStatusFilters: [Inspector2ClientTypes.CisScanStatusFilter]?
        /// The list of scheduled by filters.
        public var scheduledByFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of target account ID filters.
        public var targetAccountIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of target resource ID filters.
        public var targetResourceIdFilters: [Inspector2ClientTypes.CisStringFilter]?
        /// The list of target resource tag filters.
        public var targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]?

        public init(
            failedChecksFilters: [Inspector2ClientTypes.CisNumberFilter]? = nil,
            scanArnFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            scanAtFilters: [Inspector2ClientTypes.CisDateFilter]? = nil,
            scanConfigurationArnFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            scanNameFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            scanStatusFilters: [Inspector2ClientTypes.CisScanStatusFilter]? = nil,
            scheduledByFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            targetAccountIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            targetResourceIdFilters: [Inspector2ClientTypes.CisStringFilter]? = nil,
            targetResourceTagFilters: [Inspector2ClientTypes.TagFilter]? = nil
        )
        {
            self.failedChecksFilters = failedChecksFilters
            self.scanArnFilters = scanArnFilters
            self.scanAtFilters = scanAtFilters
            self.scanConfigurationArnFilters = scanConfigurationArnFilters
            self.scanNameFilters = scanNameFilters
            self.scanStatusFilters = scanStatusFilters
            self.scheduledByFilters = scheduledByFilters
            self.targetAccountIdFilters = targetAccountIdFilters
            self.targetResourceIdFilters = targetResourceIdFilters
            self.targetResourceTagFilters = targetResourceTagFilters
        }
    }

}

extension Inspector2ClientTypes {

    public enum ListCisScansSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedChecks
        case scanStartDate
        case scheduledBy
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ListCisScansSortBy] {
            return [
                .failedChecks,
                .scanStartDate,
                .scheduledBy,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedChecks: return "FAILED_CHECKS"
            case .scanStartDate: return "SCAN_START_DATE"
            case .scheduledBy: return "SCHEDULED_BY"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListCisScansInput {
    /// The detail applied to the CIS scan.
    public var detailLevel: Inspector2ClientTypes.ListCisScansDetailLevel?
    /// The CIS scan filter criteria.
    public var filterCriteria: Inspector2ClientTypes.ListCisScansFilterCriteria?
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The CIS scans sort by order.
    public var sortBy: Inspector2ClientTypes.ListCisScansSortBy?
    /// The CIS scans sort order.
    public var sortOrder: Inspector2ClientTypes.CisSortOrder?

    public init(
        detailLevel: Inspector2ClientTypes.ListCisScansDetailLevel? = nil,
        filterCriteria: Inspector2ClientTypes.ListCisScansFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Inspector2ClientTypes.ListCisScansSortBy? = nil,
        sortOrder: Inspector2ClientTypes.CisSortOrder? = nil
    )
    {
        self.detailLevel = detailLevel
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListCisScansOutput {
    /// The pagination token from a previous request that's used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The CIS scans.
    public var scans: [Inspector2ClientTypes.CisScan]?

    public init(
        nextToken: Swift.String? = nil,
        scans: [Inspector2ClientTypes.CisScan]? = nil
    )
    {
        self.nextToken = nextToken
        self.scans = scans
    }
}

public struct ListCoverageInput {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCoverageOutput {
    /// An object that contains details on the covered resources in your environment.
    public var coveredResources: [Inspector2ClientTypes.CoveredResource]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        coveredResources: [Inspector2ClientTypes.CoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coveredResources = coveredResources
        self.nextToken = nextToken
    }
}

public struct ListCoverageStatisticsInput {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The value to group the results by.
    public var groupBy: Inspector2ClientTypes.GroupKey?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        groupBy: Inspector2ClientTypes.GroupKey? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.groupBy = groupBy
        self.nextToken = nextToken
    }
}

public struct ListCoverageStatisticsOutput {
    /// An array with the number for each group.
    public var countsByGroup: [Inspector2ClientTypes.Counts]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The total number for all groups.
    /// This member is required.
    public var totalCounts: Swift.Int?

    public init(
        countsByGroup: [Inspector2ClientTypes.Counts]? = nil,
        nextToken: Swift.String? = nil,
        totalCounts: Swift.Int? = nil
    )
    {
        self.countsByGroup = countsByGroup
        self.nextToken = nextToken
        self.totalCounts = totalCounts
    }
}

public struct ListDelegatedAdminAccountsInput {
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDelegatedAdminAccountsOutput {
    /// Details of the Amazon Inspector delegated administrator of your organization.
    public var delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegatedAdminAccounts = delegatedAdminAccounts
        self.nextToken = nextToken
    }
}

public struct ListFiltersInput {
    /// The action the filter applies to matched findings.
    public var action: Inspector2ClientTypes.FilterAction?
    /// The Amazon resource number (ARN) of the filter.
    public var arns: [Swift.String]?
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.action = action
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFiltersOutput {
    /// Contains details on the filters associated with your account.
    /// This member is required.
    public var filters: [Inspector2ClientTypes.Filter]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filters: [Inspector2ClientTypes.Filter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

public struct ListFindingAggregationsInput {
    /// The Amazon Web Services account IDs to retrieve finding aggregation data for.
    public var accountIds: [Inspector2ClientTypes.StringFilter]?
    /// Details of the aggregation request that is used to filter your aggregation results.
    public var aggregationRequest: Inspector2ClientTypes.AggregationRequest?
    /// The type of the aggregation request.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Inspector2ClientTypes.StringFilter]? = nil,
        aggregationRequest: Inspector2ClientTypes.AggregationRequest? = nil,
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.aggregationRequest = aggregationRequest
        self.aggregationType = aggregationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFindingAggregationsOutput {
    /// The type of aggregation to perform.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Objects that contain the results of an aggregation operation.
    public var responses: [Inspector2ClientTypes.AggregationResponse]?

    public init(
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        nextToken: Swift.String? = nil,
        responses: [Inspector2ClientTypes.AggregationResponse]? = nil
    )
    {
        self.aggregationType = aggregationType
        self.nextToken = nextToken
        self.responses = responses
    }
}

extension Inspector2ClientTypes {

    public enum SortField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAccountId
        case componentType
        case ecrImagePushedAt
        case ecrImageRegistry
        case ecrImageRepositoryName
        case epssScore
        case findingStatus
        case findingType
        case firstObservedAt
        case inspectorScore
        case lastObservedAt
        case networkProtocol
        case resourceType
        case severity
        case vendorSeverity
        case vulnerabilityId
        case vulnerabilitySource
        case sdkUnknown(Swift.String)

        public static var allCases: [SortField] {
            return [
                .awsAccountId,
                .componentType,
                .ecrImagePushedAt,
                .ecrImageRegistry,
                .ecrImageRepositoryName,
                .epssScore,
                .findingStatus,
                .findingType,
                .firstObservedAt,
                .inspectorScore,
                .lastObservedAt,
                .networkProtocol,
                .resourceType,
                .severity,
                .vendorSeverity,
                .vulnerabilityId,
                .vulnerabilitySource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAccountId: return "AWS_ACCOUNT_ID"
            case .componentType: return "COMPONENT_TYPE"
            case .ecrImagePushedAt: return "ECR_IMAGE_PUSHED_AT"
            case .ecrImageRegistry: return "ECR_IMAGE_REGISTRY"
            case .ecrImageRepositoryName: return "ECR_IMAGE_REPOSITORY_NAME"
            case .epssScore: return "EPSS_SCORE"
            case .findingStatus: return "FINDING_STATUS"
            case .findingType: return "FINDING_TYPE"
            case .firstObservedAt: return "FIRST_OBSERVED_AT"
            case .inspectorScore: return "INSPECTOR_SCORE"
            case .lastObservedAt: return "LAST_OBSERVED_AT"
            case .networkProtocol: return "NETWORK_PROTOCOL"
            case .resourceType: return "RESOURCE_TYPE"
            case .severity: return "SEVERITY"
            case .vendorSeverity: return "VENDOR_SEVERITY"
            case .vulnerabilityId: return "VULNERABILITY_ID"
            case .vulnerabilitySource: return "VULNERABILITY_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Details about the criteria used to sort finding results.
    public struct SortCriteria {
        /// The finding detail field by which results are sorted.
        /// This member is required.
        public var field: Inspector2ClientTypes.SortField?
        /// The order by which findings are sorted.
        /// This member is required.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            field: Inspector2ClientTypes.SortField? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.sortOrder = sortOrder
        }
    }

}

public struct ListFindingsInput {
    /// Details on the filters to apply to your finding results.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Details on the sort criteria to apply to your finding results.
    public var sortCriteria: Inspector2ClientTypes.SortCriteria?

    public init(
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Inspector2ClientTypes.SortCriteria? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

public struct ListFindingsOutput {
    /// Contains details on the findings in your environment.
    public var findings: [Inspector2ClientTypes.Finding]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        findings: [Inspector2ClientTypes.Finding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListMembersInput {
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Specifies whether to list only currently associated members if True or to list all members within the organization if False.
    public var onlyAssociated: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

public struct ListMembersOutput {
    /// An object that contains details for each member account.
    public var members: [Inspector2ClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        members: [Inspector2ClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon resource number (ARN) of the resource to list tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListUsageTotalsInput {
    /// The Amazon Web Services account IDs to retrieve usage totals for.
    public var accountIds: [Swift.String]?
    /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Inspector2ClientTypes {

    public enum UsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2InstanceHours
        case ecrInitialScan
        case ecrRescan
        case lambdaFunctionCodeHours
        case lambdaFunctionHours
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .ec2InstanceHours,
                .ecrInitialScan,
                .ecrRescan,
                .lambdaFunctionCodeHours,
                .lambdaFunctionHours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2InstanceHours: return "EC2_INSTANCE_HOURS"
            case .ecrInitialScan: return "ECR_INITIAL_SCAN"
            case .ecrRescan: return "ECR_RESCAN"
            case .lambdaFunctionCodeHours: return "LAMBDA_FUNCTION_CODE_HOURS"
            case .lambdaFunctionHours: return "LAMBDA_FUNCTION_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains usage information about the cost of Amazon Inspector operation.
    public struct Usage {
        /// The currency type used when calculating usage data.
        public var currency: Inspector2ClientTypes.Currency?
        /// The estimated monthly cost of Amazon Inspector.
        public var estimatedMonthlyCost: Swift.Double
        /// The total of usage.
        public var total: Swift.Double
        /// The type scan.
        public var type: Inspector2ClientTypes.UsageType?

        public init(
            currency: Inspector2ClientTypes.Currency? = nil,
            estimatedMonthlyCost: Swift.Double = 0.0,
            total: Swift.Double = 0.0,
            type: Inspector2ClientTypes.UsageType? = nil
        )
        {
            self.currency = currency
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.total = total
            self.type = type
        }
    }

}

extension Inspector2ClientTypes {
    /// The total of usage for an account ID.
    public struct UsageTotal {
        /// The account ID of the account that usage data was retrieved for.
        public var accountId: Swift.String?
        /// An object representing the total usage for an account.
        public var usage: [Inspector2ClientTypes.Usage]?

        public init(
            accountId: Swift.String? = nil,
            usage: [Inspector2ClientTypes.Usage]? = nil
        )
        {
            self.accountId = accountId
            self.usage = usage
        }
    }

}

public struct ListUsageTotalsOutput {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// An object with details on the total usage for the requested account.
    public var totals: [Inspector2ClientTypes.UsageTotal]?

    public init(
        nextToken: Swift.String? = nil,
        totals: [Inspector2ClientTypes.UsageTotal]? = nil
    )
    {
        self.nextToken = nextToken
        self.totals = totals
    }
}

public struct ResetEncryptionKeyInput {
    /// The resource type the key encrypts.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type the key encrypts.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

public struct ResetEncryptionKeyOutput {

    public init() { }
}

extension Inspector2ClientTypes {
    /// Details on the criteria used to define the filter for a vulnerability search.
    public struct SearchVulnerabilitiesFilterCriteria {
        /// The IDs for specific vulnerabilities.
        /// This member is required.
        public var vulnerabilityIds: [Swift.String]?

        public init(
            vulnerabilityIds: [Swift.String]? = nil
        )
        {
            self.vulnerabilityIds = vulnerabilityIds
        }
    }

}

public struct SearchVulnerabilitiesInput {
    /// The criteria used to filter the results of a vulnerability search.
    /// This member is required.
    public var filterCriteria: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.nextToken = nextToken
    }
}

extension Inspector2ClientTypes {

    public enum VulnerabilitySource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nvd
        case sdkUnknown(Swift.String)

        public static var allCases: [VulnerabilitySource] {
            return [
                .nvd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nvd: return "NVD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// Contains details about a specific vulnerability Amazon Inspector can detect.
    public struct Vulnerability {
        /// An object that contains information about the Amazon Web Services Threat Intel Group (ATIG) details for the vulnerability.
        public var atigData: Inspector2ClientTypes.AtigData?
        /// An object that contains the Cybersecurity and Infrastructure Security Agency (CISA) details for the vulnerability.
        public var cisaData: Inspector2ClientTypes.CisaData?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 2 details for the vulnerability.
        public var cvss2: Inspector2ClientTypes.Cvss2?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 3 details for the vulnerability.
        public var cvss3: Inspector2ClientTypes.Cvss3?
        /// The Common Weakness Enumeration (CWE) associated with the vulnerability.
        public var cwes: [Swift.String]?
        /// A description of the vulnerability.
        public var description: Swift.String?
        /// Platforms that the vulnerability can be detected on.
        public var detectionPlatforms: [Swift.String]?
        /// An object that contains the Exploit Prediction Scoring System (EPSS) score for a vulnerability.
        public var epss: Inspector2ClientTypes.Epss?
        /// An object that contains details on when the exploit was observed.
        public var exploitObserved: Inspector2ClientTypes.ExploitObserved?
        /// The ID for the specific vulnerability.
        /// This member is required.
        public var id: Swift.String?
        /// Links to various resources with more information on this vulnerability.
        public var referenceUrls: [Swift.String]?
        /// A list of related vulnerabilities.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information. Possible results are RHEL, AMAZON_CVE, DEBIAN or NVD.
        public var source: Inspector2ClientTypes.VulnerabilitySource?
        /// A link to the official source material for this vulnerability.
        public var sourceUrl: Swift.String?
        /// The date and time when the vendor created this vulnerability.
        public var vendorCreatedAt: Foundation.Date?
        /// The severity assigned by the vendor.
        public var vendorSeverity: Swift.String?
        /// The date and time when the vendor last updated this vulnerability.
        public var vendorUpdatedAt: Foundation.Date?

        public init(
            atigData: Inspector2ClientTypes.AtigData? = nil,
            cisaData: Inspector2ClientTypes.CisaData? = nil,
            cvss2: Inspector2ClientTypes.Cvss2? = nil,
            cvss3: Inspector2ClientTypes.Cvss3? = nil,
            cwes: [Swift.String]? = nil,
            description: Swift.String? = nil,
            detectionPlatforms: [Swift.String]? = nil,
            epss: Inspector2ClientTypes.Epss? = nil,
            exploitObserved: Inspector2ClientTypes.ExploitObserved? = nil,
            id: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Inspector2ClientTypes.VulnerabilitySource? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: Foundation.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: Foundation.Date? = nil
        )
        {
            self.atigData = atigData
            self.cisaData = cisaData
            self.cvss2 = cvss2
            self.cvss3 = cvss3
            self.cwes = cwes
            self.description = description
            self.detectionPlatforms = detectionPlatforms
            self.epss = epss
            self.exploitObserved = exploitObserved
            self.id = id
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }
    }

}

public struct SearchVulnerabilitiesOutput {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// Details about the listed vulnerability.
    /// This member is required.
    public var vulnerabilities: [Inspector2ClientTypes.Vulnerability]?

    public init(
        nextToken: Swift.String? = nil,
        vulnerabilities: [Inspector2ClientTypes.Vulnerability]? = nil
    )
    {
        self.nextToken = nextToken
        self.vulnerabilities = vulnerabilities
    }
}

public struct SendCisSessionHealthInput {
    /// A unique identifier for the scan job.
    /// This member is required.
    public var scanJobId: Swift.String?
    /// The unique token that identifies the CIS session.
    /// This member is required.
    public var sessionToken: Swift.String?

    public init(
        scanJobId: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.scanJobId = scanJobId
        self.sessionToken = sessionToken
    }
}

public struct SendCisSessionHealthOutput {

    public init() { }
}

public struct SendCisSessionTelemetryInput {
    /// The CIS session telemetry messages.
    /// This member is required.
    public var messages: [Inspector2ClientTypes.CisSessionMessage]?
    /// A unique identifier for the scan job.
    /// This member is required.
    public var scanJobId: Swift.String?
    /// The unique token that identifies the CIS session.
    /// This member is required.
    public var sessionToken: Swift.String?

    public init(
        messages: [Inspector2ClientTypes.CisSessionMessage]? = nil,
        scanJobId: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.scanJobId = scanJobId
        self.sessionToken = sessionToken
    }
}

public struct SendCisSessionTelemetryOutput {

    public init() { }
}

extension Inspector2ClientTypes {
    /// The start CIS session message.
    public struct StartCisSessionMessage {
        /// The unique token that identifies the CIS session.
        /// This member is required.
        public var sessionToken: Swift.String?

        public init(
            sessionToken: Swift.String? = nil
        )
        {
            self.sessionToken = sessionToken
        }
    }

}

public struct StartCisSessionInput {
    /// The start CIS session message.
    /// This member is required.
    public var message: Inspector2ClientTypes.StartCisSessionMessage?
    /// A unique identifier for the scan job.
    /// This member is required.
    public var scanJobId: Swift.String?

    public init(
        message: Inspector2ClientTypes.StartCisSessionMessage? = nil,
        scanJobId: Swift.String? = nil
    )
    {
        self.message = message
        self.scanJobId = scanJobId
    }
}

public struct StartCisSessionOutput {

    public init() { }
}

extension Inspector2ClientTypes {
    /// The stop CIS message progress.
    public struct StopCisMessageProgress {
        /// The progress' error checks.
        public var errorChecks: Swift.Int
        /// The progress' failed checks.
        public var failedChecks: Swift.Int
        /// The progress' informational checks.
        public var informationalChecks: Swift.Int
        /// The progress' not applicable checks.
        public var notApplicableChecks: Swift.Int
        /// The progress' not evaluated checks.
        public var notEvaluatedChecks: Swift.Int
        /// The progress' successful checks.
        public var successfulChecks: Swift.Int
        /// The progress' total checks.
        public var totalChecks: Swift.Int
        /// The progress' unknown checks.
        public var unknownChecks: Swift.Int

        public init(
            errorChecks: Swift.Int = 0,
            failedChecks: Swift.Int = 0,
            informationalChecks: Swift.Int = 0,
            notApplicableChecks: Swift.Int = 0,
            notEvaluatedChecks: Swift.Int = 0,
            successfulChecks: Swift.Int = 0,
            totalChecks: Swift.Int = 0,
            unknownChecks: Swift.Int = 0
        )
        {
            self.errorChecks = errorChecks
            self.failedChecks = failedChecks
            self.informationalChecks = informationalChecks
            self.notApplicableChecks = notApplicableChecks
            self.notEvaluatedChecks = notEvaluatedChecks
            self.successfulChecks = successfulChecks
            self.totalChecks = totalChecks
            self.unknownChecks = unknownChecks
        }
    }

}

extension Inspector2ClientTypes {

    public enum StopCisSessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case interrupted
        case success
        case unsupportedOs
        case sdkUnknown(Swift.String)

        public static var allCases: [StopCisSessionStatus] {
            return [
                .failed,
                .interrupted,
                .success,
                .unsupportedOs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .success: return "SUCCESS"
            case .unsupportedOs: return "UNSUPPORTED_OS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Inspector2ClientTypes {
    /// The stop CIS session message.
    public struct StopCisSessionMessage {
        /// The message benchmark profile.
        public var benchmarkProfile: Swift.String?
        /// The message benchmark version.
        public var benchmarkVersion: Swift.String?
        /// The message compute platform.
        public var computePlatform: Inspector2ClientTypes.ComputePlatform?
        /// The progress of the message.
        /// This member is required.
        public var progress: Inspector2ClientTypes.StopCisMessageProgress?
        /// The reason for the message.
        public var reason: Swift.String?
        /// The status of the message.
        /// This member is required.
        public var status: Inspector2ClientTypes.StopCisSessionStatus?

        public init(
            benchmarkProfile: Swift.String? = nil,
            benchmarkVersion: Swift.String? = nil,
            computePlatform: Inspector2ClientTypes.ComputePlatform? = nil,
            progress: Inspector2ClientTypes.StopCisMessageProgress? = nil,
            reason: Swift.String? = nil,
            status: Inspector2ClientTypes.StopCisSessionStatus? = nil
        )
        {
            self.benchmarkProfile = benchmarkProfile
            self.benchmarkVersion = benchmarkVersion
            self.computePlatform = computePlatform
            self.progress = progress
            self.reason = reason
            self.status = status
        }
    }

}

public struct StopCisSessionInput {
    /// The stop CIS session message.
    /// This member is required.
    public var message: Inspector2ClientTypes.StopCisSessionMessage?
    /// A unique identifier for the scan job.
    /// This member is required.
    public var scanJobId: Swift.String?
    /// The unique token that identifies the CIS session.
    /// This member is required.
    public var sessionToken: Swift.String?

    public init(
        message: Inspector2ClientTypes.StopCisSessionMessage? = nil,
        scanJobId: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.message = message
        self.scanJobId = scanJobId
        self.sessionToken = sessionToken
    }
}

public struct StopCisSessionOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension Inspector2ClientTypes {
    /// Updates CIS targets.
    public struct UpdateCisTargets {
        /// The target account ids.
        public var accountIds: [Swift.String]?
        /// The target resource tags.
        public var targetResourceTags: [Swift.String: [Swift.String]]?

        public init(
            accountIds: [Swift.String]? = nil,
            targetResourceTags: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }
    }

}

public struct UpdateCisScanConfigurationInput {
    /// The CIS scan configuration ARN.
    /// This member is required.
    public var scanConfigurationArn: Swift.String?
    /// The scan name for the CIS scan configuration.
    public var scanName: Swift.String?
    /// The schedule for the CIS scan configuration.
    public var schedule: Inspector2ClientTypes.Schedule?
    /// The security level for the CIS scan configuration. Security level refers to the Benchmark levels that CIS assigns to a profile.
    public var securityLevel: Inspector2ClientTypes.CisSecurityLevel?
    /// The targets for the CIS scan configuration.
    public var targets: Inspector2ClientTypes.UpdateCisTargets?

    public init(
        scanConfigurationArn: Swift.String? = nil,
        scanName: Swift.String? = nil,
        schedule: Inspector2ClientTypes.Schedule? = nil,
        securityLevel: Inspector2ClientTypes.CisSecurityLevel? = nil,
        targets: Inspector2ClientTypes.UpdateCisTargets? = nil
    )
    {
        self.scanConfigurationArn = scanConfigurationArn
        self.scanName = scanName
        self.schedule = schedule
        self.securityLevel = securityLevel
        self.targets = targets
    }
}

public struct UpdateCisScanConfigurationOutput {
    /// The CIS scan configuration ARN.
    /// This member is required.
    public var scanConfigurationArn: Swift.String?

    public init(
        scanConfigurationArn: Swift.String? = nil
    )
    {
        self.scanConfigurationArn = scanConfigurationArn
    }
}

public struct UpdateConfigurationInput {
    /// Specifies how the Amazon EC2 automated scan will be updated for your environment.
    public var ec2Configuration: Inspector2ClientTypes.Ec2Configuration?
    /// Specifies how the ECR automated re-scan will be updated for your environment.
    public var ecrConfiguration: Inspector2ClientTypes.EcrConfiguration?

    public init(
        ec2Configuration: Inspector2ClientTypes.Ec2Configuration? = nil,
        ecrConfiguration: Inspector2ClientTypes.EcrConfiguration? = nil
    )
    {
        self.ec2Configuration = ec2Configuration
        self.ecrConfiguration = ecrConfiguration
    }
}

public struct UpdateConfigurationOutput {

    public init() { }
}

public struct UpdateEc2DeepInspectionConfigurationInput {
    /// Specify TRUE to activate Amazon Inspector deep inspection in your account, or FALSE to deactivate. Member accounts in an organization cannot deactivate deep inspection, instead the delegated administrator for the organization can deactivate a member account using [BatchUpdateMemberEc2DeepInspectionStatus](https://docs.aws.amazon.com/inspector/v2/APIReference/API_BatchUpdateMemberEc2DeepInspectionStatus.html).
    public var activateDeepInspection: Swift.Bool?
    /// The Amazon Inspector deep inspection custom paths you are adding for your account.
    public var packagePaths: [Swift.String]?

    public init(
        activateDeepInspection: Swift.Bool? = nil,
        packagePaths: [Swift.String]? = nil
    )
    {
        self.activateDeepInspection = activateDeepInspection
        self.packagePaths = packagePaths
    }
}

public struct UpdateEc2DeepInspectionConfigurationOutput {
    /// An error message explaining why new Amazon Inspector deep inspection custom paths could not be added.
    public var errorMessage: Swift.String?
    /// The current Amazon Inspector deep inspection custom paths for the organization.
    public var orgPackagePaths: [Swift.String]?
    /// The current Amazon Inspector deep inspection custom paths for your account.
    public var packagePaths: [Swift.String]?
    /// The status of Amazon Inspector deep inspection in your account.
    public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

    public init(
        errorMessage: Swift.String? = nil,
        orgPackagePaths: [Swift.String]? = nil,
        packagePaths: [Swift.String]? = nil,
        status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.orgPackagePaths = orgPackagePaths
        self.packagePaths = packagePaths
        self.status = status
    }
}

public struct UpdateEncryptionKeyInput {
    /// A KMS key ID for the encryption key.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The resource type for the encryption key.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type for the encryption key.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        kmsKeyId: Swift.String? = nil,
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

public struct UpdateEncryptionKeyOutput {

    public init() { }
}

public struct UpdateFilterInput {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// The Amazon Resource Number (ARN) of the filter to update.
    /// This member is required.
    public var filterArn: Swift.String?
    /// Defines the criteria to be update in the filter.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter.
    public var name: Swift.String?
    /// The reason the filter was updated.
    public var reason: Swift.String?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterArn: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterArn = filterArn
        self.filterCriteria = filterCriteria
        self.name = name
        self.reason = reason
    }
}

public struct UpdateFilterOutput {
    /// The Amazon Resource Number (ARN) of the successfully updated filter.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct UpdateOrganizationConfigurationInput {
    /// Defines which scan types are enabled automatically for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

public struct UpdateOrganizationConfigurationOutput {
    /// The updated status of scan types automatically enabled for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

public struct UpdateOrgEc2DeepInspectionConfigurationInput {
    /// The Amazon Inspector deep inspection custom paths you are adding for your organization.
    /// This member is required.
    public var orgPackagePaths: [Swift.String]?

    public init(
        orgPackagePaths: [Swift.String]? = nil
    )
    {
        self.orgPackagePaths = orgPackagePaths
    }
}

public struct UpdateOrgEc2DeepInspectionConfigurationOutput {

    public init() { }
}

extension AssociateMemberInput {

    static func urlPathProvider(_ value: AssociateMemberInput) -> Swift.String? {
        return "/members/associate"
    }
}

extension BatchGetAccountStatusInput {

    static func urlPathProvider(_ value: BatchGetAccountStatusInput) -> Swift.String? {
        return "/status/batch/get"
    }
}

extension BatchGetCodeSnippetInput {

    static func urlPathProvider(_ value: BatchGetCodeSnippetInput) -> Swift.String? {
        return "/codesnippet/batchget"
    }
}

extension BatchGetFindingDetailsInput {

    static func urlPathProvider(_ value: BatchGetFindingDetailsInput) -> Swift.String? {
        return "/findings/details/batch/get"
    }
}

extension BatchGetFreeTrialInfoInput {

    static func urlPathProvider(_ value: BatchGetFreeTrialInfoInput) -> Swift.String? {
        return "/freetrialinfo/batchget"
    }
}

extension BatchGetMemberEc2DeepInspectionStatusInput {

    static func urlPathProvider(_ value: BatchGetMemberEc2DeepInspectionStatusInput) -> Swift.String? {
        return "/ec2deepinspectionstatus/member/batch/get"
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusInput {

    static func urlPathProvider(_ value: BatchUpdateMemberEc2DeepInspectionStatusInput) -> Swift.String? {
        return "/ec2deepinspectionstatus/member/batch/update"
    }
}

extension CancelFindingsReportInput {

    static func urlPathProvider(_ value: CancelFindingsReportInput) -> Swift.String? {
        return "/reporting/cancel"
    }
}

extension CancelSbomExportInput {

    static func urlPathProvider(_ value: CancelSbomExportInput) -> Swift.String? {
        return "/sbomexport/cancel"
    }
}

extension CreateCisScanConfigurationInput {

    static func urlPathProvider(_ value: CreateCisScanConfigurationInput) -> Swift.String? {
        return "/cis/scan-configuration/create"
    }
}

extension CreateFilterInput {

    static func urlPathProvider(_ value: CreateFilterInput) -> Swift.String? {
        return "/filters/create"
    }
}

extension CreateFindingsReportInput {

    static func urlPathProvider(_ value: CreateFindingsReportInput) -> Swift.String? {
        return "/reporting/create"
    }
}

extension CreateSbomExportInput {

    static func urlPathProvider(_ value: CreateSbomExportInput) -> Swift.String? {
        return "/sbomexport/create"
    }
}

extension DeleteCisScanConfigurationInput {

    static func urlPathProvider(_ value: DeleteCisScanConfigurationInput) -> Swift.String? {
        return "/cis/scan-configuration/delete"
    }
}

extension DeleteFilterInput {

    static func urlPathProvider(_ value: DeleteFilterInput) -> Swift.String? {
        return "/filters/delete"
    }
}

extension DescribeOrganizationConfigurationInput {

    static func urlPathProvider(_ value: DescribeOrganizationConfigurationInput) -> Swift.String? {
        return "/organizationconfiguration/describe"
    }
}

extension DisableInput {

    static func urlPathProvider(_ value: DisableInput) -> Swift.String? {
        return "/disable"
    }
}

extension DisableDelegatedAdminAccountInput {

    static func urlPathProvider(_ value: DisableDelegatedAdminAccountInput) -> Swift.String? {
        return "/delegatedadminaccounts/disable"
    }
}

extension DisassociateMemberInput {

    static func urlPathProvider(_ value: DisassociateMemberInput) -> Swift.String? {
        return "/members/disassociate"
    }
}

extension EnableInput {

    static func urlPathProvider(_ value: EnableInput) -> Swift.String? {
        return "/enable"
    }
}

extension EnableDelegatedAdminAccountInput {

    static func urlPathProvider(_ value: EnableDelegatedAdminAccountInput) -> Swift.String? {
        return "/delegatedadminaccounts/enable"
    }
}

extension GetCisScanReportInput {

    static func urlPathProvider(_ value: GetCisScanReportInput) -> Swift.String? {
        return "/cis/scan/report/get"
    }
}

extension GetCisScanResultDetailsInput {

    static func urlPathProvider(_ value: GetCisScanResultDetailsInput) -> Swift.String? {
        return "/cis/scan-result/details/get"
    }
}

extension GetConfigurationInput {

    static func urlPathProvider(_ value: GetConfigurationInput) -> Swift.String? {
        return "/configuration/get"
    }
}

extension GetDelegatedAdminAccountInput {

    static func urlPathProvider(_ value: GetDelegatedAdminAccountInput) -> Swift.String? {
        return "/delegatedadminaccounts/get"
    }
}

extension GetEc2DeepInspectionConfigurationInput {

    static func urlPathProvider(_ value: GetEc2DeepInspectionConfigurationInput) -> Swift.String? {
        return "/ec2deepinspectionconfiguration/get"
    }
}

extension GetEncryptionKeyInput {

    static func urlPathProvider(_ value: GetEncryptionKeyInput) -> Swift.String? {
        return "/encryptionkey/get"
    }
}

extension GetEncryptionKeyInput {

    static func queryItemProvider(_ value: GetEncryptionKeyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let scanType = value.scanType else {
            let message = "Creating a URL Query Item failed. scanType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let scanTypeQueryItem = Smithy.URIQueryItem(name: "scanType".urlPercentEncoding(), value: Swift.String(scanType.rawValue).urlPercentEncoding())
        items.append(scanTypeQueryItem)
        guard let resourceType = value.resourceType else {
            let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
        items.append(resourceTypeQueryItem)
        return items
    }
}

extension GetFindingsReportStatusInput {

    static func urlPathProvider(_ value: GetFindingsReportStatusInput) -> Swift.String? {
        return "/reporting/status/get"
    }
}

extension GetMemberInput {

    static func urlPathProvider(_ value: GetMemberInput) -> Swift.String? {
        return "/members/get"
    }
}

extension GetSbomExportInput {

    static func urlPathProvider(_ value: GetSbomExportInput) -> Swift.String? {
        return "/sbomexport/get"
    }
}

extension ListAccountPermissionsInput {

    static func urlPathProvider(_ value: ListAccountPermissionsInput) -> Swift.String? {
        return "/accountpermissions/list"
    }
}

extension ListCisScanConfigurationsInput {

    static func urlPathProvider(_ value: ListCisScanConfigurationsInput) -> Swift.String? {
        return "/cis/scan-configuration/list"
    }
}

extension ListCisScanResultsAggregatedByChecksInput {

    static func urlPathProvider(_ value: ListCisScanResultsAggregatedByChecksInput) -> Swift.String? {
        return "/cis/scan-result/check/list"
    }
}

extension ListCisScanResultsAggregatedByTargetResourceInput {

    static func urlPathProvider(_ value: ListCisScanResultsAggregatedByTargetResourceInput) -> Swift.String? {
        return "/cis/scan-result/resource/list"
    }
}

extension ListCisScansInput {

    static func urlPathProvider(_ value: ListCisScansInput) -> Swift.String? {
        return "/cis/scan/list"
    }
}

extension ListCoverageInput {

    static func urlPathProvider(_ value: ListCoverageInput) -> Swift.String? {
        return "/coverage/list"
    }
}

extension ListCoverageStatisticsInput {

    static func urlPathProvider(_ value: ListCoverageStatisticsInput) -> Swift.String? {
        return "/coverage/statistics/list"
    }
}

extension ListDelegatedAdminAccountsInput {

    static func urlPathProvider(_ value: ListDelegatedAdminAccountsInput) -> Swift.String? {
        return "/delegatedadminaccounts/list"
    }
}

extension ListFiltersInput {

    static func urlPathProvider(_ value: ListFiltersInput) -> Swift.String? {
        return "/filters/list"
    }
}

extension ListFindingAggregationsInput {

    static func urlPathProvider(_ value: ListFindingAggregationsInput) -> Swift.String? {
        return "/findings/aggregation/list"
    }
}

extension ListFindingsInput {

    static func urlPathProvider(_ value: ListFindingsInput) -> Swift.String? {
        return "/findings/list"
    }
}

extension ListMembersInput {

    static func urlPathProvider(_ value: ListMembersInput) -> Swift.String? {
        return "/members/list"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListUsageTotalsInput {

    static func urlPathProvider(_ value: ListUsageTotalsInput) -> Swift.String? {
        return "/usage/list"
    }
}

extension ResetEncryptionKeyInput {

    static func urlPathProvider(_ value: ResetEncryptionKeyInput) -> Swift.String? {
        return "/encryptionkey/reset"
    }
}

extension SearchVulnerabilitiesInput {

    static func urlPathProvider(_ value: SearchVulnerabilitiesInput) -> Swift.String? {
        return "/vulnerabilities/search"
    }
}

extension SendCisSessionHealthInput {

    static func urlPathProvider(_ value: SendCisSessionHealthInput) -> Swift.String? {
        return "/cissession/health/send"
    }
}

extension SendCisSessionTelemetryInput {

    static func urlPathProvider(_ value: SendCisSessionTelemetryInput) -> Swift.String? {
        return "/cissession/telemetry/send"
    }
}

extension StartCisSessionInput {

    static func urlPathProvider(_ value: StartCisSessionInput) -> Swift.String? {
        return "/cissession/start"
    }
}

extension StopCisSessionInput {

    static func urlPathProvider(_ value: StopCisSessionInput) -> Swift.String? {
        return "/cissession/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateCisScanConfigurationInput {

    static func urlPathProvider(_ value: UpdateCisScanConfigurationInput) -> Swift.String? {
        return "/cis/scan-configuration/update"
    }
}

extension UpdateConfigurationInput {

    static func urlPathProvider(_ value: UpdateConfigurationInput) -> Swift.String? {
        return "/configuration/update"
    }
}

extension UpdateEc2DeepInspectionConfigurationInput {

    static func urlPathProvider(_ value: UpdateEc2DeepInspectionConfigurationInput) -> Swift.String? {
        return "/ec2deepinspectionconfiguration/update"
    }
}

extension UpdateEncryptionKeyInput {

    static func urlPathProvider(_ value: UpdateEncryptionKeyInput) -> Swift.String? {
        return "/encryptionkey/update"
    }
}

extension UpdateFilterInput {

    static func urlPathProvider(_ value: UpdateFilterInput) -> Swift.String? {
        return "/filters/update"
    }
}

extension UpdateOrganizationConfigurationInput {

    static func urlPathProvider(_ value: UpdateOrganizationConfigurationInput) -> Swift.String? {
        return "/organizationconfiguration/update"
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationInput {

    static func urlPathProvider(_ value: UpdateOrgEc2DeepInspectionConfigurationInput) -> Swift.String? {
        return "/ec2deepinspectionconfiguration/org/update"
    }
}

extension AssociateMemberInput {

    static func write(value: AssociateMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }
}

extension BatchGetAccountStatusInput {

    static func write(value: BatchGetAccountStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCodeSnippetInput {

    static func write(value: BatchGetCodeSnippetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingArns"].writeList(value.findingArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetFindingDetailsInput {

    static func write(value: BatchGetFindingDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingArns"].writeList(value.findingArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetFreeTrialInfoInput {

    static func write(value: BatchGetFreeTrialInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetMemberEc2DeepInspectionStatusInput {

    static func write(value: BatchGetMemberEc2DeepInspectionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusInput {

    static func write(value: BatchUpdateMemberEc2DeepInspectionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelFindingsReportInput {

    static func write(value: CancelFindingsReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportId"].write(value.reportId)
    }
}

extension CancelSbomExportInput {

    static func write(value: CancelSbomExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportId"].write(value.reportId)
    }
}

extension CreateCisScanConfigurationInput {

    static func write(value: CreateCisScanConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanName"].write(value.scanName)
        try writer["schedule"].write(value.schedule, with: Inspector2ClientTypes.Schedule.write(value:to:))
        try writer["securityLevel"].write(value.securityLevel)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].write(value.targets, with: Inspector2ClientTypes.CreateCisTargets.write(value:to:))
    }
}

extension CreateFilterInput {

    static func write(value: CreateFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.FilterCriteria.write(value:to:))
        try writer["name"].write(value.name)
        try writer["reason"].write(value.reason)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFindingsReportInput {

    static func write(value: CreateFindingsReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.FilterCriteria.write(value:to:))
        try writer["reportFormat"].write(value.reportFormat)
        try writer["s3Destination"].write(value.s3Destination, with: Inspector2ClientTypes.Destination.write(value:to:))
    }
}

extension CreateSbomExportInput {

    static func write(value: CreateSbomExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportFormat"].write(value.reportFormat)
        try writer["resourceFilterCriteria"].write(value.resourceFilterCriteria, with: Inspector2ClientTypes.ResourceFilterCriteria.write(value:to:))
        try writer["s3Destination"].write(value.s3Destination, with: Inspector2ClientTypes.Destination.write(value:to:))
    }
}

extension DeleteCisScanConfigurationInput {

    static func write(value: DeleteCisScanConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanConfigurationArn"].write(value.scanConfigurationArn)
    }
}

extension DeleteFilterInput {

    static func write(value: DeleteFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DisableInput {

    static func write(value: DisableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Inspector2ClientTypes.ResourceScanType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisableDelegatedAdminAccountInput {

    static func write(value: DisableDelegatedAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["delegatedAdminAccountId"].write(value.delegatedAdminAccountId)
    }
}

extension DisassociateMemberInput {

    static func write(value: DisassociateMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }
}

extension EnableInput {

    static func write(value: EnableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Inspector2ClientTypes.ResourceScanType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension EnableDelegatedAdminAccountInput {

    static func write(value: EnableDelegatedAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["delegatedAdminAccountId"].write(value.delegatedAdminAccountId)
    }
}

extension GetCisScanReportInput {

    static func write(value: GetCisScanReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportFormat"].write(value.reportFormat)
        try writer["scanArn"].write(value.scanArn)
        try writer["targetAccounts"].writeList(value.targetAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetCisScanResultDetailsInput {

    static func write(value: GetCisScanResultDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.CisScanResultDetailsFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["scanArn"].write(value.scanArn)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
        try writer["targetResourceId"].write(value.targetResourceId)
    }
}

extension GetFindingsReportStatusInput {

    static func write(value: GetFindingsReportStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportId"].write(value.reportId)
    }
}

extension GetMemberInput {

    static func write(value: GetMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }
}

extension GetSbomExportInput {

    static func write(value: GetSbomExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reportId"].write(value.reportId)
    }
}

extension ListAccountPermissionsInput {

    static func write(value: ListAccountPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["service"].write(value.service)
    }
}

extension ListCisScanConfigurationsInput {

    static func write(value: ListCisScanConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.ListCisScanConfigurationsFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListCisScanResultsAggregatedByChecksInput {

    static func write(value: ListCisScanResultsAggregatedByChecksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.CisScanResultsAggregatedByChecksFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["scanArn"].write(value.scanArn)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListCisScanResultsAggregatedByTargetResourceInput {

    static func write(value: ListCisScanResultsAggregatedByTargetResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["scanArn"].write(value.scanArn)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListCisScansInput {

    static func write(value: ListCisScansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detailLevel"].write(value.detailLevel)
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.ListCisScansFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ListCoverageInput {

    static func write(value: ListCoverageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.CoverageFilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCoverageStatisticsInput {

    static func write(value: ListCoverageStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.CoverageFilterCriteria.write(value:to:))
        try writer["groupBy"].write(value.groupBy)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDelegatedAdminAccountsInput {

    static func write(value: ListDelegatedAdminAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFiltersInput {

    static func write(value: ListFiltersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFindingAggregationsInput {

    static func write(value: ListFindingAggregationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["aggregationRequest"].write(value.aggregationRequest, with: Inspector2ClientTypes.AggregationRequest.write(value:to:))
        try writer["aggregationType"].write(value.aggregationType)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFindingsInput {

    static func write(value: ListFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.FilterCriteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortCriteria"].write(value.sortCriteria, with: Inspector2ClientTypes.SortCriteria.write(value:to:))
    }
}

extension ListMembersInput {

    static func write(value: ListMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["onlyAssociated"].write(value.onlyAssociated)
    }
}

extension ListUsageTotalsInput {

    static func write(value: ListUsageTotalsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ResetEncryptionKeyInput {

    static func write(value: ResetEncryptionKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceType"].write(value.resourceType)
        try writer["scanType"].write(value.scanType)
    }
}

extension SearchVulnerabilitiesInput {

    static func write(value: SearchVulnerabilitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria.write(value:to:))
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SendCisSessionHealthInput {

    static func write(value: SendCisSessionHealthInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanJobId"].write(value.scanJobId)
        try writer["sessionToken"].write(value.sessionToken)
    }
}

extension SendCisSessionTelemetryInput {

    static func write(value: SendCisSessionTelemetryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messages"].writeList(value.messages, memberWritingClosure: Inspector2ClientTypes.CisSessionMessage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanJobId"].write(value.scanJobId)
        try writer["sessionToken"].write(value.sessionToken)
    }
}

extension StartCisSessionInput {

    static func write(value: StartCisSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message, with: Inspector2ClientTypes.StartCisSessionMessage.write(value:to:))
        try writer["scanJobId"].write(value.scanJobId)
    }
}

extension StopCisSessionInput {

    static func write(value: StopCisSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message, with: Inspector2ClientTypes.StopCisSessionMessage.write(value:to:))
        try writer["scanJobId"].write(value.scanJobId)
        try writer["sessionToken"].write(value.sessionToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateCisScanConfigurationInput {

    static func write(value: UpdateCisScanConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanConfigurationArn"].write(value.scanConfigurationArn)
        try writer["scanName"].write(value.scanName)
        try writer["schedule"].write(value.schedule, with: Inspector2ClientTypes.Schedule.write(value:to:))
        try writer["securityLevel"].write(value.securityLevel)
        try writer["targets"].write(value.targets, with: Inspector2ClientTypes.UpdateCisTargets.write(value:to:))
    }
}

extension UpdateConfigurationInput {

    static func write(value: UpdateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ec2Configuration"].write(value.ec2Configuration, with: Inspector2ClientTypes.Ec2Configuration.write(value:to:))
        try writer["ecrConfiguration"].write(value.ecrConfiguration, with: Inspector2ClientTypes.EcrConfiguration.write(value:to:))
    }
}

extension UpdateEc2DeepInspectionConfigurationInput {

    static func write(value: UpdateEc2DeepInspectionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activateDeepInspection"].write(value.activateDeepInspection)
        try writer["packagePaths"].writeList(value.packagePaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateEncryptionKeyInput {

    static func write(value: UpdateEncryptionKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["resourceType"].write(value.resourceType)
        try writer["scanType"].write(value.scanType)
    }
}

extension UpdateFilterInput {

    static func write(value: UpdateFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["filterArn"].write(value.filterArn)
        try writer["filterCriteria"].write(value.filterCriteria, with: Inspector2ClientTypes.FilterCriteria.write(value:to:))
        try writer["name"].write(value.name)
        try writer["reason"].write(value.reason)
    }
}

extension UpdateOrganizationConfigurationInput {

    static func write(value: UpdateOrganizationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoEnable"].write(value.autoEnable, with: Inspector2ClientTypes.AutoEnable.write(value:to:))
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationInput {

    static func write(value: UpdateOrgEc2DeepInspectionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["orgPackagePaths"].writeList(value.orgPackagePaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateMemberOutput()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        return value
    }
}

extension BatchGetAccountStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAccountStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAccountStatusOutput()
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.AccountState.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedAccounts = try reader["failedAccounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FailedAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetCodeSnippetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCodeSnippetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCodeSnippetOutput()
        value.codeSnippetResults = try reader["codeSnippetResults"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CodeSnippetResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CodeSnippetError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetFindingDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetFindingDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetFindingDetailsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FindingDetailsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingDetails = try reader["findingDetails"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FindingDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetFreeTrialInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetFreeTrialInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetFreeTrialInfoOutput()
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FreeTrialAccountInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedAccounts = try reader["failedAccounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FreeTrialInfoError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetMemberEc2DeepInspectionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetMemberEc2DeepInspectionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetMemberEc2DeepInspectionStatusOutput()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedAccountIds = try reader["failedAccountIds"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateMemberEc2DeepInspectionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateMemberEc2DeepInspectionStatusOutput()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedAccountIds = try reader["failedAccountIds"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelFindingsReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelFindingsReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelFindingsReportOutput()
        value.reportId = try reader["reportId"].readIfPresent() ?? ""
        return value
    }
}

extension CancelSbomExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSbomExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelSbomExportOutput()
        value.reportId = try reader["reportId"].readIfPresent()
        return value
    }
}

extension CreateCisScanConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCisScanConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCisScanConfigurationOutput()
        value.scanConfigurationArn = try reader["scanConfigurationArn"].readIfPresent()
        return value
    }
}

extension CreateFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFilterOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFindingsReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFindingsReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFindingsReportOutput()
        value.reportId = try reader["reportId"].readIfPresent()
        return value
    }
}

extension CreateSbomExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSbomExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSbomExportOutput()
        value.reportId = try reader["reportId"].readIfPresent()
        return value
    }
}

extension DeleteCisScanConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCisScanConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCisScanConfigurationOutput()
        value.scanConfigurationArn = try reader["scanConfigurationArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFilterOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeOrganizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConfigurationOutput()
        value.autoEnable = try reader["autoEnable"].readIfPresent(with: Inspector2ClientTypes.AutoEnable.read(from:))
        value.maxAccountLimitReached = try reader["maxAccountLimitReached"].readIfPresent()
        return value
    }
}

extension DisableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableOutput()
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Account.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedAccounts = try reader["failedAccounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FailedAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisableDelegatedAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableDelegatedAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableDelegatedAdminAccountOutput()
        value.delegatedAdminAccountId = try reader["delegatedAdminAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension DisassociateMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateMemberOutput()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        return value
    }
}

extension EnableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableOutput()
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Account.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.failedAccounts = try reader["failedAccounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FailedAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EnableDelegatedAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableDelegatedAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableDelegatedAdminAccountOutput()
        value.delegatedAdminAccountId = try reader["delegatedAdminAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension GetCisScanReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCisScanReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCisScanReportOutput()
        value.status = try reader["status"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension GetCisScanResultDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCisScanResultDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCisScanResultDetailsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scanResultDetails = try reader["scanResultDetails"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CisScanResultDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfigurationOutput()
        value.ec2Configuration = try reader["ec2Configuration"].readIfPresent(with: Inspector2ClientTypes.Ec2ConfigurationState.read(from:))
        value.ecrConfiguration = try reader["ecrConfiguration"].readIfPresent(with: Inspector2ClientTypes.EcrConfigurationState.read(from:))
        return value
    }
}

extension GetDelegatedAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDelegatedAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDelegatedAdminAccountOutput()
        value.delegatedAdmin = try reader["delegatedAdmin"].readIfPresent(with: Inspector2ClientTypes.DelegatedAdmin.read(from:))
        return value
    }
}

extension GetEc2DeepInspectionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEc2DeepInspectionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEc2DeepInspectionConfigurationOutput()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.orgPackagePaths = try reader["orgPackagePaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.packagePaths = try reader["packagePaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEncryptionKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEncryptionKeyOutput()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent() ?? ""
        return value
    }
}

extension GetFindingsReportStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingsReportStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingsReportStatusOutput()
        value.destination = try reader["destination"].readIfPresent(with: Inspector2ClientTypes.Destination.read(from:))
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.filterCriteria = try reader["filterCriteria"].readIfPresent(with: Inspector2ClientTypes.FilterCriteria.read(from:))
        value.reportId = try reader["reportId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMemberOutput()
        value.member = try reader["member"].readIfPresent(with: Inspector2ClientTypes.Member.read(from:))
        return value
    }
}

extension GetSbomExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSbomExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSbomExportOutput()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.filterCriteria = try reader["filterCriteria"].readIfPresent(with: Inspector2ClientTypes.ResourceFilterCriteria.read(from:))
        value.format = try reader["format"].readIfPresent()
        value.reportId = try reader["reportId"].readIfPresent()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: Inspector2ClientTypes.Destination.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension ListAccountPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountPermissionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.permissions = try reader["permissions"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Permission.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListCisScanConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCisScanConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCisScanConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scanConfigurations = try reader["scanConfigurations"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CisScanConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCisScanResultsAggregatedByChecksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCisScanResultsAggregatedByChecksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCisScanResultsAggregatedByChecksOutput()
        value.checkAggregations = try reader["checkAggregations"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CisCheckAggregation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCisScanResultsAggregatedByTargetResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCisScanResultsAggregatedByTargetResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCisScanResultsAggregatedByTargetResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.targetResourceAggregations = try reader["targetResourceAggregations"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CisTargetResourceAggregation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCisScansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCisScansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCisScansOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scans = try reader["scans"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CisScan.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCoverageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoverageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoverageOutput()
        value.coveredResources = try reader["coveredResources"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CoveredResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCoverageStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoverageStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoverageStatisticsOutput()
        value.countsByGroup = try reader["countsByGroup"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Counts.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totalCounts = try reader["totalCounts"].readIfPresent() ?? 0
        return value
    }
}

extension ListDelegatedAdminAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDelegatedAdminAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDelegatedAdminAccountsOutput()
        value.delegatedAdminAccounts = try reader["delegatedAdminAccounts"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DelegatedAdminAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFiltersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFiltersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFiltersOutput()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFindingAggregationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingAggregationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingAggregationsOutput()
        value.aggregationType = try reader["aggregationType"].readIfPresent() ?? .sdkUnknown("")
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.responses = try reader["responses"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.AggregationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Finding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Member.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListUsageTotalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsageTotalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsageTotalsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.totals = try reader["totals"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.UsageTotal.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResetEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetEncryptionKeyOutput {
        return ResetEncryptionKeyOutput()
    }
}

extension SearchVulnerabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchVulnerabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchVulnerabilitiesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vulnerabilities = try reader["vulnerabilities"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Vulnerability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SendCisSessionHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendCisSessionHealthOutput {
        return SendCisSessionHealthOutput()
    }
}

extension SendCisSessionTelemetryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendCisSessionTelemetryOutput {
        return SendCisSessionTelemetryOutput()
    }
}

extension StartCisSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCisSessionOutput {
        return StartCisSessionOutput()
    }
}

extension StopCisSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCisSessionOutput {
        return StopCisSessionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCisScanConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCisScanConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCisScanConfigurationOutput()
        value.scanConfigurationArn = try reader["scanConfigurationArn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfigurationOutput {
        return UpdateConfigurationOutput()
    }
}

extension UpdateEc2DeepInspectionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEc2DeepInspectionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEc2DeepInspectionConfigurationOutput()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.orgPackagePaths = try reader["orgPackagePaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.packagePaths = try reader["packagePaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEncryptionKeyOutput {
        return UpdateEncryptionKeyOutput()
    }
}

extension UpdateFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFilterOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateOrganizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOrganizationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOrganizationConfigurationOutput()
        value.autoEnable = try reader["autoEnable"].readIfPresent(with: Inspector2ClientTypes.AutoEnable.read(from:))
        return value
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOrgEc2DeepInspectionConfigurationOutput {
        return UpdateOrgEc2DeepInspectionConfigurationOutput()
    }
}

enum AssociateMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAccountStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetCodeSnippetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetFindingDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetFreeTrialInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetMemberEc2DeepInspectionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateMemberEc2DeepInspectionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelFindingsReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelSbomExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCisScanConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFindingsReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSbomExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCisScanConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableDelegatedAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableDelegatedAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCisScanReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCisScanResultDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDelegatedAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEc2DeepInspectionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingsReportStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSbomExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCisScanConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCisScanResultsAggregatedByChecksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCisScanResultsAggregatedByTargetResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCisScansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoverageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoverageStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDelegatedAdminAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFiltersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingAggregationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsageTotalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchVulnerabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendCisSessionHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendCisSessionTelemetryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCisSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCisSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCisScanConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEc2DeepInspectionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOrganizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOrgEc2DeepInspectionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["fields"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension Inspector2ClientTypes.AccountState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AccountState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AccountState()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent(with: Inspector2ClientTypes.State.read(from:))
        value.resourceState = try reader["resourceState"].readIfPresent(with: Inspector2ClientTypes.ResourceState.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.ResourceState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceState()
        value.ec2 = try reader["ec2"].readIfPresent(with: Inspector2ClientTypes.State.read(from:))
        value.ecr = try reader["ecr"].readIfPresent(with: Inspector2ClientTypes.State.read(from:))
        value.lambda = try reader["lambda"].readIfPresent(with: Inspector2ClientTypes.State.read(from:))
        value.lambdaCode = try reader["lambdaCode"].readIfPresent(with: Inspector2ClientTypes.State.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.State {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.State {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.State()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.FailedAccount {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FailedAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FailedAccount()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.resourceStatus = try reader["resourceStatus"].readIfPresent(with: Inspector2ClientTypes.ResourceStatus.read(from:))
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.ResourceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceStatus()
        value.ec2 = try reader["ec2"].readIfPresent() ?? .sdkUnknown("")
        value.ecr = try reader["ecr"].readIfPresent() ?? .sdkUnknown("")
        value.lambda = try reader["lambda"].readIfPresent()
        value.lambdaCode = try reader["lambdaCode"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CodeSnippetResult {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CodeSnippetResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CodeSnippetResult()
        value.findingArn = try reader["findingArn"].readIfPresent()
        value.startLine = try reader["startLine"].readIfPresent()
        value.endLine = try reader["endLine"].readIfPresent()
        value.codeSnippet = try reader["codeSnippet"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CodeLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.suggestedFixes = try reader["suggestedFixes"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.SuggestedFix.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.SuggestedFix {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.SuggestedFix {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.SuggestedFix()
        value.description = try reader["description"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CodeLine {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CodeLine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CodeLine()
        value.content = try reader["content"].readIfPresent() ?? ""
        value.lineNumber = try reader["lineNumber"].readIfPresent() ?? 0
        return value
    }
}

extension Inspector2ClientTypes.CodeSnippetError {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CodeSnippetError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CodeSnippetError()
        value.findingArn = try reader["findingArn"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.FindingDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FindingDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FindingDetail()
        value.findingArn = try reader["findingArn"].readIfPresent()
        value.cisaData = try reader["cisaData"].readIfPresent(with: Inspector2ClientTypes.CisaData.read(from:))
        value.riskScore = try reader["riskScore"].readIfPresent()
        value.evidences = try reader["evidences"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Evidence.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ttps = try reader["ttps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tools = try reader["tools"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exploitObserved = try reader["exploitObserved"].readIfPresent(with: Inspector2ClientTypes.ExploitObserved.read(from:))
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cwes = try reader["cwes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.epssScore = try reader["epssScore"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.ExploitObserved {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ExploitObserved {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ExploitObserved()
        value.lastSeen = try reader["lastSeen"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstSeen = try reader["firstSeen"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.Evidence {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Evidence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Evidence()
        value.evidenceRule = try reader["evidenceRule"].readIfPresent()
        value.evidenceDetail = try reader["evidenceDetail"].readIfPresent()
        value.severity = try reader["severity"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CisaData {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisaData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisaData()
        value.dateAdded = try reader["dateAdded"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateDue = try reader["dateDue"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.FindingDetailsError {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FindingDetailsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FindingDetailsError()
        value.findingArn = try reader["findingArn"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.FreeTrialAccountInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FreeTrialAccountInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FreeTrialAccountInfo()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.freeTrialInfo = try reader["freeTrialInfo"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.FreeTrialInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension Inspector2ClientTypes.FreeTrialInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FreeTrialInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FreeTrialInfo()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.start = try reader["start"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.end = try reader["end"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Inspector2ClientTypes.FreeTrialInfoError {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FreeTrialInfoError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FreeTrialInfoError()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.ec2ScanStatus = try reader["ec2ScanStatus"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AutoEnable {

    static func write(value: Inspector2ClientTypes.AutoEnable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ec2"].write(value.ec2)
        try writer["ecr"].write(value.ecr)
        try writer["lambda"].write(value.lambda)
        try writer["lambdaCode"].write(value.lambdaCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AutoEnable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AutoEnable()
        value.ec2 = try reader["ec2"].readIfPresent() ?? false
        value.ecr = try reader["ecr"].readIfPresent() ?? false
        value.lambda = try reader["lambda"].readIfPresent()
        value.lambdaCode = try reader["lambdaCode"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Account {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Account {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Account()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resourceStatus = try reader["resourceStatus"].readIfPresent(with: Inspector2ClientTypes.ResourceStatus.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.CisScanResultDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisScanResultDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisScanResultDetails()
        value.scanArn = try reader["scanArn"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.targetResourceId = try reader["targetResourceId"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.checkId = try reader["checkId"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.checkDescription = try reader["checkDescription"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent()
        value.level = try reader["level"].readIfPresent()
        value.findingArn = try reader["findingArn"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.EcrConfigurationState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.EcrConfigurationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.EcrConfigurationState()
        value.rescanDurationState = try reader["rescanDurationState"].readIfPresent(with: Inspector2ClientTypes.EcrRescanDurationState.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.EcrRescanDurationState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.EcrRescanDurationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.EcrRescanDurationState()
        value.rescanDuration = try reader["rescanDuration"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pullDateRescanDuration = try reader["pullDateRescanDuration"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Ec2ConfigurationState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Ec2ConfigurationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Ec2ConfigurationState()
        value.scanModeState = try reader["scanModeState"].readIfPresent(with: Inspector2ClientTypes.Ec2ScanModeState.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.Ec2ScanModeState {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Ec2ScanModeState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Ec2ScanModeState()
        value.scanMode = try reader["scanMode"].readIfPresent()
        value.scanModeStatus = try reader["scanModeStatus"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.DelegatedAdmin {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.DelegatedAdmin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.DelegatedAdmin()
        value.accountId = try reader["accountId"].readIfPresent()
        value.relationshipStatus = try reader["relationshipStatus"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Destination {

    static func write(value: Inspector2ClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keyPrefix"].write(value.keyPrefix)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Destination()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.FilterCriteria {

    static func write(value: Inspector2ClientTypes.FilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].writeList(value.awsAccountId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["codeVulnerabilityDetectorName"].writeList(value.codeVulnerabilityDetectorName, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["codeVulnerabilityDetectorTags"].writeList(value.codeVulnerabilityDetectorTags, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["codeVulnerabilityFilePath"].writeList(value.codeVulnerabilityFilePath, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["componentId"].writeList(value.componentId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["componentType"].writeList(value.componentType, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ec2InstanceImageId"].writeList(value.ec2InstanceImageId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ec2InstanceSubnetId"].writeList(value.ec2InstanceSubnetId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ec2InstanceVpcId"].writeList(value.ec2InstanceVpcId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageArchitecture"].writeList(value.ecrImageArchitecture, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageHash"].writeList(value.ecrImageHash, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImagePushedAt"].writeList(value.ecrImagePushedAt, memberWritingClosure: Inspector2ClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageRegistry"].writeList(value.ecrImageRegistry, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageRepositoryName"].writeList(value.ecrImageRepositoryName, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageTags"].writeList(value.ecrImageTags, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["epssScore"].writeList(value.epssScore, memberWritingClosure: Inspector2ClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["exploitAvailable"].writeList(value.exploitAvailable, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingArn"].writeList(value.findingArn, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingStatus"].writeList(value.findingStatus, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingType"].writeList(value.findingType, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["firstObservedAt"].writeList(value.firstObservedAt, memberWritingClosure: Inspector2ClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["fixAvailable"].writeList(value.fixAvailable, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inspectorScore"].writeList(value.inspectorScore, memberWritingClosure: Inspector2ClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionExecutionRoleArn"].writeList(value.lambdaFunctionExecutionRoleArn, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionLastModifiedAt"].writeList(value.lambdaFunctionLastModifiedAt, memberWritingClosure: Inspector2ClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionLayers"].writeList(value.lambdaFunctionLayers, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionName"].writeList(value.lambdaFunctionName, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionRuntime"].writeList(value.lambdaFunctionRuntime, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastObservedAt"].writeList(value.lastObservedAt, memberWritingClosure: Inspector2ClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["networkProtocol"].writeList(value.networkProtocol, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["portRange"].writeList(value.portRange, memberWritingClosure: Inspector2ClientTypes.PortRangeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["relatedVulnerabilities"].writeList(value.relatedVulnerabilities, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceId"].writeList(value.resourceId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTags"].writeList(value.resourceTags, memberWritingClosure: Inspector2ClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceType"].writeList(value.resourceType, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["severity"].writeList(value.severity, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["title"].writeList(value.title, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["updatedAt"].writeList(value.updatedAt, memberWritingClosure: Inspector2ClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vendorSeverity"].writeList(value.vendorSeverity, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vulnerabilityId"].writeList(value.vulnerabilityId, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vulnerabilitySource"].writeList(value.vulnerabilitySource, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vulnerablePackages"].writeList(value.vulnerablePackages, memberWritingClosure: Inspector2ClientTypes.PackageFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FilterCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FilterCriteria()
        value.findingArn = try reader["findingArn"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["awsAccountId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingType = try reader["findingType"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severity = try reader["severity"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.firstObservedAt = try reader["firstObservedAt"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastObservedAt = try reader["lastObservedAt"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingStatus = try reader["findingStatus"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.title = try reader["title"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inspectorScore = try reader["inspectorScore"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["resourceType"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceId = try reader["resourceId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2InstanceImageId = try reader["ec2InstanceImageId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2InstanceVpcId = try reader["ec2InstanceVpcId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2InstanceSubnetId = try reader["ec2InstanceSubnetId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImagePushedAt = try reader["ecrImagePushedAt"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageArchitecture = try reader["ecrImageArchitecture"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageRegistry = try reader["ecrImageRegistry"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageRepositoryName = try reader["ecrImageRepositoryName"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageTags = try reader["ecrImageTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageHash = try reader["ecrImageHash"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.portRange = try reader["portRange"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.PortRangeFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkProtocol = try reader["networkProtocol"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.componentId = try reader["componentId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.componentType = try reader["componentType"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vulnerabilityId = try reader["vulnerabilityId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vulnerabilitySource = try reader["vulnerabilitySource"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vendorSeverity = try reader["vendorSeverity"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vulnerablePackages = try reader["vulnerablePackages"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.PackageFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedVulnerabilities = try reader["relatedVulnerabilities"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fixAvailable = try reader["fixAvailable"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionName = try reader["lambdaFunctionName"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionLayers = try reader["lambdaFunctionLayers"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionRuntime = try reader["lambdaFunctionRuntime"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionLastModifiedAt = try reader["lambdaFunctionLastModifiedAt"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionExecutionRoleArn = try reader["lambdaFunctionExecutionRoleArn"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exploitAvailable = try reader["exploitAvailable"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeVulnerabilityDetectorName = try reader["codeVulnerabilityDetectorName"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeVulnerabilityDetectorTags = try reader["codeVulnerabilityDetectorTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeVulnerabilityFilePath = try reader["codeVulnerabilityFilePath"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.epssScore = try reader["epssScore"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.NumberFilter {

    static func write(value: Inspector2ClientTypes.NumberFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lowerInclusive"].write(value.lowerInclusive)
        try writer["upperInclusive"].write(value.upperInclusive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.NumberFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.NumberFilter()
        value.upperInclusive = try reader["upperInclusive"].readIfPresent()
        value.lowerInclusive = try reader["lowerInclusive"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.StringFilter {

    static func write(value: Inspector2ClientTypes.StringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.StringFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.StringFilter()
        value.comparison = try reader["comparison"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.DateFilter {

    static func write(value: Inspector2ClientTypes.DateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endInclusive"].writeTimestamp(value.endInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startInclusive"].writeTimestamp(value.startInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.DateFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.DateFilter()
        value.startInclusive = try reader["startInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endInclusive = try reader["endInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.PackageFilter {

    static func write(value: Inspector2ClientTypes.PackageFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["architecture"].write(value.architecture, with: Inspector2ClientTypes.StringFilter.write(value:to:))
        try writer["epoch"].write(value.epoch, with: Inspector2ClientTypes.NumberFilter.write(value:to:))
        try writer["name"].write(value.name, with: Inspector2ClientTypes.StringFilter.write(value:to:))
        try writer["release"].write(value.release, with: Inspector2ClientTypes.StringFilter.write(value:to:))
        try writer["sourceLambdaLayerArn"].write(value.sourceLambdaLayerArn, with: Inspector2ClientTypes.StringFilter.write(value:to:))
        try writer["sourceLayerHash"].write(value.sourceLayerHash, with: Inspector2ClientTypes.StringFilter.write(value:to:))
        try writer["version"].write(value.version, with: Inspector2ClientTypes.StringFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.PackageFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.PackageFilter()
        value.name = try reader["name"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        value.version = try reader["version"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        value.epoch = try reader["epoch"].readIfPresent(with: Inspector2ClientTypes.NumberFilter.read(from:))
        value.release = try reader["release"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        value.architecture = try reader["architecture"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        value.sourceLayerHash = try reader["sourceLayerHash"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        value.sourceLambdaLayerArn = try reader["sourceLambdaLayerArn"].readIfPresent(with: Inspector2ClientTypes.StringFilter.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.PortRangeFilter {

    static func write(value: Inspector2ClientTypes.PortRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["beginInclusive"].write(value.beginInclusive)
        try writer["endInclusive"].write(value.endInclusive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.PortRangeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.PortRangeFilter()
        value.beginInclusive = try reader["beginInclusive"].readIfPresent()
        value.endInclusive = try reader["endInclusive"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.MapFilter {

    static func write(value: Inspector2ClientTypes.MapFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.MapFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.MapFilter()
        value.comparison = try reader["comparison"].readIfPresent() ?? .sdkUnknown("")
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Member {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Member {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Member()
        value.accountId = try reader["accountId"].readIfPresent()
        value.relationshipStatus = try reader["relationshipStatus"].readIfPresent()
        value.delegatedAdminAccountId = try reader["delegatedAdminAccountId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.ResourceFilterCriteria {

    static func write(value: Inspector2ClientTypes.ResourceFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].writeList(value.accountId, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ec2InstanceTags"].writeList(value.ec2InstanceTags, memberWritingClosure: Inspector2ClientTypes.ResourceMapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageTags"].writeList(value.ecrImageTags, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrRepositoryName"].writeList(value.ecrRepositoryName, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionName"].writeList(value.lambdaFunctionName, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionTags"].writeList(value.lambdaFunctionTags, memberWritingClosure: Inspector2ClientTypes.ResourceMapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceId"].writeList(value.resourceId, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceType"].writeList(value.resourceType, memberWritingClosure: Inspector2ClientTypes.ResourceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceFilterCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceFilterCriteria()
        value.accountId = try reader["accountId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceId = try reader["resourceId"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["resourceType"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrRepositoryName = try reader["ecrRepositoryName"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionName = try reader["lambdaFunctionName"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ecrImageTags = try reader["ecrImageTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceStringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2InstanceTags = try reader["ec2InstanceTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceMapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaFunctionTags = try reader["lambdaFunctionTags"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.ResourceMapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.ResourceMapFilter {

    static func write(value: Inspector2ClientTypes.ResourceMapFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceMapFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceMapFilter()
        value.comparison = try reader["comparison"].readIfPresent() ?? .sdkUnknown("")
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.ResourceStringFilter {

    static func write(value: Inspector2ClientTypes.ResourceStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceStringFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceStringFilter()
        value.comparison = try reader["comparison"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.Permission {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Permission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Permission()
        value.service = try reader["service"].readIfPresent() ?? .sdkUnknown("")
        value.operation = try reader["operation"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Inspector2ClientTypes.CisScanConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisScanConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisScanConfiguration()
        value.scanConfigurationArn = try reader["scanConfigurationArn"].readIfPresent() ?? ""
        value.ownerId = try reader["ownerId"].readIfPresent()
        value.scanName = try reader["scanName"].readIfPresent()
        value.securityLevel = try reader["securityLevel"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: Inspector2ClientTypes.Schedule.read(from:))
        value.targets = try reader["targets"].readIfPresent(with: Inspector2ClientTypes.CisTargets.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.CisTargets {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisTargets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisTargets()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetResourceTags = try reader["targetResourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.Schedule {

    static func write(value: Inspector2ClientTypes.Schedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .daily(daily):
                try writer["daily"].write(daily, with: Inspector2ClientTypes.DailySchedule.write(value:to:))
            case let .monthly(monthly):
                try writer["monthly"].write(monthly, with: Inspector2ClientTypes.MonthlySchedule.write(value:to:))
            case let .onetime(onetime):
                try writer["oneTime"].write(onetime, with: Inspector2ClientTypes.OneTimeSchedule.write(value:to:))
            case let .weekly(weekly):
                try writer["weekly"].write(weekly, with: Inspector2ClientTypes.WeeklySchedule.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "oneTime":
                return .onetime(try reader["oneTime"].read(with: Inspector2ClientTypes.OneTimeSchedule.read(from:)))
            case "daily":
                return .daily(try reader["daily"].read(with: Inspector2ClientTypes.DailySchedule.read(from:)))
            case "weekly":
                return .weekly(try reader["weekly"].read(with: Inspector2ClientTypes.WeeklySchedule.read(from:)))
            case "monthly":
                return .monthly(try reader["monthly"].read(with: Inspector2ClientTypes.MonthlySchedule.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension Inspector2ClientTypes.MonthlySchedule {

    static func write(value: Inspector2ClientTypes.MonthlySchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["day"].write(value.day)
        try writer["startTime"].write(value.startTime, with: Inspector2ClientTypes.Time.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.MonthlySchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.MonthlySchedule()
        value.startTime = try reader["startTime"].readIfPresent(with: Inspector2ClientTypes.Time.read(from:))
        value.day = try reader["day"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Inspector2ClientTypes.Time {

    static func write(value: Inspector2ClientTypes.Time?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timeOfDay"].write(value.timeOfDay)
        try writer["timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Time {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Time()
        value.timeOfDay = try reader["timeOfDay"].readIfPresent() ?? ""
        value.timezone = try reader["timezone"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.WeeklySchedule {

    static func write(value: Inspector2ClientTypes.WeeklySchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["days"].writeList(value.days, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Inspector2ClientTypes.Day>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].write(value.startTime, with: Inspector2ClientTypes.Time.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.WeeklySchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.WeeklySchedule()
        value.startTime = try reader["startTime"].readIfPresent(with: Inspector2ClientTypes.Time.read(from:))
        value.days = try reader["days"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<Inspector2ClientTypes.Day>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension Inspector2ClientTypes.DailySchedule {

    static func write(value: Inspector2ClientTypes.DailySchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["startTime"].write(value.startTime, with: Inspector2ClientTypes.Time.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.DailySchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.DailySchedule()
        value.startTime = try reader["startTime"].readIfPresent(with: Inspector2ClientTypes.Time.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.OneTimeSchedule {

    static func write(value: Inspector2ClientTypes.OneTimeSchedule?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.OneTimeSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return Inspector2ClientTypes.OneTimeSchedule()
    }
}

extension Inspector2ClientTypes.CisCheckAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisCheckAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisCheckAggregation()
        value.scanArn = try reader["scanArn"].readIfPresent() ?? ""
        value.checkId = try reader["checkId"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.checkDescription = try reader["checkDescription"].readIfPresent()
        value.level = try reader["level"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.statusCounts = try reader["statusCounts"].readIfPresent(with: Inspector2ClientTypes.StatusCounts.read(from:))
        value.platform = try reader["platform"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.StatusCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.StatusCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.StatusCounts()
        value.failed = try reader["failed"].readIfPresent()
        value.skipped = try reader["skipped"].readIfPresent()
        value.passed = try reader["passed"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CisTargetResourceAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisTargetResourceAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisTargetResourceAggregation()
        value.scanArn = try reader["scanArn"].readIfPresent() ?? ""
        value.targetResourceId = try reader["targetResourceId"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.targetResourceTags = try reader["targetResourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusCounts = try reader["statusCounts"].readIfPresent(with: Inspector2ClientTypes.StatusCounts.read(from:))
        value.platform = try reader["platform"].readIfPresent()
        value.targetStatus = try reader["targetStatus"].readIfPresent()
        value.targetStatusReason = try reader["targetStatusReason"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CisScan {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CisScan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CisScan()
        value.scanArn = try reader["scanArn"].readIfPresent() ?? ""
        value.scanConfigurationArn = try reader["scanConfigurationArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.scanName = try reader["scanName"].readIfPresent()
        value.scanDate = try reader["scanDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failedChecks = try reader["failedChecks"].readIfPresent()
        value.totalChecks = try reader["totalChecks"].readIfPresent()
        value.targets = try reader["targets"].readIfPresent(with: Inspector2ClientTypes.CisTargets.read(from:))
        value.scheduledBy = try reader["scheduledBy"].readIfPresent()
        value.securityLevel = try reader["securityLevel"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.CoveredResource {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CoveredResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CoveredResource()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.scanType = try reader["scanType"].readIfPresent() ?? .sdkUnknown("")
        value.scanStatus = try reader["scanStatus"].readIfPresent(with: Inspector2ClientTypes.ScanStatus.read(from:))
        value.resourceMetadata = try reader["resourceMetadata"].readIfPresent(with: Inspector2ClientTypes.ResourceScanMetadata.read(from:))
        value.lastScannedAt = try reader["lastScannedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scanMode = try reader["scanMode"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.ResourceScanMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceScanMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceScanMetadata()
        value.ecrRepository = try reader["ecrRepository"].readIfPresent(with: Inspector2ClientTypes.EcrRepositoryMetadata.read(from:))
        value.ecrImage = try reader["ecrImage"].readIfPresent(with: Inspector2ClientTypes.EcrContainerImageMetadata.read(from:))
        value.ec2 = try reader["ec2"].readIfPresent(with: Inspector2ClientTypes.Ec2Metadata.read(from:))
        value.lambdaFunction = try reader["lambdaFunction"].readIfPresent(with: Inspector2ClientTypes.LambdaFunctionMetadata.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.LambdaFunctionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.LambdaFunctionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.LambdaFunctionMetadata()
        value.functionTags = try reader["functionTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.layers = try reader["layers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionName = try reader["functionName"].readIfPresent()
        value.runtime = try reader["runtime"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Ec2Metadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Ec2Metadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Ec2Metadata()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.amiId = try reader["amiId"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.EcrContainerImageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.EcrContainerImageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.EcrContainerImageMetadata()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.imagePulledAt = try reader["imagePulledAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.EcrRepositoryMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.EcrRepositoryMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.EcrRepositoryMetadata()
        value.name = try reader["name"].readIfPresent()
        value.scanFrequency = try reader["scanFrequency"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.ScanStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ScanStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ScanStatus()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        value.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Inspector2ClientTypes.Counts {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Counts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Counts()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.groupKey = try reader["groupKey"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.DelegatedAdminAccount {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.DelegatedAdminAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.DelegatedAdminAccount()
        value.accountId = try reader["accountId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Filter {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Filter()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.ownerId = try reader["ownerId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.criteria = try reader["criteria"].readIfPresent(with: Inspector2ClientTypes.FilterCriteria.read(from:))
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.AggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accountAggregation":
                return .accountaggregation(try reader["accountAggregation"].read(with: Inspector2ClientTypes.AccountAggregationResponse.read(from:)))
            case "amiAggregation":
                return .amiaggregation(try reader["amiAggregation"].read(with: Inspector2ClientTypes.AmiAggregationResponse.read(from:)))
            case "awsEcrContainerAggregation":
                return .awsecrcontaineraggregation(try reader["awsEcrContainerAggregation"].read(with: Inspector2ClientTypes.AwsEcrContainerAggregationResponse.read(from:)))
            case "ec2InstanceAggregation":
                return .ec2instanceaggregation(try reader["ec2InstanceAggregation"].read(with: Inspector2ClientTypes.Ec2InstanceAggregationResponse.read(from:)))
            case "findingTypeAggregation":
                return .findingtypeaggregation(try reader["findingTypeAggregation"].read(with: Inspector2ClientTypes.FindingTypeAggregationResponse.read(from:)))
            case "imageLayerAggregation":
                return .imagelayeraggregation(try reader["imageLayerAggregation"].read(with: Inspector2ClientTypes.ImageLayerAggregationResponse.read(from:)))
            case "packageAggregation":
                return .packageaggregation(try reader["packageAggregation"].read(with: Inspector2ClientTypes.PackageAggregationResponse.read(from:)))
            case "repositoryAggregation":
                return .repositoryaggregation(try reader["repositoryAggregation"].read(with: Inspector2ClientTypes.RepositoryAggregationResponse.read(from:)))
            case "titleAggregation":
                return .titleaggregation(try reader["titleAggregation"].read(with: Inspector2ClientTypes.TitleAggregationResponse.read(from:)))
            case "lambdaLayerAggregation":
                return .lambdalayeraggregation(try reader["lambdaLayerAggregation"].read(with: Inspector2ClientTypes.LambdaLayerAggregationResponse.read(from:)))
            case "lambdaFunctionAggregation":
                return .lambdafunctionaggregation(try reader["lambdaFunctionAggregation"].read(with: Inspector2ClientTypes.LambdaFunctionAggregationResponse.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension Inspector2ClientTypes.LambdaFunctionAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.LambdaFunctionAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.LambdaFunctionAggregationResponse()
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.functionName = try reader["functionName"].readIfPresent()
        value.runtime = try reader["runtime"].readIfPresent()
        value.lambdaTags = try reader["lambdaTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.lastModifiedAt = try reader["lastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.SeverityCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.SeverityCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.SeverityCounts()
        value.all = try reader["all"].readIfPresent()
        value.medium = try reader["medium"].readIfPresent()
        value.high = try reader["high"].readIfPresent()
        value.critical = try reader["critical"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.LambdaLayerAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.LambdaLayerAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.LambdaLayerAggregationResponse()
        value.functionName = try reader["functionName"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.layerArn = try reader["layerArn"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.TitleAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.TitleAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.TitleAggregationResponse()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.vulnerabilityId = try reader["vulnerabilityId"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.RepositoryAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.RepositoryAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.RepositoryAggregationResponse()
        value.repository = try reader["repository"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.affectedImages = try reader["affectedImages"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.PackageAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.PackageAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.PackageAggregationResponse()
        value.packageName = try reader["packageName"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.ImageLayerAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ImageLayerAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ImageLayerAggregationResponse()
        value.repository = try reader["repository"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.layerHash = try reader["layerHash"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.FindingTypeAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.FindingTypeAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.FindingTypeAggregationResponse()
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.exploitAvailableCount = try reader["exploitAvailableCount"].readIfPresent()
        value.fixAvailableCount = try reader["fixAvailableCount"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Ec2InstanceAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Ec2InstanceAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Ec2InstanceAggregationResponse()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.ami = try reader["ami"].readIfPresent()
        value.operatingSystem = try reader["operatingSystem"].readIfPresent()
        value.instanceTags = try reader["instanceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.networkFindings = try reader["networkFindings"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AwsEcrContainerAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AwsEcrContainerAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AwsEcrContainerAggregationResponse()
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.imageSha = try reader["imageSha"].readIfPresent()
        value.repository = try reader["repository"].readIfPresent()
        value.architecture = try reader["architecture"].readIfPresent()
        value.imageTags = try reader["imageTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.AmiAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AmiAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AmiAggregationResponse()
        value.ami = try reader["ami"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.affectedInstances = try reader["affectedInstances"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AccountAggregationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AccountAggregationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AccountAggregationResponse()
        value.accountId = try reader["accountId"].readIfPresent()
        value.severityCounts = try reader["severityCounts"].readIfPresent(with: Inspector2ClientTypes.SeverityCounts.read(from:))
        value.exploitAvailableCount = try reader["exploitAvailableCount"].readIfPresent()
        value.fixAvailableCount = try reader["fixAvailableCount"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Finding {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Finding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Finding()
        value.findingArn = try reader["findingArn"].readIfPresent() ?? ""
        value.awsAccountId = try reader["awsAccountId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent(with: Inspector2ClientTypes.Remediation.read(from:))
        value.severity = try reader["severity"].readIfPresent() ?? .sdkUnknown("")
        value.firstObservedAt = try reader["firstObservedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastObservedAt = try reader["lastObservedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.inspectorScore = try reader["inspectorScore"].readIfPresent()
        value.inspectorScoreDetails = try reader["inspectorScoreDetails"].readIfPresent(with: Inspector2ClientTypes.InspectorScoreDetails.read(from:))
        value.networkReachabilityDetails = try reader["networkReachabilityDetails"].readIfPresent(with: Inspector2ClientTypes.NetworkReachabilityDetails.read(from:))
        value.packageVulnerabilityDetails = try reader["packageVulnerabilityDetails"].readIfPresent(with: Inspector2ClientTypes.PackageVulnerabilityDetails.read(from:))
        value.fixAvailable = try reader["fixAvailable"].readIfPresent()
        value.exploitAvailable = try reader["exploitAvailable"].readIfPresent()
        value.exploitabilityDetails = try reader["exploitabilityDetails"].readIfPresent(with: Inspector2ClientTypes.ExploitabilityDetails.read(from:))
        value.codeVulnerabilityDetails = try reader["codeVulnerabilityDetails"].readIfPresent(with: Inspector2ClientTypes.CodeVulnerabilityDetails.read(from:))
        value.epss = try reader["epss"].readIfPresent(with: Inspector2ClientTypes.EpssDetails.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.EpssDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.EpssDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.EpssDetails()
        value.score = try reader["score"].readIfPresent() ?? 0
        return value
    }
}

extension Inspector2ClientTypes.CodeVulnerabilityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CodeVulnerabilityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CodeVulnerabilityDetails()
        value.filePath = try reader["filePath"].readIfPresent(with: Inspector2ClientTypes.CodeFilePath.read(from:))
        value.detectorTags = try reader["detectorTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.sourceLambdaLayerArn = try reader["sourceLambdaLayerArn"].readIfPresent()
        value.detectorId = try reader["detectorId"].readIfPresent() ?? ""
        value.detectorName = try reader["detectorName"].readIfPresent() ?? ""
        value.cwes = try reader["cwes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension Inspector2ClientTypes.CodeFilePath {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CodeFilePath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CodeFilePath()
        value.fileName = try reader["fileName"].readIfPresent() ?? ""
        value.filePath = try reader["filePath"].readIfPresent() ?? ""
        value.startLine = try reader["startLine"].readIfPresent()
        value.endLine = try reader["endLine"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.ExploitabilityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ExploitabilityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ExploitabilityDetails()
        value.lastKnownExploitAt = try reader["lastKnownExploitAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.PackageVulnerabilityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.PackageVulnerabilityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.PackageVulnerabilityDetails()
        value.vulnerabilityId = try reader["vulnerabilityId"].readIfPresent() ?? ""
        value.vulnerablePackages = try reader["vulnerablePackages"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.VulnerablePackage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent() ?? ""
        value.cvss = try reader["cvss"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CvssScore.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedVulnerabilities = try reader["relatedVulnerabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceUrl = try reader["sourceUrl"].readIfPresent()
        value.vendorSeverity = try reader["vendorSeverity"].readIfPresent()
        value.vendorCreatedAt = try reader["vendorCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vendorUpdatedAt = try reader["vendorUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.CvssScore {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CvssScore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CvssScore()
        value.baseScore = try reader["baseScore"].readIfPresent() ?? 0.0
        value.scoringVector = try reader["scoringVector"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.VulnerablePackage {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.VulnerablePackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.VulnerablePackage()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.sourceLayerHash = try reader["sourceLayerHash"].readIfPresent()
        value.epoch = try reader["epoch"].readIfPresent() ?? 0
        value.release = try reader["release"].readIfPresent()
        value.arch = try reader["arch"].readIfPresent()
        value.packageManager = try reader["packageManager"].readIfPresent()
        value.filePath = try reader["filePath"].readIfPresent()
        value.fixedInVersion = try reader["fixedInVersion"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent()
        value.sourceLambdaLayerArn = try reader["sourceLambdaLayerArn"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.NetworkReachabilityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.NetworkReachabilityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.NetworkReachabilityDetails()
        value.openPortRange = try reader["openPortRange"].readIfPresent(with: Inspector2ClientTypes.PortRange.read(from:))
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.networkPath = try reader["networkPath"].readIfPresent(with: Inspector2ClientTypes.NetworkPath.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.NetworkPath {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.NetworkPath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.NetworkPath()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.Step {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Step()
        value.componentId = try reader["componentId"].readIfPresent() ?? ""
        value.componentType = try reader["componentType"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.PortRange {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.PortRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.PortRange()
        value.begin = try reader["begin"].readIfPresent() ?? 0
        value.end = try reader["end"].readIfPresent() ?? 0
        return value
    }
}

extension Inspector2ClientTypes.InspectorScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.InspectorScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.InspectorScoreDetails()
        value.adjustedCvss = try reader["adjustedCvss"].readIfPresent(with: Inspector2ClientTypes.CvssScoreDetails.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.CvssScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CvssScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CvssScoreDetails()
        value.scoreSource = try reader["scoreSource"].readIfPresent() ?? ""
        value.cvssSource = try reader["cvssSource"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.score = try reader["score"].readIfPresent() ?? 0.0
        value.scoringVector = try reader["scoringVector"].readIfPresent() ?? ""
        value.adjustments = try reader["adjustments"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.CvssScoreAdjustment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.CvssScoreAdjustment {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.CvssScoreAdjustment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.CvssScoreAdjustment()
        value.metric = try reader["metric"].readIfPresent() ?? ""
        value.reason = try reader["reason"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Resource()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.partition = try reader["partition"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.details = try reader["details"].readIfPresent(with: Inspector2ClientTypes.ResourceDetails.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.ResourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ResourceDetails()
        value.awsEc2Instance = try reader["awsEc2Instance"].readIfPresent(with: Inspector2ClientTypes.AwsEc2InstanceDetails.read(from:))
        value.awsEcrContainerImage = try reader["awsEcrContainerImage"].readIfPresent(with: Inspector2ClientTypes.AwsEcrContainerImageDetails.read(from:))
        value.awsLambdaFunction = try reader["awsLambdaFunction"].readIfPresent(with: Inspector2ClientTypes.AwsLambdaFunctionDetails.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.AwsLambdaFunctionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AwsLambdaFunctionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AwsLambdaFunctionDetails()
        value.functionName = try reader["functionName"].readIfPresent() ?? ""
        value.runtime = try reader["runtime"].readIfPresent() ?? .sdkUnknown("")
        value.codeSha256 = try reader["codeSha256"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.layers = try reader["layers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: Inspector2ClientTypes.LambdaVpcConfig.read(from:))
        value.packageType = try reader["packageType"].readIfPresent()
        value.architectures = try reader["architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<Inspector2ClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedAt = try reader["lastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Inspector2ClientTypes.LambdaVpcConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.LambdaVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.LambdaVpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AwsEcrContainerImageDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AwsEcrContainerImageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AwsEcrContainerImageDetails()
        value.repositoryName = try reader["repositoryName"].readIfPresent() ?? ""
        value.imageTags = try reader["imageTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pushedAt = try reader["pushedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.author = try reader["author"].readIfPresent()
        value.architecture = try reader["architecture"].readIfPresent()
        value.imageHash = try reader["imageHash"].readIfPresent() ?? ""
        value.registry = try reader["registry"].readIfPresent() ?? ""
        value.platform = try reader["platform"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AwsEc2InstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AwsEc2InstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AwsEc2InstanceDetails()
        value.type = try reader["type"].readIfPresent()
        value.imageId = try reader["imageId"].readIfPresent()
        value.ipV4Addresses = try reader["ipV4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipV6Addresses = try reader["ipV6Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.keyName = try reader["keyName"].readIfPresent()
        value.iamInstanceProfileArn = try reader["iamInstanceProfileArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.launchedAt = try reader["launchedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.platform = try reader["platform"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Remediation {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Remediation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Remediation()
        value.recommendation = try reader["recommendation"].readIfPresent(with: Inspector2ClientTypes.Recommendation.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Recommendation()
        value.text = try reader["text"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.UsageTotal {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.UsageTotal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.UsageTotal()
        value.accountId = try reader["accountId"].readIfPresent()
        value.usage = try reader["usage"].readListIfPresent(memberReadingClosure: Inspector2ClientTypes.Usage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.Usage {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Usage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Usage()
        value.type = try reader["type"].readIfPresent()
        value.total = try reader["total"].readIfPresent() ?? 0
        value.estimatedMonthlyCost = try reader["estimatedMonthlyCost"].readIfPresent() ?? 0
        value.currency = try reader["currency"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Vulnerability {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Vulnerability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Vulnerability()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.cwes = try reader["cwes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cisaData = try reader["cisaData"].readIfPresent(with: Inspector2ClientTypes.CisaData.read(from:))
        value.source = try reader["source"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.atigData = try reader["atigData"].readIfPresent(with: Inspector2ClientTypes.AtigData.read(from:))
        value.vendorSeverity = try reader["vendorSeverity"].readIfPresent()
        value.cvss3 = try reader["cvss3"].readIfPresent(with: Inspector2ClientTypes.Cvss3.read(from:))
        value.relatedVulnerabilities = try reader["relatedVulnerabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cvss2 = try reader["cvss2"].readIfPresent(with: Inspector2ClientTypes.Cvss2.read(from:))
        value.vendorCreatedAt = try reader["vendorCreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vendorUpdatedAt = try reader["vendorUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceUrl = try reader["sourceUrl"].readIfPresent()
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exploitObserved = try reader["exploitObserved"].readIfPresent(with: Inspector2ClientTypes.ExploitObserved.read(from:))
        value.detectionPlatforms = try reader["detectionPlatforms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.epss = try reader["epss"].readIfPresent(with: Inspector2ClientTypes.Epss.read(from:))
        return value
    }
}

extension Inspector2ClientTypes.Epss {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Epss {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Epss()
        value.score = try reader["score"].readIfPresent() ?? 0
        return value
    }
}

extension Inspector2ClientTypes.Cvss2 {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Cvss2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Cvss2()
        value.baseScore = try reader["baseScore"].readIfPresent() ?? 0
        value.scoringVector = try reader["scoringVector"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.Cvss3 {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.Cvss3 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.Cvss3()
        value.baseScore = try reader["baseScore"].readIfPresent() ?? 0
        value.scoringVector = try reader["scoringVector"].readIfPresent()
        return value
    }
}

extension Inspector2ClientTypes.AtigData {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.AtigData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.AtigData()
        value.firstSeen = try reader["firstSeen"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSeen = try reader["lastSeen"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ttps = try reader["ttps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Inspector2ClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> Inspector2ClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Inspector2ClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus {

    static func write(value: Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["activateDeepInspection"].write(value.activateDeepInspection)
    }
}

extension Inspector2ClientTypes.CreateCisTargets {

    static func write(value: Inspector2ClientTypes.CreateCisTargets?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceTags"].writeMap(value.targetResourceTags, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisScanResultDetailsFilterCriteria {

    static func write(value: Inspector2ClientTypes.CisScanResultDetailsFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkIdFilters"].writeList(value.checkIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingArnFilters"].writeList(value.findingArnFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["findingStatusFilters"].writeList(value.findingStatusFilters, memberWritingClosure: Inspector2ClientTypes.CisFindingStatusFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["securityLevelFilters"].writeList(value.securityLevelFilters, memberWritingClosure: Inspector2ClientTypes.CisSecurityLevelFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["titleFilters"].writeList(value.titleFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisStringFilter {

    static func write(value: Inspector2ClientTypes.CisStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CisSecurityLevelFilter {

    static func write(value: Inspector2ClientTypes.CisSecurityLevelFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CisFindingStatusFilter {

    static func write(value: Inspector2ClientTypes.CisFindingStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.ListCisScanConfigurationsFilterCriteria {

    static func write(value: Inspector2ClientTypes.ListCisScanConfigurationsFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanConfigurationArnFilters"].writeList(value.scanConfigurationArnFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanNameFilters"].writeList(value.scanNameFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceTagFilters"].writeList(value.targetResourceTagFilters, memberWritingClosure: Inspector2ClientTypes.TagFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.TagFilter {

    static func write(value: Inspector2ClientTypes.TagFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CisScanResultsAggregatedByChecksFilterCriteria {

    static func write(value: Inspector2ClientTypes.CisScanResultsAggregatedByChecksFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIdFilters"].writeList(value.accountIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["checkIdFilters"].writeList(value.checkIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["failedResourcesFilters"].writeList(value.failedResourcesFilters, memberWritingClosure: Inspector2ClientTypes.CisNumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["platformFilters"].writeList(value.platformFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["securityLevelFilters"].writeList(value.securityLevelFilters, memberWritingClosure: Inspector2ClientTypes.CisSecurityLevelFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["titleFilters"].writeList(value.titleFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisNumberFilter {

    static func write(value: Inspector2ClientTypes.CisNumberFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lowerInclusive"].write(value.lowerInclusive)
        try writer["upperInclusive"].write(value.upperInclusive)
    }
}

extension Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceFilterCriteria {

    static func write(value: Inspector2ClientTypes.CisScanResultsAggregatedByTargetResourceFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIdFilters"].writeList(value.accountIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["checkIdFilters"].writeList(value.checkIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["failedChecksFilters"].writeList(value.failedChecksFilters, memberWritingClosure: Inspector2ClientTypes.CisNumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["platformFilters"].writeList(value.platformFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["statusFilters"].writeList(value.statusFilters, memberWritingClosure: Inspector2ClientTypes.CisResultStatusFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceIdFilters"].writeList(value.targetResourceIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceTagFilters"].writeList(value.targetResourceTagFilters, memberWritingClosure: Inspector2ClientTypes.TagFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetStatusFilters"].writeList(value.targetStatusFilters, memberWritingClosure: Inspector2ClientTypes.CisTargetStatusFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetStatusReasonFilters"].writeList(value.targetStatusReasonFilters, memberWritingClosure: Inspector2ClientTypes.CisTargetStatusReasonFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisTargetStatusReasonFilter {

    static func write(value: Inspector2ClientTypes.CisTargetStatusReasonFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CisTargetStatusFilter {

    static func write(value: Inspector2ClientTypes.CisTargetStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CisResultStatusFilter {

    static func write(value: Inspector2ClientTypes.CisResultStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.ListCisScansFilterCriteria {

    static func write(value: Inspector2ClientTypes.ListCisScansFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failedChecksFilters"].writeList(value.failedChecksFilters, memberWritingClosure: Inspector2ClientTypes.CisNumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanArnFilters"].writeList(value.scanArnFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanAtFilters"].writeList(value.scanAtFilters, memberWritingClosure: Inspector2ClientTypes.CisDateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanConfigurationArnFilters"].writeList(value.scanConfigurationArnFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanNameFilters"].writeList(value.scanNameFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanStatusFilters"].writeList(value.scanStatusFilters, memberWritingClosure: Inspector2ClientTypes.CisScanStatusFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scheduledByFilters"].writeList(value.scheduledByFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetAccountIdFilters"].writeList(value.targetAccountIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceIdFilters"].writeList(value.targetResourceIdFilters, memberWritingClosure: Inspector2ClientTypes.CisStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceTagFilters"].writeList(value.targetResourceTagFilters, memberWritingClosure: Inspector2ClientTypes.TagFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisDateFilter {

    static func write(value: Inspector2ClientTypes.CisDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["earliestScanStartTime"].writeTimestamp(value.earliestScanStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["latestScanStartTime"].writeTimestamp(value.latestScanStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension Inspector2ClientTypes.CisScanStatusFilter {

    static func write(value: Inspector2ClientTypes.CisScanStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CoverageFilterCriteria {

    static func write(value: Inspector2ClientTypes.CoverageFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].writeList(value.accountId, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ec2InstanceTags"].writeList(value.ec2InstanceTags, memberWritingClosure: Inspector2ClientTypes.CoverageMapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrImageTags"].writeList(value.ecrImageTags, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ecrRepositoryName"].writeList(value.ecrRepositoryName, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["imagePulledAt"].writeList(value.imagePulledAt, memberWritingClosure: Inspector2ClientTypes.CoverageDateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionName"].writeList(value.lambdaFunctionName, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionRuntime"].writeList(value.lambdaFunctionRuntime, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionTags"].writeList(value.lambdaFunctionTags, memberWritingClosure: Inspector2ClientTypes.CoverageMapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastScannedAt"].writeList(value.lastScannedAt, memberWritingClosure: Inspector2ClientTypes.CoverageDateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceId"].writeList(value.resourceId, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceType"].writeList(value.resourceType, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanMode"].writeList(value.scanMode, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanStatusCode"].writeList(value.scanStatusCode, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanStatusReason"].writeList(value.scanStatusReason, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scanType"].writeList(value.scanType, memberWritingClosure: Inspector2ClientTypes.CoverageStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CoverageDateFilter {

    static func write(value: Inspector2ClientTypes.CoverageDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endInclusive"].writeTimestamp(value.endInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startInclusive"].writeTimestamp(value.startInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension Inspector2ClientTypes.CoverageStringFilter {

    static func write(value: Inspector2ClientTypes.CoverageStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.CoverageMapFilter {

    static func write(value: Inspector2ClientTypes.CoverageMapFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension Inspector2ClientTypes.AggregationRequest {

    static func write(value: Inspector2ClientTypes.AggregationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accountaggregation(accountaggregation):
                try writer["accountAggregation"].write(accountaggregation, with: Inspector2ClientTypes.AccountAggregation.write(value:to:))
            case let .amiaggregation(amiaggregation):
                try writer["amiAggregation"].write(amiaggregation, with: Inspector2ClientTypes.AmiAggregation.write(value:to:))
            case let .awsecrcontaineraggregation(awsecrcontaineraggregation):
                try writer["awsEcrContainerAggregation"].write(awsecrcontaineraggregation, with: Inspector2ClientTypes.AwsEcrContainerAggregation.write(value:to:))
            case let .ec2instanceaggregation(ec2instanceaggregation):
                try writer["ec2InstanceAggregation"].write(ec2instanceaggregation, with: Inspector2ClientTypes.Ec2InstanceAggregation.write(value:to:))
            case let .findingtypeaggregation(findingtypeaggregation):
                try writer["findingTypeAggregation"].write(findingtypeaggregation, with: Inspector2ClientTypes.FindingTypeAggregation.write(value:to:))
            case let .imagelayeraggregation(imagelayeraggregation):
                try writer["imageLayerAggregation"].write(imagelayeraggregation, with: Inspector2ClientTypes.ImageLayerAggregation.write(value:to:))
            case let .lambdafunctionaggregation(lambdafunctionaggregation):
                try writer["lambdaFunctionAggregation"].write(lambdafunctionaggregation, with: Inspector2ClientTypes.LambdaFunctionAggregation.write(value:to:))
            case let .lambdalayeraggregation(lambdalayeraggregation):
                try writer["lambdaLayerAggregation"].write(lambdalayeraggregation, with: Inspector2ClientTypes.LambdaLayerAggregation.write(value:to:))
            case let .packageaggregation(packageaggregation):
                try writer["packageAggregation"].write(packageaggregation, with: Inspector2ClientTypes.PackageAggregation.write(value:to:))
            case let .repositoryaggregation(repositoryaggregation):
                try writer["repositoryAggregation"].write(repositoryaggregation, with: Inspector2ClientTypes.RepositoryAggregation.write(value:to:))
            case let .titleaggregation(titleaggregation):
                try writer["titleAggregation"].write(titleaggregation, with: Inspector2ClientTypes.TitleAggregation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension Inspector2ClientTypes.LambdaFunctionAggregation {

    static func write(value: Inspector2ClientTypes.LambdaFunctionAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["functionNames"].writeList(value.functionNames, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["functionTags"].writeList(value.functionTags, memberWritingClosure: Inspector2ClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceIds"].writeList(value.resourceIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["runtimes"].writeList(value.runtimes, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.LambdaLayerAggregation {

    static func write(value: Inspector2ClientTypes.LambdaLayerAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["functionNames"].writeList(value.functionNames, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["layerArns"].writeList(value.layerArns, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceIds"].writeList(value.resourceIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.TitleAggregation {

    static func write(value: Inspector2ClientTypes.TitleAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingType"].write(value.findingType)
        try writer["resourceType"].write(value.resourceType)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
        try writer["titles"].writeList(value.titles, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vulnerabilityIds"].writeList(value.vulnerabilityIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.RepositoryAggregation {

    static func write(value: Inspector2ClientTypes.RepositoryAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositories"].writeList(value.repositories, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.PackageAggregation {

    static func write(value: Inspector2ClientTypes.PackageAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["packageNames"].writeList(value.packageNames, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.ImageLayerAggregation {

    static func write(value: Inspector2ClientTypes.ImageLayerAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["layerHashes"].writeList(value.layerHashes, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["repositories"].writeList(value.repositories, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceIds"].writeList(value.resourceIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.FindingTypeAggregation {

    static func write(value: Inspector2ClientTypes.FindingTypeAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingType"].write(value.findingType)
        try writer["resourceType"].write(value.resourceType)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.Ec2InstanceAggregation {

    static func write(value: Inspector2ClientTypes.Ec2InstanceAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].writeList(value.amis, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["instanceIds"].writeList(value.instanceIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["instanceTags"].writeList(value.instanceTags, memberWritingClosure: Inspector2ClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["operatingSystems"].writeList(value.operatingSystems, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.AwsEcrContainerAggregation {

    static func write(value: Inspector2ClientTypes.AwsEcrContainerAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["architectures"].writeList(value.architectures, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["imageShas"].writeList(value.imageShas, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["imageTags"].writeList(value.imageTags, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["repositories"].writeList(value.repositories, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceIds"].writeList(value.resourceIds, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.AmiAggregation {

    static func write(value: Inspector2ClientTypes.AmiAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amis"].writeList(value.amis, memberWritingClosure: Inspector2ClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.AccountAggregation {

    static func write(value: Inspector2ClientTypes.AccountAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingType"].write(value.findingType)
        try writer["resourceType"].write(value.resourceType)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.SortCriteria {

    static func write(value: Inspector2ClientTypes.SortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["field"].write(value.field)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria {

    static func write(value: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vulnerabilityIds"].writeList(value.vulnerabilityIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Inspector2ClientTypes.CisSessionMessage {

    static func write(value: Inspector2ClientTypes.CisSessionMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cisRuleDetails"].write(value.cisRuleDetails)
        try writer["ruleId"].write(value.ruleId)
        try writer["status"].write(value.status)
    }
}

extension Inspector2ClientTypes.StartCisSessionMessage {

    static func write(value: Inspector2ClientTypes.StartCisSessionMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionToken"].write(value.sessionToken)
    }
}

extension Inspector2ClientTypes.StopCisSessionMessage {

    static func write(value: Inspector2ClientTypes.StopCisSessionMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["benchmarkProfile"].write(value.benchmarkProfile)
        try writer["benchmarkVersion"].write(value.benchmarkVersion)
        try writer["computePlatform"].write(value.computePlatform, with: Inspector2ClientTypes.ComputePlatform.write(value:to:))
        try writer["progress"].write(value.progress, with: Inspector2ClientTypes.StopCisMessageProgress.write(value:to:))
        try writer["reason"].write(value.reason)
        try writer["status"].write(value.status)
    }
}

extension Inspector2ClientTypes.ComputePlatform {

    static func write(value: Inspector2ClientTypes.ComputePlatform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["product"].write(value.product)
        try writer["vendor"].write(value.vendor)
        try writer["version"].write(value.version)
    }
}

extension Inspector2ClientTypes.StopCisMessageProgress {

    static func write(value: Inspector2ClientTypes.StopCisMessageProgress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorChecks"].write(value.errorChecks)
        try writer["failedChecks"].write(value.failedChecks)
        try writer["informationalChecks"].write(value.informationalChecks)
        try writer["notApplicableChecks"].write(value.notApplicableChecks)
        try writer["notEvaluatedChecks"].write(value.notEvaluatedChecks)
        try writer["successfulChecks"].write(value.successfulChecks)
        try writer["totalChecks"].write(value.totalChecks)
        try writer["unknownChecks"].write(value.unknownChecks)
    }
}

extension Inspector2ClientTypes.UpdateCisTargets {

    static func write(value: Inspector2ClientTypes.UpdateCisTargets?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetResourceTags"].writeMap(value.targetResourceTags, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension Inspector2ClientTypes.EcrConfiguration {

    static func write(value: Inspector2ClientTypes.EcrConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pullDateRescanDuration"].write(value.pullDateRescanDuration)
        try writer["rescanDuration"].write(value.rescanDuration)
    }
}

extension Inspector2ClientTypes.Ec2Configuration {

    static func write(value: Inspector2ClientTypes.Ec2Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanMode"].write(value.scanMode)
    }
}

public enum Inspector2ClientTypes {}
