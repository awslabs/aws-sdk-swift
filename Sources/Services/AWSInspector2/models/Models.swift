// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.Account: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case resourceStatus
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceStatus = self.resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
    }
}

extension Inspector2ClientTypes {
    /// An Amazon Web Services account within your environment that Amazon Inspector has been enabled for.
    public struct Account: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Details of the status of Amazon Inspector scans by resource type.
        /// This member is required.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init(
            accountId: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

extension Inspector2ClientTypes.AccountAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingType
        case resourceType
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingType = self.findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AccountSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about an aggregation response based on Amazon Web Services accounts.
    public struct AccountAggregation: Swift.Equatable {
        /// The type of finding.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The type of resource.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AccountSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.AccountSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AccountAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of findings by Amazon Web Services account ID.
    public struct AccountAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The number of findings by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum AccountSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountSortBy(rawValue: rawValue) ?? AccountSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AccountState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case resourceState
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceState = self.resourceState {
            try encodeContainer.encode(resourceState, forKey: .resourceState)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceState.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object with details the status of an Amazon Web Services account within your Amazon Inspector environment.
    public struct AccountState: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        /// This member is required.
        public var resourceState: Inspector2ClientTypes.ResourceState?
        /// An object detailing the status of Amazon Inspector for the account.
        /// This member is required.
        public var state: Inspector2ClientTypes.State?

        public init(
            accountId: Swift.String? = nil,
            resourceState: Inspector2ClientTypes.ResourceState? = nil,
            state: Inspector2ClientTypes.State? = nil
        )
        {
            self.accountId = accountId
            self.resourceState = resourceState
            self.state = state
        }
    }

}

extension Inspector2ClientTypes {
    public enum AggregationFindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeVulnerability
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFindingType] {
            return [
                .codeVulnerability,
                .networkReachability,
                .packageVulnerability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeVulnerability: return "CODE_VULNERABILITY"
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationFindingType(rawValue: rawValue) ?? AggregationFindingType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AggregationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountaggregation = "accountAggregation"
        case amiaggregation = "amiAggregation"
        case awsecrcontaineraggregation = "awsEcrContainerAggregation"
        case ec2instanceaggregation = "ec2InstanceAggregation"
        case findingtypeaggregation = "findingTypeAggregation"
        case imagelayeraggregation = "imageLayerAggregation"
        case lambdafunctionaggregation = "lambdaFunctionAggregation"
        case lambdalayeraggregation = "lambdaLayerAggregation"
        case packageaggregation = "packageAggregation"
        case repositoryaggregation = "repositoryAggregation"
        case sdkUnknown
        case titleaggregation = "titleAggregation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountaggregation(accountaggregation):
                try container.encode(accountaggregation, forKey: .accountaggregation)
            case let .amiaggregation(amiaggregation):
                try container.encode(amiaggregation, forKey: .amiaggregation)
            case let .awsecrcontaineraggregation(awsecrcontaineraggregation):
                try container.encode(awsecrcontaineraggregation, forKey: .awsecrcontaineraggregation)
            case let .ec2instanceaggregation(ec2instanceaggregation):
                try container.encode(ec2instanceaggregation, forKey: .ec2instanceaggregation)
            case let .findingtypeaggregation(findingtypeaggregation):
                try container.encode(findingtypeaggregation, forKey: .findingtypeaggregation)
            case let .imagelayeraggregation(imagelayeraggregation):
                try container.encode(imagelayeraggregation, forKey: .imagelayeraggregation)
            case let .lambdafunctionaggregation(lambdafunctionaggregation):
                try container.encode(lambdafunctionaggregation, forKey: .lambdafunctionaggregation)
            case let .lambdalayeraggregation(lambdalayeraggregation):
                try container.encode(lambdalayeraggregation, forKey: .lambdalayeraggregation)
            case let .packageaggregation(packageaggregation):
                try container.encode(packageaggregation, forKey: .packageaggregation)
            case let .repositoryaggregation(repositoryaggregation):
                try container.encode(repositoryaggregation, forKey: .repositoryaggregation)
            case let .titleaggregation(titleaggregation):
                try container.encode(titleaggregation, forKey: .titleaggregation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AccountAggregation.self, forKey: .accountaggregation)
        if let accountaggregation = accountaggregationDecoded {
            self = .accountaggregation(accountaggregation)
            return
        }
        let amiaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AmiAggregation.self, forKey: .amiaggregation)
        if let amiaggregation = amiaggregationDecoded {
            self = .amiaggregation(amiaggregation)
            return
        }
        let awsecrcontaineraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerAggregation.self, forKey: .awsecrcontaineraggregation)
        if let awsecrcontaineraggregation = awsecrcontaineraggregationDecoded {
            self = .awsecrcontaineraggregation(awsecrcontaineraggregation)
            return
        }
        let ec2instanceaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceAggregation.self, forKey: .ec2instanceaggregation)
        if let ec2instanceaggregation = ec2instanceaggregationDecoded {
            self = .ec2instanceaggregation(ec2instanceaggregation)
            return
        }
        let findingtypeaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.FindingTypeAggregation.self, forKey: .findingtypeaggregation)
        if let findingtypeaggregation = findingtypeaggregationDecoded {
            self = .findingtypeaggregation(findingtypeaggregation)
            return
        }
        let imagelayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.ImageLayerAggregation.self, forKey: .imagelayeraggregation)
        if let imagelayeraggregation = imagelayeraggregationDecoded {
            self = .imagelayeraggregation(imagelayeraggregation)
            return
        }
        let packageaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.PackageAggregation.self, forKey: .packageaggregation)
        if let packageaggregation = packageaggregationDecoded {
            self = .packageaggregation(packageaggregation)
            return
        }
        let repositoryaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.RepositoryAggregation.self, forKey: .repositoryaggregation)
        if let repositoryaggregation = repositoryaggregationDecoded {
            self = .repositoryaggregation(repositoryaggregation)
            return
        }
        let titleaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.TitleAggregation.self, forKey: .titleaggregation)
        if let titleaggregation = titleaggregationDecoded {
            self = .titleaggregation(titleaggregation)
            return
        }
        let lambdalayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.LambdaLayerAggregation.self, forKey: .lambdalayeraggregation)
        if let lambdalayeraggregation = lambdalayeraggregationDecoded {
            self = .lambdalayeraggregation(lambdalayeraggregation)
            return
        }
        let lambdafunctionaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.LambdaFunctionAggregation.self, forKey: .lambdafunctionaggregation)
        if let lambdafunctionaggregation = lambdafunctionaggregationDecoded {
            self = .lambdafunctionaggregation(lambdafunctionaggregation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension Inspector2ClientTypes {
    /// Contains details about an aggregation request.
    public enum AggregationRequest: Swift.Equatable {
        /// An object that contains details about an aggregation request based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregation)
        /// An object that contains details about an aggregation request based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregation)
        /// An object that contains details about an aggregation request based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregation)
        /// An object that contains details about an aggregation request based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregation)
        /// An object that contains details about an aggregation request based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregation)
        /// An object that contains details about an aggregation request based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregation)
        /// An object that contains details about an aggregation request based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregation)
        /// Returns an object with findings aggregated by AWS Lambda layer.
        case lambdalayeraggregation(Inspector2ClientTypes.LambdaLayerAggregation)
        /// Returns an object with findings aggregated by AWS Lambda function.
        case lambdafunctionaggregation(Inspector2ClientTypes.LambdaFunctionAggregation)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    public enum AggregationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsLambdaFunction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationResourceType(rawValue: rawValue) ?? AggregationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountaggregation = "accountAggregation"
        case amiaggregation = "amiAggregation"
        case awsecrcontaineraggregation = "awsEcrContainerAggregation"
        case ec2instanceaggregation = "ec2InstanceAggregation"
        case findingtypeaggregation = "findingTypeAggregation"
        case imagelayeraggregation = "imageLayerAggregation"
        case lambdafunctionaggregation = "lambdaFunctionAggregation"
        case lambdalayeraggregation = "lambdaLayerAggregation"
        case packageaggregation = "packageAggregation"
        case repositoryaggregation = "repositoryAggregation"
        case sdkUnknown
        case titleaggregation = "titleAggregation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountaggregation(accountaggregation):
                try container.encode(accountaggregation, forKey: .accountaggregation)
            case let .amiaggregation(amiaggregation):
                try container.encode(amiaggregation, forKey: .amiaggregation)
            case let .awsecrcontaineraggregation(awsecrcontaineraggregation):
                try container.encode(awsecrcontaineraggregation, forKey: .awsecrcontaineraggregation)
            case let .ec2instanceaggregation(ec2instanceaggregation):
                try container.encode(ec2instanceaggregation, forKey: .ec2instanceaggregation)
            case let .findingtypeaggregation(findingtypeaggregation):
                try container.encode(findingtypeaggregation, forKey: .findingtypeaggregation)
            case let .imagelayeraggregation(imagelayeraggregation):
                try container.encode(imagelayeraggregation, forKey: .imagelayeraggregation)
            case let .lambdafunctionaggregation(lambdafunctionaggregation):
                try container.encode(lambdafunctionaggregation, forKey: .lambdafunctionaggregation)
            case let .lambdalayeraggregation(lambdalayeraggregation):
                try container.encode(lambdalayeraggregation, forKey: .lambdalayeraggregation)
            case let .packageaggregation(packageaggregation):
                try container.encode(packageaggregation, forKey: .packageaggregation)
            case let .repositoryaggregation(repositoryaggregation):
                try container.encode(repositoryaggregation, forKey: .repositoryaggregation)
            case let .titleaggregation(titleaggregation):
                try container.encode(titleaggregation, forKey: .titleaggregation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AccountAggregationResponse.self, forKey: .accountaggregation)
        if let accountaggregation = accountaggregationDecoded {
            self = .accountaggregation(accountaggregation)
            return
        }
        let amiaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AmiAggregationResponse.self, forKey: .amiaggregation)
        if let amiaggregation = amiaggregationDecoded {
            self = .amiaggregation(amiaggregation)
            return
        }
        let awsecrcontaineraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerAggregationResponse.self, forKey: .awsecrcontaineraggregation)
        if let awsecrcontaineraggregation = awsecrcontaineraggregationDecoded {
            self = .awsecrcontaineraggregation(awsecrcontaineraggregation)
            return
        }
        let ec2instanceaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceAggregationResponse.self, forKey: .ec2instanceaggregation)
        if let ec2instanceaggregation = ec2instanceaggregationDecoded {
            self = .ec2instanceaggregation(ec2instanceaggregation)
            return
        }
        let findingtypeaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.FindingTypeAggregationResponse.self, forKey: .findingtypeaggregation)
        if let findingtypeaggregation = findingtypeaggregationDecoded {
            self = .findingtypeaggregation(findingtypeaggregation)
            return
        }
        let imagelayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.ImageLayerAggregationResponse.self, forKey: .imagelayeraggregation)
        if let imagelayeraggregation = imagelayeraggregationDecoded {
            self = .imagelayeraggregation(imagelayeraggregation)
            return
        }
        let packageaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.PackageAggregationResponse.self, forKey: .packageaggregation)
        if let packageaggregation = packageaggregationDecoded {
            self = .packageaggregation(packageaggregation)
            return
        }
        let repositoryaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.RepositoryAggregationResponse.self, forKey: .repositoryaggregation)
        if let repositoryaggregation = repositoryaggregationDecoded {
            self = .repositoryaggregation(repositoryaggregation)
            return
        }
        let titleaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.TitleAggregationResponse.self, forKey: .titleaggregation)
        if let titleaggregation = titleaggregationDecoded {
            self = .titleaggregation(titleaggregation)
            return
        }
        let lambdalayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.LambdaLayerAggregationResponse.self, forKey: .lambdalayeraggregation)
        if let lambdalayeraggregation = lambdalayeraggregationDecoded {
            self = .lambdalayeraggregation(lambdalayeraggregation)
            return
        }
        let lambdafunctionaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.LambdaFunctionAggregationResponse.self, forKey: .lambdafunctionaggregation)
        if let lambdafunctionaggregation = lambdafunctionaggregationDecoded {
            self = .lambdafunctionaggregation(lambdafunctionaggregation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension Inspector2ClientTypes {
    /// A structure that contains details about the results of an aggregation type.
    public enum AggregationResponse: Swift.Equatable {
        /// An object that contains details about an aggregation response based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregationResponse)
        /// An object that contains details about an aggregation response based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregationResponse)
        /// An object that contains details about an aggregation response based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregationResponse)
        /// An object that contains details about an aggregation response based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregationResponse)
        /// An object that contains details about an aggregation response based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregationResponse)
        /// An aggregation of findings by AWS Lambda layer.
        case lambdalayeraggregation(Inspector2ClientTypes.LambdaLayerAggregationResponse)
        /// An aggregation of findings by AWS Lambda function.
        case lambdafunctionaggregation(Inspector2ClientTypes.LambdaFunctionAggregationResponse)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case ami
        case awsEc2Instance
        case awsEcrContainer
        case awsLambdaFunction
        case findingType
        case imageLayer
        case lambdaLayer
        case package
        case repository
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .account,
                .ami,
                .awsEc2Instance,
                .awsEcrContainer,
                .awsLambdaFunction,
                .findingType,
                .imageLayer,
                .lambdaLayer,
                .package,
                .repository,
                .title,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .ami: return "AMI"
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainer: return "AWS_ECR_CONTAINER"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case .findingType: return "FINDING_TYPE"
            case .imageLayer: return "IMAGE_LAYER"
            case .lambdaLayer: return "LAMBDA_LAYER"
            case .package: return "PACKAGE"
            case .repository: return "REPOSITORY"
            case .title: return "TITLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AmiAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for stringfilter0 in amis {
                try amisContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .amis)
        var amisDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AmiSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon machine images (AMIs).
    public struct AmiAggregation: Swift.Equatable {
        /// The IDs of AMIs to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.AmiSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AmiSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AmiAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case affectedInstances
        case ami
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let affectedInstances = self.affectedInstances {
            try encodeContainer.encode(affectedInstances, forKey: .affectedInstances)
        }
        if let ami = self.ami {
            try encodeContainer.encode(ami, forKey: .ami)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ami)
        ami = amiDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let affectedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .affectedInstances)
        affectedInstances = affectedInstancesDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by AMI.
    public struct AmiAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID for the AMI.
        public var accountId: Swift.String?
        /// The IDs of Amazon EC2 instances using this AMI.
        public var affectedInstances: Swift.Int?
        /// The ID of the AMI that findings were aggregated for.
        /// This member is required.
        public var ami: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            affectedInstances: Swift.Int? = nil,
            ami: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedInstances = affectedInstances
            self.ami = ami
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum AmiSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case affectedInstances
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiSortBy] {
            return [
                .affectedInstances,
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .affectedInstances: return "AFFECTED_INSTANCES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmiSortBy(rawValue: rawValue) ?? AmiSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension AssociateMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension AssociateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/associate"
    }
}

public struct AssociateMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to be associated.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct AssociateMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension AssociateMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension AssociateMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
        } else {
            self.accountId = nil
        }
    }
}

public struct AssociateMemberOutput: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully associated member account.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct AssociateMemberOutputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension AssociateMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

enum AssociateMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.AtigData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstSeen
        case lastSeen
        case targets
        case ttps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstSeen = self.firstSeen {
            try encodeContainer.encodeTimestamp(firstSeen, format: .epochSeconds, forKey: .firstSeen)
        }
        if let lastSeen = self.lastSeen {
            try encodeContainer.encodeTimestamp(lastSeen, format: .epochSeconds, forKey: .lastSeen)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
        if let ttps = ttps {
            var ttpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ttps)
            for ttp0 in ttps {
                try ttpsContainer.encode(ttp0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstSeenDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
        let lastSeenDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let ttpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ttps)
        var ttpsDecoded0:[Swift.String]? = nil
        if let ttpsContainer = ttpsContainer {
            ttpsDecoded0 = [Swift.String]()
            for string0 in ttpsContainer {
                if let string0 = string0 {
                    ttpsDecoded0?.append(string0)
                }
            }
        }
        ttps = ttpsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// The Amazon Web Services Threat Intel Group (ATIG) details for a specific vulnerability.
    public struct AtigData: Swift.Equatable {
        /// The date and time this vulnerability was first observed.
        public var firstSeen: ClientRuntime.Date?
        /// The date and time this vulnerability was last observed.
        public var lastSeen: ClientRuntime.Date?
        /// The commercial sectors this vulnerability targets.
        public var targets: [Swift.String]?
        /// The [MITRE ATT&CK](https://attack.mitre.org/) tactics, techniques, and procedures (TTPs) associated with vulnerability.
        public var ttps: [Swift.String]?

        public init(
            firstSeen: ClientRuntime.Date? = nil,
            lastSeen: ClientRuntime.Date? = nil,
            targets: [Swift.String]? = nil,
            ttps: [Swift.String]? = nil
        )
        {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.targets = targets
            self.ttps = ttps
        }
    }

}

extension Inspector2ClientTypes.AutoEnable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
        case lambda
        case lambdaCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = self.ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecr = self.ecr {
            try encodeContainer.encode(ecr, forKey: .ecr)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let lambdaCode = self.lambdaCode {
            try encodeContainer.encode(lambdaCode, forKey: .lambdaCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ecr)
        ecr = ecrDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .lambda)
        lambda = lambdaDecoded
        let lambdaCodeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .lambdaCode)
        lambdaCode = lambdaCodeDecoded
    }
}

extension Inspector2ClientTypes {
    /// Represents which scan types are automatically enabled for new members of your Amazon Inspector organization.
    public struct AutoEnable: Swift.Equatable {
        /// Represents whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ec2: Swift.Bool?
        /// Represents whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ecr: Swift.Bool?
        /// Represents whether AWS Lambda standard scans are automatically enabled for new members of your Amazon Inspector organization.
        public var lambda: Swift.Bool?
        /// Represents whether AWS Lambda code scans are automatically enabled for new members of your Amazon Inspector organization.
        public var lambdaCode: Swift.Bool?

        public init(
            ec2: Swift.Bool? = nil,
            ecr: Swift.Bool? = nil,
            lambda: Swift.Bool? = nil,
            lambdaCode: Swift.Bool? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes.AwsEc2InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamInstanceProfileArn
        case imageId
        case ipV4Addresses
        case ipV6Addresses
        case keyName
        case launchedAt
        case platform
        case subnetId
        case type
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamInstanceProfileArn = self.iamInstanceProfileArn {
            try encodeContainer.encode(iamInstanceProfileArn, forKey: .iamInstanceProfileArn)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let ipV4Addresses = ipV4Addresses {
            var ipV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV4Addresses)
            for ipv4address0 in ipV4Addresses {
                try ipV4AddressesContainer.encode(ipv4address0)
            }
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for ipv6address0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(ipv6address0)
            }
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let launchedAt = self.launchedAt {
            try encodeContainer.encodeTimestamp(launchedAt, format: .epochSeconds, forKey: .launchedAt)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let ipV4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV4Addresses)
        var ipV4AddressesDecoded0:[Swift.String]? = nil
        if let ipV4AddressesContainer = ipV4AddressesContainer {
            ipV4AddressesDecoded0 = [Swift.String]()
            for string0 in ipV4AddressesContainer {
                if let string0 = string0 {
                    ipV4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV4Addresses = ipV4AddressesDecoded0
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[Swift.String]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [Swift.String]()
            for string0 in ipV6AddressesContainer {
                if let string0 = string0 {
                    ipV6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let iamInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamInstanceProfileArn)
        iamInstanceProfileArn = iamInstanceProfileArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let launchedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon EC2 instance involved in a finding.
    public struct AwsEc2InstanceDetails: Swift.Equatable {
        /// The IAM instance profile ARN of the Amazon EC2 instance.
        public var iamInstanceProfileArn: Swift.String?
        /// The image ID of the Amazon EC2 instance.
        public var imageId: Swift.String?
        /// The IPv4 addresses of the Amazon EC2 instance.
        public var ipV4Addresses: [Swift.String]?
        /// The IPv6 addresses of the Amazon EC2 instance.
        public var ipV6Addresses: [Swift.String]?
        /// The name of the key pair used to launch the Amazon EC2 instance.
        public var keyName: Swift.String?
        /// The date and time the Amazon EC2 instance was launched at.
        public var launchedAt: ClientRuntime.Date?
        /// The platform of the Amazon EC2 instance.
        public var platform: Swift.String?
        /// The subnet ID of the Amazon EC2 instance.
        public var subnetId: Swift.String?
        /// The type of the Amazon EC2 instance.
        public var type: Swift.String?
        /// The VPC ID of the Amazon EC2 instance.
        public var vpcId: Swift.String?

        public init(
            iamInstanceProfileArn: Swift.String? = nil,
            imageId: Swift.String? = nil,
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil,
            keyName: Swift.String? = nil,
            launchedAt: ClientRuntime.Date? = nil,
            platform: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            type: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.platform = platform
            self.subnetId = subnetId
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures
        case imageShas
        case imageTags
        case repositories
        case resourceIds
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for stringfilter0 in architectures {
                try architecturesContainer.encode(stringfilter0)
            }
        }
        if let imageShas = imageShas {
            var imageShasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageShas)
            for stringfilter0 in imageShas {
                try imageShasContainer.encode(stringfilter0)
            }
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for stringfilter0 in imageTags {
                try imageTagsContainer.encode(stringfilter0)
            }
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilter0 in repositories {
                try repositoriesContainer.encode(stringfilter0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilter0 in resourceIds {
                try resourceIdsContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let imageShasContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .imageShas)
        var imageShasDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let imageShasContainer = imageShasContainer {
            imageShasDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in imageShasContainer {
                if let structure0 = structure0 {
                    imageShasDecoded0?.append(structure0)
                }
            }
        }
        imageShas = imageShasDecoded0
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let architecturesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .architectures)
        var architecturesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in architecturesContainer {
                if let structure0 = structure0 {
                    architecturesDecoded0?.append(structure0)
                }
            }
        }
        architectures = architecturesDecoded0
        let imageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in imageTagsContainer {
                if let structure0 = structure0 {
                    imageTagsDecoded0?.append(structure0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregation: Swift.Equatable {
        /// The architecture of the containers.
        public var architectures: [Inspector2ClientTypes.StringFilter]?
        /// The image SHA values.
        public var imageShas: [Inspector2ClientTypes.StringFilter]?
        /// The image tags.
        public var imageTags: [Inspector2ClientTypes.StringFilter]?
        /// The container repositories.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The container resource IDs.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            architectures: [Inspector2ClientTypes.StringFilter]? = nil,
            imageShas: [Inspector2ClientTypes.StringFilter]? = nil,
            imageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.architectures = architectures
            self.imageShas = imageShas
            self.imageTags = imageTags
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case architecture
        case imageSha
        case imageTags
        case repository
        case resourceId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let imageSha = self.imageSha {
            try encodeContainer.encode(imageSha, forKey: .imageSha)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for nonemptystring0 in imageTags {
                try imageTagsContainer.encode(nonemptystring0)
            }
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let imageShaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSha)
        imageSha = imageShaDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID of the account that owns the container.
        public var accountId: Swift.String?
        /// The architecture of the container.
        public var architecture: Swift.String?
        /// The SHA value of the container image.
        public var imageSha: Swift.String?
        /// The container image stags.
        public var imageTags: [Swift.String]?
        /// The container repository.
        public var repository: Swift.String?
        /// The resource ID of the container.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The number of finding by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            architecture: Swift.String? = nil,
            imageSha: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.architecture = architecture
            self.imageSha = imageSha
            self.imageTags = imageTags
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerImageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case author
        case imageHash
        case imageTags
        case platform
        case pushedAt
        case registry
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let imageHash = self.imageHash {
            try encodeContainer.encode(imageHash, forKey: .imageHash)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for nonemptystring0 in imageTags {
                try imageTagsContainer.encode(nonemptystring0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let pushedAt = self.pushedAt {
            try encodeContainer.encodeTimestamp(pushedAt, format: .epochSeconds, forKey: .pushedAt)
        }
        if let registry = self.registry {
            try encodeContainer.encode(registry, forKey: .registry)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let pushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .pushedAt)
        pushedAt = pushedAtDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageHash)
        imageHash = imageHashDecoded
        let registryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registry)
        registry = registryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// The image details of the Amazon ECR container image.
    public struct AwsEcrContainerImageDetails: Swift.Equatable {
        /// The architecture of the Amazon ECR container image.
        public var architecture: Swift.String?
        /// The image author of the Amazon ECR container image.
        public var author: Swift.String?
        /// The image hash of the Amazon ECR container image.
        /// This member is required.
        public var imageHash: Swift.String?
        /// The image tags attached to the Amazon ECR container image.
        public var imageTags: [Swift.String]?
        /// The platform of the Amazon ECR container image.
        public var platform: Swift.String?
        /// The date and time the Amazon ECR container image was pushed.
        public var pushedAt: ClientRuntime.Date?
        /// The registry for the Amazon ECR container image.
        /// This member is required.
        public var registry: Swift.String?
        /// The name of the repository the Amazon ECR container image resides in.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            author: Swift.String? = nil,
            imageHash: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            platform: Swift.String? = nil,
            pushedAt: ClientRuntime.Date? = nil,
            registry: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }
    }

}

extension Inspector2ClientTypes {
    public enum AwsEcrContainerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsEcrContainerSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsEcrContainerSortBy(rawValue: rawValue) ?? AwsEcrContainerSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AwsLambdaFunctionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures
        case codeSha256
        case executionRoleArn
        case functionName
        case lastModifiedAt
        case layers
        case packageType
        case runtime
        case version
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let codeSha256 = self.codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for lambdalayerarn0 in layers {
                try layersContainer.encode(lambdalayerarn0)
            }
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.LambdaVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[Inspector2ClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Inspector2ClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// A summary of information about the AWS Lambda function.
    public struct AwsLambdaFunctionDetails: Swift.Equatable {
        /// The instruction set architecture that the AWS Lambda function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [Inspector2ClientTypes.Architecture]?
        /// The SHA256 hash of the AWS Lambda function's deployment package.
        /// This member is required.
        public var codeSha256: Swift.String?
        /// The AWS Lambda function's execution role.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The name of the AWS Lambda function.
        /// This member is required.
        public var functionName: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html)
        public var lastModifiedAt: ClientRuntime.Date?
        /// The AWS Lambda function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). A Lambda function can have up to five layers.
        public var layers: [Swift.String]?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: Inspector2ClientTypes.PackageType?
        /// The runtime environment for the AWS Lambda function.
        /// This member is required.
        public var runtime: Inspector2ClientTypes.Runtime?
        /// The version of the AWS Lambda function.
        /// This member is required.
        public var version: Swift.String?
        /// The AWS Lambda function's networking configuration.
        public var vpcConfig: Inspector2ClientTypes.LambdaVpcConfig?

        public init(
            architectures: [Inspector2ClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            layers: [Swift.String]? = nil,
            packageType: Inspector2ClientTypes.PackageType? = nil,
            runtime: Inspector2ClientTypes.Runtime? = nil,
            version: Swift.String? = nil,
            vpcConfig: Inspector2ClientTypes.LambdaVpcConfig? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.executionRoleArn = executionRoleArn
            self.functionName = functionName
            self.lastModifiedAt = lastModifiedAt
            self.layers = layers
            self.packageType = packageType
            self.runtime = runtime
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more tags submitted as part of the request is not valid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchGetAccountStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension BatchGetAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/status/batch/get"
    }
}

public struct BatchGetAccountStatusInput: Swift.Equatable {
    /// The 12-digit Amazon Web Services account IDs of the accounts to retrieve Amazon Inspector status for.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchGetAccountStatusInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension BatchGetAccountStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetAccountStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetAccountStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct BatchGetAccountStatusOutput: Swift.Equatable {
    /// An array of objects that provide details on the status of Amazon Inspector for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.AccountState]?
    /// An array of objects detailing any accounts that failed to enable Amazon Inspector and why.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.AccountState]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct BatchGetAccountStatusOutputBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.AccountState]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension BatchGetAccountStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.AccountState?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.AccountState]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.AccountState]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

enum BatchGetAccountStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetCodeSnippetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for findingarn0 in findingArns {
                try findingArnsContainer.encode(findingarn0)
            }
        }
    }
}

extension BatchGetCodeSnippetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/codesnippet/batchget"
    }
}

public struct BatchGetCodeSnippetInput: Swift.Equatable {
    /// An array of finding ARNs for the findings you want to retrieve code snippets from.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        findingArns: [Swift.String]? = nil
    )
    {
        self.findingArns = findingArns
    }
}

struct BatchGetCodeSnippetInputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
}

extension BatchGetCodeSnippetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
    }
}

extension BatchGetCodeSnippetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetCodeSnippetOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSnippetResults = output.codeSnippetResults
            self.errors = output.errors
        } else {
            self.codeSnippetResults = nil
            self.errors = nil
        }
    }
}

public struct BatchGetCodeSnippetOutput: Swift.Equatable {
    /// The retrieved code snippets associated with the provided finding ARNs.
    public var codeSnippetResults: [Inspector2ClientTypes.CodeSnippetResult]?
    /// Any errors Amazon Inspector encountered while trying to retrieve the requested code snippets.
    public var errors: [Inspector2ClientTypes.CodeSnippetError]?

    public init(
        codeSnippetResults: [Inspector2ClientTypes.CodeSnippetResult]? = nil,
        errors: [Inspector2ClientTypes.CodeSnippetError]? = nil
    )
    {
        self.codeSnippetResults = codeSnippetResults
        self.errors = errors
    }
}

struct BatchGetCodeSnippetOutputBody: Swift.Equatable {
    let codeSnippetResults: [Inspector2ClientTypes.CodeSnippetResult]?
    let errors: [Inspector2ClientTypes.CodeSnippetError]?
}

extension BatchGetCodeSnippetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSnippetResults
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSnippetResultsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CodeSnippetResult?].self, forKey: .codeSnippetResults)
        var codeSnippetResultsDecoded0:[Inspector2ClientTypes.CodeSnippetResult]? = nil
        if let codeSnippetResultsContainer = codeSnippetResultsContainer {
            codeSnippetResultsDecoded0 = [Inspector2ClientTypes.CodeSnippetResult]()
            for structure0 in codeSnippetResultsContainer {
                if let structure0 = structure0 {
                    codeSnippetResultsDecoded0?.append(structure0)
                }
            }
        }
        codeSnippetResults = codeSnippetResultsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CodeSnippetError?].self, forKey: .errors)
        var errorsDecoded0:[Inspector2ClientTypes.CodeSnippetError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Inspector2ClientTypes.CodeSnippetError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetCodeSnippetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetFindingDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for findingarn0 in findingArns {
                try findingArnsContainer.encode(findingarn0)
            }
        }
    }
}

extension BatchGetFindingDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/details/batch/get"
    }
}

public struct BatchGetFindingDetailsInput: Swift.Equatable {
    /// A list of finding ARNs.
    /// This member is required.
    public var findingArns: [Swift.String]?

    public init(
        findingArns: [Swift.String]? = nil
    )
    {
        self.findingArns = findingArns
    }
}

struct BatchGetFindingDetailsInputBody: Swift.Equatable {
    let findingArns: [Swift.String]?
}

extension BatchGetFindingDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[Swift.String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [Swift.String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
    }
}

extension BatchGetFindingDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFindingDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.findingDetails = output.findingDetails
        } else {
            self.errors = nil
            self.findingDetails = nil
        }
    }
}

public struct BatchGetFindingDetailsOutput: Swift.Equatable {
    /// Error information for findings that details could not be returned for.
    public var errors: [Inspector2ClientTypes.FindingDetailsError]?
    /// A finding's vulnerability details.
    public var findingDetails: [Inspector2ClientTypes.FindingDetail]?

    public init(
        errors: [Inspector2ClientTypes.FindingDetailsError]? = nil,
        findingDetails: [Inspector2ClientTypes.FindingDetail]? = nil
    )
    {
        self.errors = errors
        self.findingDetails = findingDetails
    }
}

struct BatchGetFindingDetailsOutputBody: Swift.Equatable {
    let findingDetails: [Inspector2ClientTypes.FindingDetail]?
    let errors: [Inspector2ClientTypes.FindingDetailsError]?
}

extension BatchGetFindingDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case findingDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDetailsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FindingDetail?].self, forKey: .findingDetails)
        var findingDetailsDecoded0:[Inspector2ClientTypes.FindingDetail]? = nil
        if let findingDetailsContainer = findingDetailsContainer {
            findingDetailsDecoded0 = [Inspector2ClientTypes.FindingDetail]()
            for structure0 in findingDetailsContainer {
                if let structure0 = structure0 {
                    findingDetailsDecoded0?.append(structure0)
                }
            }
        }
        findingDetails = findingDetailsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FindingDetailsError?].self, forKey: .errors)
        var errorsDecoded0:[Inspector2ClientTypes.FindingDetailsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Inspector2ClientTypes.FindingDetailsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetFindingDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetFreeTrialInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for meteringaccountid0 in accountIds {
                try accountIdsContainer.encode(meteringaccountid0)
            }
        }
    }
}

extension BatchGetFreeTrialInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/freetrialinfo/batchget"
    }
}

public struct BatchGetFreeTrialInfoInput: Swift.Equatable {
    /// The account IDs to get free trial status for.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchGetFreeTrialInfoInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension BatchGetFreeTrialInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetFreeTrialInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFreeTrialInfoOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct BatchGetFreeTrialInfoOutput: Swift.Equatable {
    /// An array of objects that provide Amazon Inspector free trial details for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]?
    /// An array of objects detailing any accounts that free trial data could not be returned for.
    /// This member is required.
    public var failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]?

    public init(
        accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]? = nil,
        failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct BatchGetFreeTrialInfoOutputBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]?
    let failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]?
}

extension BatchGetFreeTrialInfoOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialAccountInfo?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.FreeTrialAccountInfo]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.FreeTrialAccountInfo]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialInfoError?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FreeTrialInfoError]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FreeTrialInfoError]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

enum BatchGetFreeTrialInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetMemberEc2DeepInspectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension BatchGetMemberEc2DeepInspectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ec2deepinspectionstatus/member/batch/get"
    }
}

public struct BatchGetMemberEc2DeepInspectionStatusInput: Swift.Equatable {
    /// The unique identifiers for the Amazon Web Services accounts to retrieve Amazon Inspector deep inspection activation status for.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchGetMemberEc2DeepInspectionStatusInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension BatchGetMemberEc2DeepInspectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetMemberEc2DeepInspectionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetMemberEc2DeepInspectionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.failedAccountIds = output.failedAccountIds
        } else {
            self.accountIds = nil
            self.failedAccountIds = nil
        }
    }
}

public struct BatchGetMemberEc2DeepInspectionStatusOutput: Swift.Equatable {
    /// An array of objects that provide details on the activation status of Amazon Inspector deep inspection for each of the requested accounts.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    /// An array of objects that provide details on any accounts that failed to activate Amazon Inspector deep inspection and why.
    public var failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil,
        failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
    )
    {
        self.accountIds = accountIds
        self.failedAccountIds = failedAccountIds
    }
}

struct BatchGetMemberEc2DeepInspectionStatusOutputBody: Swift.Equatable {
    let accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    let failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?
}

extension BatchGetMemberEc2DeepInspectionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case failedAccountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]()
            for structure0 in accountIdsContainer {
                if let structure0 = structure0 {
                    accountIdsDecoded0?.append(structure0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let failedAccountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState?].self, forKey: .failedAccountIds)
        var failedAccountIdsDecoded0:[Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
        if let failedAccountIdsContainer = failedAccountIdsContainer {
            failedAccountIdsDecoded0 = [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]()
            for structure0 in failedAccountIdsContainer {
                if let structure0 = structure0 {
                    failedAccountIdsDecoded0?.append(structure0)
                }
            }
        }
        failedAccountIds = failedAccountIdsDecoded0
    }
}

enum BatchGetMemberEc2DeepInspectionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for memberaccountec2deepinspectionstatus0 in accountIds {
                try accountIdsContainer.encode(memberaccountec2deepinspectionstatus0)
            }
        }
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ec2deepinspectionstatus/member/batch/update"
    }
}

public struct BatchUpdateMemberEc2DeepInspectionStatusInput: Swift.Equatable {
    /// The unique identifiers for the Amazon Web Services accounts to change Amazon Inspector deep inspection status for.
    /// This member is required.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchUpdateMemberEc2DeepInspectionStatusInputBody: Swift.Equatable {
    let accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]?
}

extension BatchUpdateMemberEc2DeepInspectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus]()
            for structure0 in accountIdsContainer {
                if let structure0 = structure0 {
                    accountIdsDecoded0?.append(structure0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchUpdateMemberEc2DeepInspectionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateMemberEc2DeepInspectionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.failedAccountIds = output.failedAccountIds
        } else {
            self.accountIds = nil
            self.failedAccountIds = nil
        }
    }
}

public struct BatchUpdateMemberEc2DeepInspectionStatusOutput: Swift.Equatable {
    /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status was successfully changed for.
    public var accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status could not be successfully changed for.
    public var failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?

    public init(
        accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil,
        failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
    )
    {
        self.accountIds = accountIds
        self.failedAccountIds = failedAccountIds
    }
}

struct BatchUpdateMemberEc2DeepInspectionStatusOutputBody: Swift.Equatable {
    let accountIds: [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]?
    let failedAccountIds: [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]?
}

extension BatchUpdateMemberEc2DeepInspectionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case failedAccountIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState]()
            for structure0 in accountIdsContainer {
                if let structure0 = structure0 {
                    accountIdsDecoded0?.append(structure0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let failedAccountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState?].self, forKey: .failedAccountIds)
        var failedAccountIdsDecoded0:[Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]? = nil
        if let failedAccountIdsContainer = failedAccountIdsContainer {
            failedAccountIdsDecoded0 = [Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState]()
            for structure0 in failedAccountIdsContainer {
                if let structure0 = structure0 {
                    failedAccountIdsDecoded0?.append(structure0)
                }
            }
        }
        failedAccountIds = failedAccountIdsDecoded0
    }
}

enum BatchUpdateMemberEc2DeepInspectionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelFindingsReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension CancelFindingsReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/cancel"
    }
}

public struct CancelFindingsReportInput: Swift.Equatable {
    /// The ID of the report to be canceled.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelFindingsReportInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelFindingsReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension CancelFindingsReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelFindingsReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CancelFindingsReportOutput: Swift.Equatable {
    /// The ID of the canceled report.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelFindingsReportOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelFindingsReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum CancelFindingsReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelSbomExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension CancelSbomExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sbomexport/cancel"
    }
}

public struct CancelSbomExportInput: Swift.Equatable {
    /// The report ID of the SBOM export to cancel.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelSbomExportInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelSbomExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension CancelSbomExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelSbomExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CancelSbomExportOutput: Swift.Equatable {
    /// The report ID of the canceled SBOM export.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelSbomExportOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelSbomExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum CancelSbomExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.CisaData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case dateAdded
        case dateDue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let dateAdded = self.dateAdded {
            try encodeContainer.encodeTimestamp(dateAdded, format: .epochSeconds, forKey: .dateAdded)
        }
        if let dateDue = self.dateDue {
            try encodeContainer.encodeTimestamp(dateDue, format: .epochSeconds, forKey: .dateDue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateAddedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateAdded)
        dateAdded = dateAddedDecoded
        let dateDueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateDue)
        dateDue = dateDueDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
    }
}

extension Inspector2ClientTypes {
    /// The Cybersecurity and Infrastructure Security Agency (CISA) details for a specific vulnerability.
    public struct CisaData: Swift.Equatable {
        /// The remediation action recommended by CISA for this vulnerability.
        public var action: Swift.String?
        /// The date and time CISA added this vulnerability to their catalogue.
        public var dateAdded: ClientRuntime.Date?
        /// The date and time CISA expects a fix to have been provided vulnerability.
        public var dateDue: ClientRuntime.Date?

        public init(
            action: Swift.String? = nil,
            dateAdded: ClientRuntime.Date? = nil,
            dateDue: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.dateAdded = dateAdded
            self.dateDue = dateDue
        }
    }

}

extension Inspector2ClientTypes.CodeFilePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endLine
        case fileName
        case filePath
        case startLine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endLine = self.endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let startLine = self.startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on where a code vulnerability is located in your Lambda function.
    public struct CodeFilePath: Swift.Equatable {
        /// The line number of the last line of code that a vulnerability was found in.
        /// This member is required.
        public var endLine: Swift.Int?
        /// The name of the file the code vulnerability was found in.
        /// This member is required.
        public var fileName: Swift.String?
        /// The file path to the code that a vulnerability was found in.
        /// This member is required.
        public var filePath: Swift.String?
        /// The line number of the first line of code that a vulnerability was found in.
        /// This member is required.
        public var startLine: Swift.Int?

        public init(
            endLine: Swift.Int? = nil,
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.fileName = fileName
            self.filePath = filePath
            self.startLine = startLine
        }
    }

}

extension Inspector2ClientTypes.CodeLine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case lineNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let lineNumber = self.lineNumber {
            try encodeContainer.encode(lineNumber, forKey: .lineNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let lineNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lineNumber)
        lineNumber = lineNumberDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the lines of code associated with a code snippet.
    public struct CodeLine: Swift.Equatable {
        /// The content of a line of code
        /// This member is required.
        public var content: Swift.String?
        /// The line number that a section of code is located at.
        /// This member is required.
        public var lineNumber: Swift.Int?

        public init(
            content: Swift.String? = nil,
            lineNumber: Swift.Int? = nil
        )
        {
            self.content = content
            self.lineNumber = lineNumber
        }
    }

}

extension Inspector2ClientTypes.CodeSnippetError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case findingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CodeSnippetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information about any errors encountered while trying to retrieve a code snippet.
    public struct CodeSnippetError: Swift.Equatable {
        /// The error code for the error that prevented a code snippet from being retrieved.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.CodeSnippetErrorCode?
        /// The error message received when Amazon Inspector failed to retrieve a code snippet.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The ARN of the finding that a code snippet couldn't be retrieved for.
        /// This member is required.
        public var findingArn: Swift.String?

        public init(
            errorCode: Inspector2ClientTypes.CodeSnippetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            findingArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }
    }

}

extension Inspector2ClientTypes {
    public enum CodeSnippetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case codeSnippetNotFound
        case internalError
        case invalidInput
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSnippetErrorCode] {
            return [
                .accessDenied,
                .codeSnippetNotFound,
                .internalError,
                .invalidInput,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .codeSnippetNotFound: return "CODE_SNIPPET_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInput: return "INVALID_INPUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeSnippetErrorCode(rawValue: rawValue) ?? CodeSnippetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CodeSnippetResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSnippet
        case endLine
        case findingArn
        case startLine
        case suggestedFixes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSnippet = codeSnippet {
            var codeSnippetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeSnippet)
            for codeline0 in codeSnippet {
                try codeSnippetContainer.encode(codeline0)
            }
        }
        if let endLine = self.endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
        if let startLine = self.startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
        if let suggestedFixes = suggestedFixes {
            var suggestedFixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suggestedFixes)
            for suggestedfix0 in suggestedFixes {
                try suggestedFixesContainer.encode(suggestedfix0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let codeSnippetContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CodeLine?].self, forKey: .codeSnippet)
        var codeSnippetDecoded0:[Inspector2ClientTypes.CodeLine]? = nil
        if let codeSnippetContainer = codeSnippetContainer {
            codeSnippetDecoded0 = [Inspector2ClientTypes.CodeLine]()
            for structure0 in codeSnippetContainer {
                if let structure0 = structure0 {
                    codeSnippetDecoded0?.append(structure0)
                }
            }
        }
        codeSnippet = codeSnippetDecoded0
        let suggestedFixesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.SuggestedFix?].self, forKey: .suggestedFixes)
        var suggestedFixesDecoded0:[Inspector2ClientTypes.SuggestedFix]? = nil
        if let suggestedFixesContainer = suggestedFixesContainer {
            suggestedFixesDecoded0 = [Inspector2ClientTypes.SuggestedFix]()
            for structure0 in suggestedFixesContainer {
                if let structure0 = structure0 {
                    suggestedFixesDecoded0?.append(structure0)
                }
            }
        }
        suggestedFixes = suggestedFixesDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Contains information on a code snippet retrieved by Amazon Inspector from a code vulnerability finding.
    public struct CodeSnippetResult: Swift.Equatable {
        /// Contains information on the retrieved code snippet.
        public var codeSnippet: [Inspector2ClientTypes.CodeLine]?
        /// The line number of the last line of a code snippet.
        public var endLine: Swift.Int?
        /// The ARN of a finding that the code snippet is associated with.
        public var findingArn: Swift.String?
        /// The line number of the first line of a code snippet.
        public var startLine: Swift.Int?
        /// Details of a suggested code fix.
        public var suggestedFixes: [Inspector2ClientTypes.SuggestedFix]?

        public init(
            codeSnippet: [Inspector2ClientTypes.CodeLine]? = nil,
            endLine: Swift.Int? = nil,
            findingArn: Swift.String? = nil,
            startLine: Swift.Int? = nil,
            suggestedFixes: [Inspector2ClientTypes.SuggestedFix]? = nil
        )
        {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.findingArn = findingArn
            self.startLine = startLine
            self.suggestedFixes = suggestedFixes
        }
    }

}

extension Inspector2ClientTypes.CodeVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cwes
        case detectorId
        case detectorName
        case detectorTags
        case filePath
        case referenceUrls
        case ruleId
        case sourceLambdaLayerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cwes = cwes {
            var cwesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cwes)
            for nonemptystring0 in cwes {
                try cwesContainer.encode(nonemptystring0)
            }
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorName = self.detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorTags = detectorTags {
            var detectorTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectorTags)
            for nonemptystring0 in detectorTags {
                try detectorTagsContainer.encode(nonemptystring0)
            }
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for nonemptystring0 in referenceUrls {
                try referenceUrlsContainer.encode(nonemptystring0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let sourceLambdaLayerArn = self.sourceLambdaLayerArn {
            try encodeContainer.encode(sourceLambdaLayerArn, forKey: .sourceLambdaLayerArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CodeFilePath.self, forKey: .filePath)
        filePath = filePathDecoded
        let detectorTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectorTags)
        var detectorTagsDecoded0:[Swift.String]? = nil
        if let detectorTagsContainer = detectorTagsContainer {
            detectorTagsDecoded0 = [Swift.String]()
            for string0 in detectorTagsContainer {
                if let string0 = string0 {
                    detectorTagsDecoded0?.append(string0)
                }
            }
        }
        detectorTags = detectorTagsDecoded0
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let sourceLambdaLayerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLambdaLayerArn)
        sourceLambdaLayerArn = sourceLambdaLayerArnDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let cwesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cwes)
        var cwesDecoded0:[Swift.String]? = nil
        if let cwesContainer = cwesContainer {
            cwesDecoded0 = [Swift.String]()
            for string0 in cwesContainer {
                if let string0 = string0 {
                    cwesDecoded0?.append(string0)
                }
            }
        }
        cwes = cwesDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the code vulnerability identified in your Lambda function.
    public struct CodeVulnerabilityDetails: Swift.Equatable {
        /// The Common Weakness Enumeration (CWE) item associated with the detected vulnerability.
        /// This member is required.
        public var cwes: [Swift.String]?
        /// The ID for the Amazon CodeGuru detector associated with the finding. For more information on detectors see [Amazon CodeGuru Detector Library](https://docs.aws.amazon.com/codeguru/detector-library).
        /// This member is required.
        public var detectorId: Swift.String?
        /// The name of the detector used to identify the code vulnerability. For more information on detectors see [CodeGuru Detector Library](https://docs.aws.amazon.com/codeguru/detector-library).
        /// This member is required.
        public var detectorName: Swift.String?
        /// The detector tag associated with the vulnerability. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see [Java tags](https://docs.aws.amazon.com/codeguru/detector-library/java/tags/), or [Python tags](https://docs.aws.amazon.com/codeguru/detector-library/python/tags/).
        public var detectorTags: [Swift.String]?
        /// Contains information on where the code vulnerability is located in your code.
        /// This member is required.
        public var filePath: Inspector2ClientTypes.CodeFilePath?
        /// A URL containing supporting documentation about the code vulnerability detected.
        public var referenceUrls: [Swift.String]?
        /// The identifier for a rule that was used to detect the code vulnerability.
        public var ruleId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Lambda layer that the code vulnerability was detected in.
        public var sourceLambdaLayerArn: Swift.String?

        public init(
            cwes: [Swift.String]? = nil,
            detectorId: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorTags: [Swift.String]? = nil,
            filePath: Inspector2ClientTypes.CodeFilePath? = nil,
            referenceUrls: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            sourceLambdaLayerArn: Swift.String? = nil
        )
        {
            self.cwes = cwes
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.filePath = filePath
            self.referenceUrls = referenceUrls
            self.ruleId = ruleId
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflict occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Inspector2ClientTypes.Counts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case groupKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupKey = self.groupKey {
            try encodeContainer.encode(groupKey.rawValue, forKey: .groupKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let groupKeyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.GroupKey.self, forKey: .groupKey)
        groupKey = groupKeyDecoded
    }
}

extension Inspector2ClientTypes {
    /// a structure that contains information on the count of resources within a group.
    public struct Counts: Swift.Equatable {
        /// The number of resources.
        public var count: Swift.Int
        /// The key associated with this group
        public var groupKey: Inspector2ClientTypes.GroupKey?

        public init(
            count: Swift.Int = 0,
            groupKey: Inspector2ClientTypes.GroupKey? = nil
        )
        {
            self.count = count
            self.groupKey = groupKey
        }
    }

}

extension Inspector2ClientTypes.CoverageDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endInclusive
        case startInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endInclusive = self.endInclusive {
            try encodeContainer.encodeTimestamp(endInclusive, format: .epochSeconds, forKey: .endInclusive)
        }
        if let startInclusive = self.startInclusive {
            try encodeContainer.encodeTimestamp(startInclusive, format: .epochSeconds, forKey: .startInclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startInclusive)
        startInclusive = startInclusiveDecoded
        let endInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endInclusive)
        endInclusive = endInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage date filter.
    public struct CoverageDateFilter: Swift.Equatable {
        /// A timestamp representing the end of the time period to filter results by.
        public var endInclusive: ClientRuntime.Date?
        /// A timestamp representing the start of the time period to filter results by.
        public var startInclusive: ClientRuntime.Date?

        public init(
            endInclusive: ClientRuntime.Date? = nil,
            startInclusive: ClientRuntime.Date? = nil
        )
        {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }
    }

}

extension Inspector2ClientTypes.CoverageFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ec2InstanceTags
        case ecrImageTags
        case ecrRepositoryName
        case lambdaFunctionName
        case lambdaFunctionRuntime
        case lambdaFunctionTags
        case lastScannedAt
        case resourceId
        case resourceType
        case scanStatusCode
        case scanStatusReason
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            var accountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountId)
            for coveragestringfilter0 in accountId {
                try accountIdContainer.encode(coveragestringfilter0)
            }
        }
        if let ec2InstanceTags = ec2InstanceTags {
            var ec2InstanceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTags)
            for coveragemapfilter0 in ec2InstanceTags {
                try ec2InstanceTagsContainer.encode(coveragemapfilter0)
            }
        }
        if let ecrImageTags = ecrImageTags {
            var ecrImageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageTags)
            for coveragestringfilter0 in ecrImageTags {
                try ecrImageTagsContainer.encode(coveragestringfilter0)
            }
        }
        if let ecrRepositoryName = ecrRepositoryName {
            var ecrRepositoryNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrRepositoryName)
            for coveragestringfilter0 in ecrRepositoryName {
                try ecrRepositoryNameContainer.encode(coveragestringfilter0)
            }
        }
        if let lambdaFunctionName = lambdaFunctionName {
            var lambdaFunctionNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionName)
            for coveragestringfilter0 in lambdaFunctionName {
                try lambdaFunctionNameContainer.encode(coveragestringfilter0)
            }
        }
        if let lambdaFunctionRuntime = lambdaFunctionRuntime {
            var lambdaFunctionRuntimeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionRuntime)
            for coveragestringfilter0 in lambdaFunctionRuntime {
                try lambdaFunctionRuntimeContainer.encode(coveragestringfilter0)
            }
        }
        if let lambdaFunctionTags = lambdaFunctionTags {
            var lambdaFunctionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionTags)
            for coveragemapfilter0 in lambdaFunctionTags {
                try lambdaFunctionTagsContainer.encode(coveragemapfilter0)
            }
        }
        if let lastScannedAt = lastScannedAt {
            var lastScannedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastScannedAt)
            for coveragedatefilter0 in lastScannedAt {
                try lastScannedAtContainer.encode(coveragedatefilter0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for coveragestringfilter0 in resourceId {
                try resourceIdContainer.encode(coveragestringfilter0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for coveragestringfilter0 in resourceType {
                try resourceTypeContainer.encode(coveragestringfilter0)
            }
        }
        if let scanStatusCode = scanStatusCode {
            var scanStatusCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanStatusCode)
            for coveragestringfilter0 in scanStatusCode {
                try scanStatusCodeContainer.encode(coveragestringfilter0)
            }
        }
        if let scanStatusReason = scanStatusReason {
            var scanStatusReasonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanStatusReason)
            for coveragestringfilter0 in scanStatusReason {
                try scanStatusReasonContainer.encode(coveragestringfilter0)
            }
        }
        if let scanType = scanType {
            var scanTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanType)
            for coveragestringfilter0 in scanType {
                try scanTypeContainer.encode(coveragestringfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanStatusCodeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanStatusCode)
        var scanStatusCodeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanStatusCodeContainer = scanStatusCodeContainer {
            scanStatusCodeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanStatusCodeContainer {
                if let structure0 = structure0 {
                    scanStatusCodeDecoded0?.append(structure0)
                }
            }
        }
        scanStatusCode = scanStatusCodeDecoded0
        let scanStatusReasonContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanStatusReason)
        var scanStatusReasonDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanStatusReasonContainer = scanStatusReasonContainer {
            scanStatusReasonDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanStatusReasonContainer {
                if let structure0 = structure0 {
                    scanStatusReasonDecoded0?.append(structure0)
                }
            }
        }
        scanStatusReason = scanStatusReasonDecoded0
        let accountIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .accountId)
        var accountIdDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let accountIdContainer = accountIdContainer {
            accountIdDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in accountIdContainer {
                if let structure0 = structure0 {
                    accountIdDecoded0?.append(structure0)
                }
            }
        }
        accountId = accountIdDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let scanTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanType)
        var scanTypeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanTypeContainer = scanTypeContainer {
            scanTypeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanTypeContainer {
                if let structure0 = structure0 {
                    scanTypeDecoded0?.append(structure0)
                }
            }
        }
        scanType = scanTypeDecoded0
        let ecrRepositoryNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .ecrRepositoryName)
        var ecrRepositoryNameDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let ecrRepositoryNameContainer = ecrRepositoryNameContainer {
            ecrRepositoryNameDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in ecrRepositoryNameContainer {
                if let structure0 = structure0 {
                    ecrRepositoryNameDecoded0?.append(structure0)
                }
            }
        }
        ecrRepositoryName = ecrRepositoryNameDecoded0
        let ecrImageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .ecrImageTags)
        var ecrImageTagsDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let ecrImageTagsContainer = ecrImageTagsContainer {
            ecrImageTagsDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in ecrImageTagsContainer {
                if let structure0 = structure0 {
                    ecrImageTagsDecoded0?.append(structure0)
                }
            }
        }
        ecrImageTags = ecrImageTagsDecoded0
        let ec2InstanceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageMapFilter?].self, forKey: .ec2InstanceTags)
        var ec2InstanceTagsDecoded0:[Inspector2ClientTypes.CoverageMapFilter]? = nil
        if let ec2InstanceTagsContainer = ec2InstanceTagsContainer {
            ec2InstanceTagsDecoded0 = [Inspector2ClientTypes.CoverageMapFilter]()
            for structure0 in ec2InstanceTagsContainer {
                if let structure0 = structure0 {
                    ec2InstanceTagsDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceTags = ec2InstanceTagsDecoded0
        let lambdaFunctionNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .lambdaFunctionName)
        var lambdaFunctionNameDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let lambdaFunctionNameContainer = lambdaFunctionNameContainer {
            lambdaFunctionNameDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in lambdaFunctionNameContainer {
                if let structure0 = structure0 {
                    lambdaFunctionNameDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionName = lambdaFunctionNameDecoded0
        let lambdaFunctionTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageMapFilter?].self, forKey: .lambdaFunctionTags)
        var lambdaFunctionTagsDecoded0:[Inspector2ClientTypes.CoverageMapFilter]? = nil
        if let lambdaFunctionTagsContainer = lambdaFunctionTagsContainer {
            lambdaFunctionTagsDecoded0 = [Inspector2ClientTypes.CoverageMapFilter]()
            for structure0 in lambdaFunctionTagsContainer {
                if let structure0 = structure0 {
                    lambdaFunctionTagsDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionTags = lambdaFunctionTagsDecoded0
        let lambdaFunctionRuntimeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .lambdaFunctionRuntime)
        var lambdaFunctionRuntimeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let lambdaFunctionRuntimeContainer = lambdaFunctionRuntimeContainer {
            lambdaFunctionRuntimeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in lambdaFunctionRuntimeContainer {
                if let structure0 = structure0 {
                    lambdaFunctionRuntimeDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionRuntime = lambdaFunctionRuntimeDecoded0
        let lastScannedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageDateFilter?].self, forKey: .lastScannedAt)
        var lastScannedAtDecoded0:[Inspector2ClientTypes.CoverageDateFilter]? = nil
        if let lastScannedAtContainer = lastScannedAtContainer {
            lastScannedAtDecoded0 = [Inspector2ClientTypes.CoverageDateFilter]()
            for structure0 in lastScannedAtContainer {
                if let structure0 = structure0 {
                    lastScannedAtDecoded0?.append(structure0)
                }
            }
        }
        lastScannedAt = lastScannedAtDecoded0
    }
}

extension Inspector2ClientTypes {
    /// A structure that identifies filter criteria for GetCoverageStatistics.
    public struct CoverageFilterCriteria: Swift.Equatable {
        /// An array of Amazon Web Services account IDs to return coverage statistics for.
        public var accountId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon EC2 instance tags to filter on.
        public var ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]?
        /// The Amazon ECR image tags to filter on.
        public var ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon ECR repository name to filter on.
        public var ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by function names.
        public var lambdaFunctionName: [Inspector2ClientTypes.CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by runtime.
        public var lambdaFunctionRuntime: [Inspector2ClientTypes.CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by tag.
        public var lambdaFunctionTags: [Inspector2ClientTypes.CoverageMapFilter]?
        /// Filters Amazon Web Services resources based on whether Amazon Inspector has checked them for vulnerabilities within the specified time range.
        public var lastScannedAt: [Inspector2ClientTypes.CoverageDateFilter]?
        /// An array of Amazon Web Services resource IDs to return coverage statistics for.
        public var resourceId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Web Services resource types to return coverage statistics for. The values can be AWS_EC2_INSTANCE, AWS_LAMBDA_FUNCTION or AWS_ECR_REPOSITORY.
        public var resourceType: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status code to filter on.
        public var scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status reason to filter on.
        public var scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Inspector scan types to return coverage statistics for.
        public var scanType: [Inspector2ClientTypes.CoverageStringFilter]?

        public init(
            accountId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            lambdaFunctionRuntime: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            lambdaFunctionTags: [Inspector2ClientTypes.CoverageMapFilter]? = nil,
            lastScannedAt: [Inspector2ClientTypes.CoverageDateFilter]? = nil,
            resourceId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            resourceType: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanType: [Inspector2ClientTypes.CoverageStringFilter]? = nil
        )
        {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lambdaFunctionTags = lambdaFunctionTags
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.scanStatusCode = scanStatusCode
            self.scanStatusReason = scanStatusReason
            self.scanType = scanType
        }
    }

}

extension Inspector2ClientTypes {
    public enum CoverageMapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageMapComparison] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageMapComparison(rawValue: rawValue) ?? CoverageMapComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CoverageMapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageMapComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage map filter.
    public struct CoverageMapFilter: Swift.Equatable {
        /// The operator to compare coverage on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageMapComparison?
        /// The tag key associated with the coverage map filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value associated with the coverage map filter.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.CoverageMapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    public enum CoverageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .awsLambdaFunction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageResourceType(rawValue: rawValue) ?? CoverageResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum CoverageStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageStringComparison] {
            return [
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageStringComparison(rawValue: rawValue) ?? CoverageStringComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CoverageStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageStringComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage string filter.
    public struct CoverageStringFilter: Swift.Equatable {
        /// The operator to compare strings on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageStringComparison?
        /// The value to compare strings on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.CoverageStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes.CoveredResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case lastScannedAt
        case resourceId
        case resourceMetadata
        case resourceType
        case scanStatus
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let lastScannedAt = self.lastScannedAt {
            try encodeContainer.encodeTimestamp(lastScannedAt, format: .epochSeconds, forKey: .lastScannedAt)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceMetadata = self.resourceMetadata {
            try encodeContainer.encode(resourceMetadata, forKey: .resourceMetadata)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let scanStatus = self.scanStatus {
            try encodeContainer.encode(scanStatus, forKey: .scanStatus)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let scanTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let scanStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatus.self, forKey: .scanStatus)
        scanStatus = scanStatusDecoded
        let resourceMetadataDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceScanMetadata.self, forKey: .resourceMetadata)
        resourceMetadata = resourceMetadataDecoded
        let lastScannedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastScannedAt)
        lastScannedAt = lastScannedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about a resource covered by Amazon Inspector.
    public struct CoveredResource: Swift.Equatable {
        /// The Amazon Web Services account ID of the covered resource.
        /// This member is required.
        public var accountId: Swift.String?
        /// The date and time the resource was last checked for vulnerabilities.
        public var lastScannedAt: ClientRuntime.Date?
        /// The ID of the covered resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that contains details about the metadata.
        public var resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata?
        /// The type of the covered resource.
        /// This member is required.
        public var resourceType: Inspector2ClientTypes.CoverageResourceType?
        /// The status of the scan covering the resource.
        public var scanStatus: Inspector2ClientTypes.ScanStatus?
        /// The Amazon Inspector scan type covering the resource.
        /// This member is required.
        public var scanType: Inspector2ClientTypes.ScanType?

        public init(
            accountId: Swift.String? = nil,
            lastScannedAt: ClientRuntime.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata? = nil,
            resourceType: Inspector2ClientTypes.CoverageResourceType? = nil,
            scanStatus: Inspector2ClientTypes.ScanStatus? = nil,
            scanType: Inspector2ClientTypes.ScanType? = nil
        )
        {
            self.accountId = accountId
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceMetadata = resourceMetadata
            self.resourceType = resourceType
            self.scanStatus = scanStatus
            self.scanType = scanType
        }
    }

}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterCriteria
        case name
        case reason
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/create"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// Defines the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// Defines the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
    /// This member is required.
    public var name: Swift.String?
    /// The reason for creating the filter.
    public var reason: Swift.String?
    /// A list of tags for the filter.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil,
        reason: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterCriteria = filterCriteria
        self.name = name
        self.reason = reason
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let action: Inspector2ClientTypes.FilterAction?
    let description: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let reason: Swift.String?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterCriteria
        case name
        case reason
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateFilterOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the successfully created filter.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateFilterOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFindingsReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case reportFormat
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let reportFormat = self.reportFormat {
            try encodeContainer.encode(reportFormat.rawValue, forKey: .reportFormat)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }
}

extension CreateFindingsReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/create"
    }
}

public struct CreateFindingsReportInput: Swift.Equatable {
    /// The filter criteria to apply to the results of the finding report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The format to generate the report in.
    /// This member is required.
    public var reportFormat: Inspector2ClientTypes.ReportFormat?
    /// The Amazon S3 export destination for the report.
    /// This member is required.
    public var s3Destination: Inspector2ClientTypes.Destination?

    public init(
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportFormat: Inspector2ClientTypes.ReportFormat? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.reportFormat = reportFormat
        self.s3Destination = s3Destination
    }
}

struct CreateFindingsReportInputBody: Swift.Equatable {
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let reportFormat: Inspector2ClientTypes.ReportFormat?
    let s3Destination: Inspector2ClientTypes.Destination?
}

extension CreateFindingsReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case reportFormat
        case s3Destination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let reportFormatDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ReportFormat.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension CreateFindingsReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFindingsReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CreateFindingsReportOutput: Swift.Equatable {
    /// The ID of the report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CreateFindingsReportOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CreateFindingsReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum CreateFindingsReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSbomExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportFormat
        case resourceFilterCriteria
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportFormat = self.reportFormat {
            try encodeContainer.encode(reportFormat.rawValue, forKey: .reportFormat)
        }
        if let resourceFilterCriteria = self.resourceFilterCriteria {
            try encodeContainer.encode(resourceFilterCriteria, forKey: .resourceFilterCriteria)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }
}

extension CreateSbomExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sbomexport/create"
    }
}

public struct CreateSbomExportInput: Swift.Equatable {
    /// The output format for the software bill of materials (SBOM) report.
    /// This member is required.
    public var reportFormat: Inspector2ClientTypes.SbomReportFormat?
    /// The resource filter criteria for the software bill of materials (SBOM) report.
    public var resourceFilterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    /// This member is required.
    public var s3Destination: Inspector2ClientTypes.Destination?

    public init(
        reportFormat: Inspector2ClientTypes.SbomReportFormat? = nil,
        resourceFilterCriteria: Inspector2ClientTypes.ResourceFilterCriteria? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil
    )
    {
        self.reportFormat = reportFormat
        self.resourceFilterCriteria = resourceFilterCriteria
        self.s3Destination = s3Destination
    }
}

struct CreateSbomExportInputBody: Swift.Equatable {
    let resourceFilterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
    let reportFormat: Inspector2ClientTypes.SbomReportFormat?
    let s3Destination: Inspector2ClientTypes.Destination?
}

extension CreateSbomExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportFormat
        case resourceFilterCriteria
        case s3Destination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceFilterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceFilterCriteria.self, forKey: .resourceFilterCriteria)
        resourceFilterCriteria = resourceFilterCriteriaDecoded
        let reportFormatDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SbomReportFormat.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension CreateSbomExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSbomExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CreateSbomExportOutput: Swift.Equatable {
    /// The report ID for the software bill of materials (SBOM) report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CreateSbomExportOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CreateSbomExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum CreateSbomExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Currency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [Currency] {
            return [
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Currency(rawValue: rawValue) ?? Currency.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Cvss2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseScore != 0.0 {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore) ?? 0.0
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
    }
}

extension Inspector2ClientTypes {
    /// The Common Vulnerability Scoring System (CVSS) version 2 details for the vulnerability.
    public struct Cvss2: Swift.Equatable {
        /// The CVSS v2 base score for the vulnerability.
        public var baseScore: Swift.Double
        /// The scoring vector associated with the CVSS v2 score.
        public var scoringVector: Swift.String?

        public init(
            baseScore: Swift.Double = 0.0,
            scoringVector: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }
    }

}

extension Inspector2ClientTypes.Cvss3: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseScore != 0.0 {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore) ?? 0.0
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
    }
}

extension Inspector2ClientTypes {
    /// The Common Vulnerability Scoring System (CVSS) version 3 details for the vulnerability.
    public struct Cvss3: Swift.Equatable {
        /// The CVSS v3 base score for the vulnerability.
        public var baseScore: Swift.Double
        /// The scoring vector associated with the CVSS v3 score.
        public var scoringVector: Swift.String?

        public init(
            baseScore: Swift.Double = 0.0,
            scoringVector: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }
    }

}

extension Inspector2ClientTypes.CvssScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
        case source
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseScore = self.baseScore {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore)
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension Inspector2ClientTypes {
    /// The CVSS score for a finding.
    public struct CvssScore: Swift.Equatable {
        /// The base CVSS score used for the finding.
        /// This member is required.
        public var baseScore: Swift.Double?
        /// The vector string of the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        /// This member is required.
        public var source: Swift.String?
        /// The version of CVSS used for the score.
        /// This member is required.
        public var version: Swift.String?

        public init(
            baseScore: Swift.Double? = nil,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }

}

extension Inspector2ClientTypes.CvssScoreAdjustment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details on adjustments Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment: Swift.Equatable {
        /// The metric used to adjust the CVSS score.
        /// This member is required.
        public var metric: Swift.String?
        /// The reason the CVSS score has been adjustment.
        /// This member is required.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension Inspector2ClientTypes.CvssScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustments
        case cvssSource
        case score
        case scoreSource
        case scoringVector
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustments = adjustments {
            var adjustmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adjustments)
            for cvssscoreadjustment0 in adjustments {
                try adjustmentsContainer.encode(cvssscoreadjustment0)
            }
        }
        if let cvssSource = self.cvssSource {
            try encodeContainer.encode(cvssSource, forKey: .cvssSource)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let scoreSource = self.scoreSource {
            try encodeContainer.encode(scoreSource, forKey: .scoreSource)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoreSource)
        scoreSource = scoreSourceDecoded
        let cvssSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cvssSource)
        cvssSource = cvssSourceDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let adjustmentsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CvssScoreAdjustment?].self, forKey: .adjustments)
        var adjustmentsDecoded0:[Inspector2ClientTypes.CvssScoreAdjustment]? = nil
        if let adjustmentsContainer = adjustmentsContainer {
            adjustmentsDecoded0 = [Inspector2ClientTypes.CvssScoreAdjustment]()
            for structure0 in adjustmentsContainer {
                if let structure0 = structure0 {
                    adjustmentsDecoded0?.append(structure0)
                }
            }
        }
        adjustments = adjustmentsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about the CVSS score.
    public struct CvssScoreDetails: Swift.Equatable {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public var adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]?
        /// The source of the CVSS data.
        public var cvssSource: Swift.String?
        /// The CVSS score.
        /// This member is required.
        public var score: Swift.Double?
        /// The source for the CVSS score.
        /// This member is required.
        public var scoreSource: Swift.String?
        /// The vector for the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The CVSS version used in scoring.
        /// This member is required.
        public var version: Swift.String?

        public init(
            adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]? = nil,
            cvssSource: Swift.String? = nil,
            score: Swift.Double? = nil,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }

}

extension Inspector2ClientTypes.DateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endInclusive
        case startInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endInclusive = self.endInclusive {
            try encodeContainer.encodeTimestamp(endInclusive, format: .epochSeconds, forKey: .endInclusive)
        }
        if let startInclusive = self.startInclusive {
            try encodeContainer.encodeTimestamp(startInclusive, format: .epochSeconds, forKey: .startInclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startInclusive)
        startInclusive = startInclusiveDecoded
        let endInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endInclusive)
        endInclusive = endInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details on the time range used to filter findings.
    public struct DateFilter: Swift.Equatable {
        /// A timestamp representing the end of the time period filtered on.
        public var endInclusive: ClientRuntime.Date?
        /// A timestamp representing the start of the time period filtered on.
        public var startInclusive: ClientRuntime.Date?

        public init(
            endInclusive: ClientRuntime.Date? = nil,
            startInclusive: ClientRuntime.Date? = nil
        )
        {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }
    }

}

extension Inspector2ClientTypes.DelegatedAdmin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case relationshipStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdmin: Swift.Equatable {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?

        public init(
            accountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil
        )
        {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension Inspector2ClientTypes.DelegatedAdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.DelegatedAdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdminAccount: Swift.Equatable {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var status: Inspector2ClientTypes.DelegatedAdminStatus?

        public init(
            accountId: Swift.String? = nil,
            status: Inspector2ClientTypes.DelegatedAdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    public enum DelegatedAdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegatedAdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DelegatedAdminStatus(rawValue: rawValue) ?? DelegatedAdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/delete"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the filter to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteFilterOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the filter that has been deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteFilterOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizationconfiguration/describe"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.maxAccountLimitReached = output.maxAccountLimitReached
        } else {
            self.autoEnable = nil
            self.maxAccountLimitReached = nil
        }
    }
}

public struct DescribeOrganizationConfigurationOutput: Swift.Equatable {
    /// The scan types are automatically enabled for new members of your organization.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?
    /// Represents whether your organization has reached the maximum Amazon Web Services account limit for Amazon Inspector.
    public var maxAccountLimitReached: Swift.Bool?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil,
        maxAccountLimitReached: Swift.Bool? = nil
    )
    {
        self.autoEnable = autoEnable
        self.maxAccountLimitReached = maxAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
    let maxAccountLimitReached: Swift.Bool?
}

extension DescribeOrganizationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
        case maxAccountLimitReached
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let maxAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .maxAccountLimitReached)
        maxAccountLimitReached = maxAccountLimitReachedDecoded
    }
}

enum DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case keyPrefix
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let keyPrefix = self.keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    public struct Destination: Swift.Equatable {
        /// The name of the Amazon S3 bucket to export findings to.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The prefix that the findings will be written under.
        public var keyPrefix: Swift.String?
        /// The ARN of the KMS key used to encrypt data when exporting findings.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension DisableDelegatedAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccountId = self.delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension DisableDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/disable"
    }
}

public struct DisableDelegatedAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the current Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DisableDelegatedAdminAccountInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DisableDelegatedAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension DisableDelegatedAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableDelegatedAdminAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccountId = output.delegatedAdminAccountId
        } else {
            self.delegatedAdminAccountId = nil
        }
    }
}

public struct DisableDelegatedAdminAccountOutput: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully disabled delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DisableDelegatedAdminAccountOutputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DisableDelegatedAdminAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

enum DisableDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcescantype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcescantype0.rawValue)
            }
        }
    }
}

extension DisableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disable"
    }
}

public struct DisableInput: Swift.Equatable {
    /// An array of account IDs you want to disable Amazon Inspector scans for.
    public var accountIds: [Swift.String]?
    /// The resource scan types you want to disable.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init(
        accountIds: [Swift.String]? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.resourceTypes = resourceTypes
    }
}

struct DisableInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let resourceTypes: [Inspector2ClientTypes.ResourceScanType]?
}

extension DisableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case resourceTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceScanType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Inspector2ClientTypes.ResourceScanType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Inspector2ClientTypes.ResourceScanType]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension DisableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct DisableOutput: Swift.Equatable {
    /// Information on the accounts that have had Amazon Inspector scans successfully disabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be disabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct DisableOutputBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.Account]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension DisableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

enum DisableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension DisassociateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/disassociate"
    }
}

public struct DisassociateMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to disassociate.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DisassociateMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension DisassociateMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DisassociateMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
        } else {
            self.accountId = nil
        }
    }
}

public struct DisassociateMemberOutput: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully disassociated member.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DisassociateMemberOutputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension DisassociateMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

enum DisassociateMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Ec2DeepInspectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case deactivated
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2DeepInspectionStatus] {
            return [
                .activated,
                .deactivated,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2DeepInspectionStatus(rawValue: rawValue) ?? Ec2DeepInspectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Ec2InstanceAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case instanceIds
        case instanceTags
        case operatingSystems
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for stringfilter0 in amis {
                try amisContainer.encode(stringfilter0)
            }
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for stringfilter0 in instanceIds {
                try instanceIdsContainer.encode(stringfilter0)
            }
        }
        if let instanceTags = instanceTags {
            var instanceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTags)
            for mapfilter0 in instanceTags {
                try instanceTagsContainer.encode(mapfilter0)
            }
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for stringfilter0 in operatingSystems {
                try operatingSystemsContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .amis)
        var amisDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in operatingSystemsContainer {
                if let structure0 = structure0 {
                    operatingSystemsDecoded0?.append(structure0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in instanceIdsContainer {
                if let structure0 = structure0 {
                    instanceIdsDecoded0?.append(structure0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let instanceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MapFilter?].self, forKey: .instanceTags)
        var instanceTagsDecoded0:[Inspector2ClientTypes.MapFilter]? = nil
        if let instanceTagsContainer = instanceTagsContainer {
            instanceTagsDecoded0 = [Inspector2ClientTypes.MapFilter]()
            for structure0 in instanceTagsContainer {
                if let structure0 = structure0 {
                    instanceTagsDecoded0?.append(structure0)
                }
            }
        }
        instanceTags = instanceTagsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon EC2 instances.
    public struct Ec2InstanceAggregation: Swift.Equatable {
        /// The AMI IDs associated with the Amazon EC2 instances to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance IDs to aggregate findings for.
        public var instanceIds: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance tags to aggregate findings for.
        public var instanceTags: [Inspector2ClientTypes.MapFilter]?
        /// The operating system types to aggregate findings for. Valid values must be uppercase and underscore separated, examples are ORACLE_LINUX_7 and ALPINE_LINUX_3_8.
        public var operatingSystems: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.Ec2InstanceSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            operatingSystems: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.Ec2InstanceSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.instanceIds = instanceIds
            self.instanceTags = instanceTags
            self.operatingSystems = operatingSystems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.Ec2InstanceAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ami
        case instanceId
        case instanceTags
        case networkFindings
        case operatingSystem
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let ami = self.ami {
            try encodeContainer.encode(ami, forKey: .ami)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceTags = instanceTags {
            var instanceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .instanceTags)
            for (dictKey0, tagMap0) in instanceTags {
                try instanceTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let networkFindings = self.networkFindings {
            try encodeContainer.encode(networkFindings, forKey: .networkFindings)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let amiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ami)
        ami = amiDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let instanceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .instanceTags)
        var instanceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let instanceTagsContainer = instanceTagsContainer {
            instanceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in instanceTagsContainer {
                if let mapvalue0 = mapvalue0 {
                    instanceTagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        instanceTags = instanceTagsDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let networkFindingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkFindings)
        networkFindings = networkFindingsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by Amazon EC2 instance.
    public struct Ec2InstanceAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account for the Amazon EC2 instance.
        public var accountId: Swift.String?
        /// The Amazon Machine Image (AMI) of the Amazon EC2 instance.
        public var ami: Swift.String?
        /// The Amazon EC2 instance ID.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The tags attached to the instance.
        public var instanceTags: [Swift.String:Swift.String]?
        /// The number of network findings for the Amazon EC2 instance.
        public var networkFindings: Swift.Int?
        /// The operating system of the Amazon EC2 instance.
        public var operatingSystem: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            ami: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceTags: [Swift.String:Swift.String]? = nil,
            networkFindings: Swift.Int? = nil,
            operatingSystem: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.ami = ami
            self.instanceId = instanceId
            self.instanceTags = instanceTags
            self.networkFindings = networkFindings
            self.operatingSystem = operatingSystem
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum Ec2InstanceSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case networkFindings
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2InstanceSortBy] {
            return [
                .all,
                .critical,
                .high,
                .networkFindings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .networkFindings: return "NETWORK_FINDINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2InstanceSortBy(rawValue: rawValue) ?? Ec2InstanceSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Ec2Metadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2Platform.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// Meta data details of an Amazon EC2 instance.
    public struct Ec2Metadata: Swift.Equatable {
        /// The ID of the Amazon Machine Image (AMI) used to launch the instance.
        public var amiId: Swift.String?
        /// The platform of the instance.
        public var platform: Inspector2ClientTypes.Ec2Platform?
        /// The tags attached to the instance.
        public var tags: [Swift.String:Swift.String]?

        public init(
            amiId: Swift.String? = nil,
            platform: Inspector2ClientTypes.Ec2Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.amiId = amiId
            self.platform = platform
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes {
    public enum Ec2Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case unknown
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2Platform] {
            return [
                .linux,
                .unknown,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .unknown: return "UNKNOWN"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2Platform(rawValue: rawValue) ?? Ec2Platform.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.EcrConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rescanDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rescanDuration = self.rescanDuration {
            try encodeContainer.encode(rescanDuration.rawValue, forKey: .rescanDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rescanDurationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRescanDuration.self, forKey: .rescanDuration)
        rescanDuration = rescanDurationDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the ECR automated re-scan duration setting for your environment.
    public struct EcrConfiguration: Swift.Equatable {
        /// The ECR automated re-scan duration defines how long an ECR image will be actively scanned by Amazon Inspector. When the number of days since an image was last pushed exceeds the automated re-scan duration the monitoring state of that image becomes inactive and all associated findings are scheduled for closure.
        /// This member is required.
        public var rescanDuration: Inspector2ClientTypes.EcrRescanDuration?

        public init(
            rescanDuration: Inspector2ClientTypes.EcrRescanDuration? = nil
        )
        {
            self.rescanDuration = rescanDuration
        }
    }

}

extension Inspector2ClientTypes.EcrConfigurationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rescanDurationState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rescanDurationState = self.rescanDurationState {
            try encodeContainer.encode(rescanDurationState, forKey: .rescanDurationState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rescanDurationStateDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRescanDurationState.self, forKey: .rescanDurationState)
        rescanDurationState = rescanDurationStateDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the state of the ECR scans for your environment.
    public struct EcrConfigurationState: Swift.Equatable {
        /// An object that contains details about the state of the ECR automated re-scan setting.
        public var rescanDurationState: Inspector2ClientTypes.EcrRescanDurationState?

        public init(
            rescanDurationState: Inspector2ClientTypes.EcrRescanDurationState? = nil
        )
        {
            self.rescanDurationState = rescanDurationState
        }
    }

}

extension Inspector2ClientTypes.EcrContainerImageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for string0 in tags {
                try tagsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR image metadata associated with a finding.
    public struct EcrContainerImageMetadata: Swift.Equatable {
        /// Tags associated with the Amazon ECR image metadata.
        public var tags: [Swift.String]?

        public init(
            tags: [Swift.String]? = nil
        )
        {
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes.EcrRepositoryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case scanFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scanFrequency = self.scanFrequency {
            try encodeContainer.encode(scanFrequency.rawValue, forKey: .scanFrequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scanFrequencyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrScanFrequency.self, forKey: .scanFrequency)
        scanFrequency = scanFrequencyDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR repository metadata associated with a finding.
    public struct EcrRepositoryMetadata: Swift.Equatable {
        /// The name of the Amazon ECR repository.
        public var name: Swift.String?
        /// The frequency of scans.
        public var scanFrequency: Inspector2ClientTypes.EcrScanFrequency?

        public init(
            name: Swift.String? = nil,
            scanFrequency: Inspector2ClientTypes.EcrScanFrequency? = nil
        )
        {
            self.name = name
            self.scanFrequency = scanFrequency
        }
    }

}

extension Inspector2ClientTypes {
    public enum EcrRescanDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days180
        case days30
        case lifetime
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrRescanDuration] {
            return [
                .days180,
                .days30,
                .lifetime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days180: return "DAYS_180"
            case .days30: return "DAYS_30"
            case .lifetime: return "LIFETIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EcrRescanDuration(rawValue: rawValue) ?? EcrRescanDuration.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.EcrRescanDurationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rescanDuration
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rescanDuration = self.rescanDuration {
            try encodeContainer.encode(rescanDuration.rawValue, forKey: .rescanDuration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rescanDurationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRescanDuration.self, forKey: .rescanDuration)
        rescanDuration = rescanDurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRescanDurationStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the state of any changes to the ECR automated re-scan duration setting.
    public struct EcrRescanDurationState: Swift.Equatable {
        /// The ECR automated re-scan duration defines how long an ECR image will be actively scanned by Amazon Inspector. When the number of days since an image was last pushed exceeds the automated re-scan duration the monitoring state of that image becomes inactive and all associated findings are scheduled for closure.
        public var rescanDuration: Inspector2ClientTypes.EcrRescanDuration?
        /// The status of changes to the ECR automated re-scan duration.
        public var status: Inspector2ClientTypes.EcrRescanDurationStatus?
        /// A timestamp representing when the last time the ECR scan duration setting was changed.
        public var updatedAt: ClientRuntime.Date?

        public init(
            rescanDuration: Inspector2ClientTypes.EcrRescanDuration? = nil,
            status: Inspector2ClientTypes.EcrRescanDurationStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.rescanDuration = rescanDuration
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum EcrRescanDurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrRescanDurationStatus] {
            return [
                .failed,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EcrRescanDurationStatus(rawValue: rawValue) ?? EcrRescanDurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum EcrScanFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuousScan
        case manual
        case scanOnPush
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrScanFrequency] {
            return [
                .continuousScan,
                .manual,
                .scanOnPush,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuousScan: return "CONTINUOUS_SCAN"
            case .manual: return "MANUAL"
            case .scanOnPush: return "SCAN_ON_PUSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EcrScanFrequency(rawValue: rawValue) ?? EcrScanFrequency.sdkUnknown(rawValue)
        }
    }
}

extension EnableDelegatedAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case delegatedAdminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let delegatedAdminAccountId = self.delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension EnableDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/enable"
    }
}

public struct EnableDelegatedAdminAccountInput: Swift.Equatable {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct EnableDelegatedAdminAccountInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
    let clientToken: Swift.String?
}

extension EnableDelegatedAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case delegatedAdminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableDelegatedAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableDelegatedAdminAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccountId = output.delegatedAdminAccountId
        } else {
            self.delegatedAdminAccountId = nil
        }
    }
}

public struct EnableDelegatedAdminAccountOutput: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct EnableDelegatedAdminAccountOutputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension EnableDelegatedAdminAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

enum EnableDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case clientToken
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcescantype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcescantype0.rawValue)
            }
        }
    }
}

extension EnableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enable"
    }
}

public struct EnableInput: Swift.Equatable {
    /// A list of account IDs you want to enable Amazon Inspector scans for.
    public var accountIds: [Swift.String]?
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The resource scan types you want to enable.
    /// This member is required.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init(
        accountIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.clientToken = clientToken
        self.resourceTypes = resourceTypes
    }
}

struct EnableInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let resourceTypes: [Inspector2ClientTypes.ResourceScanType]?
    let clientToken: Swift.String?
}

extension EnableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case clientToken
        case resourceTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceScanType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Inspector2ClientTypes.ResourceScanType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Inspector2ClientTypes.ResourceScanType]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct EnableOutput: Swift.Equatable {
    /// Information on the accounts that have had Amazon Inspector scans successfully enabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be enabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init(
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct EnableOutputBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.Account]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension EnableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

enum EnableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.Epss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the Exploit Prediction Scoring System (EPSS) score.
    public struct Epss: Swift.Equatable {
        /// The Exploit Prediction Scoring System (EPSS) score.
        public var score: Swift.Double

        public init(
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension Inspector2ClientTypes.EpssDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the Exploit Prediction Scoring System (EPSS) score for a finding.
    public struct EpssDetails: Swift.Equatable {
        /// The EPSS score.
        public var score: Swift.Double

        public init(
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension Inspector2ClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case accountIsIsolated
        case alreadyEnabled
        case disableInProgress
        case disassociateAllMembers
        case enableInProgress
        case eventbridgeThrottled
        case eventbridgeUnavailable
        case internalError
        case resourceNotFound
        case resourceScanNotDisabled
        case ssmThrottled
        case ssmUnavailable
        case suspendInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .accountIsIsolated,
                .alreadyEnabled,
                .disableInProgress,
                .disassociateAllMembers,
                .enableInProgress,
                .eventbridgeThrottled,
                .eventbridgeUnavailable,
                .internalError,
                .resourceNotFound,
                .resourceScanNotDisabled,
                .ssmThrottled,
                .ssmUnavailable,
                .suspendInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .accountIsIsolated: return "ACCOUNT_IS_ISOLATED"
            case .alreadyEnabled: return "ALREADY_ENABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .disassociateAllMembers: return "DISASSOCIATE_ALL_MEMBERS"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case .eventbridgeThrottled: return "EVENTBRIDGE_THROTTLED"
            case .eventbridgeUnavailable: return "EVENTBRIDGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .resourceScanNotDisabled: return "RESOURCE_SCAN_NOT_DISABLED"
            case .ssmThrottled: return "SSM_THROTTLED"
            case .ssmUnavailable: return "SSM_UNAVAILABLE"
            case .suspendInProgress: return "SUSPEND_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceDetail
        case evidenceRule
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceDetail = self.evidenceDetail {
            try encodeContainer.encode(evidenceDetail, forKey: .evidenceDetail)
        }
        if let evidenceRule = self.evidenceRule {
            try encodeContainer.encode(evidenceRule, forKey: .evidenceRule)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceRule)
        evidenceRule = evidenceRuleDecoded
        let evidenceDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceDetail)
        evidenceDetail = evidenceDetailDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the evidence for a vulnerability identified in a finding.
    public struct Evidence: Swift.Equatable {
        /// The evidence details.
        public var evidenceDetail: Swift.String?
        /// The evidence rule.
        public var evidenceRule: Swift.String?
        /// The evidence severity.
        public var severity: Swift.String?

        public init(
            evidenceDetail: Swift.String? = nil,
            evidenceRule: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.evidenceDetail = evidenceDetail
            self.evidenceRule = evidenceRule
            self.severity = severity
        }
    }

}

extension Inspector2ClientTypes {
    public enum ExploitAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [ExploitAvailable] {
            return [
                .no,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExploitAvailable(rawValue: rawValue) ?? ExploitAvailable.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ExploitObserved: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstSeen
        case lastSeen
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstSeen = self.firstSeen {
            try encodeContainer.encodeTimestamp(firstSeen, format: .epochSeconds, forKey: .firstSeen)
        }
        if let lastSeen = self.lastSeen {
            try encodeContainer.encodeTimestamp(lastSeen, format: .epochSeconds, forKey: .lastSeen)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastSeenDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
        let firstSeenDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on when this exploit was observed.
    public struct ExploitObserved: Swift.Equatable {
        /// The date an time when the exploit was first seen.
        public var firstSeen: ClientRuntime.Date?
        /// The date an time when the exploit was last seen.
        public var lastSeen: ClientRuntime.Date?

        public init(
            firstSeen: ClientRuntime.Date? = nil,
            lastSeen: ClientRuntime.Date? = nil
        )
        {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }
    }

}

extension Inspector2ClientTypes.ExploitabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastKnownExploitAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastKnownExploitAt = self.lastKnownExploitAt {
            try encodeContainer.encodeTimestamp(lastKnownExploitAt, format: .epochSeconds, forKey: .lastKnownExploitAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastKnownExploitAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastKnownExploitAt)
        lastKnownExploitAt = lastKnownExploitAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details of an exploit available for a finding discovered in your environment.
    public struct ExploitabilityDetails: Swift.Equatable {
        /// The date and time of the last exploit associated with a finding discovered in your environment.
        public var lastKnownExploitAt: ClientRuntime.Date?

        public init(
            lastKnownExploitAt: ClientRuntime.Date? = nil
        )
        {
            self.lastKnownExploitAt = lastKnownExploitAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum ExternalReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalReportStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalReportStatus(rawValue: rawValue) ?? ExternalReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FailedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case errorCode
        case errorMessage
        case resourceStatus
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let resourceStatus = self.resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object with details on why an account failed to enable Amazon Inspector.
    public struct FailedAccount: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        public var status: Inspector2ClientTypes.Status?

        public init(
            accountId: Swift.String? = nil,
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

extension Inspector2ClientTypes.FailedMemberAccountEc2DeepInspectionStatusState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ec2ScanStatus
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let ec2ScanStatus = self.ec2ScanStatus {
            try encodeContainer.encode(ec2ScanStatus.rawValue, forKey: .ec2ScanStatus)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let ec2ScanStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .ec2ScanStatus)
        ec2ScanStatus = ec2ScanStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about a member account in your organization that failed to activate Amazon Inspector deep inspection.
    public struct FailedMemberAccountEc2DeepInspectionStatusState: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account of the organization member that failed to activate Amazon Inspector deep inspection.
        /// This member is required.
        public var accountId: Swift.String?
        /// The status of EC2 scanning in the account that failed to activate Amazon Inspector deep inspection.
        public var ec2ScanStatus: Inspector2ClientTypes.Status?
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public var errorMessage: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            ec2ScanStatus: Inspector2ClientTypes.Status? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.ec2ScanStatus = ec2ScanStatus
            self.errorMessage = errorMessage
        }
    }

}

extension Inspector2ClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case createdAt
        case criteria
        case description
        case name
        case ownerId
        case reason
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let criteria = self.criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Details about a filter.
    public struct Filter: Swift.Equatable {
        /// The action that is to be applied to the findings that match the filter.
        /// This member is required.
        public var action: Inspector2ClientTypes.FilterAction?
        /// The Amazon Resource Number (ARN) associated with this filter.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time this filter was created at.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Details on the filter criteria associated with this filter.
        /// This member is required.
        public var criteria: Inspector2ClientTypes.FilterCriteria?
        /// A description of the filter.
        public var description: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the account that created the filter.
        /// This member is required.
        public var ownerId: Swift.String?
        /// The reason for the filter.
        public var reason: Swift.String?
        /// The tags attached to the filter.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time the filter was last updated at.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            action: Inspector2ClientTypes.FilterAction? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            criteria: Inspector2ClientTypes.FilterCriteria? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            reason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.criteria = criteria
            self.description = description
            self.name = name
            self.ownerId = ownerId
            self.reason = reason
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .none,
                .suppress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case codeVulnerabilityDetectorName
        case codeVulnerabilityDetectorTags
        case codeVulnerabilityFilePath
        case componentId
        case componentType
        case ec2InstanceImageId
        case ec2InstanceSubnetId
        case ec2InstanceVpcId
        case ecrImageArchitecture
        case ecrImageHash
        case ecrImagePushedAt
        case ecrImageRegistry
        case ecrImageRepositoryName
        case ecrImageTags
        case epssScore
        case exploitAvailable
        case findingArn
        case findingStatus
        case findingType
        case firstObservedAt
        case fixAvailable
        case inspectorScore
        case lambdaFunctionExecutionRoleArn
        case lambdaFunctionLastModifiedAt
        case lambdaFunctionLayers
        case lambdaFunctionName
        case lambdaFunctionRuntime
        case lastObservedAt
        case networkProtocol
        case portRange
        case relatedVulnerabilities
        case resourceId
        case resourceTags
        case resourceType
        case severity
        case title
        case updatedAt
        case vendorSeverity
        case vulnerabilityId
        case vulnerabilitySource
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            var awsAccountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountId)
            for stringfilter0 in awsAccountId {
                try awsAccountIdContainer.encode(stringfilter0)
            }
        }
        if let codeVulnerabilityDetectorName = codeVulnerabilityDetectorName {
            var codeVulnerabilityDetectorNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeVulnerabilityDetectorName)
            for stringfilter0 in codeVulnerabilityDetectorName {
                try codeVulnerabilityDetectorNameContainer.encode(stringfilter0)
            }
        }
        if let codeVulnerabilityDetectorTags = codeVulnerabilityDetectorTags {
            var codeVulnerabilityDetectorTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeVulnerabilityDetectorTags)
            for stringfilter0 in codeVulnerabilityDetectorTags {
                try codeVulnerabilityDetectorTagsContainer.encode(stringfilter0)
            }
        }
        if let codeVulnerabilityFilePath = codeVulnerabilityFilePath {
            var codeVulnerabilityFilePathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeVulnerabilityFilePath)
            for stringfilter0 in codeVulnerabilityFilePath {
                try codeVulnerabilityFilePathContainer.encode(stringfilter0)
            }
        }
        if let componentId = componentId {
            var componentIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentId)
            for stringfilter0 in componentId {
                try componentIdContainer.encode(stringfilter0)
            }
        }
        if let componentType = componentType {
            var componentTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentType)
            for stringfilter0 in componentType {
                try componentTypeContainer.encode(stringfilter0)
            }
        }
        if let ec2InstanceImageId = ec2InstanceImageId {
            var ec2InstanceImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceImageId)
            for stringfilter0 in ec2InstanceImageId {
                try ec2InstanceImageIdContainer.encode(stringfilter0)
            }
        }
        if let ec2InstanceSubnetId = ec2InstanceSubnetId {
            var ec2InstanceSubnetIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceSubnetId)
            for stringfilter0 in ec2InstanceSubnetId {
                try ec2InstanceSubnetIdContainer.encode(stringfilter0)
            }
        }
        if let ec2InstanceVpcId = ec2InstanceVpcId {
            var ec2InstanceVpcIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceVpcId)
            for stringfilter0 in ec2InstanceVpcId {
                try ec2InstanceVpcIdContainer.encode(stringfilter0)
            }
        }
        if let ecrImageArchitecture = ecrImageArchitecture {
            var ecrImageArchitectureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageArchitecture)
            for stringfilter0 in ecrImageArchitecture {
                try ecrImageArchitectureContainer.encode(stringfilter0)
            }
        }
        if let ecrImageHash = ecrImageHash {
            var ecrImageHashContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageHash)
            for stringfilter0 in ecrImageHash {
                try ecrImageHashContainer.encode(stringfilter0)
            }
        }
        if let ecrImagePushedAt = ecrImagePushedAt {
            var ecrImagePushedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImagePushedAt)
            for datefilter0 in ecrImagePushedAt {
                try ecrImagePushedAtContainer.encode(datefilter0)
            }
        }
        if let ecrImageRegistry = ecrImageRegistry {
            var ecrImageRegistryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageRegistry)
            for stringfilter0 in ecrImageRegistry {
                try ecrImageRegistryContainer.encode(stringfilter0)
            }
        }
        if let ecrImageRepositoryName = ecrImageRepositoryName {
            var ecrImageRepositoryNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageRepositoryName)
            for stringfilter0 in ecrImageRepositoryName {
                try ecrImageRepositoryNameContainer.encode(stringfilter0)
            }
        }
        if let ecrImageTags = ecrImageTags {
            var ecrImageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageTags)
            for stringfilter0 in ecrImageTags {
                try ecrImageTagsContainer.encode(stringfilter0)
            }
        }
        if let epssScore = epssScore {
            var epssScoreContainer = encodeContainer.nestedUnkeyedContainer(forKey: .epssScore)
            for numberfilter0 in epssScore {
                try epssScoreContainer.encode(numberfilter0)
            }
        }
        if let exploitAvailable = exploitAvailable {
            var exploitAvailableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exploitAvailable)
            for stringfilter0 in exploitAvailable {
                try exploitAvailableContainer.encode(stringfilter0)
            }
        }
        if let findingArn = findingArn {
            var findingArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArn)
            for stringfilter0 in findingArn {
                try findingArnContainer.encode(stringfilter0)
            }
        }
        if let findingStatus = findingStatus {
            var findingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatus)
            for stringfilter0 in findingStatus {
                try findingStatusContainer.encode(stringfilter0)
            }
        }
        if let findingType = findingType {
            var findingTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingType)
            for stringfilter0 in findingType {
                try findingTypeContainer.encode(stringfilter0)
            }
        }
        if let firstObservedAt = firstObservedAt {
            var firstObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .firstObservedAt)
            for datefilter0 in firstObservedAt {
                try firstObservedAtContainer.encode(datefilter0)
            }
        }
        if let fixAvailable = fixAvailable {
            var fixAvailableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fixAvailable)
            for stringfilter0 in fixAvailable {
                try fixAvailableContainer.encode(stringfilter0)
            }
        }
        if let inspectorScore = inspectorScore {
            var inspectorScoreContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inspectorScore)
            for numberfilter0 in inspectorScore {
                try inspectorScoreContainer.encode(numberfilter0)
            }
        }
        if let lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArn {
            var lambdaFunctionExecutionRoleArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionExecutionRoleArn)
            for stringfilter0 in lambdaFunctionExecutionRoleArn {
                try lambdaFunctionExecutionRoleArnContainer.encode(stringfilter0)
            }
        }
        if let lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAt {
            var lambdaFunctionLastModifiedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionLastModifiedAt)
            for datefilter0 in lambdaFunctionLastModifiedAt {
                try lambdaFunctionLastModifiedAtContainer.encode(datefilter0)
            }
        }
        if let lambdaFunctionLayers = lambdaFunctionLayers {
            var lambdaFunctionLayersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionLayers)
            for stringfilter0 in lambdaFunctionLayers {
                try lambdaFunctionLayersContainer.encode(stringfilter0)
            }
        }
        if let lambdaFunctionName = lambdaFunctionName {
            var lambdaFunctionNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionName)
            for stringfilter0 in lambdaFunctionName {
                try lambdaFunctionNameContainer.encode(stringfilter0)
            }
        }
        if let lambdaFunctionRuntime = lambdaFunctionRuntime {
            var lambdaFunctionRuntimeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionRuntime)
            for stringfilter0 in lambdaFunctionRuntime {
                try lambdaFunctionRuntimeContainer.encode(stringfilter0)
            }
        }
        if let lastObservedAt = lastObservedAt {
            var lastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastObservedAt)
            for datefilter0 in lastObservedAt {
                try lastObservedAtContainer.encode(datefilter0)
            }
        }
        if let networkProtocol = networkProtocol {
            var networkProtocolContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkProtocol)
            for stringfilter0 in networkProtocol {
                try networkProtocolContainer.encode(stringfilter0)
            }
        }
        if let portRange = portRange {
            var portRangeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRange)
            for portrangefilter0 in portRange {
                try portRangeContainer.encode(portrangefilter0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for stringfilter0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(stringfilter0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for stringfilter0 in resourceId {
                try resourceIdContainer.encode(stringfilter0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for mapfilter0 in resourceTags {
                try resourceTagsContainer.encode(mapfilter0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for stringfilter0 in resourceType {
                try resourceTypeContainer.encode(stringfilter0)
            }
        }
        if let severity = severity {
            var severityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severity)
            for stringfilter0 in severity {
                try severityContainer.encode(stringfilter0)
            }
        }
        if let title = title {
            var titleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .title)
            for stringfilter0 in title {
                try titleContainer.encode(stringfilter0)
            }
        }
        if let updatedAt = updatedAt {
            var updatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatedAt)
            for datefilter0 in updatedAt {
                try updatedAtContainer.encode(datefilter0)
            }
        }
        if let vendorSeverity = vendorSeverity {
            var vendorSeverityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vendorSeverity)
            for stringfilter0 in vendorSeverity {
                try vendorSeverityContainer.encode(stringfilter0)
            }
        }
        if let vulnerabilityId = vulnerabilityId {
            var vulnerabilityIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilityId)
            for stringfilter0 in vulnerabilityId {
                try vulnerabilityIdContainer.encode(stringfilter0)
            }
        }
        if let vulnerabilitySource = vulnerabilitySource {
            var vulnerabilitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilitySource)
            for stringfilter0 in vulnerabilitySource {
                try vulnerabilitySourceContainer.encode(stringfilter0)
            }
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for packagefilter0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(packagefilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingArn)
        var findingArnDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingArnContainer = findingArnContainer {
            findingArnDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingArnContainer {
                if let structure0 = structure0 {
                    findingArnDecoded0?.append(structure0)
                }
            }
        }
        findingArn = findingArnDecoded0
        let awsAccountIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .awsAccountId)
        var awsAccountIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let awsAccountIdContainer = awsAccountIdContainer {
            awsAccountIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in awsAccountIdContainer {
                if let structure0 = structure0 {
                    awsAccountIdDecoded0?.append(structure0)
                }
            }
        }
        awsAccountId = awsAccountIdDecoded0
        let findingTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingType)
        var findingTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingTypeContainer = findingTypeContainer {
            findingTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingTypeContainer {
                if let structure0 = structure0 {
                    findingTypeDecoded0?.append(structure0)
                }
            }
        }
        findingType = findingTypeDecoded0
        let severityContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .severity)
        var severityDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let severityContainer = severityContainer {
            severityDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in severityContainer {
                if let structure0 = structure0 {
                    severityDecoded0?.append(structure0)
                }
            }
        }
        severity = severityDecoded0
        let firstObservedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .firstObservedAt)
        var firstObservedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let firstObservedAtContainer = firstObservedAtContainer {
            firstObservedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in firstObservedAtContainer {
                if let structure0 = structure0 {
                    firstObservedAtDecoded0?.append(structure0)
                }
            }
        }
        firstObservedAt = firstObservedAtDecoded0
        let lastObservedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .lastObservedAt)
        var lastObservedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let lastObservedAtContainer = lastObservedAtContainer {
            lastObservedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in lastObservedAtContainer {
                if let structure0 = structure0 {
                    lastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        lastObservedAt = lastObservedAtDecoded0
        let updatedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .updatedAt)
        var updatedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let updatedAtContainer = updatedAtContainer {
            updatedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in updatedAtContainer {
                if let structure0 = structure0 {
                    updatedAtDecoded0?.append(structure0)
                }
            }
        }
        updatedAt = updatedAtDecoded0
        let findingStatusContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingStatus)
        var findingStatusDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingStatusContainer = findingStatusContainer {
            findingStatusDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingStatusContainer {
                if let structure0 = structure0 {
                    findingStatusDecoded0?.append(structure0)
                }
            }
        }
        findingStatus = findingStatusDecoded0
        let titleContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .title)
        var titleDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let titleContainer = titleContainer {
            titleDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in titleContainer {
                if let structure0 = structure0 {
                    titleDecoded0?.append(structure0)
                }
            }
        }
        title = titleDecoded0
        let inspectorScoreContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.NumberFilter?].self, forKey: .inspectorScore)
        var inspectorScoreDecoded0:[Inspector2ClientTypes.NumberFilter]? = nil
        if let inspectorScoreContainer = inspectorScoreContainer {
            inspectorScoreDecoded0 = [Inspector2ClientTypes.NumberFilter]()
            for structure0 in inspectorScoreContainer {
                if let structure0 = structure0 {
                    inspectorScoreDecoded0?.append(structure0)
                }
            }
        }
        inspectorScore = inspectorScoreDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MapFilter?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[Inspector2ClientTypes.MapFilter]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Inspector2ClientTypes.MapFilter]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let ec2InstanceImageIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceImageId)
        var ec2InstanceImageIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceImageIdContainer = ec2InstanceImageIdContainer {
            ec2InstanceImageIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceImageIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceImageIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceImageId = ec2InstanceImageIdDecoded0
        let ec2InstanceVpcIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceVpcId)
        var ec2InstanceVpcIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceVpcIdContainer = ec2InstanceVpcIdContainer {
            ec2InstanceVpcIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceVpcIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceVpcIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceVpcId = ec2InstanceVpcIdDecoded0
        let ec2InstanceSubnetIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceSubnetId)
        var ec2InstanceSubnetIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceSubnetIdContainer = ec2InstanceSubnetIdContainer {
            ec2InstanceSubnetIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceSubnetIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceSubnetIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceSubnetId = ec2InstanceSubnetIdDecoded0
        let ecrImagePushedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .ecrImagePushedAt)
        var ecrImagePushedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let ecrImagePushedAtContainer = ecrImagePushedAtContainer {
            ecrImagePushedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in ecrImagePushedAtContainer {
                if let structure0 = structure0 {
                    ecrImagePushedAtDecoded0?.append(structure0)
                }
            }
        }
        ecrImagePushedAt = ecrImagePushedAtDecoded0
        let ecrImageArchitectureContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageArchitecture)
        var ecrImageArchitectureDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageArchitectureContainer = ecrImageArchitectureContainer {
            ecrImageArchitectureDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageArchitectureContainer {
                if let structure0 = structure0 {
                    ecrImageArchitectureDecoded0?.append(structure0)
                }
            }
        }
        ecrImageArchitecture = ecrImageArchitectureDecoded0
        let ecrImageRegistryContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageRegistry)
        var ecrImageRegistryDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageRegistryContainer = ecrImageRegistryContainer {
            ecrImageRegistryDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageRegistryContainer {
                if let structure0 = structure0 {
                    ecrImageRegistryDecoded0?.append(structure0)
                }
            }
        }
        ecrImageRegistry = ecrImageRegistryDecoded0
        let ecrImageRepositoryNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageRepositoryName)
        var ecrImageRepositoryNameDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageRepositoryNameContainer = ecrImageRepositoryNameContainer {
            ecrImageRepositoryNameDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageRepositoryNameContainer {
                if let structure0 = structure0 {
                    ecrImageRepositoryNameDecoded0?.append(structure0)
                }
            }
        }
        ecrImageRepositoryName = ecrImageRepositoryNameDecoded0
        let ecrImageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageTags)
        var ecrImageTagsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageTagsContainer = ecrImageTagsContainer {
            ecrImageTagsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageTagsContainer {
                if let structure0 = structure0 {
                    ecrImageTagsDecoded0?.append(structure0)
                }
            }
        }
        ecrImageTags = ecrImageTagsDecoded0
        let ecrImageHashContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageHash)
        var ecrImageHashDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageHashContainer = ecrImageHashContainer {
            ecrImageHashDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageHashContainer {
                if let structure0 = structure0 {
                    ecrImageHashDecoded0?.append(structure0)
                }
            }
        }
        ecrImageHash = ecrImageHashDecoded0
        let portRangeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.PortRangeFilter?].self, forKey: .portRange)
        var portRangeDecoded0:[Inspector2ClientTypes.PortRangeFilter]? = nil
        if let portRangeContainer = portRangeContainer {
            portRangeDecoded0 = [Inspector2ClientTypes.PortRangeFilter]()
            for structure0 in portRangeContainer {
                if let structure0 = structure0 {
                    portRangeDecoded0?.append(structure0)
                }
            }
        }
        portRange = portRangeDecoded0
        let networkProtocolContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .networkProtocol)
        var networkProtocolDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let networkProtocolContainer = networkProtocolContainer {
            networkProtocolDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in networkProtocolContainer {
                if let structure0 = structure0 {
                    networkProtocolDecoded0?.append(structure0)
                }
            }
        }
        networkProtocol = networkProtocolDecoded0
        let componentIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .componentId)
        var componentIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let componentIdContainer = componentIdContainer {
            componentIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in componentIdContainer {
                if let structure0 = structure0 {
                    componentIdDecoded0?.append(structure0)
                }
            }
        }
        componentId = componentIdDecoded0
        let componentTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .componentType)
        var componentTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let componentTypeContainer = componentTypeContainer {
            componentTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in componentTypeContainer {
                if let structure0 = structure0 {
                    componentTypeDecoded0?.append(structure0)
                }
            }
        }
        componentType = componentTypeDecoded0
        let vulnerabilityIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilityId)
        var vulnerabilityIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilityIdContainer = vulnerabilityIdContainer {
            vulnerabilityIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilityIdContainer {
                if let structure0 = structure0 {
                    vulnerabilityIdDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilityId = vulnerabilityIdDecoded0
        let vulnerabilitySourceContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilitySource)
        var vulnerabilitySourceDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilitySourceContainer = vulnerabilitySourceContainer {
            vulnerabilitySourceDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilitySourceContainer {
                if let structure0 = structure0 {
                    vulnerabilitySourceDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilitySource = vulnerabilitySourceDecoded0
        let vendorSeverityContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vendorSeverity)
        var vendorSeverityDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vendorSeverityContainer = vendorSeverityContainer {
            vendorSeverityDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vendorSeverityContainer {
                if let structure0 = structure0 {
                    vendorSeverityDecoded0?.append(structure0)
                }
            }
        }
        vendorSeverity = vendorSeverityDecoded0
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.PackageFilter?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[Inspector2ClientTypes.PackageFilter]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [Inspector2ClientTypes.PackageFilter]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in relatedVulnerabilitiesContainer {
                if let structure0 = structure0 {
                    relatedVulnerabilitiesDecoded0?.append(structure0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let fixAvailableContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .fixAvailable)
        var fixAvailableDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let fixAvailableContainer = fixAvailableContainer {
            fixAvailableDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in fixAvailableContainer {
                if let structure0 = structure0 {
                    fixAvailableDecoded0?.append(structure0)
                }
            }
        }
        fixAvailable = fixAvailableDecoded0
        let lambdaFunctionNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .lambdaFunctionName)
        var lambdaFunctionNameDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let lambdaFunctionNameContainer = lambdaFunctionNameContainer {
            lambdaFunctionNameDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in lambdaFunctionNameContainer {
                if let structure0 = structure0 {
                    lambdaFunctionNameDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionName = lambdaFunctionNameDecoded0
        let lambdaFunctionLayersContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .lambdaFunctionLayers)
        var lambdaFunctionLayersDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let lambdaFunctionLayersContainer = lambdaFunctionLayersContainer {
            lambdaFunctionLayersDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in lambdaFunctionLayersContainer {
                if let structure0 = structure0 {
                    lambdaFunctionLayersDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionLayers = lambdaFunctionLayersDecoded0
        let lambdaFunctionRuntimeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .lambdaFunctionRuntime)
        var lambdaFunctionRuntimeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let lambdaFunctionRuntimeContainer = lambdaFunctionRuntimeContainer {
            lambdaFunctionRuntimeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in lambdaFunctionRuntimeContainer {
                if let structure0 = structure0 {
                    lambdaFunctionRuntimeDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionRuntime = lambdaFunctionRuntimeDecoded0
        let lambdaFunctionLastModifiedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .lambdaFunctionLastModifiedAt)
        var lambdaFunctionLastModifiedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let lambdaFunctionLastModifiedAtContainer = lambdaFunctionLastModifiedAtContainer {
            lambdaFunctionLastModifiedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in lambdaFunctionLastModifiedAtContainer {
                if let structure0 = structure0 {
                    lambdaFunctionLastModifiedAtDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAtDecoded0
        let lambdaFunctionExecutionRoleArnContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .lambdaFunctionExecutionRoleArn)
        var lambdaFunctionExecutionRoleArnDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let lambdaFunctionExecutionRoleArnContainer = lambdaFunctionExecutionRoleArnContainer {
            lambdaFunctionExecutionRoleArnDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in lambdaFunctionExecutionRoleArnContainer {
                if let structure0 = structure0 {
                    lambdaFunctionExecutionRoleArnDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArnDecoded0
        let exploitAvailableContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .exploitAvailable)
        var exploitAvailableDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let exploitAvailableContainer = exploitAvailableContainer {
            exploitAvailableDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in exploitAvailableContainer {
                if let structure0 = structure0 {
                    exploitAvailableDecoded0?.append(structure0)
                }
            }
        }
        exploitAvailable = exploitAvailableDecoded0
        let codeVulnerabilityDetectorNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .codeVulnerabilityDetectorName)
        var codeVulnerabilityDetectorNameDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let codeVulnerabilityDetectorNameContainer = codeVulnerabilityDetectorNameContainer {
            codeVulnerabilityDetectorNameDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in codeVulnerabilityDetectorNameContainer {
                if let structure0 = structure0 {
                    codeVulnerabilityDetectorNameDecoded0?.append(structure0)
                }
            }
        }
        codeVulnerabilityDetectorName = codeVulnerabilityDetectorNameDecoded0
        let codeVulnerabilityDetectorTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .codeVulnerabilityDetectorTags)
        var codeVulnerabilityDetectorTagsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let codeVulnerabilityDetectorTagsContainer = codeVulnerabilityDetectorTagsContainer {
            codeVulnerabilityDetectorTagsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in codeVulnerabilityDetectorTagsContainer {
                if let structure0 = structure0 {
                    codeVulnerabilityDetectorTagsDecoded0?.append(structure0)
                }
            }
        }
        codeVulnerabilityDetectorTags = codeVulnerabilityDetectorTagsDecoded0
        let codeVulnerabilityFilePathContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .codeVulnerabilityFilePath)
        var codeVulnerabilityFilePathDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let codeVulnerabilityFilePathContainer = codeVulnerabilityFilePathContainer {
            codeVulnerabilityFilePathDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in codeVulnerabilityFilePathContainer {
                if let structure0 = structure0 {
                    codeVulnerabilityFilePathDecoded0?.append(structure0)
                }
            }
        }
        codeVulnerabilityFilePath = codeVulnerabilityFilePathDecoded0
        let epssScoreContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.NumberFilter?].self, forKey: .epssScore)
        var epssScoreDecoded0:[Inspector2ClientTypes.NumberFilter]? = nil
        if let epssScoreContainer = epssScoreContainer {
            epssScoreDecoded0 = [Inspector2ClientTypes.NumberFilter]()
            for structure0 in epssScoreContainer {
                if let structure0 = structure0 {
                    epssScoreDecoded0?.append(structure0)
                }
            }
        }
        epssScore = epssScoreDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Details on the criteria used to define the filter.
    public struct FilterCriteria: Swift.Equatable {
        /// Details of the Amazon Web Services account IDs used to filter findings.
        public var awsAccountId: [Inspector2ClientTypes.StringFilter]?
        /// The name of the detector used to identify a code vulnerability in a Lambda function used to filter findings.
        public var codeVulnerabilityDetectorName: [Inspector2ClientTypes.StringFilter]?
        /// The detector type tag associated with the vulnerability used to filter findings. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see [Java tags](https://docs.aws.amazon.com/codeguru/detector-library/java/tags/), or [Python tags](https://docs.aws.amazon.com/codeguru/detector-library/python/tags/).
        public var codeVulnerabilityDetectorTags: [Inspector2ClientTypes.StringFilter]?
        /// The file path to the file in a Lambda function that contains a code vulnerability used to filter findings.
        public var codeVulnerabilityFilePath: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component IDs used to filter findings.
        public var componentId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component types used to filter findings.
        public var componentType: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance image IDs used to filter findings.
        public var ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance subnet IDs used to filter findings.
        public var ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance VPC IDs used to filter findings.
        public var ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image architecture types used to filter findings.
        public var ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image hashes used to filter findings.
        public var ecrImageHash: [Inspector2ClientTypes.StringFilter]?
        /// Details on the Amazon ECR image push date and time used to filter findings.
        public var ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the Amazon ECR registry used to filter findings.
        public var ecrImageRegistry: [Inspector2ClientTypes.StringFilter]?
        /// Details on the name of the Amazon ECR repository used to filter findings.
        public var ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]?
        /// The tags attached to the Amazon ECR container image.
        public var ecrImageTags: [Inspector2ClientTypes.StringFilter]?
        /// The EPSS score used to filter findings.
        public var epssScore: [Inspector2ClientTypes.NumberFilter]?
        /// Filters the list of AWS Lambda findings by the availability of exploits.
        public var exploitAvailable: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding ARNs used to filter findings.
        public var findingArn: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding status types used to filter findings.
        public var findingStatus: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding types used to filter findings.
        public var findingType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was first seen used to filter findings.
        public var firstObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL. A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public var fixAvailable: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon Inspector score to filter on.
        public var inspectorScore: [Inspector2ClientTypes.NumberFilter]?
        /// Filters the list of AWS Lambda functions by execution role.
        public var lambdaFunctionExecutionRoleArn: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of AWS Lambda functions by the date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html)
        public var lambdaFunctionLastModifiedAt: [Inspector2ClientTypes.DateFilter]?
        /// Filters the list of AWS Lambda functions by the function's [ layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). A Lambda function can have up to five layers.
        public var lambdaFunctionLayers: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of AWS Lambda functions by the name of the function.
        public var lambdaFunctionName: [Inspector2ClientTypes.StringFilter]?
        /// Filters the list of AWS Lambda functions by the runtime environment for the Lambda function.
        public var lambdaFunctionRuntime: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was last seen used to filter findings.
        public var lastObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on network protocol used to filter findings.
        public var networkProtocol: [Inspector2ClientTypes.StringFilter]?
        /// Details on the port ranges used to filter findings.
        public var portRange: [Inspector2ClientTypes.PortRangeFilter]?
        /// Details on the related vulnerabilities used to filter findings.
        public var relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource IDs used to filter findings.
        public var resourceId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource tags used to filter findings.
        public var resourceTags: [Inspector2ClientTypes.MapFilter]?
        /// Details on the resource types used to filter findings.
        public var resourceType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the severity used to filter findings.
        public var severity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding title used to filter findings.
        public var title: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was last updated at used to filter findings.
        public var updatedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the vendor severity used to filter findings.
        public var vendorSeverity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability ID used to filter findings.
        public var vulnerabilityId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability type used to filter findings.
        public var vulnerabilitySource: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerable packages used to filter findings.
        public var vulnerablePackages: [Inspector2ClientTypes.PackageFilter]?

        public init(
            awsAccountId: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityDetectorName: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityDetectorTags: [Inspector2ClientTypes.StringFilter]? = nil,
            codeVulnerabilityFilePath: [Inspector2ClientTypes.StringFilter]? = nil,
            componentId: [Inspector2ClientTypes.StringFilter]? = nil,
            componentType: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageHash: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            ecrImageRegistry: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            epssScore: [Inspector2ClientTypes.NumberFilter]? = nil,
            exploitAvailable: [Inspector2ClientTypes.StringFilter]? = nil,
            findingArn: [Inspector2ClientTypes.StringFilter]? = nil,
            findingStatus: [Inspector2ClientTypes.StringFilter]? = nil,
            findingType: [Inspector2ClientTypes.StringFilter]? = nil,
            firstObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            fixAvailable: [Inspector2ClientTypes.StringFilter]? = nil,
            inspectorScore: [Inspector2ClientTypes.NumberFilter]? = nil,
            lambdaFunctionExecutionRoleArn: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionLastModifiedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            lambdaFunctionLayers: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.StringFilter]? = nil,
            lambdaFunctionRuntime: [Inspector2ClientTypes.StringFilter]? = nil,
            lastObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            networkProtocol: [Inspector2ClientTypes.StringFilter]? = nil,
            portRange: [Inspector2ClientTypes.PortRangeFilter]? = nil,
            relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceId: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            resourceType: [Inspector2ClientTypes.StringFilter]? = nil,
            severity: [Inspector2ClientTypes.StringFilter]? = nil,
            title: [Inspector2ClientTypes.StringFilter]? = nil,
            updatedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            vendorSeverity: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityId: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilitySource: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerablePackages: [Inspector2ClientTypes.PackageFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetectorName = codeVulnerabilityDetectorName
            self.codeVulnerabilityDetectorTags = codeVulnerabilityDetectorTags
            self.codeVulnerabilityFilePath = codeVulnerabilityFilePath
            self.componentId = componentId
            self.componentType = componentType
            self.ec2InstanceImageId = ec2InstanceImageId
            self.ec2InstanceSubnetId = ec2InstanceSubnetId
            self.ec2InstanceVpcId = ec2InstanceVpcId
            self.ecrImageArchitecture = ecrImageArchitecture
            self.ecrImageHash = ecrImageHash
            self.ecrImagePushedAt = ecrImagePushedAt
            self.ecrImageRegistry = ecrImageRegistry
            self.ecrImageRepositoryName = ecrImageRepositoryName
            self.ecrImageTags = ecrImageTags
            self.epssScore = epssScore
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.findingStatus = findingStatus
            self.findingType = findingType
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArn
            self.lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAt
            self.lambdaFunctionLayers = lambdaFunctionLayers
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lastObservedAt = lastObservedAt
            self.networkProtocol = networkProtocol
            self.portRange = portRange
            self.relatedVulnerabilities = relatedVulnerabilities
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.vendorSeverity = vendorSeverity
            self.vulnerabilityId = vulnerabilityId
            self.vulnerabilitySource = vulnerabilitySource
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension Inspector2ClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case codeVulnerabilityDetails
        case description
        case epss
        case exploitAvailable
        case exploitabilityDetails
        case findingArn
        case firstObservedAt
        case fixAvailable
        case inspectorScore
        case inspectorScoreDetails
        case lastObservedAt
        case networkReachabilityDetails
        case packageVulnerabilityDetails
        case remediation
        case resources
        case severity
        case status
        case title
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let codeVulnerabilityDetails = self.codeVulnerabilityDetails {
            try encodeContainer.encode(codeVulnerabilityDetails, forKey: .codeVulnerabilityDetails)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let epss = self.epss {
            try encodeContainer.encode(epss, forKey: .epss)
        }
        if let exploitAvailable = self.exploitAvailable {
            try encodeContainer.encode(exploitAvailable.rawValue, forKey: .exploitAvailable)
        }
        if let exploitabilityDetails = self.exploitabilityDetails {
            try encodeContainer.encode(exploitabilityDetails, forKey: .exploitabilityDetails)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
        if let firstObservedAt = self.firstObservedAt {
            try encodeContainer.encodeTimestamp(firstObservedAt, format: .epochSeconds, forKey: .firstObservedAt)
        }
        if let fixAvailable = self.fixAvailable {
            try encodeContainer.encode(fixAvailable.rawValue, forKey: .fixAvailable)
        }
        if let inspectorScore = self.inspectorScore {
            try encodeContainer.encode(inspectorScore, forKey: .inspectorScore)
        }
        if let inspectorScoreDetails = self.inspectorScoreDetails {
            try encodeContainer.encode(inspectorScoreDetails, forKey: .inspectorScoreDetails)
        }
        if let lastObservedAt = self.lastObservedAt {
            try encodeContainer.encodeTimestamp(lastObservedAt, format: .epochSeconds, forKey: .lastObservedAt)
        }
        if let networkReachabilityDetails = self.networkReachabilityDetails {
            try encodeContainer.encode(networkReachabilityDetails, forKey: .networkReachabilityDetails)
        }
        if let packageVulnerabilityDetails = self.packageVulnerabilityDetails {
            try encodeContainer.encode(packageVulnerabilityDetails, forKey: .packageVulnerabilityDetails)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let firstObservedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Inspector2ClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Inspector2ClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let inspectorScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .inspectorScore)
        inspectorScore = inspectorScoreDecoded
        let inspectorScoreDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.InspectorScoreDetails.self, forKey: .inspectorScoreDetails)
        inspectorScoreDetails = inspectorScoreDetailsDecoded
        let networkReachabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkReachabilityDetails.self, forKey: .networkReachabilityDetails)
        networkReachabilityDetails = networkReachabilityDetailsDecoded
        let packageVulnerabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageVulnerabilityDetails.self, forKey: .packageVulnerabilityDetails)
        packageVulnerabilityDetails = packageVulnerabilityDetailsDecoded
        let fixAvailableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FixAvailable.self, forKey: .fixAvailable)
        fixAvailable = fixAvailableDecoded
        let exploitAvailableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExploitAvailable.self, forKey: .exploitAvailable)
        exploitAvailable = exploitAvailableDecoded
        let exploitabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExploitabilityDetails.self, forKey: .exploitabilityDetails)
        exploitabilityDetails = exploitabilityDetailsDecoded
        let codeVulnerabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CodeVulnerabilityDetails.self, forKey: .codeVulnerabilityDetails)
        codeVulnerabilityDetails = codeVulnerabilityDetailsDecoded
        let epssDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EpssDetails.self, forKey: .epss)
        epss = epssDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about an Amazon Inspector finding.
    public struct Finding: Swift.Equatable {
        /// The Amazon Web Services account ID associated with the finding.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// Details about the code vulnerability identified in a Lambda function used to filter findings.
        public var codeVulnerabilityDetails: Inspector2ClientTypes.CodeVulnerabilityDetails?
        /// The description of the finding.
        /// This member is required.
        public var description: Swift.String?
        /// The finding's EPSS score.
        public var epss: Inspector2ClientTypes.EpssDetails?
        /// If a finding discovered in your environment has an exploit available.
        public var exploitAvailable: Inspector2ClientTypes.ExploitAvailable?
        /// The details of an exploit available for a finding discovered in your environment.
        public var exploitabilityDetails: Inspector2ClientTypes.ExploitabilityDetails?
        /// The Amazon Resource Number (ARN) of the finding.
        /// This member is required.
        public var findingArn: Swift.String?
        /// The date and time that the finding was first observed.
        /// This member is required.
        public var firstObservedAt: ClientRuntime.Date?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL. A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public var fixAvailable: Inspector2ClientTypes.FixAvailable?
        /// The Amazon Inspector score given to the finding.
        public var inspectorScore: Swift.Double?
        /// An object that contains details of the Amazon Inspector score.
        public var inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails?
        /// The date and time that the finding was last observed.
        /// This member is required.
        public var lastObservedAt: ClientRuntime.Date?
        /// An object that contains the details of a network reachability finding.
        public var networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        /// This member is required.
        public var remediation: Inspector2ClientTypes.Remediation?
        /// Contains information on the resources involved in a finding.
        /// This member is required.
        public var resources: [Inspector2ClientTypes.Resource]?
        /// The severity of the finding.
        /// This member is required.
        public var severity: Inspector2ClientTypes.Severity?
        /// The status of the finding.
        /// This member is required.
        public var status: Inspector2ClientTypes.FindingStatus?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding.
        /// This member is required.
        public var type: Inspector2ClientTypes.FindingType?
        /// The date and time the finding was last updated at.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            codeVulnerabilityDetails: Inspector2ClientTypes.CodeVulnerabilityDetails? = nil,
            description: Swift.String? = nil,
            epss: Inspector2ClientTypes.EpssDetails? = nil,
            exploitAvailable: Inspector2ClientTypes.ExploitAvailable? = nil,
            exploitabilityDetails: Inspector2ClientTypes.ExploitabilityDetails? = nil,
            findingArn: Swift.String? = nil,
            firstObservedAt: ClientRuntime.Date? = nil,
            fixAvailable: Inspector2ClientTypes.FixAvailable? = nil,
            inspectorScore: Swift.Double? = nil,
            inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails? = nil,
            lastObservedAt: ClientRuntime.Date? = nil,
            networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails? = nil,
            packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: Inspector2ClientTypes.Remediation? = nil,
            resources: [Inspector2ClientTypes.Resource]? = nil,
            severity: Inspector2ClientTypes.Severity? = nil,
            status: Inspector2ClientTypes.FindingStatus? = nil,
            title: Swift.String? = nil,
            type: Inspector2ClientTypes.FindingType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetails = codeVulnerabilityDetails
            self.description = description
            self.epss = epss
            self.exploitAvailable = exploitAvailable
            self.exploitabilityDetails = exploitabilityDetails
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.lastObservedAt = lastObservedAt
            self.networkReachabilityDetails = networkReachabilityDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes.FindingDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cisaData
        case cwes
        case epssScore
        case evidences
        case exploitObserved
        case findingArn
        case referenceUrls
        case riskScore
        case tools
        case ttps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cisaData = self.cisaData {
            try encodeContainer.encode(cisaData, forKey: .cisaData)
        }
        if let cwes = cwes {
            var cwesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cwes)
            for cwe0 in cwes {
                try cwesContainer.encode(cwe0)
            }
        }
        if let epssScore = self.epssScore {
            try encodeContainer.encode(epssScore, forKey: .epssScore)
        }
        if let evidences = evidences {
            var evidencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidences)
            for evidence0 in evidences {
                try evidencesContainer.encode(evidence0)
            }
        }
        if let exploitObserved = self.exploitObserved {
            try encodeContainer.encode(exploitObserved, forKey: .exploitObserved)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for vulnerabilityreferenceurl0 in referenceUrls {
                try referenceUrlsContainer.encode(vulnerabilityreferenceurl0)
            }
        }
        if let riskScore = self.riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tool0 in tools {
                try toolsContainer.encode(tool0)
            }
        }
        if let ttps = ttps {
            var ttpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ttps)
            for ttp0 in ttps {
                try ttpsContainer.encode(ttp0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let cisaDataDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CisaData.self, forKey: .cisaData)
        cisaData = cisaDataDecoded
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
        let evidencesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Evidence?].self, forKey: .evidences)
        var evidencesDecoded0:[Inspector2ClientTypes.Evidence]? = nil
        if let evidencesContainer = evidencesContainer {
            evidencesDecoded0 = [Inspector2ClientTypes.Evidence]()
            for structure0 in evidencesContainer {
                if let structure0 = structure0 {
                    evidencesDecoded0?.append(structure0)
                }
            }
        }
        evidences = evidencesDecoded0
        let ttpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ttps)
        var ttpsDecoded0:[Swift.String]? = nil
        if let ttpsContainer = ttpsContainer {
            ttpsDecoded0 = [Swift.String]()
            for string0 in ttpsContainer {
                if let string0 = string0 {
                    ttpsDecoded0?.append(string0)
                }
            }
        }
        ttps = ttpsDecoded0
        let toolsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tools)
        var toolsDecoded0:[Swift.String]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [Swift.String]()
            for string0 in toolsContainer {
                if let string0 = string0 {
                    toolsDecoded0?.append(string0)
                }
            }
        }
        tools = toolsDecoded0
        let exploitObservedDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExploitObserved.self, forKey: .exploitObserved)
        exploitObserved = exploitObservedDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let cwesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cwes)
        var cwesDecoded0:[Swift.String]? = nil
        if let cwesContainer = cwesContainer {
            cwesDecoded0 = [Swift.String]()
            for string0 in cwesContainer {
                if let string0 = string0 {
                    cwesDecoded0?.append(string0)
                }
            }
        }
        cwes = cwesDecoded0
        let epssScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .epssScore)
        epssScore = epssScoreDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the vulnerability identified in a finding.
    public struct FindingDetail: Swift.Equatable {
        /// The Cybersecurity and Infrastructure Security Agency (CISA) details for a specific vulnerability.
        public var cisaData: Inspector2ClientTypes.CisaData?
        /// The Common Weakness Enumerations (CWEs) associated with the vulnerability.
        public var cwes: [Swift.String]?
        /// The Exploit Prediction Scoring System (EPSS) score of the vulnerability.
        public var epssScore: Swift.Double?
        /// Information on the evidence of the vulnerability.
        public var evidences: [Inspector2ClientTypes.Evidence]?
        /// Contains information on when this exploit was observed.
        public var exploitObserved: Inspector2ClientTypes.ExploitObserved?
        /// The finding ARN that the vulnerability details are associated with.
        public var findingArn: Swift.String?
        /// The reference URLs for the vulnerability data.
        public var referenceUrls: [Swift.String]?
        /// The risk score of the vulnerability.
        public var riskScore: Swift.Int?
        /// The known malware tools or kits that can exploit the vulnerability.
        public var tools: [Swift.String]?
        /// The MITRE adversary tactics, techniques, or procedures (TTPs) associated with the vulnerability.
        public var ttps: [Swift.String]?

        public init(
            cisaData: Inspector2ClientTypes.CisaData? = nil,
            cwes: [Swift.String]? = nil,
            epssScore: Swift.Double? = nil,
            evidences: [Inspector2ClientTypes.Evidence]? = nil,
            exploitObserved: Inspector2ClientTypes.ExploitObserved? = nil,
            findingArn: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            riskScore: Swift.Int? = nil,
            tools: [Swift.String]? = nil,
            ttps: [Swift.String]? = nil
        )
        {
            self.cisaData = cisaData
            self.cwes = cwes
            self.epssScore = epssScore
            self.evidences = evidences
            self.exploitObserved = exploitObserved
            self.findingArn = findingArn
            self.referenceUrls = referenceUrls
            self.riskScore = riskScore
            self.tools = tools
            self.ttps = ttps
        }
    }

}

extension Inspector2ClientTypes.FindingDetailsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case findingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingDetailsErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about an error encountered when trying to return vulnerability data for a finding.
    public struct FindingDetailsError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.FindingDetailsErrorCode?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The finding ARN that returned an error.
        /// This member is required.
        public var findingArn: Swift.String?

        public init(
            errorCode: Inspector2ClientTypes.FindingDetailsErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            findingArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }
    }

}

extension Inspector2ClientTypes {
    public enum FindingDetailsErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case findingDetailsNotFound
        case internalError
        case invalidInput
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingDetailsErrorCode] {
            return [
                .accessDenied,
                .findingDetailsNotFound,
                .internalError,
                .invalidInput,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .findingDetailsNotFound: return "FINDING_DETAILS_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInput: return "INVALID_INPUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingDetailsErrorCode(rawValue: rawValue) ?? FindingDetailsErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case closed
        case suppressed
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .closed,
                .suppressed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .suppressed: return "SUPPRESSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatus(rawValue: rawValue) ?? FindingStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeVulnerability
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingType] {
            return [
                .codeVulnerability,
                .networkReachability,
                .packageVulnerability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeVulnerability: return "CODE_VULNERABILITY"
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingType(rawValue: rawValue) ?? FindingType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FindingTypeAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingType
        case resourceType
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingType = self.findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding type.
    public struct FindingTypeAggregation: Swift.Equatable {
        /// The finding type to aggregate.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The resource type to aggregate.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.FindingTypeSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.FindingTypeSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.FindingTypeAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding type aggregation.
    public struct FindingTypeAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The value to sort results by.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum FindingTypeSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingTypeSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingTypeSortBy(rawValue: rawValue) ?? FindingTypeSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FixAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case partial
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [FixAvailable] {
            return [
                .no,
                .partial,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .partial: return "PARTIAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FixAvailable(rawValue: rawValue) ?? FixAvailable.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FreeTrialAccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case freeTrialInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let freeTrialInfo = freeTrialInfo {
            var freeTrialInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .freeTrialInfo)
            for freetrialinfo0 in freeTrialInfo {
                try freeTrialInfoContainer.encode(freetrialinfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let freeTrialInfoContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialInfo?].self, forKey: .freeTrialInfo)
        var freeTrialInfoDecoded0:[Inspector2ClientTypes.FreeTrialInfo]? = nil
        if let freeTrialInfoContainer = freeTrialInfoContainer {
            freeTrialInfoDecoded0 = [Inspector2ClientTypes.FreeTrialInfo]()
            for structure0 in freeTrialInfoContainer {
                if let structure0 = structure0 {
                    freeTrialInfoDecoded0?.append(structure0)
                }
            }
        }
        freeTrialInfo = freeTrialInfoDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector free trial for an account.
    public struct FreeTrialAccountInfo: Swift.Equatable {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information about the Amazon Inspector free trial for an account.
        /// This member is required.
        public var freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]?

        public init(
            accountId: Swift.String? = nil,
            freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]? = nil
        )
        {
            self.accountId = accountId
            self.freeTrialInfo = freeTrialInfo
        }
    }

}

extension Inspector2ClientTypes.FreeTrialInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encodeTimestamp(end, format: .epochSeconds, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .epochSeconds, forKey: .start)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialType.self, forKey: .type)
        type = typeDecoded
        let startDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .end)
        end = endDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains information about the Amazon Inspector free trial for an account.
    public struct FreeTrialInfo: Swift.Equatable {
        /// The date and time that the Amazon Inspector free trail ends for a given account.
        /// This member is required.
        public var end: ClientRuntime.Date?
        /// The date and time that the Amazon Inspector free trail started for a given account.
        /// This member is required.
        public var start: ClientRuntime.Date?
        /// The order to sort results by.
        /// This member is required.
        public var status: Inspector2ClientTypes.FreeTrialStatus?
        /// The type of scan covered by the Amazon Inspector free trail.
        /// This member is required.
        public var type: Inspector2ClientTypes.FreeTrialType?

        public init(
            end: ClientRuntime.Date? = nil,
            start: ClientRuntime.Date? = nil,
            status: Inspector2ClientTypes.FreeTrialStatus? = nil,
            type: Inspector2ClientTypes.FreeTrialType? = nil
        )
        {
            self.end = end
            self.start = start
            self.status = status
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.FreeTrialInfoError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialInfoErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information about an error received while accessing free trail data for an account.
    public struct FreeTrialInfoError: Swift.Equatable {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: Inspector2ClientTypes.FreeTrialInfoErrorCode?
        /// The error message returned.
        /// This member is required.
        public var message: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            code: Inspector2ClientTypes.FreeTrialInfoErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.code = code
            self.message = message
        }
    }

}

extension Inspector2ClientTypes {
    public enum FreeTrialInfoErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialInfoErrorCode] {
            return [
                .accessDenied,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialInfoErrorCode(rawValue: rawValue) ?? FreeTrialInfoErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FreeTrialStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialStatus(rawValue: rawValue) ?? FreeTrialStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FreeTrialType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case lambdaCode
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialType] {
            return [
                .ec2,
                .ecr,
                .lambda,
                .lambdaCode,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case .lambdaCode: return "LAMBDA_CODE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialType(rawValue: rawValue) ?? FreeTrialType.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/get"
    }
}

public struct GetConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetConfigurationInputBody: Swift.Equatable {
}

extension GetConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.ecrConfiguration = output.ecrConfiguration
        } else {
            self.ecrConfiguration = nil
        }
    }
}

public struct GetConfigurationOutput: Swift.Equatable {
    /// Specifies how the ECR automated re-scan duration is currently configured for your environment.
    public var ecrConfiguration: Inspector2ClientTypes.EcrConfigurationState?

    public init(
        ecrConfiguration: Inspector2ClientTypes.EcrConfigurationState? = nil
    )
    {
        self.ecrConfiguration = ecrConfiguration
    }
}

struct GetConfigurationOutputBody: Swift.Equatable {
    let ecrConfiguration: Inspector2ClientTypes.EcrConfigurationState?
}

extension GetConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrConfigurationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrConfigurationState.self, forKey: .ecrConfiguration)
        ecrConfiguration = ecrConfigurationDecoded
    }
}

enum GetConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/get"
    }
}

public struct GetDelegatedAdminAccountInput: Swift.Equatable {

    public init() { }
}

struct GetDelegatedAdminAccountInputBody: Swift.Equatable {
}

extension GetDelegatedAdminAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDelegatedAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDelegatedAdminAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdmin = output.delegatedAdmin
        } else {
            self.delegatedAdmin = nil
        }
    }
}

public struct GetDelegatedAdminAccountOutput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    public var delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin?

    public init(
        delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin? = nil
    )
    {
        self.delegatedAdmin = delegatedAdmin
    }
}

struct GetDelegatedAdminAccountOutputBody: Swift.Equatable {
    let delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin?
}

extension GetDelegatedAdminAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdmin
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.DelegatedAdmin.self, forKey: .delegatedAdmin)
        delegatedAdmin = delegatedAdminDecoded
    }
}

enum GetDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEc2DeepInspectionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ec2deepinspectionconfiguration/get"
    }
}

public struct GetEc2DeepInspectionConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetEc2DeepInspectionConfigurationInputBody: Swift.Equatable {
}

extension GetEc2DeepInspectionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEc2DeepInspectionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEc2DeepInspectionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorMessage = output.errorMessage
            self.orgPackagePaths = output.orgPackagePaths
            self.packagePaths = output.packagePaths
            self.status = output.status
        } else {
            self.errorMessage = nil
            self.orgPackagePaths = nil
            self.packagePaths = nil
            self.status = nil
        }
    }
}

public struct GetEc2DeepInspectionConfigurationOutput: Swift.Equatable {
    /// An error message explaining why Amazon Inspector deep inspection configurations could not be retrieved for your account.
    public var errorMessage: Swift.String?
    /// The Amazon Inspector deep inspection custom paths for your organization.
    public var orgPackagePaths: [Swift.String]?
    /// The Amazon Inspector deep inspection custom paths for your account.
    public var packagePaths: [Swift.String]?
    /// The activation status of Amazon Inspector deep inspection in your account.
    public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

    public init(
        errorMessage: Swift.String? = nil,
        orgPackagePaths: [Swift.String]? = nil,
        packagePaths: [Swift.String]? = nil,
        status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.orgPackagePaths = orgPackagePaths
        self.packagePaths = packagePaths
        self.status = status
    }
}

struct GetEc2DeepInspectionConfigurationOutputBody: Swift.Equatable {
    let packagePaths: [Swift.String]?
    let orgPackagePaths: [Swift.String]?
    let status: Inspector2ClientTypes.Ec2DeepInspectionStatus?
    let errorMessage: Swift.String?
}

extension GetEc2DeepInspectionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case orgPackagePaths
        case packagePaths
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packagePaths)
        var packagePathsDecoded0:[Swift.String]? = nil
        if let packagePathsContainer = packagePathsContainer {
            packagePathsDecoded0 = [Swift.String]()
            for string0 in packagePathsContainer {
                if let string0 = string0 {
                    packagePathsDecoded0?.append(string0)
                }
            }
        }
        packagePaths = packagePathsDecoded0
        let orgPackagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .orgPackagePaths)
        var orgPackagePathsDecoded0:[Swift.String]? = nil
        if let orgPackagePathsContainer = orgPackagePathsContainer {
            orgPackagePathsDecoded0 = [Swift.String]()
            for string0 in orgPackagePathsContainer {
                if let string0 = string0 {
                    orgPackagePathsDecoded0?.append(string0)
                }
            }
        }
        orgPackagePaths = orgPackagePathsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2DeepInspectionStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum GetEc2DeepInspectionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEncryptionKeyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let scanType = scanType else {
                let message = "Creating a URL Query Item failed. scanType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let scanTypeQueryItem = ClientRuntime.URLQueryItem(name: "scanType".urlPercentEncoding(), value: Swift.String(scanType.rawValue).urlPercentEncoding())
            items.append(scanTypeQueryItem)
            guard let resourceType = resourceType else {
                let message = "Creating a URL Query Item failed. resourceType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
            return items
        }
    }
}

extension GetEncryptionKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/encryptionkey/get"
    }
}

public struct GetEncryptionKeyInput: Swift.Equatable {
    /// The resource type the key encrypts.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type the key encrypts.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

struct GetEncryptionKeyInputBody: Swift.Equatable {
}

extension GetEncryptionKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEncryptionKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEncryptionKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.kmsKeyId = output.kmsKeyId
        } else {
            self.kmsKeyId = nil
        }
    }
}

public struct GetEncryptionKeyOutput: Swift.Equatable {
    /// A kms key ID.
    /// This member is required.
    public var kmsKeyId: Swift.String?

    public init(
        kmsKeyId: Swift.String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
    }
}

struct GetEncryptionKeyOutputBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
}

extension GetEncryptionKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum GetEncryptionKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsReportStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension GetFindingsReportStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/status/get"
    }
}

public struct GetFindingsReportStatusInput: Swift.Equatable {
    /// The ID of the report to retrieve the status of.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetFindingsReportStatusInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension GetFindingsReportStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension GetFindingsReportStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsReportStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.destination = output.destination
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.filterCriteria = output.filterCriteria
            self.reportId = output.reportId
            self.status = output.status
        } else {
            self.destination = nil
            self.errorCode = nil
            self.errorMessage = nil
            self.filterCriteria = nil
            self.reportId = nil
            self.status = nil
        }
    }
}

public struct GetFindingsReportStatusOutput: Swift.Equatable {
    /// The destination of the report.
    public var destination: Inspector2ClientTypes.Destination?
    /// The error code of the report.
    public var errorCode: Inspector2ClientTypes.ReportingErrorCode?
    /// The error message of the report.
    public var errorMessage: Swift.String?
    /// The filter criteria associated with the report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The ID of the report.
    public var reportId: Swift.String?
    /// The status of the report.
    public var status: Inspector2ClientTypes.ExternalReportStatus?

    public init(
        destination: Inspector2ClientTypes.Destination? = nil,
        errorCode: Inspector2ClientTypes.ReportingErrorCode? = nil,
        errorMessage: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportId: Swift.String? = nil,
        status: Inspector2ClientTypes.ExternalReportStatus? = nil
    )
    {
        self.destination = destination
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.filterCriteria = filterCriteria
        self.reportId = reportId
        self.status = status
    }
}

struct GetFindingsReportStatusOutputBody: Swift.Equatable {
    let reportId: Swift.String?
    let status: Inspector2ClientTypes.ExternalReportStatus?
    let errorCode: Inspector2ClientTypes.ReportingErrorCode?
    let errorMessage: Swift.String?
    let destination: Inspector2ClientTypes.Destination?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
}

extension GetFindingsReportStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorCode
        case errorMessage
        case filterCriteria
        case reportId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExternalReportStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ReportingErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
    }
}

enum GetFindingsReportStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension GetMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/get"
    }
}

public struct GetMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to retrieve information on.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension GetMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetMemberOutput: Swift.Equatable {
    /// Details of the retrieved member account.
    public var member: Inspector2ClientTypes.Member?

    public init(
        member: Inspector2ClientTypes.Member? = nil
    )
    {
        self.member = member
    }
}

struct GetMemberOutputBody: Swift.Equatable {
    let member: Inspector2ClientTypes.Member?
}

extension GetMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Member.self, forKey: .member)
        member = memberDecoded
    }
}

enum GetMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSbomExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension GetSbomExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sbomexport/get"
    }
}

public struct GetSbomExportInput: Swift.Equatable {
    /// The report ID of the SBOM export to get details for.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetSbomExportInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension GetSbomExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension GetSbomExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSbomExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.filterCriteria = output.filterCriteria
            self.format = output.format
            self.reportId = output.reportId
            self.s3Destination = output.s3Destination
            self.status = output.status
        } else {
            self.errorCode = nil
            self.errorMessage = nil
            self.filterCriteria = nil
            self.format = nil
            self.reportId = nil
            self.s3Destination = nil
            self.status = nil
        }
    }
}

public struct GetSbomExportOutput: Swift.Equatable {
    /// An error code.
    public var errorCode: Inspector2ClientTypes.ReportingErrorCode?
    /// An error message.
    public var errorMessage: Swift.String?
    /// Contains details about the resource filter criteria used for the software bill of materials (SBOM) report.
    public var filterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
    /// The format of the software bill of materials (SBOM) report.
    public var format: Inspector2ClientTypes.SbomReportFormat?
    /// The report ID of the software bill of materials (SBOM) report.
    public var reportId: Swift.String?
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    public var s3Destination: Inspector2ClientTypes.Destination?
    /// The status of the software bill of materials (SBOM) report.
    public var status: Inspector2ClientTypes.ExternalReportStatus?

    public init(
        errorCode: Inspector2ClientTypes.ReportingErrorCode? = nil,
        errorMessage: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.ResourceFilterCriteria? = nil,
        format: Inspector2ClientTypes.SbomReportFormat? = nil,
        reportId: Swift.String? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil,
        status: Inspector2ClientTypes.ExternalReportStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.filterCriteria = filterCriteria
        self.format = format
        self.reportId = reportId
        self.s3Destination = s3Destination
        self.status = status
    }
}

struct GetSbomExportOutputBody: Swift.Equatable {
    let reportId: Swift.String?
    let format: Inspector2ClientTypes.SbomReportFormat?
    let status: Inspector2ClientTypes.ExternalReportStatus?
    let errorCode: Inspector2ClientTypes.ReportingErrorCode?
    let errorMessage: Swift.String?
    let s3Destination: Inspector2ClientTypes.Destination?
    let filterCriteria: Inspector2ClientTypes.ResourceFilterCriteria?
}

extension GetSbomExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case filterCriteria
        case format
        case reportId
        case s3Destination
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SbomReportFormat.self, forKey: .format)
        format = formatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExternalReportStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ReportingErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
    }
}

enum GetSbomExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes {
    public enum GroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case ecrRepositoryName
        case resourceType
        case scanStatusCode
        case scanStatusReason
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupKey] {
            return [
                .accountId,
                .ecrRepositoryName,
                .resourceType,
                .scanStatusCode,
                .scanStatusReason,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .ecrRepositoryName: return "ECR_REPOSITORY_NAME"
            case .resourceType: return "RESOURCE_TYPE"
            case .scanStatusCode: return "SCAN_STATUS_CODE"
            case .scanStatusReason: return "SCAN_STATUS_REASON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupKey(rawValue: rawValue) ?? GroupKey.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ImageLayerAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerHashes
        case repositories
        case resourceIds
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerHashes = layerHashes {
            var layerHashesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerHashes)
            for stringfilter0 in layerHashes {
                try layerHashesContainer.encode(stringfilter0)
            }
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilter0 in repositories {
                try repositoriesContainer.encode(stringfilter0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilter0 in resourceIds {
                try resourceIdsContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let layerHashesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .layerHashes)
        var layerHashesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let layerHashesContainer = layerHashesContainer {
            layerHashesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in layerHashesContainer {
                if let structure0 = structure0 {
                    layerHashesDecoded0?.append(structure0)
                }
            }
        }
        layerHashes = layerHashesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ImageLayerSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on container image layers.
    public struct ImageLayerAggregation: Swift.Equatable {
        /// The hashes associated with the layers.
        public var layerHashes: [Inspector2ClientTypes.StringFilter]?
        /// The repository associated with the container image hosting the layers.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The ID of the container image layer.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.ImageLayerSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            layerHashes: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.ImageLayerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.layerHashes = layerHashes
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.ImageLayerAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case layerHash
        case repository
        case resourceId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let layerHash = self.layerHash {
            try encodeContainer.encode(layerHash, forKey: .layerHash)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let layerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerHash)
        layerHash = layerHashDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct ImageLayerAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the container image hosting the layer image.
        /// This member is required.
        public var accountId: Swift.String?
        /// The layer hash.
        /// This member is required.
        public var layerHash: Swift.String?
        /// The repository the layer resides in.
        /// This member is required.
        public var repository: Swift.String?
        /// The resource ID of the container image layer.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that represents the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            layerHash: Swift.String? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.layerHash = layerHash
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum ImageLayerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageLayerSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageLayerSortBy(rawValue: rawValue) ?? ImageLayerSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.InspectorScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustedCvss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustedCvss = self.adjustedCvss {
            try encodeContainer.encode(adjustedCvss, forKey: .adjustedCvss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adjustedCvssDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CvssScoreDetails.self, forKey: .adjustedCvss)
        adjustedCvss = adjustedCvssDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector score given to a finding.
    public struct InspectorScoreDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score given to a finding.
        public var adjustedCvss: Inspector2ClientTypes.CvssScoreDetails?

        public init(
            adjustedCvss: Inspector2ClientTypes.CvssScoreDetails? = nil
        )
        {
            self.adjustedCvss = adjustedCvss
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed due to an internal failure of the Amazon Inspector service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.LambdaFunctionAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionNames
        case functionTags
        case resourceIds
        case runtimes
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionNames = functionNames {
            var functionNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionNames)
            for stringfilter0 in functionNames {
                try functionNamesContainer.encode(stringfilter0)
            }
        }
        if let functionTags = functionTags {
            var functionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionTags)
            for mapfilter0 in functionTags {
                try functionTagsContainer.encode(mapfilter0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilter0 in resourceIds {
                try resourceIdsContainer.encode(stringfilter0)
            }
        }
        if let runtimes = runtimes {
            var runtimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimes)
            for stringfilter0 in runtimes {
                try runtimesContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let functionNamesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .functionNames)
        var functionNamesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let functionNamesContainer = functionNamesContainer {
            functionNamesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in functionNamesContainer {
                if let structure0 = structure0 {
                    functionNamesDecoded0?.append(structure0)
                }
            }
        }
        functionNames = functionNamesDecoded0
        let runtimesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .runtimes)
        var runtimesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let runtimesContainer = runtimesContainer {
            runtimesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in runtimesContainer {
                if let structure0 = structure0 {
                    runtimesDecoded0?.append(structure0)
                }
            }
        }
        runtimes = runtimesDecoded0
        let functionTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MapFilter?].self, forKey: .functionTags)
        var functionTagsDecoded0:[Inspector2ClientTypes.MapFilter]? = nil
        if let functionTagsContainer = functionTagsContainer {
            functionTagsDecoded0 = [Inspector2ClientTypes.MapFilter]()
            for structure0 in functionTagsContainer {
                if let structure0 = structure0 {
                    functionTagsDecoded0?.append(structure0)
                }
            }
        }
        functionTags = functionTagsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.LambdaFunctionSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define a findings aggregation based on AWS Lambda functions.
    public struct LambdaFunctionAggregation: Swift.Equatable {
        /// The AWS Lambda function names to include in the aggregation results.
        public var functionNames: [Inspector2ClientTypes.StringFilter]?
        /// The tags to include in the aggregation results.
        public var functionTags: [Inspector2ClientTypes.MapFilter]?
        /// The resource IDs to include in the aggregation results.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// Returns findings aggregated by AWS Lambda function runtime environments.
        public var runtimes: [Inspector2ClientTypes.StringFilter]?
        /// The finding severity to use for sorting the results.
        public var sortBy: Inspector2ClientTypes.LambdaFunctionSortBy?
        /// The order to use for sorting the results.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            functionNames: [Inspector2ClientTypes.StringFilter]? = nil,
            functionTags: [Inspector2ClientTypes.MapFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            runtimes: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.LambdaFunctionSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.functionNames = functionNames
            self.functionTags = functionTags
            self.resourceIds = resourceIds
            self.runtimes = runtimes
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.LambdaFunctionAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case functionName
        case lambdaTags
        case lastModifiedAt
        case resourceId
        case runtime
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let lambdaTags = lambdaTags {
            var lambdaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .lambdaTags)
            for (dictKey0, tagMap0) in lambdaTags {
                try lambdaTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let lambdaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .lambdaTags)
        var lambdaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let lambdaTagsContainer = lambdaTagsContainer {
            lambdaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in lambdaTagsContainer {
                if let mapvalue0 = mapvalue0 {
                    lambdaTagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        lambdaTags = lambdaTagsDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of an AWS Lambda function finding aggregation.
    public struct LambdaFunctionAggregationResponse: Swift.Equatable {
        /// The ID of the AWS account that owns the AWS Lambda function.
        public var accountId: Swift.String?
        /// The AWS Lambda function names included in the aggregation results.
        public var functionName: Swift.String?
        /// The tags included in the aggregation results.
        public var lambdaTags: [Swift.String:Swift.String]?
        /// The date that the AWS Lambda function included in the aggregation results was last changed.
        public var lastModifiedAt: ClientRuntime.Date?
        /// The resource IDs included in the aggregation results.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The runtimes included in the aggregation results.
        public var runtime: Swift.String?
        /// An object that contains the counts of aggregated finding per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            functionName: Swift.String? = nil,
            lambdaTags: [Swift.String:Swift.String]? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            resourceId: Swift.String? = nil,
            runtime: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.functionName = functionName
            self.lambdaTags = lambdaTags
            self.lastModifiedAt = lastModifiedAt
            self.resourceId = resourceId
            self.runtime = runtime
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes.LambdaFunctionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionName
        case functionTags
        case layers
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionTags = functionTags {
            var functionTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functionTags)
            for (dictKey0, tagMap0) in functionTags {
                try functionTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for string0 in layers {
                try layersContainer.encode(string0)
            }
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .functionTags)
        var functionTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let functionTagsContainer = functionTagsContainer {
            functionTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in functionTagsContainer {
                if let mapvalue0 = mapvalue0 {
                    functionTagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        functionTags = functionTagsDecoded0
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension Inspector2ClientTypes {
    /// The AWS Lambda function metadata.
    public struct LambdaFunctionMetadata: Swift.Equatable {
        /// The name of a function.
        public var functionName: Swift.String?
        /// The resource tags on an AWS Lambda function.
        public var functionTags: [Swift.String:Swift.String]?
        /// The layers for an AWS Lambda function. A Lambda function can have up to five layers.
        public var layers: [Swift.String]?
        /// An AWS Lambda function's runtime.
        public var runtime: Inspector2ClientTypes.Runtime?

        public init(
            functionName: Swift.String? = nil,
            functionTags: [Swift.String:Swift.String]? = nil,
            layers: [Swift.String]? = nil,
            runtime: Inspector2ClientTypes.Runtime? = nil
        )
        {
            self.functionName = functionName
            self.functionTags = functionTags
            self.layers = layers
            self.runtime = runtime
        }
    }

}

extension Inspector2ClientTypes {
    public enum LambdaFunctionSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaFunctionSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaFunctionSortBy(rawValue: rawValue) ?? LambdaFunctionSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.LambdaLayerAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionNames
        case layerArns
        case resourceIds
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionNames = functionNames {
            var functionNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionNames)
            for stringfilter0 in functionNames {
                try functionNamesContainer.encode(stringfilter0)
            }
        }
        if let layerArns = layerArns {
            var layerArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerArns)
            for stringfilter0 in layerArns {
                try layerArnsContainer.encode(stringfilter0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilter0 in resourceIds {
                try resourceIdsContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNamesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .functionNames)
        var functionNamesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let functionNamesContainer = functionNamesContainer {
            functionNamesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in functionNamesContainer {
                if let structure0 = structure0 {
                    functionNamesDecoded0?.append(structure0)
                }
            }
        }
        functionNames = functionNamesDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let layerArnsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .layerArns)
        var layerArnsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let layerArnsContainer = layerArnsContainer {
            layerArnsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in layerArnsContainer {
                if let structure0 = structure0 {
                    layerArnsDecoded0?.append(structure0)
                }
            }
        }
        layerArns = layerArnsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.LambdaLayerSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define a findings aggregation based on an AWS Lambda function's layers.
    public struct LambdaLayerAggregation: Swift.Equatable {
        /// The names of the AWS Lambda functions associated with the layers.
        public var functionNames: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon Resource Name (ARN) of the AWS Lambda function layer.
        public var layerArns: [Inspector2ClientTypes.StringFilter]?
        /// The resource IDs for the AWS Lambda function layers.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The finding severity to use for sorting the results.
        public var sortBy: Inspector2ClientTypes.LambdaLayerSortBy?
        /// The order to use for sorting the results.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            functionNames: [Inspector2ClientTypes.StringFilter]? = nil,
            layerArns: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.LambdaLayerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.functionNames = functionNames
            self.layerArns = layerArns
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.LambdaLayerAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case functionName
        case layerArn
        case resourceId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let layerArn = self.layerArn {
            try encodeContainer.encode(layerArn, forKey: .layerArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of an AWS Lambda function layer finding aggregation.
    public struct LambdaLayerAggregationResponse: Swift.Equatable {
        /// The account ID of the AWS Lambda function layer.
        /// This member is required.
        public var accountId: Swift.String?
        /// The names of the AWS Lambda functions associated with the layers.
        /// This member is required.
        public var functionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Lambda function layer.
        /// This member is required.
        public var layerArn: Swift.String?
        /// The Resource ID of the AWS Lambda function layer.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that contains the counts of aggregated finding per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            functionName: Swift.String? = nil,
            layerArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.functionName = functionName
            self.layerArn = layerArn
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum LambdaLayerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaLayerSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaLayerSortBy(rawValue: rawValue) ?? LambdaLayerSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.LambdaVpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension Inspector2ClientTypes {
    /// The VPC security groups and subnets that are attached to an AWS Lambda function. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct LambdaVpcConfig: Swift.Equatable {
        /// The VPC security groups and subnets that are attached to an AWS Lambda function. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension ListAccountPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }
}

extension ListAccountPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accountpermissions/list"
    }
}

public struct ListAccountPermissionsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The service scan type to check permissions for.
    public var service: Inspector2ClientTypes.Service?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        service: Inspector2ClientTypes.Service? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.service = service
    }
}

struct ListAccountPermissionsInputBody: Swift.Equatable {
    let service: Inspector2ClientTypes.Service?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case service
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListAccountPermissionsOutput: Swift.Equatable {
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Contains details on the permissions an account has to configure Amazon Inspector.
    /// This member is required.
    public var permissions: [Inspector2ClientTypes.Permission]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [Inspector2ClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListAccountPermissionsOutputBody: Swift.Equatable {
    let permissions: [Inspector2ClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListAccountPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Inspector2ClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Inspector2ClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/coverage/list"
    }
}

public struct ListCoverageInput: Swift.Equatable {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoverageInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
}

extension ListCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
    }
}

extension ListCoverageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoverageOutputBody = try responseDecoder.decode(responseBody: data)
            self.coveredResources = output.coveredResources
            self.nextToken = output.nextToken
        } else {
            self.coveredResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoverageOutput: Swift.Equatable {
    /// An object that contains details on the covered resources in your environment.
    public var coveredResources: [Inspector2ClientTypes.CoveredResource]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        coveredResources: [Inspector2ClientTypes.CoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coveredResources = coveredResources
        self.nextToken = nextToken
    }
}

struct ListCoverageOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let coveredResources: [Inspector2ClientTypes.CoveredResource]?
}

extension ListCoverageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveredResources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let coveredResourcesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoveredResource?].self, forKey: .coveredResources)
        var coveredResourcesDecoded0:[Inspector2ClientTypes.CoveredResource]? = nil
        if let coveredResourcesContainer = coveredResourcesContainer {
            coveredResourcesDecoded0 = [Inspector2ClientTypes.CoveredResource]()
            for structure0 in coveredResourcesContainer {
                if let structure0 = structure0 {
                    coveredResourcesDecoded0?.append(structure0)
                }
            }
        }
        coveredResources = coveredResourcesDecoded0
    }
}

enum ListCoverageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCoverageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case groupBy
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCoverageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/coverage/statistics/list"
    }
}

public struct ListCoverageStatisticsInput: Swift.Equatable {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The value to group the results by.
    public var groupBy: Inspector2ClientTypes.GroupKey?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        groupBy: Inspector2ClientTypes.GroupKey? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.groupBy = groupBy
        self.nextToken = nextToken
    }
}

struct ListCoverageStatisticsInputBody: Swift.Equatable {
    let filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    let groupBy: Inspector2ClientTypes.GroupKey?
    let nextToken: Swift.String?
}

extension ListCoverageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case groupBy
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.GroupKey.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoverageStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoverageStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.countsByGroup = output.countsByGroup
            self.nextToken = output.nextToken
            self.totalCounts = output.totalCounts
        } else {
            self.countsByGroup = nil
            self.nextToken = nil
            self.totalCounts = nil
        }
    }
}

public struct ListCoverageStatisticsOutput: Swift.Equatable {
    /// An array with the number for each group.
    public var countsByGroup: [Inspector2ClientTypes.Counts]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The total number for all groups.
    /// This member is required.
    public var totalCounts: Swift.Int?

    public init(
        countsByGroup: [Inspector2ClientTypes.Counts]? = nil,
        nextToken: Swift.String? = nil,
        totalCounts: Swift.Int? = nil
    )
    {
        self.countsByGroup = countsByGroup
        self.nextToken = nextToken
        self.totalCounts = totalCounts
    }
}

struct ListCoverageStatisticsOutputBody: Swift.Equatable {
    let countsByGroup: [Inspector2ClientTypes.Counts]?
    let totalCounts: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCoverageStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countsByGroup
        case nextToken
        case totalCounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countsByGroupContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Counts?].self, forKey: .countsByGroup)
        var countsByGroupDecoded0:[Inspector2ClientTypes.Counts]? = nil
        if let countsByGroupContainer = countsByGroupContainer {
            countsByGroupDecoded0 = [Inspector2ClientTypes.Counts]()
            for structure0 in countsByGroupContainer {
                if let structure0 = structure0 {
                    countsByGroupDecoded0?.append(structure0)
                }
            }
        }
        countsByGroup = countsByGroupDecoded0
        let totalCountsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCounts)
        totalCounts = totalCountsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCoverageStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDelegatedAdminAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDelegatedAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/list"
    }
}

public struct ListDelegatedAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDelegatedAdminAccountsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDelegatedAdminAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDelegatedAdminAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDelegatedAdminAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccounts = output.delegatedAdminAccounts
            self.nextToken = output.nextToken
        } else {
            self.delegatedAdminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListDelegatedAdminAccountsOutput: Swift.Equatable {
    /// Details of the Amazon Inspector delegated administrator of your organization.
    public var delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegatedAdminAccounts = delegatedAdminAccounts
        self.nextToken = nextToken
    }
}

struct ListDelegatedAdminAccountsOutputBody: Swift.Equatable {
    let delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]?
    let nextToken: Swift.String?
}

extension ListDelegatedAdminAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccounts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DelegatedAdminAccount?].self, forKey: .delegatedAdminAccounts)
        var delegatedAdminAccountsDecoded0:[Inspector2ClientTypes.DelegatedAdminAccount]? = nil
        if let delegatedAdminAccountsContainer = delegatedAdminAccountsContainer {
            delegatedAdminAccountsDecoded0 = [Inspector2ClientTypes.DelegatedAdminAccount]()
            for structure0 in delegatedAdminAccountsContainer {
                if let structure0 = structure0 {
                    delegatedAdminAccountsDecoded0?.append(structure0)
                }
            }
        }
        delegatedAdminAccounts = delegatedAdminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDelegatedAdminAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFiltersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arns
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for filterarn0 in arns {
                try arnsContainer.encode(filterarn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/list"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The action the filter applies to matched findings.
    public var action: Inspector2ClientTypes.FilterAction?
    /// The Amazon resource number (ARN) of the filter.
    public var arns: [Swift.String]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.action = action
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let action: Inspector2ClientTypes.FilterAction?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFiltersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arns
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFiltersOutputBody = try responseDecoder.decode(responseBody: data)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutput: Swift.Equatable {
    /// Contains details on the filters associated with your account.
    /// This member is required.
    public var filters: [Inspector2ClientTypes.Filter]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filters: [Inspector2ClientTypes.Filter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputBody: Swift.Equatable {
    let filters: [Inspector2ClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Inspector2ClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Inspector2ClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFiltersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingAggregationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case aggregationRequest
        case aggregationType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for stringfilter0 in accountIds {
                try accountIdsContainer.encode(stringfilter0)
            }
        }
        if let aggregationRequest = self.aggregationRequest {
            try encodeContainer.encode(aggregationRequest, forKey: .aggregationRequest)
        }
        if let aggregationType = self.aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFindingAggregationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/aggregation/list"
    }
}

public struct ListFindingAggregationsInput: Swift.Equatable {
    /// The Amazon Web Services account IDs to retrieve finding aggregation data for.
    public var accountIds: [Inspector2ClientTypes.StringFilter]?
    /// Details of the aggregation request that is used to filter your aggregation results.
    public var aggregationRequest: Inspector2ClientTypes.AggregationRequest?
    /// The type of the aggregation request.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Inspector2ClientTypes.StringFilter]? = nil,
        aggregationRequest: Inspector2ClientTypes.AggregationRequest? = nil,
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.aggregationRequest = aggregationRequest
        self.aggregationType = aggregationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingAggregationsInputBody: Swift.Equatable {
    let aggregationType: Inspector2ClientTypes.AggregationType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let accountIds: [Inspector2ClientTypes.StringFilter]?
    let aggregationRequest: Inspector2ClientTypes.AggregationRequest?
}

extension ListFindingAggregationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case aggregationRequest
        case aggregationType
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in accountIdsContainer {
                if let structure0 = structure0 {
                    accountIdsDecoded0?.append(structure0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let aggregationRequestDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationRequest.self, forKey: .aggregationRequest)
        aggregationRequest = aggregationRequestDecoded
    }
}

extension ListFindingAggregationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingAggregationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationType = output.aggregationType
            self.nextToken = output.nextToken
            self.responses = output.responses
        } else {
            self.aggregationType = nil
            self.nextToken = nil
            self.responses = nil
        }
    }
}

public struct ListFindingAggregationsOutput: Swift.Equatable {
    /// The type of aggregation to perform.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Objects that contain the results of an aggregation operation.
    public var responses: [Inspector2ClientTypes.AggregationResponse]?

    public init(
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        nextToken: Swift.String? = nil,
        responses: [Inspector2ClientTypes.AggregationResponse]? = nil
    )
    {
        self.aggregationType = aggregationType
        self.nextToken = nextToken
        self.responses = responses
    }
}

struct ListFindingAggregationsOutputBody: Swift.Equatable {
    let aggregationType: Inspector2ClientTypes.AggregationType?
    let responses: [Inspector2ClientTypes.AggregationResponse]?
    let nextToken: Swift.String?
}

extension ListFindingAggregationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
        case nextToken
        case responses
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let responsesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.AggregationResponse?].self, forKey: .responses)
        var responsesDecoded0:[Inspector2ClientTypes.AggregationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [Inspector2ClientTypes.AggregationResponse]()
            for union0 in responsesContainer {
                if let union0 = union0 {
                    responsesDecoded0?.append(union0)
                }
            }
        }
        responses = responsesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingAggregationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
        case sortCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/list"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// Details on the filters to apply to your finding results.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Details on the sort criteria to apply to your finding results.
    public var sortCriteria: Inspector2ClientTypes.SortCriteria?

    public init(
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Inspector2ClientTypes.SortCriteria? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let sortCriteria: Inspector2ClientTypes.SortCriteria?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
        case sortCriteria
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutput: Swift.Equatable {
    /// Contains details on the findings in your environment.
    public var findings: [Inspector2ClientTypes.Finding]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        findings: [Inspector2ClientTypes.Finding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let findings: [Inspector2ClientTypes.Finding]?
}

extension ListFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let findingsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[Inspector2ClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Inspector2ClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

enum ListFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case onlyAssociated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let onlyAssociated = self.onlyAssociated {
            try encodeContainer.encode(onlyAssociated, forKey: .onlyAssociated)
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/list"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Specifies whether to list only currently associated members if True or to list all members within the organization if False.
    public var onlyAssociated: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
    let onlyAssociated: Swift.Bool?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case onlyAssociated
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onlyAssociatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyAssociated)
        onlyAssociated = onlyAssociatedDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutput: Swift.Equatable {
    /// An object that contains details for each member account.
    public var members: [Inspector2ClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        members: [Inspector2ClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputBody: Swift.Equatable {
    let members: [Inspector2ClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[Inspector2ClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Inspector2ClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon resource number (ARN) of the resource to list tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsageTotalsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for usageaccountid0 in accountIds {
                try accountIdsContainer.encode(usageaccountid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUsageTotalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usage/list"
    }
}

public struct ListUsageTotalsInput: Swift.Equatable {
    /// The Amazon Web Services account IDs to retrieve usage totals for.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsageTotalsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountIds: [Swift.String]?
}

extension ListUsageTotalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension ListUsageTotalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsageTotalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.totals = output.totals
        } else {
            self.nextToken = nil
            self.totals = nil
        }
    }
}

public struct ListUsageTotalsOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// An object with details on the total usage for the requested account.
    public var totals: [Inspector2ClientTypes.UsageTotal]?

    public init(
        nextToken: Swift.String? = nil,
        totals: [Inspector2ClientTypes.UsageTotal]? = nil
    )
    {
        self.nextToken = nextToken
        self.totals = totals
    }
}

struct ListUsageTotalsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totals: [Inspector2ClientTypes.UsageTotal]?
}

extension ListUsageTotalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case totals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.UsageTotal?].self, forKey: .totals)
        var totalsDecoded0:[Inspector2ClientTypes.UsageTotal]? = nil
        if let totalsContainer = totalsContainer {
            totalsDecoded0 = [Inspector2ClientTypes.UsageTotal]()
            for structure0 in totalsContainer {
                if let structure0 = structure0 {
                    totalsDecoded0?.append(structure0)
                }
            }
        }
        totals = totalsDecoded0
    }
}

enum ListUsageTotalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes {
    public enum MapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [MapComparison] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MapComparison(rawValue: rawValue) ?? MapComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.MapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.MapComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes details of a map filter.
    public struct MapFilter: Swift.Equatable {
        /// The operator to use when comparing values in the filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.MapComparison?
        /// The tag key used in the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value used in the filter.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.MapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case delegatedAdminAccountId
        case relationshipStatus
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let delegatedAdminAccountId = self.delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details on a member account in your organization.
    public struct Member: Swift.Equatable {
        /// The Amazon Web Services account ID of the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.
        public var delegatedAdminAccountId: Swift.String?
        /// The status of the member account.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?
        /// A timestamp showing when the status of this member was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            delegatedAdminAccountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.delegatedAdminAccountId = delegatedAdminAccountId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case activateDeepInspection
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let activateDeepInspection = self.activateDeepInspection {
            try encodeContainer.encode(activateDeepInspection, forKey: .activateDeepInspection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let activateDeepInspectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activateDeepInspection)
        activateDeepInspection = activateDeepInspectionDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the status of Amazon Inspector deep inspection for a member account in your organization.
    public struct MemberAccountEc2DeepInspectionStatus: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account of the organization member.
        /// This member is required.
        public var accountId: Swift.String?
        /// Whether Amazon Inspector deep inspection is active in the account. If TRUE Amazon Inspector deep inspection is active, if FALSE it is not active.
        /// This member is required.
        public var activateDeepInspection: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            activateDeepInspection: Swift.Bool? = nil
        )
        {
            self.accountId = accountId
            self.activateDeepInspection = activateDeepInspection
        }
    }

}

extension Inspector2ClientTypes.MemberAccountEc2DeepInspectionStatusState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case errorMessage
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2DeepInspectionStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the state of Amazon Inspector deep inspection for a member account.
    public struct MemberAccountEc2DeepInspectionStatusState: Swift.Equatable {
        /// The unique identifier for the Amazon Web Services account of the organization member
        /// This member is required.
        public var accountId: Swift.String?
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public var errorMessage: Swift.String?
        /// The state of Amazon Inspector deep inspection in the member account.
        public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

        public init(
            accountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
        )
        {
            self.accountId = accountId
            self.errorMessage = errorMessage
            self.status = status
        }
    }

}

extension Inspector2ClientTypes.NetworkPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for step0 in steps {
                try stepsContainer.encode(step0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[Inspector2ClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [Inspector2ClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information on the network path associated with a finding.
    public struct NetworkPath: Swift.Equatable {
        /// The details on the steps in the network path.
        public var steps: [Inspector2ClientTypes.Step]?

        public init(
            steps: [Inspector2ClientTypes.Step]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension Inspector2ClientTypes {
    public enum NetworkProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkProtocol(rawValue: rawValue) ?? NetworkProtocol.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.NetworkReachabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkPath
        case openPortRange
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkPath = self.networkPath {
            try encodeContainer.encode(networkPath, forKey: .networkPath)
        }
        if let openPortRange = self.openPortRange {
            try encodeContainer.encode(openPortRange, forKey: .openPortRange)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openPortRangeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PortRange.self, forKey: .openPortRange)
        openPortRange = openPortRangeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let networkPathDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkPath.self, forKey: .networkPath)
        networkPath = networkPathDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains the details of a network reachability finding.
    public struct NetworkReachabilityDetails: Swift.Equatable {
        /// An object that contains details about a network path associated with a finding.
        /// This member is required.
        public var networkPath: Inspector2ClientTypes.NetworkPath?
        /// An object that contains details about the open port range associated with a finding.
        /// This member is required.
        public var openPortRange: Inspector2ClientTypes.PortRange?
        /// The protocol associated with a finding.
        /// This member is required.
        public var `protocol`: Inspector2ClientTypes.NetworkProtocol?

        public init(
            networkPath: Inspector2ClientTypes.NetworkPath? = nil,
            openPortRange: Inspector2ClientTypes.PortRange? = nil,
            `protocol`: Inspector2ClientTypes.NetworkProtocol? = nil
        )
        {
            self.networkPath = networkPath
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
        }
    }

}

extension Inspector2ClientTypes.NumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerInclusive
        case upperInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerInclusive = self.lowerInclusive {
            try encodeContainer.encode(lowerInclusive, forKey: .lowerInclusive)
        }
        if let upperInclusive = self.upperInclusive {
            try encodeContainer.encode(upperInclusive, forKey: .upperInclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upperInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .upperInclusive)
        upperInclusive = upperInclusiveDecoded
        let lowerInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lowerInclusive)
        lowerInclusive = lowerInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a number filter.
    public struct NumberFilter: Swift.Equatable {
        /// The lowest number to be included in the filter.
        public var lowerInclusive: Swift.Double?
        /// The highest number to be included in the filter.
        public var upperInclusive: Swift.Double?

        public init(
            lowerInclusive: Swift.Double? = nil,
            upperInclusive: Swift.Double? = nil
        )
        {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }
    }

}

extension Inspector2ClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableRepository
        case disableScanning
        case enableRepository
        case enableScanning
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .disableRepository,
                .disableScanning,
                .enableRepository,
                .enableScanning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableRepository: return "DISABLE_REPOSITORY"
            case .disableScanning: return "DISABLE_SCANNING"
            case .enableRepository: return "ENABLE_REPOSITORY"
            case .enableScanning: return "ENABLE_SCANNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.PackageAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageNames
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageNames = packageNames {
            var packageNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packageNames)
            for stringfilter0 in packageNames {
                try packageNamesContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNamesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .packageNames)
        var packageNamesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let packageNamesContainer = packageNamesContainer {
            packageNamesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in packageNamesContainer {
                if let structure0 = structure0 {
                    packageNamesDecoded0?.append(structure0)
                }
            }
        }
        packageNames = packageNamesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on operating system package type.
    public struct PackageAggregation: Swift.Equatable {
        /// The names of packages to aggregate findings on.
        public var packageNames: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.PackageSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            packageNames: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.PackageSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.packageNames = packageNames
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.PackageAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case packageName
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct PackageAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The name of the operating system package.
        /// This member is required.
        public var packageName: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.packageName = packageName
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes.PackageFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case epoch
        case name
        case release
        case sourceLambdaLayerArn
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let epoch = self.epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let release = self.release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let sourceLambdaLayerArn = self.sourceLambdaLayerArn {
            try encodeContainer.encode(sourceLambdaLayerArn, forKey: .sourceLambdaLayerArn)
        }
        if let sourceLayerHash = self.sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .version)
        version = versionDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NumberFilter.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .release)
        release = releaseDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .architecture)
        architecture = architectureDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let sourceLambdaLayerArnDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .sourceLambdaLayerArn)
        sourceLambdaLayerArn = sourceLambdaLayerArnDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the details of a package filter.
    public struct PackageFilter: Swift.Equatable {
        /// An object that contains details on the package architecture type to filter on.
        public var architecture: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package epoch to filter on.
        public var epoch: Inspector2ClientTypes.NumberFilter?
        /// An object that contains details on the name of the package to filter on.
        public var name: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package release to filter on.
        public var release: Inspector2ClientTypes.StringFilter?
        /// An object that describes the details of a string filter.
        public var sourceLambdaLayerArn: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the source layer hash to filter on.
        public var sourceLayerHash: Inspector2ClientTypes.StringFilter?
        /// The package version to filter on.
        public var version: Inspector2ClientTypes.StringFilter?

        public init(
            architecture: Inspector2ClientTypes.StringFilter? = nil,
            epoch: Inspector2ClientTypes.NumberFilter? = nil,
            name: Inspector2ClientTypes.StringFilter? = nil,
            release: Inspector2ClientTypes.StringFilter? = nil,
            sourceLambdaLayerArn: Inspector2ClientTypes.StringFilter? = nil,
            sourceLayerHash: Inspector2ClientTypes.StringFilter? = nil,
            version: Inspector2ClientTypes.StringFilter? = nil
        )
        {
            self.architecture = architecture
            self.epoch = epoch
            self.name = name
            self.release = release
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {
    public enum PackageManager: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bundler
        case cargo
        case composer
        case gemspec
        case gobinary
        case gomod
        case jar
        case nodepkg
        case npm
        case nuget
        case os
        case pip
        case pipenv
        case poetry
        case pom
        case pythonpkg
        case yarn
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageManager] {
            return [
                .bundler,
                .cargo,
                .composer,
                .gemspec,
                .gobinary,
                .gomod,
                .jar,
                .nodepkg,
                .npm,
                .nuget,
                .os,
                .pip,
                .pipenv,
                .poetry,
                .pom,
                .pythonpkg,
                .yarn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bundler: return "BUNDLER"
            case .cargo: return "CARGO"
            case .composer: return "COMPOSER"
            case .gemspec: return "GEMSPEC"
            case .gobinary: return "GOBINARY"
            case .gomod: return "GOMOD"
            case .jar: return "JAR"
            case .nodepkg: return "NODEPKG"
            case .npm: return "NPM"
            case .nuget: return "NUGET"
            case .os: return "OS"
            case .pip: return "PIP"
            case .pipenv: return "PIPENV"
            case .poetry: return "POETRY"
            case .pom: return "POM"
            case .pythonpkg: return "PYTHONPKG"
            case .yarn: return "YARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageManager(rawValue: rawValue) ?? PackageManager.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum PackageSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageSortBy(rawValue: rawValue) ?? PackageSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.PackageVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
        case vulnerabilityId
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvssscore0 in cvss {
                try cvssContainer.encode(cvssscore0)
            }
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for nonemptystring0 in referenceUrls {
                try referenceUrlsContainer.encode(nonemptystring0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for vulnerabilityid0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(vulnerabilityid0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encodeTimestamp(vendorCreatedAt, format: .epochSeconds, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encodeTimestamp(vendorUpdatedAt, format: .epochSeconds, forKey: .vendorUpdatedAt)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for vulnerablepackage0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(vulnerablepackage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.VulnerablePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[Inspector2ClientTypes.VulnerablePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [Inspector2ClientTypes.VulnerablePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let cvssContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CvssScore?].self, forKey: .cvss)
        var cvssDecoded0:[Inspector2ClientTypes.CvssScore]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [Inspector2ClientTypes.CvssScore]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about a package vulnerability finding.
    public struct PackageVulnerabilityDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score of a finding.
        public var cvss: [Inspector2ClientTypes.CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        /// This member is required.
        public var source: Swift.String?
        /// A URL to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: ClientRuntime.Date?
        /// The severity the vendor has given to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: ClientRuntime.Date?
        /// The ID given to this vulnerability.
        /// This member is required.
        public var vulnerabilityId: Swift.String?
        /// The packages impacted by this vulnerability.
        public var vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]?

        public init(
            cvss: [Inspector2ClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: ClientRuntime.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: ClientRuntime.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension Inspector2ClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the permissions an account has within Amazon Inspector.
    public struct Permission: Swift.Equatable {
        /// The operations that can be performed with the given permissions.
        /// This member is required.
        public var operation: Inspector2ClientTypes.Operation?
        /// The services that the permissions allow an account to perform the given operations for.
        /// This member is required.
        public var service: Inspector2ClientTypes.Service?

        public init(
            operation: Inspector2ClientTypes.Operation? = nil,
            service: Inspector2ClientTypes.Service? = nil
        )
        {
            self.operation = operation
            self.service = service
        }
    }

}

extension Inspector2ClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case begin
        case end
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let begin = self.begin {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the port range associated with a finding.
    public struct PortRange: Swift.Equatable {
        /// The beginning port in a port range.
        /// This member is required.
        public var begin: Swift.Int?
        /// The ending port in a port range.
        /// This member is required.
        public var end: Swift.Int?

        public init(
            begin: Swift.Int? = nil,
            end: Swift.Int? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension Inspector2ClientTypes.PortRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginInclusive
        case endInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginInclusive = self.beginInclusive {
            try encodeContainer.encode(beginInclusive, forKey: .beginInclusive)
        }
        if let endInclusive = self.endInclusive {
            try encodeContainer.encode(endInclusive, forKey: .endInclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginInclusive)
        beginInclusive = beginInclusiveDecoded
        let endInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endInclusive)
        endInclusive = endInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a port range filter.
    public struct PortRangeFilter: Swift.Equatable {
        /// The port number the port range begins at.
        public var beginInclusive: Swift.Int?
        /// The port number the port range ends at.
        public var endInclusive: Swift.Int?

        public init(
            beginInclusive: Swift.Int? = nil,
            endInclusive: Swift.Int? = nil
        )
        {
            self.beginInclusive = beginInclusive
            self.endInclusive = endInclusive
        }
    }

}

extension Inspector2ClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the recommended course of action to remediate the finding.
    public struct Recommendation: Swift.Equatable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the CVE remediation recommendations.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension Inspector2ClientTypes {
    public enum RelationshipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSuspended
        case cannotCreateDetectorInOrgMaster
        case created
        case deleted
        case disabled
        case emailVerificationFailed
        case emailVerificationInProgress
        case enabled
        case invited
        case regionDisabled
        case removed
        case resigned
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipStatus] {
            return [
                .accountSuspended,
                .cannotCreateDetectorInOrgMaster,
                .created,
                .deleted,
                .disabled,
                .emailVerificationFailed,
                .emailVerificationInProgress,
                .enabled,
                .invited,
                .regionDisabled,
                .removed,
                .resigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSuspended: return "ACCOUNT_SUSPENDED"
            case .cannotCreateDetectorInOrgMaster: return "CANNOT_CREATE_DETECTOR_IN_ORG_MASTER"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .emailVerificationFailed: return "EMAIL_VERIFICATION_FAILED"
            case .emailVerificationInProgress: return "EMAIL_VERIFICATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .invited: return "INVITED"
            case .regionDisabled: return "REGION_DISABLED"
            case .removed: return "REMOVED"
            case .resigned: return "RESIGNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipStatus(rawValue: rawValue) ?? RelationshipStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on how to remediate a finding.
    public struct Remediation: Swift.Equatable {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: Inspector2ClientTypes.Recommendation?

        public init(
            recommendation: Inspector2ClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension Inspector2ClientTypes {
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ReportingErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketNotFound
        case incompatibleBucketRegion
        case internalError
        case invalidPermissions
        case malformedKmsKey
        case noFindingsFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportingErrorCode] {
            return [
                .bucketNotFound,
                .incompatibleBucketRegion,
                .internalError,
                .invalidPermissions,
                .malformedKmsKey,
                .noFindingsFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketNotFound: return "BUCKET_NOT_FOUND"
            case .incompatibleBucketRegion: return "INCOMPATIBLE_BUCKET_REGION"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidPermissions: return "INVALID_PERMISSIONS"
            case .malformedKmsKey: return "MALFORMED_KMS_KEY"
            case .noFindingsFound: return "NO_FINDINGS_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportingErrorCode(rawValue: rawValue) ?? ReportingErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.RepositoryAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositories
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilter0 in repositories {
                try repositoriesContainer.encode(stringfilter0)
            }
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RepositorySortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on repository.
    public struct RepositoryAggregation: Swift.Equatable {
        /// The names of repositories to aggregate findings on.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.RepositorySortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.RepositorySortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.repositories = repositories
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.RepositoryAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case affectedImages
        case repository
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let affectedImages = self.affectedImages {
            try encodeContainer.encode(affectedImages, forKey: .affectedImages)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let affectedImagesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .affectedImages)
        affectedImages = affectedImagesDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by repository.
    public struct RepositoryAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The number of container images impacted by the findings.
        public var affectedImages: Swift.Int?
        /// The name of the repository associated with the findings.
        /// This member is required.
        public var repository: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init(
            accountId: Swift.String? = nil,
            affectedImages: Swift.Int? = nil,
            repository: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedImages = affectedImages
            self.repository = repository
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum RepositorySortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case affectedImages
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositorySortBy] {
            return [
                .affectedImages,
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .affectedImages: return "AFFECTED_IMAGES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositorySortBy(rawValue: rawValue) ?? RepositorySortBy.sdkUnknown(rawValue)
        }
    }
}

extension ResetEncryptionKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }
}

extension ResetEncryptionKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/encryptionkey/reset"
    }
}

public struct ResetEncryptionKeyInput: Swift.Equatable {
    /// The resource type the key encrypts.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type the key encrypts.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

struct ResetEncryptionKeyInputBody: Swift.Equatable {
    let scanType: Inspector2ClientTypes.ScanType?
    let resourceType: Inspector2ClientTypes.ResourceType?
}

extension ResetEncryptionKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
        case scanType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResetEncryptionKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetEncryptionKeyOutput: Swift.Equatable {

    public init() { }
}

enum ResetEncryptionKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case id
        case partition
        case region
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let detailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the resource involved in a finding.
    public struct Resource: Swift.Equatable {
        /// An object that contains details about the resource involved in a finding.
        public var details: Inspector2ClientTypes.ResourceDetails?
        /// The ID of the resource.
        /// This member is required.
        public var id: Swift.String?
        /// The partition of the resource.
        public var partition: Swift.String?
        /// The Amazon Web Services Region the impacted resource is located in.
        public var region: Swift.String?
        /// The tags attached to the resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of resource.
        /// This member is required.
        public var type: Inspector2ClientTypes.ResourceType?

        public init(
            details: Inspector2ClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Inspector2ClientTypes.ResourceType? = nil
        )
        {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsLambdaFunction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2Instance = self.awsEc2Instance {
            try encodeContainer.encode(awsEc2Instance, forKey: .awsEc2Instance)
        }
        if let awsEcrContainerImage = self.awsEcrContainerImage {
            try encodeContainer.encode(awsEcrContainerImage, forKey: .awsEcrContainerImage)
        }
        if let awsLambdaFunction = self.awsLambdaFunction {
            try encodeContainer.encode(awsLambdaFunction, forKey: .awsLambdaFunction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsEc2InstanceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEc2InstanceDetails.self, forKey: .awsEc2Instance)
        awsEc2Instance = awsEc2InstanceDecoded
        let awsEcrContainerImageDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerImageDetails.self, forKey: .awsEcrContainerImage)
        awsEcrContainerImage = awsEcrContainerImageDecoded
        let awsLambdaFunctionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsLambdaFunctionDetails.self, forKey: .awsLambdaFunction)
        awsLambdaFunction = awsLambdaFunctionDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details about the resource involved in the finding.
    public struct ResourceDetails: Swift.Equatable {
        /// An object that contains details about the Amazon EC2 instance involved in the finding.
        public var awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails?
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public var awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails?
        /// A summary of the information about an AWS Lambda function affected by a finding.
        public var awsLambdaFunction: Inspector2ClientTypes.AwsLambdaFunctionDetails?

        public init(
            awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails? = nil,
            awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails? = nil,
            awsLambdaFunction: Inspector2ClientTypes.AwsLambdaFunctionDetails? = nil
        )
        {
            self.awsEc2Instance = awsEc2Instance
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsLambdaFunction = awsLambdaFunction
        }
    }

}

extension Inspector2ClientTypes.ResourceFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ec2InstanceTags
        case ecrImageTags
        case ecrRepositoryName
        case lambdaFunctionName
        case lambdaFunctionTags
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            var accountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountId)
            for resourcestringfilter0 in accountId {
                try accountIdContainer.encode(resourcestringfilter0)
            }
        }
        if let ec2InstanceTags = ec2InstanceTags {
            var ec2InstanceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTags)
            for resourcemapfilter0 in ec2InstanceTags {
                try ec2InstanceTagsContainer.encode(resourcemapfilter0)
            }
        }
        if let ecrImageTags = ecrImageTags {
            var ecrImageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageTags)
            for resourcestringfilter0 in ecrImageTags {
                try ecrImageTagsContainer.encode(resourcestringfilter0)
            }
        }
        if let ecrRepositoryName = ecrRepositoryName {
            var ecrRepositoryNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrRepositoryName)
            for resourcestringfilter0 in ecrRepositoryName {
                try ecrRepositoryNameContainer.encode(resourcestringfilter0)
            }
        }
        if let lambdaFunctionName = lambdaFunctionName {
            var lambdaFunctionNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionName)
            for resourcestringfilter0 in lambdaFunctionName {
                try lambdaFunctionNameContainer.encode(resourcestringfilter0)
            }
        }
        if let lambdaFunctionTags = lambdaFunctionTags {
            var lambdaFunctionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaFunctionTags)
            for resourcemapfilter0 in lambdaFunctionTags {
                try lambdaFunctionTagsContainer.encode(resourcemapfilter0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for resourcestringfilter0 in resourceId {
                try resourceIdContainer.encode(resourcestringfilter0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for resourcestringfilter0 in resourceType {
                try resourceTypeContainer.encode(resourcestringfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .accountId)
        var accountIdDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let accountIdContainer = accountIdContainer {
            accountIdDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in accountIdContainer {
                if let structure0 = structure0 {
                    accountIdDecoded0?.append(structure0)
                }
            }
        }
        accountId = accountIdDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let ecrRepositoryNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .ecrRepositoryName)
        var ecrRepositoryNameDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let ecrRepositoryNameContainer = ecrRepositoryNameContainer {
            ecrRepositoryNameDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in ecrRepositoryNameContainer {
                if let structure0 = structure0 {
                    ecrRepositoryNameDecoded0?.append(structure0)
                }
            }
        }
        ecrRepositoryName = ecrRepositoryNameDecoded0
        let lambdaFunctionNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .lambdaFunctionName)
        var lambdaFunctionNameDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let lambdaFunctionNameContainer = lambdaFunctionNameContainer {
            lambdaFunctionNameDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in lambdaFunctionNameContainer {
                if let structure0 = structure0 {
                    lambdaFunctionNameDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionName = lambdaFunctionNameDecoded0
        let ecrImageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceStringFilter?].self, forKey: .ecrImageTags)
        var ecrImageTagsDecoded0:[Inspector2ClientTypes.ResourceStringFilter]? = nil
        if let ecrImageTagsContainer = ecrImageTagsContainer {
            ecrImageTagsDecoded0 = [Inspector2ClientTypes.ResourceStringFilter]()
            for structure0 in ecrImageTagsContainer {
                if let structure0 = structure0 {
                    ecrImageTagsDecoded0?.append(structure0)
                }
            }
        }
        ecrImageTags = ecrImageTagsDecoded0
        let ec2InstanceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceMapFilter?].self, forKey: .ec2InstanceTags)
        var ec2InstanceTagsDecoded0:[Inspector2ClientTypes.ResourceMapFilter]? = nil
        if let ec2InstanceTagsContainer = ec2InstanceTagsContainer {
            ec2InstanceTagsDecoded0 = [Inspector2ClientTypes.ResourceMapFilter]()
            for structure0 in ec2InstanceTagsContainer {
                if let structure0 = structure0 {
                    ec2InstanceTagsDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceTags = ec2InstanceTagsDecoded0
        let lambdaFunctionTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceMapFilter?].self, forKey: .lambdaFunctionTags)
        var lambdaFunctionTagsDecoded0:[Inspector2ClientTypes.ResourceMapFilter]? = nil
        if let lambdaFunctionTagsContainer = lambdaFunctionTagsContainer {
            lambdaFunctionTagsDecoded0 = [Inspector2ClientTypes.ResourceMapFilter]()
            for structure0 in lambdaFunctionTagsContainer {
                if let structure0 = structure0 {
                    lambdaFunctionTagsDecoded0?.append(structure0)
                }
            }
        }
        lambdaFunctionTags = lambdaFunctionTagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// The resource filter criteria for a Software bill of materials (SBOM) report.
    public struct ResourceFilterCriteria: Swift.Equatable {
        /// The account IDs used as resource filter criteria.
        public var accountId: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The EC2 instance tags used as resource filter criteria.
        public var ec2InstanceTags: [Inspector2ClientTypes.ResourceMapFilter]?
        /// The ECR image tags used as resource filter criteria.
        public var ecrImageTags: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The ECR repository names used as resource filter criteria.
        public var ecrRepositoryName: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The AWS Lambda function name used as resource filter criteria.
        public var lambdaFunctionName: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The AWS Lambda function tags used as resource filter criteria.
        public var lambdaFunctionTags: [Inspector2ClientTypes.ResourceMapFilter]?
        /// The resource IDs used as resource filter criteria.
        public var resourceId: [Inspector2ClientTypes.ResourceStringFilter]?
        /// The resource types used as resource filter criteria.
        public var resourceType: [Inspector2ClientTypes.ResourceStringFilter]?

        public init(
            accountId: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            ec2InstanceTags: [Inspector2ClientTypes.ResourceMapFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            ecrRepositoryName: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            lambdaFunctionName: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            lambdaFunctionTags: [Inspector2ClientTypes.ResourceMapFilter]? = nil,
            resourceId: [Inspector2ClientTypes.ResourceStringFilter]? = nil,
            resourceType: [Inspector2ClientTypes.ResourceStringFilter]? = nil
        )
        {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionTags = lambdaFunctionTags
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceMapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceMapComparison] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceMapComparison(rawValue: rawValue) ?? ResourceMapComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ResourceMapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceMapComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// A resource map filter for a software bill of material report.
    public struct ResourceMapFilter: Swift.Equatable {
        /// The filter's comparison.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.ResourceMapComparison?
        /// The filter's key.
        /// This member is required.
        public var key: Swift.String?
        /// The filter's value.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.ResourceMapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation tried to access an invalid resource. Make sure the resource is specified correctly.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.ResourceScanMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecrImage
        case ecrRepository
        case lambdaFunction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = self.ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecrImage = self.ecrImage {
            try encodeContainer.encode(ecrImage, forKey: .ecrImage)
        }
        if let ecrRepository = self.ecrRepository {
            try encodeContainer.encode(ecrRepository, forKey: .ecrRepository)
        }
        if let lambdaFunction = self.lambdaFunction {
            try encodeContainer.encode(lambdaFunction, forKey: .lambdaFunction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRepositoryMetadata.self, forKey: .ecrRepository)
        ecrRepository = ecrRepositoryDecoded
        let ecrImageDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrContainerImageMetadata.self, forKey: .ecrImage)
        ecrImage = ecrImageDecoded
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2Metadata.self, forKey: .ec2)
        ec2 = ec2Decoded
        let lambdaFunctionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.LambdaFunctionMetadata.self, forKey: .lambdaFunction)
        lambdaFunction = lambdaFunctionDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the metadata for an Amazon ECR resource.
    public struct ResourceScanMetadata: Swift.Equatable {
        /// An object that contains metadata details for an Amazon EC2 instance.
        public var ec2: Inspector2ClientTypes.Ec2Metadata?
        /// An object that contains details about the container metadata for an Amazon ECR image.
        public var ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata?
        /// An object that contains details about the repository an Amazon ECR image resides in.
        public var ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata?
        /// An object that contains metadata details for an AWS Lambda function.
        public var lambdaFunction: Inspector2ClientTypes.LambdaFunctionMetadata?

        public init(
            ec2: Inspector2ClientTypes.Ec2Metadata? = nil,
            ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata? = nil,
            ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata? = nil,
            lambdaFunction: Inspector2ClientTypes.LambdaFunctionMetadata? = nil
        )
        {
            self.ec2 = ec2
            self.ecrImage = ecrImage
            self.ecrRepository = ecrRepository
            self.lambdaFunction = lambdaFunction
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case lambdaCode
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceScanType] {
            return [
                .ec2,
                .ecr,
                .lambda,
                .lambdaCode,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case .lambdaCode: return "LAMBDA_CODE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceScanType(rawValue: rawValue) ?? ResourceScanType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ResourceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
        case lambda
        case lambdaCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = self.ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecr = self.ecr {
            try encodeContainer.encode(ecr, forKey: .ecr)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let lambdaCode = self.lambdaCode {
            try encodeContainer.encode(lambdaCode, forKey: .lambdaCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .ecr)
        ecr = ecrDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .lambda)
        lambda = lambdaDecoded
        let lambdaCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .lambdaCode)
        lambdaCode = lambdaCodeDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details the state of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceState: Swift.Equatable {
        /// An object detailing the state of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.State?
        /// An object detailing the state of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.State?
        /// An object that described the state of Amazon Inspector scans for an account.
        public var lambda: Inspector2ClientTypes.State?
        /// An object that described the state of Amazon Inspector scans for an account.
        public var lambdaCode: Inspector2ClientTypes.State?

        public init(
            ec2: Inspector2ClientTypes.State? = nil,
            ecr: Inspector2ClientTypes.State? = nil,
            lambda: Inspector2ClientTypes.State? = nil,
            lambdaCode: Inspector2ClientTypes.State? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes.ResourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
        case lambda
        case lambdaCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = self.ec2 {
            try encodeContainer.encode(ec2.rawValue, forKey: .ec2)
        }
        if let ecr = self.ecr {
            try encodeContainer.encode(ecr.rawValue, forKey: .ecr)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda.rawValue, forKey: .lambda)
        }
        if let lambdaCode = self.lambdaCode {
            try encodeContainer.encode(lambdaCode.rawValue, forKey: .lambdaCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .ecr)
        ecr = ecrDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .lambda)
        lambda = lambdaDecoded
        let lambdaCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .lambdaCode)
        lambdaCode = lambdaCodeDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details the status of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceStatus: Swift.Equatable {
        /// The status of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for AWS Lambda function.
        public var lambda: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for custom application code for Amazon Web Services Lambda functions.
        public var lambdaCode: Inspector2ClientTypes.Status?

        public init(
            ec2: Inspector2ClientTypes.Status? = nil,
            ecr: Inspector2ClientTypes.Status? = nil,
            lambda: Inspector2ClientTypes.Status? = nil,
            lambdaCode: Inspector2ClientTypes.Status? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStringComparison] {
            return [
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStringComparison(rawValue: rawValue) ?? ResourceStringComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ResourceStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceStringComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// A resource string filter for a software bill of materials report.
    public struct ResourceStringFilter: Swift.Equatable {
        /// The filter's comparison.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.ResourceStringComparison?
        /// The filter's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.ResourceStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case awsLambdaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .awsLambdaFunction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case .awsLambdaFunction: return "AWS_LAMBDA_FUNCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case go1X
        case java11
        case java17
        case java8
        case java8Al2
        case nodejs
        case nodejs12X
        case nodejs14X
        case nodejs16X
        case nodejs18X
        case python310
        case python37
        case python38
        case python39
        case unsupported
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .go1X,
                .java11,
                .java17,
                .java8,
                .java8Al2,
                .nodejs,
                .nodejs12X,
                .nodejs14X,
                .nodejs16X,
                .nodejs18X,
                .python310,
                .python37,
                .python38,
                .python39,
                .unsupported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .go1X: return "GO_1_X"
            case .java11: return "JAVA_11"
            case .java17: return "JAVA_17"
            case .java8: return "JAVA_8"
            case .java8Al2: return "JAVA_8_AL2"
            case .nodejs: return "NODEJS"
            case .nodejs12X: return "NODEJS_12_X"
            case .nodejs14X: return "NODEJS_14_X"
            case .nodejs16X: return "NODEJS_16_X"
            case .nodejs18X: return "NODEJS_18_X"
            case .python310: return "PYTHON_3_10"
            case .python37: return "PYTHON_3_7"
            case .python38: return "PYTHON_3_8"
            case .python39: return "PYTHON_3_9"
            case .unsupported: return "UNSUPPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum SbomReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cyclonedx14
        case spdx23
        case sdkUnknown(Swift.String)

        public static var allCases: [SbomReportFormat] {
            return [
                .cyclonedx14,
                .spdx23,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cyclonedx14: return "CYCLONEDX_1_4"
            case .spdx23: return "SPDX_2_3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SbomReportFormat(rawValue: rawValue) ?? SbomReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ScanStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatusReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension Inspector2ClientTypes {
    /// The status of the scan.
    public struct ScanStatus: Swift.Equatable {
        /// The reason for the scan.
        /// This member is required.
        public var reason: Inspector2ClientTypes.ScanStatusReason?
        /// The status code of the scan.
        /// This member is required.
        public var statusCode: Inspector2ClientTypes.ScanStatusCode?

        public init(
            reason: Inspector2ClientTypes.ScanStatusReason? = nil,
            statusCode: Inspector2ClientTypes.ScanStatusCode? = nil
        )
        {
            self.reason = reason
            self.statusCode = statusCode
        }
    }

}

extension Inspector2ClientTypes {
    public enum ScanStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusCode] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatusCode(rawValue: rawValue) ?? ScanStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ScanStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case deepInspectionCollectionTimeLimitExceeded
        case deepInspectionDailySsmInventoryLimitExceeded
        case deepInspectionNoInventory
        case deepInspectionPackageCollectionLimitExceeded
        case ec2InstanceStopped
        case excludedByTag
        case imageSizeExceeded
        case internalError
        case noInventory
        case noResourcesFound
        case pendingDisable
        case pendingInitialScan
        case resourceTerminated
        case scanEligibilityExpired
        case scanFrequencyManual
        case scanFrequencyScanOnPush
        case staleInventory
        case successful
        case unmanagedEc2Instance
        case unsupportedConfigFile
        case unsupportedMediaType
        case unsupportedOs
        case unsupportedRuntime
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusReason] {
            return [
                .accessDenied,
                .deepInspectionCollectionTimeLimitExceeded,
                .deepInspectionDailySsmInventoryLimitExceeded,
                .deepInspectionNoInventory,
                .deepInspectionPackageCollectionLimitExceeded,
                .ec2InstanceStopped,
                .excludedByTag,
                .imageSizeExceeded,
                .internalError,
                .noInventory,
                .noResourcesFound,
                .pendingDisable,
                .pendingInitialScan,
                .resourceTerminated,
                .scanEligibilityExpired,
                .scanFrequencyManual,
                .scanFrequencyScanOnPush,
                .staleInventory,
                .successful,
                .unmanagedEc2Instance,
                .unsupportedConfigFile,
                .unsupportedMediaType,
                .unsupportedOs,
                .unsupportedRuntime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .deepInspectionCollectionTimeLimitExceeded: return "DEEP_INSPECTION_COLLECTION_TIME_LIMIT_EXCEEDED"
            case .deepInspectionDailySsmInventoryLimitExceeded: return "DEEP_INSPECTION_DAILY_SSM_INVENTORY_LIMIT_EXCEEDED"
            case .deepInspectionNoInventory: return "DEEP_INSPECTION_NO_INVENTORY"
            case .deepInspectionPackageCollectionLimitExceeded: return "DEEP_INSPECTION_PACKAGE_COLLECTION_LIMIT_EXCEEDED"
            case .ec2InstanceStopped: return "EC2_INSTANCE_STOPPED"
            case .excludedByTag: return "EXCLUDED_BY_TAG"
            case .imageSizeExceeded: return "IMAGE_SIZE_EXCEEDED"
            case .internalError: return "INTERNAL_ERROR"
            case .noInventory: return "NO_INVENTORY"
            case .noResourcesFound: return "NO_RESOURCES_FOUND"
            case .pendingDisable: return "PENDING_DISABLE"
            case .pendingInitialScan: return "PENDING_INITIAL_SCAN"
            case .resourceTerminated: return "RESOURCE_TERMINATED"
            case .scanEligibilityExpired: return "SCAN_ELIGIBILITY_EXPIRED"
            case .scanFrequencyManual: return "SCAN_FREQUENCY_MANUAL"
            case .scanFrequencyScanOnPush: return "SCAN_FREQUENCY_SCAN_ON_PUSH"
            case .staleInventory: return "STALE_INVENTORY"
            case .successful: return "SUCCESSFUL"
            case .unmanagedEc2Instance: return "UNMANAGED_EC2_INSTANCE"
            case .unsupportedConfigFile: return "UNSUPPORTED_CONFIG_FILE"
            case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
            case .unsupportedOs: return "UNSUPPORTED_OS"
            case .unsupportedRuntime: return "UNSUPPORTED_RUNTIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatusReason(rawValue: rawValue) ?? ScanStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case code
        case network
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .code,
                .network,
                .package,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .code: return "CODE"
            case .network: return "NETWORK"
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanType(rawValue: rawValue) ?? ScanType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vulnerabilityIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vulnerabilityIds = vulnerabilityIds {
            var vulnerabilityIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilityIds)
            for vulnid0 in vulnerabilityIds {
                try vulnerabilityIdsContainer.encode(vulnid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilityIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vulnerabilityIds)
        var vulnerabilityIdsDecoded0:[Swift.String]? = nil
        if let vulnerabilityIdsContainer = vulnerabilityIdsContainer {
            vulnerabilityIdsDecoded0 = [Swift.String]()
            for string0 in vulnerabilityIdsContainer {
                if let string0 = string0 {
                    vulnerabilityIdsDecoded0?.append(string0)
                }
            }
        }
        vulnerabilityIds = vulnerabilityIdsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Details on the criteria used to define the filter for a vulnerability search.
    public struct SearchVulnerabilitiesFilterCriteria: Swift.Equatable {
        /// The IDs for specific vulnerabilities.
        /// This member is required.
        public var vulnerabilityIds: [Swift.String]?

        public init(
            vulnerabilityIds: [Swift.String]? = nil
        )
        {
            self.vulnerabilityIds = vulnerabilityIds
        }
    }

}

extension SearchVulnerabilitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchVulnerabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vulnerabilities/search"
    }
}

public struct SearchVulnerabilitiesInput: Swift.Equatable {
    /// The criteria used to filter the results of a vulnerability search.
    /// This member is required.
    public var filterCriteria: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        filterCriteria: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.nextToken = nextToken
    }
}

struct SearchVulnerabilitiesInputBody: Swift.Equatable {
    let filterCriteria: Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria?
    let nextToken: Swift.String?
}

extension SearchVulnerabilitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SearchVulnerabilitiesFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchVulnerabilitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchVulnerabilitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vulnerabilities = output.vulnerabilities
        } else {
            self.nextToken = nil
            self.vulnerabilities = nil
        }
    }
}

public struct SearchVulnerabilitiesOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// Details about the listed vulnerability.
    /// This member is required.
    public var vulnerabilities: [Inspector2ClientTypes.Vulnerability]?

    public init(
        nextToken: Swift.String? = nil,
        vulnerabilities: [Inspector2ClientTypes.Vulnerability]? = nil
    )
    {
        self.nextToken = nextToken
        self.vulnerabilities = vulnerabilities
    }
}

struct SearchVulnerabilitiesOutputBody: Swift.Equatable {
    let vulnerabilities: [Inspector2ClientTypes.Vulnerability]?
    let nextToken: Swift.String?
}

extension SearchVulnerabilitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vulnerabilities
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilitiesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Vulnerability?].self, forKey: .vulnerabilities)
        var vulnerabilitiesDecoded0:[Inspector2ClientTypes.Vulnerability]? = nil
        if let vulnerabilitiesContainer = vulnerabilitiesContainer {
            vulnerabilitiesDecoded0 = [Inspector2ClientTypes.Vulnerability]()
            for structure0 in vulnerabilitiesContainer {
                if let structure0 = structure0 {
                    vulnerabilitiesDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilities = vulnerabilitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchVulnerabilitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .ec2,
                .ecr,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that exceeds a service quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension Inspector2ClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case untriaged
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .untriaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .untriaged: return "UNTRIAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.SeverityCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case all
        case critical
        case high
        case medium
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let all = self.all {
            try encodeContainer.encode(all, forKey: .all)
        }
        if let critical = self.critical {
            try encodeContainer.encode(critical, forKey: .critical)
        }
        if let high = self.high {
            try encodeContainer.encode(high, forKey: .high)
        }
        if let medium = self.medium {
            try encodeContainer.encode(medium, forKey: .medium)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .all)
        all = allDecoded
        let mediumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .medium)
        medium = mediumDecoded
        let highDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .high)
        high = highDecoded
        let criticalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .critical)
        critical = criticalDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains the counts of aggregated finding per severity.
    public struct SeverityCounts: Swift.Equatable {
        /// The total count of findings from all severities.
        public var all: Swift.Int?
        /// The total count of critical severity findings.
        public var critical: Swift.Int?
        /// The total count of high severity findings.
        public var high: Swift.Int?
        /// The total count of medium severity findings.
        public var medium: Swift.Int?

        public init(
            all: Swift.Int? = nil,
            critical: Swift.Int? = nil,
            high: Swift.Int? = nil,
            medium: Swift.Int? = nil
        )
        {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }
    }

}

extension Inspector2ClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortField.self, forKey: .field)
        field = fieldDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the criteria used to sort finding results.
    public struct SortCriteria: Swift.Equatable {
        /// The finding detail field by which results are sorted.
        /// This member is required.
        public var field: Inspector2ClientTypes.SortField?
        /// The order by which findings are sorted.
        /// This member is required.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init(
            field: Inspector2ClientTypes.SortField? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {
    public enum SortField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccountId
        case componentType
        case ecrImagePushedAt
        case ecrImageRegistry
        case ecrImageRepositoryName
        case epssScore
        case findingStatus
        case findingType
        case firstObservedAt
        case inspectorScore
        case lastObservedAt
        case networkProtocol
        case resourceType
        case severity
        case vendorSeverity
        case vulnerabilityId
        case vulnerabilitySource
        case sdkUnknown(Swift.String)

        public static var allCases: [SortField] {
            return [
                .awsAccountId,
                .componentType,
                .ecrImagePushedAt,
                .ecrImageRegistry,
                .ecrImageRepositoryName,
                .epssScore,
                .findingStatus,
                .findingType,
                .firstObservedAt,
                .inspectorScore,
                .lastObservedAt,
                .networkProtocol,
                .resourceType,
                .severity,
                .vendorSeverity,
                .vulnerabilityId,
                .vulnerabilitySource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccountId: return "AWS_ACCOUNT_ID"
            case .componentType: return "COMPONENT_TYPE"
            case .ecrImagePushedAt: return "ECR_IMAGE_PUSHED_AT"
            case .ecrImageRegistry: return "ECR_IMAGE_REGISTRY"
            case .ecrImageRepositoryName: return "ECR_IMAGE_REPOSITORY_NAME"
            case .epssScore: return "EPSS_SCORE"
            case .findingStatus: return "FINDING_STATUS"
            case .findingType: return "FINDING_TYPE"
            case .firstObservedAt: return "FIRST_OBSERVED_AT"
            case .inspectorScore: return "INSPECTOR_SCORE"
            case .lastObservedAt: return "LAST_OBSERVED_AT"
            case .networkProtocol: return "NETWORK_PROTOCOL"
            case .resourceType: return "RESOURCE_TYPE"
            case .severity: return "SEVERITY"
            case .vendorSeverity: return "VENDOR_SEVERITY"
            case .vulnerabilityId: return "VULNERABILITY_ID"
            case .vulnerabilitySource: return "VULNERABILITY_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortField(rawValue: rawValue) ?? SortField.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.State: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that described the state of Amazon Inspector scans for an account.
    public struct State: Swift.Equatable {
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init(
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case suspended
        case suspending
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .suspended,
                .suspending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .suspended: return "SUSPENDED"
            case .suspending: return "SUSPENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Step: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId
        case componentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the step associated with a finding.
    public struct Step: Swift.Equatable {
        /// The component ID.
        /// This member is required.
        public var componentId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?

        public init(
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.componentType = componentType
        }
    }

}

extension Inspector2ClientTypes {
    public enum StringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [StringComparison] {
            return [
                .equals,
                .notEquals,
                .prefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StringComparison(rawValue: rawValue) ?? StringComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.StringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a string filter.
    public struct StringFilter: Swift.Equatable {
        /// The operator to use when comparing values in the filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.StringComparison?
        /// The value to filter on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparison: Inspector2ClientTypes.StringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes.SuggestedFix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension Inspector2ClientTypes {
    /// A suggested fix for a vulnerability in your Lambda function code.
    public struct SuggestedFix: Swift.Equatable {
        /// The fix's code.
        public var code: Swift.String?
        /// The fix's description.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.TitleAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingType
        case resourceType
        case sortBy
        case sortOrder
        case titles
        case vulnerabilityIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingType = self.findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let titles = titles {
            var titlesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .titles)
            for stringfilter0 in titles {
                try titlesContainer.encode(stringfilter0)
            }
        }
        if let vulnerabilityIds = vulnerabilityIds {
            var vulnerabilityIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilityIds)
            for stringfilter0 in vulnerabilityIds {
                try vulnerabilityIdsContainer.encode(stringfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titlesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .titles)
        var titlesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let titlesContainer = titlesContainer {
            titlesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in titlesContainer {
                if let structure0 = structure0 {
                    titlesDecoded0?.append(structure0)
                }
            }
        }
        titles = titlesDecoded0
        let vulnerabilityIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilityIds)
        var vulnerabilityIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilityIdsContainer = vulnerabilityIdsContainer {
            vulnerabilityIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilityIdsContainer {
                if let structure0 = structure0 {
                    vulnerabilityIdsDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilityIds = vulnerabilityIdsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.TitleSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let findingTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding title.
    public struct TitleAggregation: Swift.Equatable {
        /// The type of finding to aggregate on.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The resource type to aggregate on.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.TitleSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?
        /// The finding titles to aggregate on.
        public var titles: [Inspector2ClientTypes.StringFilter]?
        /// The vulnerability IDs of the findings.
        public var vulnerabilityIds: [Inspector2ClientTypes.StringFilter]?

        public init(
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.TitleSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil,
            titles: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityIds: [Inspector2ClientTypes.StringFilter]? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.titles = titles
            self.vulnerabilityIds = vulnerabilityIds
        }
    }

}

extension Inspector2ClientTypes.TitleAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
        case title
        case vulnerabilityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = self.severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by title.
    public struct TitleAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?
        /// The title that the findings were aggregated on.
        /// This member is required.
        public var title: Swift.String?
        /// The vulnerability ID of the finding.
        public var vulnerabilityId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil,
            title: Swift.String? = nil,
            vulnerabilityId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
            self.title = title
            self.vulnerabilityId = vulnerabilityId
        }
    }

}

extension Inspector2ClientTypes {
    public enum TitleSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [TitleSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TitleSortBy(rawValue: rawValue) ?? TitleSortBy.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecrConfiguration = self.ecrConfiguration {
            try encodeContainer.encode(ecrConfiguration, forKey: .ecrConfiguration)
        }
    }
}

extension UpdateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/update"
    }
}

public struct UpdateConfigurationInput: Swift.Equatable {
    /// Specifies how the ECR automated re-scan will be updated for your environment.
    /// This member is required.
    public var ecrConfiguration: Inspector2ClientTypes.EcrConfiguration?

    public init(
        ecrConfiguration: Inspector2ClientTypes.EcrConfiguration? = nil
    )
    {
        self.ecrConfiguration = ecrConfiguration
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    let ecrConfiguration: Inspector2ClientTypes.EcrConfiguration?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrConfigurationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrConfiguration.self, forKey: .ecrConfiguration)
        ecrConfiguration = ecrConfigurationDecoded
    }
}

extension UpdateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEc2DeepInspectionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateDeepInspection
        case packagePaths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activateDeepInspection = self.activateDeepInspection {
            try encodeContainer.encode(activateDeepInspection, forKey: .activateDeepInspection)
        }
        if let packagePaths = packagePaths {
            var packagePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packagePaths)
            for path0 in packagePaths {
                try packagePathsContainer.encode(path0)
            }
        }
    }
}

extension UpdateEc2DeepInspectionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ec2deepinspectionconfiguration/update"
    }
}

public struct UpdateEc2DeepInspectionConfigurationInput: Swift.Equatable {
    /// Specify TRUE to activate Amazon Inspector deep inspection in your account, or FALSE to deactivate. Member accounts in an organization cannot deactivate deep inspection, instead the delegated administrator for the organization can deactivate a member account using [BatchUpdateMemberEc2DeepInspectionStatus](https://docs.aws.amazon.com/inspector/v2/APIReference/API_BatchUpdateMemberEc2DeepInspectionStatus.html).
    public var activateDeepInspection: Swift.Bool?
    /// The Amazon Inspector deep inspection custom paths you are adding for your account.
    public var packagePaths: [Swift.String]?

    public init(
        activateDeepInspection: Swift.Bool? = nil,
        packagePaths: [Swift.String]? = nil
    )
    {
        self.activateDeepInspection = activateDeepInspection
        self.packagePaths = packagePaths
    }
}

struct UpdateEc2DeepInspectionConfigurationInputBody: Swift.Equatable {
    let activateDeepInspection: Swift.Bool?
    let packagePaths: [Swift.String]?
}

extension UpdateEc2DeepInspectionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activateDeepInspection
        case packagePaths
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activateDeepInspectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activateDeepInspection)
        activateDeepInspection = activateDeepInspectionDecoded
        let packagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packagePaths)
        var packagePathsDecoded0:[Swift.String]? = nil
        if let packagePathsContainer = packagePathsContainer {
            packagePathsDecoded0 = [Swift.String]()
            for string0 in packagePathsContainer {
                if let string0 = string0 {
                    packagePathsDecoded0?.append(string0)
                }
            }
        }
        packagePaths = packagePathsDecoded0
    }
}

extension UpdateEc2DeepInspectionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEc2DeepInspectionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorMessage = output.errorMessage
            self.orgPackagePaths = output.orgPackagePaths
            self.packagePaths = output.packagePaths
            self.status = output.status
        } else {
            self.errorMessage = nil
            self.orgPackagePaths = nil
            self.packagePaths = nil
            self.status = nil
        }
    }
}

public struct UpdateEc2DeepInspectionConfigurationOutput: Swift.Equatable {
    /// An error message explaining why new Amazon Inspector deep inspection custom paths could not be added.
    public var errorMessage: Swift.String?
    /// The current Amazon Inspector deep inspection custom paths for the organization.
    public var orgPackagePaths: [Swift.String]?
    /// The current Amazon Inspector deep inspection custom paths for your account.
    public var packagePaths: [Swift.String]?
    /// The status of Amazon Inspector deep inspection in your account.
    public var status: Inspector2ClientTypes.Ec2DeepInspectionStatus?

    public init(
        errorMessage: Swift.String? = nil,
        orgPackagePaths: [Swift.String]? = nil,
        packagePaths: [Swift.String]? = nil,
        status: Inspector2ClientTypes.Ec2DeepInspectionStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.orgPackagePaths = orgPackagePaths
        self.packagePaths = packagePaths
        self.status = status
    }
}

struct UpdateEc2DeepInspectionConfigurationOutputBody: Swift.Equatable {
    let packagePaths: [Swift.String]?
    let orgPackagePaths: [Swift.String]?
    let status: Inspector2ClientTypes.Ec2DeepInspectionStatus?
    let errorMessage: Swift.String?
}

extension UpdateEc2DeepInspectionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case orgPackagePaths
        case packagePaths
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packagePaths)
        var packagePathsDecoded0:[Swift.String]? = nil
        if let packagePathsContainer = packagePathsContainer {
            packagePathsDecoded0 = [Swift.String]()
            for string0 in packagePathsContainer {
                if let string0 = string0 {
                    packagePathsDecoded0?.append(string0)
                }
            }
        }
        packagePaths = packagePathsDecoded0
        let orgPackagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .orgPackagePaths)
        var orgPackagePathsDecoded0:[Swift.String]? = nil
        if let orgPackagePathsContainer = orgPackagePathsContainer {
            orgPackagePathsDecoded0 = [Swift.String]()
            for string0 in orgPackagePathsContainer {
                if let string0 = string0 {
                    orgPackagePathsDecoded0?.append(string0)
                }
            }
        }
        orgPackagePaths = orgPackagePathsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2DeepInspectionStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum UpdateEc2DeepInspectionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEncryptionKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case resourceType
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }
}

extension UpdateEncryptionKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/encryptionkey/update"
    }
}

public struct UpdateEncryptionKeyInput: Swift.Equatable {
    /// A KMS key ID for the encryption key.
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The resource type for the encryption key.
    /// This member is required.
    public var resourceType: Inspector2ClientTypes.ResourceType?
    /// The scan type for the encryption key.
    /// This member is required.
    public var scanType: Inspector2ClientTypes.ScanType?

    public init(
        kmsKeyId: Swift.String? = nil,
        resourceType: Inspector2ClientTypes.ResourceType? = nil,
        scanType: Inspector2ClientTypes.ScanType? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.resourceType = resourceType
        self.scanType = scanType
    }
}

struct UpdateEncryptionKeyInputBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let scanType: Inspector2ClientTypes.ScanType?
    let resourceType: Inspector2ClientTypes.ResourceType?
}

extension UpdateEncryptionKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case resourceType
        case scanType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let scanTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension UpdateEncryptionKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEncryptionKeyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEncryptionKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterArn
        case filterCriteria
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension UpdateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/update"
    }
}

public struct UpdateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// The Amazon Resource Number (ARN) of the filter to update.
    /// This member is required.
    public var filterArn: Swift.String?
    /// Defines the criteria to be update in the filter.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter.
    public var name: Swift.String?
    /// The reason the filter was updated.
    public var reason: Swift.String?

    public init(
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterArn: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterArn = filterArn
        self.filterCriteria = filterCriteria
        self.name = name
        self.reason = reason
    }
}

struct UpdateFilterInputBody: Swift.Equatable {
    let action: Inspector2ClientTypes.FilterAction?
    let description: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let name: Swift.String?
    let filterArn: Swift.String?
    let reason: Swift.String?
}

extension UpdateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterArn
        case filterCriteria
        case name
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UpdateFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UpdateFilterOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the successfully updated filter.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct UpdateFilterOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension UpdateFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orgPackagePaths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let orgPackagePaths = orgPackagePaths {
            var orgPackagePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orgPackagePaths)
            for path0 in orgPackagePaths {
                try orgPackagePathsContainer.encode(path0)
            }
        }
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ec2deepinspectionconfiguration/org/update"
    }
}

public struct UpdateOrgEc2DeepInspectionConfigurationInput: Swift.Equatable {
    /// The Amazon Inspector deep inspection custom paths you are adding for your organization.
    /// This member is required.
    public var orgPackagePaths: [Swift.String]?

    public init(
        orgPackagePaths: [Swift.String]? = nil
    )
    {
        self.orgPackagePaths = orgPackagePaths
    }
}

struct UpdateOrgEc2DeepInspectionConfigurationInputBody: Swift.Equatable {
    let orgPackagePaths: [Swift.String]?
}

extension UpdateOrgEc2DeepInspectionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orgPackagePaths
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orgPackagePathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .orgPackagePaths)
        var orgPackagePathsDecoded0:[Swift.String]? = nil
        if let orgPackagePathsContainer = orgPackagePathsContainer {
            orgPackagePathsDecoded0 = [Swift.String]()
            for string0 in orgPackagePathsContainer {
                if let string0 = string0 {
                    orgPackagePathsDecoded0?.append(string0)
                }
            }
        }
        orgPackagePaths = orgPackagePathsDecoded0
    }
}

extension UpdateOrgEc2DeepInspectionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateOrgEc2DeepInspectionConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOrgEc2DeepInspectionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizationconfiguration/update"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Defines which scan types are enabled automatically for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateOrganizationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
        } else {
            self.autoEnable = nil
        }
    }
}

public struct UpdateOrganizationConfigurationOutput: Swift.Equatable {
    /// The updated status of scan types automatically enabled for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init(
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationOutputBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
}

extension UpdateOrganizationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

enum UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Inspector2ClientTypes.Usage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency
        case estimatedMonthlyCost
        case total
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if estimatedMonthlyCost != 0.0 {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if total != 0.0 {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.UsageType.self, forKey: .type)
        type = typeDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total) ?? 0.0
        total = totalDecoded
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlyCost) ?? 0.0
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Currency.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains usage information about the cost of Amazon Inspector operation.
    public struct Usage: Swift.Equatable {
        /// The currency type used when calculating usage data.
        public var currency: Inspector2ClientTypes.Currency?
        /// The estimated monthly cost of Amazon Inspector.
        public var estimatedMonthlyCost: Swift.Double
        /// The total of usage.
        public var total: Swift.Double
        /// The type scan.
        public var type: Inspector2ClientTypes.UsageType?

        public init(
            currency: Inspector2ClientTypes.Currency? = nil,
            estimatedMonthlyCost: Swift.Double = 0.0,
            total: Swift.Double = 0.0,
            type: Inspector2ClientTypes.UsageType? = nil
        )
        {
            self.currency = currency
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.total = total
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.UsageTotal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case usage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let usage = usage {
            var usageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usage)
            for usage0 in usage {
                try usageContainer.encode(usage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let usageContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Usage?].self, forKey: .usage)
        var usageDecoded0:[Inspector2ClientTypes.Usage]? = nil
        if let usageContainer = usageContainer {
            usageDecoded0 = [Inspector2ClientTypes.Usage]()
            for structure0 in usageContainer {
                if let structure0 = structure0 {
                    usageDecoded0?.append(structure0)
                }
            }
        }
        usage = usageDecoded0
    }
}

extension Inspector2ClientTypes {
    /// The total of usage for an account ID.
    public struct UsageTotal: Swift.Equatable {
        /// The account ID of the account that usage data was retrieved for.
        public var accountId: Swift.String?
        /// An object representing the total usage for an account.
        public var usage: [Inspector2ClientTypes.Usage]?

        public init(
            accountId: Swift.String? = nil,
            usage: [Inspector2ClientTypes.Usage]? = nil
        )
        {
            self.accountId = accountId
            self.usage = usage
        }
    }

}

extension Inspector2ClientTypes {
    public enum UsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2InstanceHours
        case ecrInitialScan
        case ecrRescan
        case lambdaFunctionCodeHours
        case lambdaFunctionHours
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .ec2InstanceHours,
                .ecrInitialScan,
                .ecrRescan,
                .lambdaFunctionCodeHours,
                .lambdaFunctionHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2InstanceHours: return "EC2_INSTANCE_HOURS"
            case .ecrInitialScan: return "ECR_INITIAL_SCAN"
            case .ecrRescan: return "ECR_RESCAN"
            case .lambdaFunctionCodeHours: return "LAMBDA_FUNCTION_CODE_HOURS"
            case .lambdaFunctionHours: return "LAMBDA_FUNCTION_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageType(rawValue: rawValue) ?? UsageType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed validation due to missing required fields or having invalid inputs.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that failed validation.
        public internal(set) var fields: [Inspector2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: Inspector2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [Inspector2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Inspector2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Inspector2ClientTypes.ValidationExceptionReason?
    let fields: [Inspector2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[Inspector2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Inspector2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension Inspector2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The validation exception message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Inspector2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Vulnerability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atigData
        case cisaData
        case cvss2
        case cvss3
        case cwes
        case description
        case detectionPlatforms
        case epss
        case exploitObserved
        case id
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atigData = self.atigData {
            try encodeContainer.encode(atigData, forKey: .atigData)
        }
        if let cisaData = self.cisaData {
            try encodeContainer.encode(cisaData, forKey: .cisaData)
        }
        if let cvss2 = self.cvss2 {
            try encodeContainer.encode(cvss2, forKey: .cvss2)
        }
        if let cvss3 = self.cvss3 {
            try encodeContainer.encode(cvss3, forKey: .cvss3)
        }
        if let cwes = cwes {
            var cwesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cwes)
            for cwe0 in cwes {
                try cwesContainer.encode(cwe0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectionPlatforms = detectionPlatforms {
            var detectionPlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectionPlatforms)
            for nonemptystring0 in detectionPlatforms {
                try detectionPlatformsContainer.encode(nonemptystring0)
            }
        }
        if let epss = self.epss {
            try encodeContainer.encode(epss, forKey: .epss)
        }
        if let exploitObserved = self.exploitObserved {
            try encodeContainer.encode(exploitObserved, forKey: .exploitObserved)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for vulnerabilityreferenceurl0 in referenceUrls {
                try referenceUrlsContainer.encode(vulnerabilityreferenceurl0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for relatedvulnerability0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(relatedvulnerability0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encodeTimestamp(vendorCreatedAt, format: .epochSeconds, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encodeTimestamp(vendorUpdatedAt, format: .epochSeconds, forKey: .vendorUpdatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let cwesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cwes)
        var cwesDecoded0:[Swift.String]? = nil
        if let cwesContainer = cwesContainer {
            cwesDecoded0 = [Swift.String]()
            for string0 in cwesContainer {
                if let string0 = string0 {
                    cwesDecoded0?.append(string0)
                }
            }
        }
        cwes = cwesDecoded0
        let cisaDataDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CisaData.self, forKey: .cisaData)
        cisaData = cisaDataDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.VulnerabilitySource.self, forKey: .source)
        source = sourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let atigDataDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AtigData.self, forKey: .atigData)
        atigData = atigDataDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let cvss3Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Cvss3.self, forKey: .cvss3)
        cvss3 = cvss3Decoded
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let cvss2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Cvss2.self, forKey: .cvss2)
        cvss2 = cvss2Decoded
        let vendorCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let exploitObservedDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExploitObserved.self, forKey: .exploitObserved)
        exploitObserved = exploitObservedDecoded
        let detectionPlatformsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectionPlatforms)
        var detectionPlatformsDecoded0:[Swift.String]? = nil
        if let detectionPlatformsContainer = detectionPlatformsContainer {
            detectionPlatformsDecoded0 = [Swift.String]()
            for string0 in detectionPlatformsContainer {
                if let string0 = string0 {
                    detectionPlatformsDecoded0?.append(string0)
                }
            }
        }
        detectionPlatforms = detectionPlatformsDecoded0
        let epssDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Epss.self, forKey: .epss)
        epss = epssDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details about a specific vulnerability Amazon Inspector can detect.
    public struct Vulnerability: Swift.Equatable {
        /// An object that contains information about the Amazon Web Services Threat Intel Group (ATIG) details for the vulnerability.
        public var atigData: Inspector2ClientTypes.AtigData?
        /// An object that contains the Cybersecurity and Infrastructure Security Agency (CISA) details for the vulnerability.
        public var cisaData: Inspector2ClientTypes.CisaData?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 2 details for the vulnerability.
        public var cvss2: Inspector2ClientTypes.Cvss2?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 3 details for the vulnerability.
        public var cvss3: Inspector2ClientTypes.Cvss3?
        /// The Common Weakness Enumeration (CWE) associated with the vulnerability.
        public var cwes: [Swift.String]?
        /// A description of the vulnerability.
        public var description: Swift.String?
        /// Platforms that the vulnerability can be detected on.
        public var detectionPlatforms: [Swift.String]?
        /// An object that contains the Exploit Prediction Scoring System (EPSS) score for a vulnerability.
        public var epss: Inspector2ClientTypes.Epss?
        /// An object that contains details on when the exploit was observed.
        public var exploitObserved: Inspector2ClientTypes.ExploitObserved?
        /// The ID for the specific vulnerability.
        /// This member is required.
        public var id: Swift.String?
        /// Links to various resources with more information on this vulnerability.
        public var referenceUrls: [Swift.String]?
        /// A list of related vulnerabilities.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        public var source: Inspector2ClientTypes.VulnerabilitySource?
        /// A link to the official source material for this vulnerability.
        public var sourceUrl: Swift.String?
        /// The date and time when the vendor created this vulnerability.
        public var vendorCreatedAt: ClientRuntime.Date?
        /// The severity assigned by the vendor.
        public var vendorSeverity: Swift.String?
        /// The date and time when the vendor last updated this vulnerability.
        public var vendorUpdatedAt: ClientRuntime.Date?

        public init(
            atigData: Inspector2ClientTypes.AtigData? = nil,
            cisaData: Inspector2ClientTypes.CisaData? = nil,
            cvss2: Inspector2ClientTypes.Cvss2? = nil,
            cvss3: Inspector2ClientTypes.Cvss3? = nil,
            cwes: [Swift.String]? = nil,
            description: Swift.String? = nil,
            detectionPlatforms: [Swift.String]? = nil,
            epss: Inspector2ClientTypes.Epss? = nil,
            exploitObserved: Inspector2ClientTypes.ExploitObserved? = nil,
            id: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Inspector2ClientTypes.VulnerabilitySource? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: ClientRuntime.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.atigData = atigData
            self.cisaData = cisaData
            self.cvss2 = cvss2
            self.cvss3 = cvss3
            self.cwes = cwes
            self.description = description
            self.detectionPlatforms = detectionPlatforms
            self.epss = epss
            self.exploitObserved = exploitObserved
            self.id = id
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum VulnerabilitySource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nvd
        case sdkUnknown(Swift.String)

        public static var allCases: [VulnerabilitySource] {
            return [
                .nvd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nvd: return "NVD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VulnerabilitySource(rawValue: rawValue) ?? VulnerabilitySource.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.VulnerablePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arch
        case epoch
        case filePath
        case fixedInVersion
        case name
        case packageManager
        case release
        case remediation
        case sourceLambdaLayerArn
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arch = self.arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if epoch != 0 {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fixedInVersion = self.fixedInVersion {
            try encodeContainer.encode(fixedInVersion, forKey: .fixedInVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageManager = self.packageManager {
            try encodeContainer.encode(packageManager.rawValue, forKey: .packageManager)
        }
        if let release = self.release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let sourceLambdaLayerArn = self.sourceLambdaLayerArn {
            try encodeContainer.encode(sourceLambdaLayerArn, forKey: .sourceLambdaLayerArn)
        }
        if let sourceLayerHash = self.sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epoch) ?? 0
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let packageManagerDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageManager.self, forKey: .packageManager)
        packageManager = packageManagerDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fixedInVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixedInVersion)
        fixedInVersion = fixedInVersionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediation)
        remediation = remediationDecoded
        let sourceLambdaLayerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLambdaLayerArn)
        sourceLambdaLayerArn = sourceLambdaLayerArnDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on the vulnerable package identified by a finding.
    public struct VulnerablePackage: Swift.Equatable {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The version of the package that contains the vulnerability fix.
        public var fixedInVersion: Swift.String?
        /// The name of the vulnerable package.
        /// This member is required.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Inspector2ClientTypes.PackageManager?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The code to run in your environment to update packages with a fix available.
        public var remediation: Swift.String?
        /// The Amazon Resource Number (ARN) of the AWS Lambda function affected by a finding.
        public var sourceLambdaLayerArn: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arch: Swift.String? = nil,
            epoch: Swift.Int = 0,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Inspector2ClientTypes.PackageManager? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLambdaLayerArn: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}
