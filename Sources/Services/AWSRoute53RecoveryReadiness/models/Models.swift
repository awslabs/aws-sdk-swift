// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.CellOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellArn = self.cellArn {
            try encodeContainer.encode(cellArn, forKey: .cellArn)
        }
        if let cellName = self.cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let parentReadinessScopes = parentReadinessScopes {
            var parentReadinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentReadinessScopes)
            for __string0 in parentReadinessScopes {
                try parentReadinessScopesContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Information about a cell.
    public struct CellOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the cell.
        /// This member is required.
        public var cellArn: Swift.String?
        /// The name of the cell.
        /// This member is required.
        public var cellName: Swift.String?
        /// A list of cell ARNs.
        /// This member is required.
        public var cells: [Swift.String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        /// This member is required.
        public var parentReadinessScopes: [Swift.String]?
        /// Tags on the resources.
        public var tags: [Swift.String:Swift.String]?

        public init(
            cellArn: Swift.String? = nil,
            cellName: Swift.String? = nil,
            cells: [Swift.String]? = nil,
            parentReadinessScopes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCellInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellName = self.cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cells"
    }
}

public struct CreateCellInput: Swift.Equatable {
    /// The name of the cell to create.
    /// This member is required.
    public var cellName: Swift.String?
    /// A list of cell Amazon Resource Names (ARNs) contained within this cell, for use in nested cells. For example, Availability Zones within specific Amazon Web Services Regions.
    public var cells: [Swift.String]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
        self.tags = tags
    }
}

struct CreateCellInputBody: Swift.Equatable {
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCellOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCellOutputBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct CreateCellOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct CreateCellOutputBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCellOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateCellOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCrossAccountAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccountAuthorization = self.crossAccountAuthorization {
            try encodeContainer.encode(crossAccountAuthorization, forKey: .crossAccountAuthorization)
        }
    }
}

extension CreateCrossAccountAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crossaccountauthorizations"
    }
}

public struct CreateCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross-account authorization.
    /// This member is required.
    public var crossAccountAuthorization: Swift.String?

    public init(
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationInputBody: Swift.Equatable {
    let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

extension CreateCrossAccountAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCrossAccountAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorization = output.crossAccountAuthorization
        } else {
            self.crossAccountAuthorization = nil
        }
    }
}

public struct CreateCrossAccountAuthorizationOutput: Swift.Equatable {
    /// The cross-account authorization.
    public var crossAccountAuthorization: Swift.String?

    public init(
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationOutputBody: Swift.Equatable {
    let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

enum CreateCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReadinessCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/readinesschecks"
    }
}

public struct CreateReadinessCheckInput: Swift.Equatable {
    /// The name of the readiness check to create.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The name of the resource set to check.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
        self.tags = tags
    }
}

struct CreateReadinessCheckInputBody: Swift.Equatable {
    let readinessCheckName: Swift.String?
    let resourceSetName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReadinessCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReadinessCheckOutputBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct CreateReadinessCheckOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct CreateReadinessCheckOutputBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateReadinessCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecoveryGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let recoveryGroupName = self.recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recoverygroups"
    }
}

public struct CreateRecoveryGroupInput: Swift.Equatable {
    /// A list of the cell Amazon Resource Names (ARNs) in the recovery group.
    public var cells: [Swift.String]?
    /// The name of the recovery group to create.
    /// This member is required.
    public var recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupInputBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecoveryGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecoveryGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct CreateRecoveryGroupOutput: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupOutputBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateRecoveryGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcesets"
    }
}

public struct CreateResourceSetInput: Swift.Equatable {
    /// The name of the resource set to create.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    /// This member is required.
    public var resourceSetType: Swift.String?
    /// A list of resource objects in the resource set.
    /// This member is required.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A tag to associate with the parameters for a resource set.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetInputBody: Swift.Equatable {
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct CreateResourceSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetOutputBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateResourceSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.DNSTargetResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case hostedZoneArn = "hostedZoneArn"
        case recordSetId = "recordSetId"
        case recordType = "recordType"
        case targetResource = "targetResource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneArn = self.hostedZoneArn {
            try encodeContainer.encode(hostedZoneArn, forKey: .hostedZoneArn)
        }
        if let recordSetId = self.recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
        if let recordType = self.recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let targetResource = self.targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneArn)
        hostedZoneArn = hostedZoneArnDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.TargetResource.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A component for DNS/routing control readiness checks and architecture checks.
    public struct DNSTargetResource: Swift.Equatable {
        /// The domain name that acts as an ingress point to a portion of the customer application.
        public var domainName: Swift.String?
        /// The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
        public var hostedZoneArn: Swift.String?
        /// The Route 53 record set ID that uniquely identifies a DNS record, given a name and a type.
        public var recordSetId: Swift.String?
        /// The type of DNS record of the target resource.
        public var recordType: Swift.String?
        /// The target resource of the DNS target resource.
        public var targetResource: Route53RecoveryReadinessClientTypes.TargetResource?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneArn: Swift.String? = nil,
            recordSetId: Swift.String? = nil,
            recordType: Swift.String? = nil,
            targetResource: Route53RecoveryReadinessClientTypes.TargetResource? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneArn = hostedZoneArn
            self.recordSetId = recordSetId
            self.recordType = recordType
            self.targetResource = targetResource
        }
    }

}

extension DeleteCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct DeleteCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?

    public init(
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct DeleteCellInputBody: Swift.Equatable {
}

extension DeleteCellInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCellOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCellOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCellOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCrossAccountAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crossAccountAuthorization = crossAccountAuthorization else {
            return nil
        }
        return "/crossaccountauthorizations/\(crossAccountAuthorization.urlPercentEncoding())"
    }
}

public struct DeleteCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross-account authorization.
    /// This member is required.
    public var crossAccountAuthorization: Swift.String?

    public init(
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct DeleteCrossAccountAuthorizationInputBody: Swift.Equatable {
}

extension DeleteCrossAccountAuthorizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrossAccountAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCrossAccountAuthorizationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

public struct DeleteReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init(
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct DeleteReadinessCheckInputBody: Swift.Equatable {
}

extension DeleteReadinessCheckInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReadinessCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReadinessCheckOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReadinessCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct DeleteRecoveryGroupInput: Swift.Equatable {
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init(
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct DeleteRecoveryGroupInputBody: Swift.Equatable {
}

extension DeleteRecoveryGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecoveryGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecoveryGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

public struct DeleteResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init(
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct DeleteResourceSetInputBody: Swift.Equatable {
}

extension DeleteResourceSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourceSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourceSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetArchitectureRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetArchitectureRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())/architectureRecommendations"
    }
}

public struct GetArchitectureRecommendationsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetArchitectureRecommendationsInputBody: Swift.Equatable {
}

extension GetArchitectureRecommendationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetArchitectureRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetArchitectureRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastAuditTimestamp = output.lastAuditTimestamp
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.lastAuditTimestamp = nil
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetArchitectureRecommendationsOutput: Swift.Equatable {
    /// The time that a recovery group was last assessed for recommendations, in UTC ISO-8601 format.
    public var lastAuditTimestamp: ClientRuntime.Date?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of the recommendations for the customer's application.
    public var recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?

    public init(
        lastAuditTimestamp: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]? = nil
    )
    {
        self.lastAuditTimestamp = lastAuditTimestamp
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct GetArchitectureRecommendationsOutputBody: Swift.Equatable {
    let lastAuditTimestamp: ClientRuntime.Date?
    let nextToken: Swift.String?
    let recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?
}

extension GetArchitectureRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuditTimestamp = "lastAuditTimestamp"
        case nextToken = "nextToken"
        case recommendations = "recommendations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastAuditTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuditTimestamp)
        lastAuditTimestamp = lastAuditTimestampDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[Route53RecoveryReadinessClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [Route53RecoveryReadinessClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
    }
}

enum GetArchitectureRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct GetCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?

    public init(
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct GetCellInputBody: Swift.Equatable {
}

extension GetCellInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCellOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCellOutputBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct GetCellOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct GetCellOutputBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetCellOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCellOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCellReadinessSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetCellReadinessSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cellreadiness/\(cellName.urlPercentEncoding())"
    }
}

public struct GetCellReadinessSummaryInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        cellName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cellName = cellName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCellReadinessSummaryInputBody: Swift.Equatable {
}

extension GetCellReadinessSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCellReadinessSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCellReadinessSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetCellReadinessSummaryOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at a cell level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries for the readiness checks that make up the cell.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init(
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetCellReadinessSummaryOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetCellReadinessSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

enum GetCellReadinessSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

public struct GetReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init(
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckInputBody: Swift.Equatable {
}

extension GetReadinessCheckInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadinessCheckOutputBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct GetReadinessCheckOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct GetReadinessCheckOutputBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetReadinessCheckOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetReadinessCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadinessCheckResourceStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetReadinessCheckResourceStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())/resource/\(resourceIdentifier.urlPercentEncoding())/status"
    }
}

public struct GetReadinessCheckResourceStatusInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The resource identifier, which is the Amazon Resource Name (ARN) or the identifier generated for the resource by Application Recovery Controller (for example, for a DNS target resource).
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetReadinessCheckResourceStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckResourceStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckResourceStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadinessCheckResourceStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.rules = nil
        }
    }
}

public struct GetReadinessCheckResourceStatusOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at a rule level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Details of the rule's results.
    public var rules: [Route53RecoveryReadinessClientTypes.RuleResult]?

    public init(
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        rules: [Route53RecoveryReadinessClientTypes.RuleResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.rules = rules
    }
}

struct GetReadinessCheckResourceStatusOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let rules: [Route53RecoveryReadinessClientTypes.RuleResult]?
}

extension GetReadinessCheckResourceStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case rules = "rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RuleResult?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.RuleResult]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.RuleResult]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

enum GetReadinessCheckResourceStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReadinessCheckStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetReadinessCheckStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())/status"
    }
}

public struct GetReadinessCheckStatusInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReadinessCheckStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.resources = output.resources
        } else {
            self.messages = nil
            self.nextToken = nil
            self.readiness = nil
            self.resources = nil
        }
    }
}

public struct GetReadinessCheckStatusOutput: Swift.Equatable {
    /// Top level messages for readiness check status
    public var messages: [Route53RecoveryReadinessClientTypes.Message]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at rule level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summary of the readiness of resources.
    public var resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?

    public init(
        messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        resources: [Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
        self.readiness = readiness
        self.resources = resources
    }
}

struct GetReadinessCheckStatusOutputBody: Swift.Equatable {
    let messages: [Route53RecoveryReadinessClientTypes.Message]?
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?
}

extension GetReadinessCheckStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages = "messages"
        case nextToken = "nextToken"
        case readiness = "readiness"
        case resources = "resources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceResult?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceResult]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

enum GetReadinessCheckStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct GetRecoveryGroupInput: Swift.Equatable {
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init(
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupInputBody: Swift.Equatable {
}

extension GetRecoveryGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecoveryGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct GetRecoveryGroupOutput: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct GetRecoveryGroupOutputBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetRecoveryGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetRecoveryGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecoveryGroupReadinessSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRecoveryGroupReadinessSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroupreadiness/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct GetRecoveryGroupReadinessSummaryInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupReadinessSummaryInputBody: Swift.Equatable {
}

extension GetRecoveryGroupReadinessSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupReadinessSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecoveryGroupReadinessSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetRecoveryGroupReadinessSummaryOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness status at a recovery group level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries of the readiness checks for the recovery group.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init(
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetRecoveryGroupReadinessSummaryOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetRecoveryGroupReadinessSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

enum GetRecoveryGroupReadinessSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

public struct GetResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init(
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct GetResourceSetInputBody: Swift.Equatable {
}

extension GetResourceSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct GetResourceSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct GetResourceSetOutputBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension GetResourceSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetResourceSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCellsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCellsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cells"
    }
}

public struct ListCellsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCellsInputBody: Swift.Equatable {
}

extension ListCellsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCellsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCellsOutputBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.nextToken = output.nextToken
        } else {
            self.cells = nil
            self.nextToken = nil
        }
    }
}

public struct ListCellsOutput: Swift.Equatable {
    /// A list of cells.
    public var cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        cells: [Route53RecoveryReadinessClientTypes.CellOutput]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cells = cells
        self.nextToken = nextToken
    }
}

struct ListCellsOutputBody: Swift.Equatable {
    let cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    let nextToken: Swift.String?
}

extension ListCellsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.CellOutput?].self, forKey: .cells)
        var cellsDecoded0:[Route53RecoveryReadinessClientTypes.CellOutput]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Route53RecoveryReadinessClientTypes.CellOutput]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCellsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCrossAccountAuthorizationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCrossAccountAuthorizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crossaccountauthorizations"
    }
}

public struct ListCrossAccountAuthorizationsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsInputBody: Swift.Equatable {
}

extension ListCrossAccountAuthorizationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCrossAccountAuthorizationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCrossAccountAuthorizationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorizations = output.crossAccountAuthorizations
            self.nextToken = output.nextToken
        } else {
            self.crossAccountAuthorizations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrossAccountAuthorizationsOutput: Swift.Equatable {
    /// A list of cross-account authorizations.
    public var crossAccountAuthorizations: [Swift.String]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        crossAccountAuthorizations: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crossAccountAuthorizations = crossAccountAuthorizations
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsOutputBody: Swift.Equatable {
    let crossAccountAuthorizations: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListCrossAccountAuthorizationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorizations = "crossAccountAuthorizations"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .crossAccountAuthorizations)
        var crossAccountAuthorizationsDecoded0:[Swift.String]? = nil
        if let crossAccountAuthorizationsContainer = crossAccountAuthorizationsContainer {
            crossAccountAuthorizationsDecoded0 = [Swift.String]()
            for string0 in crossAccountAuthorizationsContainer {
                if let string0 = string0 {
                    crossAccountAuthorizationsDecoded0?.append(string0)
                }
            }
        }
        crossAccountAuthorizations = crossAccountAuthorizationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCrossAccountAuthorizationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReadinessChecksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReadinessChecksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/readinesschecks"
    }
}

public struct ListReadinessChecksInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReadinessChecksInputBody: Swift.Equatable {
}

extension ListReadinessChecksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReadinessChecksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReadinessChecksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readinessChecks = nil
        }
    }
}

public struct ListReadinessChecksOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of readiness checks associated with the account.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?

    public init(
        nextToken: Swift.String? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.readinessChecks = readinessChecks
    }
}

struct ListReadinessChecksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?
}

extension ListReadinessChecksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readinessChecks = "readinessChecks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckOutput?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

enum ListReadinessChecksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecoveryGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recoverygroups"
    }
}

public struct ListRecoveryGroupsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryGroupsInputBody: Swift.Equatable {
}

extension ListRecoveryGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecoveryGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryGroups = output.recoveryGroups
        } else {
            self.nextToken = nil
            self.recoveryGroups = nil
        }
    }
}

public struct ListRecoveryGroupsOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of recovery groups.
    public var recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryGroups = recoveryGroups
    }
}

struct ListRecoveryGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?
}

extension ListRecoveryGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case recoveryGroups = "recoveryGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryGroupsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RecoveryGroupOutput?].self, forKey: .recoveryGroups)
        var recoveryGroupsDecoded0:[Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
        if let recoveryGroupsContainer = recoveryGroupsContainer {
            recoveryGroupsDecoded0 = [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]()
            for structure0 in recoveryGroupsContainer {
                if let structure0 = structure0 {
                    recoveryGroupsDecoded0?.append(structure0)
                }
            }
        }
        recoveryGroups = recoveryGroupsDecoded0
    }
}

enum ListRecoveryGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcesets"
    }
}

public struct ListResourceSetsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceSetsInputBody: Swift.Equatable {
}

extension ListResourceSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceSets = output.resourceSets
        } else {
            self.nextToken = nil
            self.resourceSets = nil
        }
    }
}

public struct ListResourceSetsOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of resource sets associated with the account.
    public var resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?

    public init(
        nextToken: Swift.String? = nil,
        resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceSets = resourceSets
    }
}

struct ListResourceSetsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?
}

extension ListResourceSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case resourceSets = "resourceSets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceSetsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceSetOutput?].self, forKey: .resourceSets)
        var resourceSetsDecoded0:[Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
        if let resourceSetsContainer = resourceSetsContainer {
            resourceSetsDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceSetOutput]()
            for structure0 in resourceSetsContainer {
                if let structure0 = structure0 {
                    resourceSetsDecoded0?.append(structure0)
                }
            }
        }
        resourceSets = resourceSetsDecoded0
    }
}

enum ListResourceSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The resource type that a readiness rule applies to.
    public var resourceType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension Route53RecoveryReadinessClientTypes.ListRulesOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "resourceType"
        case ruleDescription = "ruleDescription"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let ruleDescription = self.ruleDescription {
            try encodeContainer.encode(ruleDescription, forKey: .ruleDescription)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let ruleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDescription)
        ruleDescription = ruleDescriptionDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension ListRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutput: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of readiness rules for a specific resource type.
    public var rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?

    public init(
        nextToken: Swift.String? = nil,
        rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Readiness rule information, including the resource type, rule ID, and rule description.
    public struct ListRulesOutput: Swift.Equatable {
        /// The resource type that the readiness rule applies to.
        /// This member is required.
        public var resourceType: Swift.String?
        /// The description of a readiness rule.
        /// This member is required.
        public var ruleDescription: Swift.String?
        /// The ID for the readiness rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            resourceType: Swift.String? = nil,
            ruleDescription: Swift.String? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.ruleDescription = ruleDescription
            self.ruleId = ruleId
        }
    }

}

struct ListRulesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?
}

extension ListRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case rules = "rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ListRulesOutput?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.ListRulesOutput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

enum ListRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourcesInputBody: Swift.Equatable {
}

extension ListTagsForResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourcesOutput: Swift.Equatable {
    ///
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourcesOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageText = "messageText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageText = self.messageText {
            try encodeContainer.encode(messageText, forKey: .messageText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageText)
        messageText = messageTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Information relating to readiness check status.
    public struct Message: Swift.Equatable {
        /// The text of a readiness check message.
        public var messageText: Swift.String?

        public init(
            messageText: Swift.String? = nil
        )
        {
            self.messageText = messageText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.NLBResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The Network Load Balancer resource that a DNS target resource points to.
    public struct NLBResource: Swift.Equatable {
        /// The Network Load Balancer resource Amazon Resource Name (ARN).
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.R53ResourceRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case recordSetId = "recordSetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let recordSetId = self.recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The Route 53 resource that a DNS target resource record points to.
    public struct R53ResourceRecord: Swift.Equatable {
        /// The DNS target domain name.
        public var domainName: Swift.String?
        /// The Route 53 Resource Record Set ID.
        public var recordSetId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            recordSetId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.recordSetId = recordSetId
        }
    }

}

extension Route53RecoveryReadinessClientTypes {
    /// The readiness status.
    public enum Readiness: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notAuthorized
        case notReady
        case ready
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Readiness] {
            return [
                .notAuthorized,
                .notReady,
                .ready,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notAuthorized: return "NOT_AUTHORIZED"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Readiness(rawValue: rawValue) ?? Readiness.sdkUnknown(rawValue)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckArn = self.readinessCheckArn {
            try encodeContainer.encode(readinessCheckArn, forKey: .readinessCheckArn)
        }
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSet = self.resourceSet {
            try encodeContainer.encode(resourceSet, forKey: .resourceSet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A readiness check.
    public struct ReadinessCheckOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        /// This member is required.
        public var readinessCheckArn: Swift.String?
        /// Name of a readiness check.
        public var readinessCheckName: Swift.String?
        /// Name of the resource set to be checked.
        /// This member is required.
        public var resourceSet: Swift.String?
        /// A collection of tags associated with a resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            readinessCheckArn: Swift.String? = nil,
            readinessCheckName: Swift.String? = nil,
            resourceSet: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readiness = "readiness"
        case readinessCheckName = "readinessCheckName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Summary of all readiness check statuses in a recovery group, paginated in GetRecoveryGroupReadinessSummary and GetCellReadinessSummary.
    public struct ReadinessCheckSummary: Swift.Equatable {
        /// The readiness status of this readiness check.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The name of a readiness check.
        public var readinessCheckName: Swift.String?

        public init(
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            readinessCheckName: Swift.String? = nil
        )
        {
            self.readiness = readiness
            self.readinessCheckName = readinessCheckName
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationText = "recommendationText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationText = self.recommendationText {
            try encodeContainer.encode(recommendationText, forKey: .recommendationText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationText)
        recommendationText = recommendationTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Recommendations that are provided to make an application more recovery resilient.
    public struct Recommendation: Swift.Equatable {
        /// Text of the recommendations that are provided to make an application more recovery resilient.
        /// This member is required.
        public var recommendationText: Swift.String?

        public init(
            recommendationText: Swift.String? = nil
        )
        {
            self.recommendationText = recommendationText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RecoveryGroupOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let recoveryGroupArn = self.recoveryGroupArn {
            try encodeContainer.encode(recoveryGroupArn, forKey: .recoveryGroupArn)
        }
        if let recoveryGroupName = self.recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A representation of the application, typically containing multiple cells.
    public struct RecoveryGroupOutput: Swift.Equatable {
        /// A list of a cell's Amazon Resource Names (ARNs).
        /// This member is required.
        public var cells: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        /// This member is required.
        public var recoveryGroupArn: Swift.String?
        /// The name of the recovery group.
        /// This member is required.
        public var recoveryGroupName: Swift.String?
        /// The tags associated with the recovery group.
        public var tags: [Swift.String:Swift.String]?

        public init(
            cells: [Swift.String]? = nil,
            recoveryGroupArn: Swift.String? = nil,
            recoveryGroupName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case dnsTargetResource = "dnsTargetResource"
        case readinessScopes = "readinessScopes"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let dnsTargetResource = self.dnsTargetResource {
            try encodeContainer.encode(dnsTargetResource, forKey: .dnsTargetResource)
        }
        if let readinessScopes = readinessScopes {
            var readinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readinessScopes)
            for __string0 in readinessScopes {
                try readinessScopesContainer.encode(__string0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let dnsTargetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.DNSTargetResource.self, forKey: .dnsTargetResource)
        dnsTargetResource = dnsTargetResourceDecoded
        let readinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readinessScopes)
        var readinessScopesDecoded0:[Swift.String]? = nil
        if let readinessScopesContainer = readinessScopesContainer {
            readinessScopesDecoded0 = [Swift.String]()
            for string0 in readinessScopesContainer {
                if let string0 = string0 {
                    readinessScopesDecoded0?.append(string0)
                }
            }
        }
        readinessScopes = readinessScopesDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The resource element of a resource set.
    public struct Resource: Swift.Equatable {
        /// The component identifier of the resource, generated when DNS target resource is used.
        public var componentId: Swift.String?
        /// The DNS target resource.
        public var dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource?
        /// A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
        public var readinessScopes: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services resource.
        public var resourceArn: Swift.String?

        public init(
            componentId: Swift.String? = nil,
            dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource? = nil,
            readinessScopes: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.dnsTargetResource = dnsTargetResource
            self.readinessScopes = readinessScopes
            self.resourceArn = resourceArn
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ResourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case readiness = "readiness"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let lastCheckedTimestamp = self.lastCheckedTimestamp {
            try encodeContainer.encodeTimestamp(lastCheckedTimestamp, format: .dateTime, forKey: .lastCheckedTimestamp)
        }
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let lastCheckedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The result of a successful Resource request, with status for an individual resource.
    public struct ResourceResult: Swift.Equatable {
        /// The component id of the resource.
        public var componentId: Swift.String?
        /// The time (UTC) that the resource was last checked for readiness, in ISO-8601 format.
        /// This member is required.
        public var lastCheckedTimestamp: ClientRuntime.Date?
        /// The readiness of a resource.
        /// This member is required.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?

        public init(
            componentId: Swift.String? = nil,
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.readiness = readiness
            self.resourceArn = resourceArn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ResourceSetOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetArn = self.resourceSetArn {
            try encodeContainer.encode(resourceSetArn, forKey: .resourceSetArn)
        }
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A collection of resources of the same type.
    public struct ResourceSetOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the resource set.
        /// This member is required.
        public var resourceSetArn: Swift.String?
        /// The name of the resource set.
        /// This member is required.
        public var resourceSetName: Swift.String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        /// This member is required.
        public var resourceSetType: Swift.String?
        /// A list of resource objects.
        /// This member is required.
        public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
        /// A collection of tags associated with a resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            resourceSetArn: Swift.String? = nil,
            resourceSetName: Swift.String? = nil,
            resourceSetType: Swift.String? = nil,
            resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.resources = resources
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RuleResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case messages = "messages"
        case readiness = "readiness"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastCheckedTimestamp = self.lastCheckedTimestamp {
            try encodeContainer.encodeTimestamp(lastCheckedTimestamp, format: .dateTime, forKey: .lastCheckedTimestamp)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for message0 in messages {
                try messagesContainer.encode(message0)
            }
        }
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastCheckedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The result of a successful Rule request, with status for an individual rule.
    public struct RuleResult: Swift.Equatable {
        /// The time the resource was last checked for readiness, in ISO-8601 format, UTC.
        /// This member is required.
        public var lastCheckedTimestamp: ClientRuntime.Date?
        /// Details about the resource's readiness.
        /// This member is required.
        public var messages: [Route53RecoveryReadinessClientTypes.Message]?
        /// The readiness at rule level.
        /// This member is required.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The identifier of the rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.messages = messages
            self.readiness = readiness
            self.ruleId = ruleId
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.TargetResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nlbResource = "nLBResource"
        case r53Resource = "r53Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nlbResource = self.nlbResource {
            try encodeContainer.encode(nlbResource, forKey: .nlbResource)
        }
        if let r53Resource = self.r53Resource {
            try encodeContainer.encode(r53Resource, forKey: .r53Resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nlbResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.NLBResource.self, forKey: .nlbResource)
        nlbResource = nlbResourceDecoded
        let r53ResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.R53ResourceRecord.self, forKey: .r53Resource)
        r53Resource = r53ResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The target resource that the Route 53 record points to.
    public struct TargetResource: Swift.Equatable {
        /// The Network Load Balancer Resource.
        public var nlbResource: Route53RecoveryReadinessClientTypes.NLBResource?
        /// The Route 53 resource.
        public var r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord?

        public init(
            nlbResource: Route53RecoveryReadinessClientTypes.NLBResource? = nil,
            r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord? = nil
        )
        {
            self.nlbResource = nlbResource
            self.r53Resource = r53Resource
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys for tags you add to resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCellInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
    }
}

extension UpdateCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct UpdateCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?
    /// A list of cell Amazon Resource Names (ARNs), which completely replaces the previous list.
    /// This member is required.
    public var cells: [Swift.String]?

    public init(
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
    }
}

struct UpdateCellInputBody: Swift.Equatable {
    let cells: [Swift.String]?
}

extension UpdateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateCellOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCellOutputBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct UpdateCellOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct UpdateCellOutputBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateCellOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateCellOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReadinessCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
    }
}

extension UpdateReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

/// Name of a readiness check to describe.
public struct UpdateReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The name of the resource set to be checked.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init(
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
    }
}

struct UpdateReadinessCheckInputBody: Swift.Equatable {
    let resourceSetName: Swift.String?
}

extension UpdateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
    }
}

extension UpdateReadinessCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReadinessCheckOutputBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct UpdateReadinessCheckOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct UpdateReadinessCheckOutputBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateReadinessCheckOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateReadinessCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecoveryGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
    }
}

extension UpdateRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

/// Name of a recovery group.
public struct UpdateRecoveryGroupInput: Swift.Equatable {
    /// A list of cell Amazon Resource Names (ARNs). This list completely replaces the previous list.
    /// This member is required.
    public var cells: [Swift.String]?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init(
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
    }
}

struct UpdateRecoveryGroupInputBody: Swift.Equatable {
    let cells: [Swift.String]?
}

extension UpdateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateRecoveryGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecoveryGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRecoveryGroupOutput: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct UpdateRecoveryGroupOutputBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRecoveryGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateRecoveryGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }
}

extension UpdateResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

/// Name of a resource set.
public struct UpdateResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    /// This member is required.
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    /// This member is required.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?

    public init(
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
    }
}

struct UpdateResourceSetInputBody: Swift.Equatable {
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
}

extension UpdateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension UpdateResourceSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResourceSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct UpdateResourceSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct UpdateResourceSetOutputBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateResourceSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateResourceSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
