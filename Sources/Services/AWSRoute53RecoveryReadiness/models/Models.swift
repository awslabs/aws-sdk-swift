// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.CellOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellArn = self.cellArn {
            try encodeContainer.encode(cellArn, forKey: .cellArn)
        }
        if let cellName = self.cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let parentReadinessScopes = parentReadinessScopes {
            var parentReadinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentReadinessScopes)
            for __string0 in parentReadinessScopes {
                try parentReadinessScopesContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Information about a cell.
    public struct CellOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the cell.
        /// This member is required.
        public var cellArn: Swift.String?
        /// The name of the cell.
        /// This member is required.
        public var cellName: Swift.String?
        /// A list of cell ARNs.
        /// This member is required.
        public var cells: [Swift.String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        /// This member is required.
        public var parentReadinessScopes: [Swift.String]?
        /// Tags on the resources.
        public var tags: [Swift.String:Swift.String]?

        public init (
            cellArn: Swift.String? = nil,
            cellName: Swift.String? = nil,
            cells: [Swift.String]? = nil,
            parentReadinessScopes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCellInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellName = self.cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cells"
    }
}

public struct CreateCellInput: Swift.Equatable {
    /// The name of the cell to create.
    /// This member is required.
    public var cellName: Swift.String?
    /// A list of cell Amazon Resource Names (ARNs) contained within this cell, for use in nested cells. For example, Availability Zones within specific Amazon Web Services Regions.
    public var cells: [Swift.String]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
        self.tags = tags
    }
}

struct CreateCellInputBody: Swift.Equatable {
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct CreateCellOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct CreateCellOutputResponseBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCrossAccountAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccountAuthorization = self.crossAccountAuthorization {
            try encodeContainer.encode(crossAccountAuthorization, forKey: .crossAccountAuthorization)
        }
    }
}

extension CreateCrossAccountAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crossaccountauthorizations"
    }
}

public struct CreateCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross-account authorization.
    /// This member is required.
    public var crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationInputBody: Swift.Equatable {
    let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

extension CreateCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCrossAccountAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCrossAccountAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCrossAccountAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCrossAccountAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorization = output.crossAccountAuthorization
        } else {
            self.crossAccountAuthorization = nil
        }
    }
}

public struct CreateCrossAccountAuthorizationOutputResponse: Swift.Equatable {
    /// The cross-account authorization.
    public var crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationOutputResponseBody: Swift.Equatable {
    let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

extension CreateReadinessCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/readinesschecks"
    }
}

public struct CreateReadinessCheckInput: Swift.Equatable {
    /// The name of the readiness check to create.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The name of the resource set to check.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
        self.tags = tags
    }
}

struct CreateReadinessCheckInputBody: Swift.Equatable {
    let readinessCheckName: Swift.String?
    let resourceSetName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct CreateReadinessCheckOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct CreateReadinessCheckOutputResponseBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecoveryGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let recoveryGroupName = self.recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recoverygroups"
    }
}

public struct CreateRecoveryGroupInput: Swift.Equatable {
    /// A list of the cell Amazon Resource Names (ARNs) in the recovery group.
    public var cells: [Swift.String]?
    /// The name of the recovery group to create.
    /// This member is required.
    public var recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupInputBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct CreateRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupOutputResponseBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcesets"
    }
}

public struct CreateResourceSetInput: Swift.Equatable {
    /// The name of the resource set to create.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    /// This member is required.
    public var resourceSetType: Swift.String?
    /// A list of resource objects in the resource set.
    /// This member is required.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A tag to associate with the parameters for a resource set.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetInputBody: Swift.Equatable {
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct CreateResourceSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetOutputResponseBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.DNSTargetResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case hostedZoneArn = "hostedZoneArn"
        case recordSetId = "recordSetId"
        case recordType = "recordType"
        case targetResource = "targetResource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneArn = self.hostedZoneArn {
            try encodeContainer.encode(hostedZoneArn, forKey: .hostedZoneArn)
        }
        if let recordSetId = self.recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
        if let recordType = self.recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let targetResource = self.targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneArn)
        hostedZoneArn = hostedZoneArnDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.TargetResource.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A component for DNS/routing control readiness checks and architecture checks.
    public struct DNSTargetResource: Swift.Equatable {
        /// The domain name that acts as an ingress point to a portion of the customer application.
        public var domainName: Swift.String?
        /// The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
        public var hostedZoneArn: Swift.String?
        /// The Route 53 record set ID that uniquely identifies a DNS record, given a name and a type.
        public var recordSetId: Swift.String?
        /// The type of DNS record of the target resource.
        public var recordType: Swift.String?
        /// The target resource of the DNS target resource.
        public var targetResource: Route53RecoveryReadinessClientTypes.TargetResource?

        public init (
            domainName: Swift.String? = nil,
            hostedZoneArn: Swift.String? = nil,
            recordSetId: Swift.String? = nil,
            recordType: Swift.String? = nil,
            targetResource: Route53RecoveryReadinessClientTypes.TargetResource? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneArn = hostedZoneArn
            self.recordSetId = recordSetId
            self.recordType = recordType
            self.targetResource = targetResource
        }
    }

}

extension DeleteCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct DeleteCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?

    public init (
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct DeleteCellInputBody: Swift.Equatable {
}

extension DeleteCellInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCellOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCrossAccountAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let crossAccountAuthorization = crossAccountAuthorization else {
            return nil
        }
        return "/crossaccountauthorizations/\(crossAccountAuthorization.urlPercentEncoding())"
    }
}

public struct DeleteCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross-account authorization.
    /// This member is required.
    public var crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct DeleteCrossAccountAuthorizationInputBody: Swift.Equatable {
}

extension DeleteCrossAccountAuthorizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCrossAccountAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCrossAccountAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCrossAccountAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCrossAccountAuthorizationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

public struct DeleteReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct DeleteReadinessCheckInputBody: Swift.Equatable {
}

extension DeleteReadinessCheckInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReadinessCheckOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct DeleteRecoveryGroupInput: Swift.Equatable {
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init (
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct DeleteRecoveryGroupInputBody: Swift.Equatable {
}

extension DeleteRecoveryGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

public struct DeleteResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init (
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct DeleteResourceSetInputBody: Swift.Equatable {
}

extension DeleteResourceSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetArchitectureRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetArchitectureRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())/architectureRecommendations"
    }
}

public struct GetArchitectureRecommendationsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetArchitectureRecommendationsInputBody: Swift.Equatable {
}

extension GetArchitectureRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetArchitectureRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArchitectureRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetArchitectureRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArchitectureRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetArchitectureRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastAuditTimestamp = output.lastAuditTimestamp
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.lastAuditTimestamp = nil
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetArchitectureRecommendationsOutputResponse: Swift.Equatable {
    /// The time that a recovery group was last assessed for recommendations, in UTC ISO-8601 format.
    public var lastAuditTimestamp: ClientRuntime.Date?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of the recommendations for the customer's application.
    public var recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?

    public init (
        lastAuditTimestamp: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]? = nil
    )
    {
        self.lastAuditTimestamp = lastAuditTimestamp
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct GetArchitectureRecommendationsOutputResponseBody: Swift.Equatable {
    let lastAuditTimestamp: ClientRuntime.Date?
    let nextToken: Swift.String?
    let recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?
}

extension GetArchitectureRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuditTimestamp = "lastAuditTimestamp"
        case nextToken = "nextToken"
        case recommendations = "recommendations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastAuditTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastAuditTimestamp)
        lastAuditTimestamp = lastAuditTimestampDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[Route53RecoveryReadinessClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [Route53RecoveryReadinessClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
    }
}

extension GetCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct GetCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?

    public init (
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct GetCellInputBody: Swift.Equatable {
}

extension GetCellInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct GetCellOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct GetCellOutputResponseBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetCellReadinessSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetCellReadinessSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cellreadiness/\(cellName.urlPercentEncoding())"
    }
}

public struct GetCellReadinessSummaryInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        cellName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.cellName = cellName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCellReadinessSummaryInputBody: Swift.Equatable {
}

extension GetCellReadinessSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCellReadinessSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCellReadinessSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCellReadinessSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCellReadinessSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCellReadinessSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetCellReadinessSummaryOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at a cell level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries for the readiness checks that make up the cell.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetCellReadinessSummaryOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetCellReadinessSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension GetReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

public struct GetReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckInputBody: Swift.Equatable {
}

extension GetReadinessCheckInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct GetReadinessCheckOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct GetReadinessCheckOutputResponseBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetReadinessCheckResourceStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetReadinessCheckResourceStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())/resource/\(resourceIdentifier.urlPercentEncoding())/status"
    }
}

public struct GetReadinessCheckResourceStatusInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The resource identifier, which is the Amazon Resource Name (ARN) or the identifier generated for the resource by Application Recovery Controller (for example, for a DNS target resource).
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetReadinessCheckResourceStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckResourceStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckResourceStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckResourceStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadinessCheckResourceStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckResourceStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadinessCheckResourceStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.rules = nil
        }
    }
}

public struct GetReadinessCheckResourceStatusOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at a rule level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Details of the rule's results.
    public var rules: [Route53RecoveryReadinessClientTypes.RuleResult]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        rules: [Route53RecoveryReadinessClientTypes.RuleResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.rules = rules
    }
}

struct GetReadinessCheckResourceStatusOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let rules: [Route53RecoveryReadinessClientTypes.RuleResult]?
}

extension GetReadinessCheckResourceStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case rules = "rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RuleResult?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.RuleResult]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.RuleResult]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension GetReadinessCheckStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetReadinessCheckStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())/status"
    }
}

public struct GetReadinessCheckStatusInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadinessCheckStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadinessCheckStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.resources = output.resources
        } else {
            self.messages = nil
            self.nextToken = nil
            self.readiness = nil
            self.resources = nil
        }
    }
}

public struct GetReadinessCheckStatusOutputResponse: Swift.Equatable {
    /// Top level messages for readiness check status
    public var messages: [Route53RecoveryReadinessClientTypes.Message]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness at rule level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summary of the readiness of resources.
    public var resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?

    public init (
        messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        resources: [Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
        self.readiness = readiness
        self.resources = resources
    }
}

struct GetReadinessCheckStatusOutputResponseBody: Swift.Equatable {
    let messages: [Route53RecoveryReadinessClientTypes.Message]?
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?
}

extension GetReadinessCheckStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages = "messages"
        case nextToken = "nextToken"
        case readiness = "readiness"
        case resources = "resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceResult?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceResult]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GetRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct GetRecoveryGroupInput: Swift.Equatable {
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init (
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupInputBody: Swift.Equatable {
}

extension GetRecoveryGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct GetRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct GetRecoveryGroupOutputResponseBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRecoveryGroupReadinessSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRecoveryGroupReadinessSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroupreadiness/\(recoveryGroupName.urlPercentEncoding())"
    }
}

public struct GetRecoveryGroupReadinessSummaryInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupReadinessSummaryInputBody: Swift.Equatable {
}

extension GetRecoveryGroupReadinessSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupReadinessSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryGroupReadinessSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecoveryGroupReadinessSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryGroupReadinessSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecoveryGroupReadinessSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetRecoveryGroupReadinessSummaryOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The readiness status at a recovery group level.
    public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries of the readiness checks for the recovery group.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetRecoveryGroupReadinessSummaryOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetRecoveryGroupReadinessSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension GetResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

public struct GetResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init (
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct GetResourceSetInputBody: Swift.Equatable {
}

extension GetResourceSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct GetResourceSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct GetResourceSetOutputResponseBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension GetResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCellsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCellsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cells"
    }
}

public struct ListCellsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCellsInputBody: Swift.Equatable {
}

extension ListCellsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCellsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCellsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCellsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCellsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCellsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.nextToken = output.nextToken
        } else {
            self.cells = nil
            self.nextToken = nil
        }
    }
}

public struct ListCellsOutputResponse: Swift.Equatable {
    /// A list of cells.
    public var cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        cells: [Route53RecoveryReadinessClientTypes.CellOutput]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cells = cells
        self.nextToken = nextToken
    }
}

struct ListCellsOutputResponseBody: Swift.Equatable {
    let cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    let nextToken: Swift.String?
}

extension ListCellsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.CellOutput?].self, forKey: .cells)
        var cellsDecoded0:[Route53RecoveryReadinessClientTypes.CellOutput]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Route53RecoveryReadinessClientTypes.CellOutput]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCrossAccountAuthorizationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCrossAccountAuthorizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/crossaccountauthorizations"
    }
}

public struct ListCrossAccountAuthorizationsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsInputBody: Swift.Equatable {
}

extension ListCrossAccountAuthorizationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCrossAccountAuthorizationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCrossAccountAuthorizationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCrossAccountAuthorizationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCrossAccountAuthorizationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCrossAccountAuthorizationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorizations = output.crossAccountAuthorizations
            self.nextToken = output.nextToken
        } else {
            self.crossAccountAuthorizations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrossAccountAuthorizationsOutputResponse: Swift.Equatable {
    /// A list of cross-account authorizations.
    public var crossAccountAuthorizations: [Swift.String]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        crossAccountAuthorizations: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crossAccountAuthorizations = crossAccountAuthorizations
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsOutputResponseBody: Swift.Equatable {
    let crossAccountAuthorizations: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListCrossAccountAuthorizationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorizations = "crossAccountAuthorizations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .crossAccountAuthorizations)
        var crossAccountAuthorizationsDecoded0:[Swift.String]? = nil
        if let crossAccountAuthorizationsContainer = crossAccountAuthorizationsContainer {
            crossAccountAuthorizationsDecoded0 = [Swift.String]()
            for string0 in crossAccountAuthorizationsContainer {
                if let string0 = string0 {
                    crossAccountAuthorizationsDecoded0?.append(string0)
                }
            }
        }
        crossAccountAuthorizations = crossAccountAuthorizationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReadinessChecksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReadinessChecksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/readinesschecks"
    }
}

public struct ListReadinessChecksInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReadinessChecksInputBody: Swift.Equatable {
}

extension ListReadinessChecksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReadinessChecksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadinessChecksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReadinessChecksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadinessChecksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReadinessChecksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readinessChecks = nil
        }
    }
}

public struct ListReadinessChecksOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of readiness checks associated with the account.
    public var readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?

    public init (
        nextToken: Swift.String? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.readinessChecks = readinessChecks
    }
}

struct ListReadinessChecksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?
}

extension ListReadinessChecksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckOutput?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension ListRecoveryGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecoveryGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recoverygroups"
    }
}

public struct ListRecoveryGroupsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryGroupsInputBody: Swift.Equatable {
}

extension ListRecoveryGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecoveryGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecoveryGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryGroups = output.recoveryGroups
        } else {
            self.nextToken = nil
            self.recoveryGroups = nil
        }
    }
}

public struct ListRecoveryGroupsOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of recovery groups.
    public var recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryGroups = recoveryGroups
    }
}

struct ListRecoveryGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?
}

extension ListRecoveryGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case recoveryGroups = "recoveryGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryGroupsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RecoveryGroupOutput?].self, forKey: .recoveryGroups)
        var recoveryGroupsDecoded0:[Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
        if let recoveryGroupsContainer = recoveryGroupsContainer {
            recoveryGroupsDecoded0 = [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]()
            for structure0 in recoveryGroupsContainer {
                if let structure0 = structure0 {
                    recoveryGroupsDecoded0?.append(structure0)
                }
            }
        }
        recoveryGroups = recoveryGroupsDecoded0
    }
}

extension ListResourceSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcesets"
    }
}

public struct ListResourceSetsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceSetsInputBody: Swift.Equatable {
}

extension ListResourceSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceSets = output.resourceSets
        } else {
            self.nextToken = nil
            self.resourceSets = nil
        }
    }
}

public struct ListResourceSetsOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of resource sets associated with the account.
    public var resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?

    public init (
        nextToken: Swift.String? = nil,
        resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceSets = resourceSets
    }
}

struct ListResourceSetsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?
}

extension ListResourceSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case resourceSets = "resourceSets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceSetsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceSetOutput?].self, forKey: .resourceSets)
        var resourceSetsDecoded0:[Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
        if let resourceSetsContainer = resourceSetsContainer {
            resourceSetsDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceSetOutput]()
            for structure0 in resourceSetsContainer {
                if let structure0 = structure0 {
                    resourceSetsDecoded0?.append(structure0)
                }
            }
        }
        resourceSets = resourceSetsDecoded0
    }
}

extension ListRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The resource type that a readiness rule applies to.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension Route53RecoveryReadinessClientTypes.ListRulesOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "resourceType"
        case ruleDescription = "ruleDescription"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let ruleDescription = self.ruleDescription {
            try encodeContainer.encode(ruleDescription, forKey: .ruleDescription)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let ruleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDescription)
        ruleDescription = ruleDescriptionDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Readiness rule information, including the resource type, rule ID, and rule description.
    public struct ListRulesOutput: Swift.Equatable {
        /// The resource type that the readiness rule applies to.
        /// This member is required.
        public var resourceType: Swift.String?
        /// The description of a readiness rule.
        /// This member is required.
        public var ruleDescription: Swift.String?
        /// The ID for the readiness rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init (
            resourceType: Swift.String? = nil,
            ruleDescription: Swift.String? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.ruleDescription = ruleDescription
            self.ruleId = ruleId
        }
    }

}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// A list of readiness rules for a specific resource type.
    public var rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case rules = "rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ListRulesOutput?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.ListRulesOutput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ListTagsForResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourcesInputBody: Swift.Equatable {
}

extension ListTagsForResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourcesOutputResponse: Swift.Equatable {
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourcesOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageText = "messageText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageText = self.messageText {
            try encodeContainer.encode(messageText, forKey: .messageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageText)
        messageText = messageTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Information relating to readiness check status.
    public struct Message: Swift.Equatable {
        /// The text of a readiness check message.
        public var messageText: Swift.String?

        public init (
            messageText: Swift.String? = nil
        )
        {
            self.messageText = messageText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.NLBResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The Network Load Balancer resource that a DNS target resource points to.
    public struct NLBResource: Swift.Equatable {
        /// The Network Load Balancer resource Amazon Resource Name (ARN).
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.R53ResourceRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case recordSetId = "recordSetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let recordSetId = self.recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The Route 53 resource that a DNS target resource record points to.
    public struct R53ResourceRecord: Swift.Equatable {
        /// The DNS target domain name.
        public var domainName: Swift.String?
        /// The Route 53 Resource Record Set ID.
        public var recordSetId: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            recordSetId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.recordSetId = recordSetId
        }
    }

}

extension Route53RecoveryReadinessClientTypes {
    /// The readiness status.
    public enum Readiness: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notAuthorized
        case notReady
        case ready
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Readiness] {
            return [
                .notAuthorized,
                .notReady,
                .ready,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notAuthorized: return "NOT_AUTHORIZED"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Readiness(rawValue: rawValue) ?? Readiness.sdkUnknown(rawValue)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckArn = self.readinessCheckArn {
            try encodeContainer.encode(readinessCheckArn, forKey: .readinessCheckArn)
        }
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSet = self.resourceSet {
            try encodeContainer.encode(resourceSet, forKey: .resourceSet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A readiness check.
    public struct ReadinessCheckOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        /// This member is required.
        public var readinessCheckArn: Swift.String?
        /// Name of a readiness check.
        public var readinessCheckName: Swift.String?
        /// Name of the resource set to be checked.
        /// This member is required.
        public var resourceSet: Swift.String?
        /// A collection of tags associated with a resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            readinessCheckArn: Swift.String? = nil,
            readinessCheckName: Swift.String? = nil,
            resourceSet: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readiness = "readiness"
        case readinessCheckName = "readinessCheckName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let readinessCheckName = self.readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Summary of all readiness check statuses in a recovery group, paginated in GetRecoveryGroupReadinessSummary and GetCellReadinessSummary.
    public struct ReadinessCheckSummary: Swift.Equatable {
        /// The readiness status of this readiness check.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The name of a readiness check.
        public var readinessCheckName: Swift.String?

        public init (
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            readinessCheckName: Swift.String? = nil
        )
        {
            self.readiness = readiness
            self.readinessCheckName = readinessCheckName
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationText = "recommendationText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationText = self.recommendationText {
            try encodeContainer.encode(recommendationText, forKey: .recommendationText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationText)
        recommendationText = recommendationTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// Recommendations that are provided to make an application more recovery resilient.
    public struct Recommendation: Swift.Equatable {
        /// Text of the recommendations that are provided to make an application more recovery resilient.
        /// This member is required.
        public var recommendationText: Swift.String?

        public init (
            recommendationText: Swift.String? = nil
        )
        {
            self.recommendationText = recommendationText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RecoveryGroupOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
        if let recoveryGroupArn = self.recoveryGroupArn {
            try encodeContainer.encode(recoveryGroupArn, forKey: .recoveryGroupArn)
        }
        if let recoveryGroupName = self.recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A representation of the application, typically containing multiple cells.
    public struct RecoveryGroupOutput: Swift.Equatable {
        /// A list of a cell's Amazon Resource Names (ARNs).
        /// This member is required.
        public var cells: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        /// This member is required.
        public var recoveryGroupArn: Swift.String?
        /// The name of the recovery group.
        /// This member is required.
        public var recoveryGroupName: Swift.String?
        /// The tags associated with the recovery group.
        public var tags: [Swift.String:Swift.String]?

        public init (
            cells: [Swift.String]? = nil,
            recoveryGroupArn: Swift.String? = nil,
            recoveryGroupName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case dnsTargetResource = "dnsTargetResource"
        case readinessScopes = "readinessScopes"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let dnsTargetResource = self.dnsTargetResource {
            try encodeContainer.encode(dnsTargetResource, forKey: .dnsTargetResource)
        }
        if let readinessScopes = readinessScopes {
            var readinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readinessScopes)
            for __string0 in readinessScopes {
                try readinessScopesContainer.encode(__string0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let dnsTargetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.DNSTargetResource.self, forKey: .dnsTargetResource)
        dnsTargetResource = dnsTargetResourceDecoded
        let readinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readinessScopes)
        var readinessScopesDecoded0:[Swift.String]? = nil
        if let readinessScopesContainer = readinessScopesContainer {
            readinessScopesDecoded0 = [Swift.String]()
            for string0 in readinessScopesContainer {
                if let string0 = string0 {
                    readinessScopesDecoded0?.append(string0)
                }
            }
        }
        readinessScopes = readinessScopesDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The resource element of a resource set.
    public struct Resource: Swift.Equatable {
        /// The component identifier of the resource, generated when DNS target resource is used.
        public var componentId: Swift.String?
        /// The DNS target resource.
        public var dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource?
        /// A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
        public var readinessScopes: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services resource.
        public var resourceArn: Swift.String?

        public init (
            componentId: Swift.String? = nil,
            dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource? = nil,
            readinessScopes: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.dnsTargetResource = dnsTargetResource
            self.readinessScopes = readinessScopes
            self.resourceArn = resourceArn
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ResourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case readiness = "readiness"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let lastCheckedTimestamp = self.lastCheckedTimestamp {
            try encodeContainer.encodeTimestamp(lastCheckedTimestamp, format: .dateTime, forKey: .lastCheckedTimestamp)
        }
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let lastCheckedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The result of a successful Resource request, with status for an individual resource.
    public struct ResourceResult: Swift.Equatable {
        /// The component id of the resource.
        public var componentId: Swift.String?
        /// The time (UTC) that the resource was last checked for readiness, in ISO-8601 format.
        /// This member is required.
        public var lastCheckedTimestamp: ClientRuntime.Date?
        /// The readiness of a resource.
        /// This member is required.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?

        public init (
            componentId: Swift.String? = nil,
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.readiness = readiness
            self.resourceArn = resourceArn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ResourceSetOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetArn = self.resourceSetArn {
            try encodeContainer.encode(resourceSetArn, forKey: .resourceSetArn)
        }
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// A collection of resources of the same type.
    public struct ResourceSetOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the resource set.
        /// This member is required.
        public var resourceSetArn: Swift.String?
        /// The name of the resource set.
        /// This member is required.
        public var resourceSetName: Swift.String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        /// This member is required.
        public var resourceSetType: Swift.String?
        /// A list of resource objects.
        /// This member is required.
        public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
        /// A collection of tags associated with a resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            resourceSetArn: Swift.String? = nil,
            resourceSetName: Swift.String? = nil,
            resourceSetType: Swift.String? = nil,
            resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.resources = resources
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RuleResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case messages = "messages"
        case readiness = "readiness"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastCheckedTimestamp = self.lastCheckedTimestamp {
            try encodeContainer.encodeTimestamp(lastCheckedTimestamp, format: .dateTime, forKey: .lastCheckedTimestamp)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for message0 in messages {
                try messagesContainer.encode(message0)
            }
        }
        if let readiness = self.readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastCheckedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The result of a successful Rule request, with status for an individual rule.
    public struct RuleResult: Swift.Equatable {
        /// The time the resource was last checked for readiness, in ISO-8601 format, UTC.
        /// This member is required.
        public var lastCheckedTimestamp: ClientRuntime.Date?
        /// Details about the resource's readiness.
        /// This member is required.
        public var messages: [Route53RecoveryReadinessClientTypes.Message]?
        /// The readiness at rule level.
        /// This member is required.
        public var readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The identifier of the rule.
        /// This member is required.
        public var ruleId: Swift.String?

        public init (
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.messages = messages
            self.readiness = readiness
            self.ruleId = ruleId
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    ///
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension Route53RecoveryReadinessClientTypes.TargetResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nlbResource = "nLBResource"
        case r53Resource = "r53Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nlbResource = self.nlbResource {
            try encodeContainer.encode(nlbResource, forKey: .nlbResource)
        }
        if let r53Resource = self.r53Resource {
            try encodeContainer.encode(r53Resource, forKey: .r53Resource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nlbResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.NLBResource.self, forKey: .nlbResource)
        nlbResource = nlbResourceDecoded
        let r53ResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.R53ResourceRecord.self, forKey: .r53Resource)
        r53Resource = r53ResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes {
    /// The target resource that the Route 53 record points to.
    public struct TargetResource: Swift.Equatable {
        /// The Network Load Balancer Resource.
        public var nlbResource: Route53RecoveryReadinessClientTypes.NLBResource?
        /// The Route 53 resource.
        public var r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord?

        public init (
            nlbResource: Route53RecoveryReadinessClientTypes.NLBResource? = nil,
            r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord? = nil
        )
        {
            self.nlbResource = nlbResource
            self.r53Resource = r53Resource
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys for tags you add to resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCellInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
    }
}

extension UpdateCellInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cellName = cellName else {
            return nil
        }
        return "/cells/\(cellName.urlPercentEncoding())"
    }
}

public struct UpdateCellInput: Swift.Equatable {
    /// The name of the cell.
    /// This member is required.
    public var cellName: Swift.String?
    /// A list of cell Amazon Resource Names (ARNs), which completely replaces the previous list.
    /// This member is required.
    public var cells: [Swift.String]?

    public init (
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
    }
}

struct UpdateCellInputBody: Swift.Equatable {
    let cells: [Swift.String]?
}

extension UpdateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct UpdateCellOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the cell.
    public var cellArn: Swift.String?
    /// The name of the cell.
    public var cellName: Swift.String?
    /// A list of cell ARNs.
    public var cells: [Swift.String]?
    /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
    public var parentReadinessScopes: [Swift.String]?
    /// Tags on the resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct UpdateCellOutputResponseBody: Swift.Equatable {
    let cellArn: Swift.String?
    let cellName: Swift.String?
    let cells: [Swift.String]?
    let parentReadinessScopes: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateReadinessCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = self.resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
    }
}

extension UpdateReadinessCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let readinessCheckName = readinessCheckName else {
            return nil
        }
        return "/readinesschecks/\(readinessCheckName.urlPercentEncoding())"
    }
}

/// Name of a readiness check to describe.
public struct UpdateReadinessCheckInput: Swift.Equatable {
    /// Name of a readiness check.
    /// This member is required.
    public var readinessCheckName: Swift.String?
    /// The name of the resource set to be checked.
    /// This member is required.
    public var resourceSetName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
    }
}

struct UpdateReadinessCheckInputBody: Swift.Equatable {
    let resourceSetName: Swift.String?
}

extension UpdateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
    }
}

extension UpdateReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct UpdateReadinessCheckOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with a readiness check.
    public var readinessCheckArn: Swift.String?
    /// Name of a readiness check.
    public var readinessCheckName: Swift.String?
    /// Name of the resource set to be checked.
    public var resourceSet: Swift.String?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct UpdateReadinessCheckOutputResponseBody: Swift.Equatable {
    let readinessCheckArn: Swift.String?
    let readinessCheckName: Swift.String?
    let resourceSet: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRecoveryGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __string0 in cells {
                try cellsContainer.encode(__string0)
            }
        }
    }
}

extension UpdateRecoveryGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recoveryGroupName = recoveryGroupName else {
            return nil
        }
        return "/recoverygroups/\(recoveryGroupName.urlPercentEncoding())"
    }
}

/// Name of a recovery group.
public struct UpdateRecoveryGroupInput: Swift.Equatable {
    /// A list of cell Amazon Resource Names (ARNs). This list completely replaces the previous list.
    /// This member is required.
    public var cells: [Swift.String]?
    /// The name of a recovery group.
    /// This member is required.
    public var recoveryGroupName: Swift.String?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
    }
}

struct UpdateRecoveryGroupInputBody: Swift.Equatable {
    let cells: [Swift.String]?
}

extension UpdateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of a cell's Amazon Resource Names (ARNs).
    public var cells: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the recovery group.
    public var recoveryGroupArn: Swift.String?
    /// The name of the recovery group.
    public var recoveryGroupName: Swift.String?
    /// The tags associated with the recovery group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct UpdateRecoveryGroupOutputResponseBody: Swift.Equatable {
    let cells: [Swift.String]?
    let recoveryGroupArn: Swift.String?
    let recoveryGroupName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetType = self.resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }
}

extension UpdateResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceSetName = resourceSetName else {
            return nil
        }
        return "/resourcesets/\(resourceSetName.urlPercentEncoding())"
    }
}

/// Name of a resource set.
public struct UpdateResourceSetInput: Swift.Equatable {
    /// Name of a resource set.
    /// This member is required.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    /// This member is required.
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    /// This member is required.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?

    public init (
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
    }
}

struct UpdateResourceSetInputBody: Swift.Equatable {
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
}

extension UpdateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension UpdateResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct UpdateResourceSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource set.
    public var resourceSetArn: Swift.String?
    /// The name of the resource set.
    public var resourceSetName: Swift.String?
    /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
    public var resourceSetType: Swift.String?
    /// A list of resource objects.
    public var resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct UpdateResourceSetOutputResponseBody: Swift.Equatable {
    let resourceSetArn: Swift.String?
    let resourceSetName: Swift.String?
    let resourceSetType: Swift.String?
    let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
