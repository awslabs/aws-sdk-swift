// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in your request already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input you provided is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSMSVoiceClientTypes.CallInstructionsMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
    public struct CallInstructionsMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension PinpointSMSVoiceClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        public var iamRoleArn: Swift.String?
        /// The name of the Amazon CloudWatch Log Group that you want to record events in.
        public var logGroupArn: Swift.String?

        public init(
            iamRoleArn: Swift.String? = nil,
            logGroupArn: Swift.String? = nil
        )
        {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }
    }

}

extension CreateConfigurationSetEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = self.eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

extension CreateConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations"
    }
}

/// Create a new event destination in a configuration set.
public struct CreateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An object that defines a single event destination.
    public var eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition?
    /// A name that identifies the event destination.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    let eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition?
    let eventDestinationName: Swift.String?
}

extension CreateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty object that indicates that the event destination was created successfully.
public struct CreateConfigurationSetEventDestinationOutput: Swift.Equatable {

    public init() { }
}

enum CreateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension CreateConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/configuration-sets"
    }
}

/// A request to create a new configuration set.
public struct CreateConfigurationSetInput: Swift.Equatable {
    /// The name that you want to give the configuration set.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct CreateConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension CreateConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension CreateConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty object that indicates that the configuration set was successfully created.
public struct CreateConfigurationSetOutput: Swift.Equatable {

    public init() { }
}

enum CreateConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        guard let eventDestinationName = eventDestinationName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations/\(eventDestinationName.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// EventDestinationName
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty object that indicates that the event destination was deleted successfully.
public struct DeleteConfigurationSetEventDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationSetInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty object that indicates that the configuration set was deleted successfully.
public struct DeleteConfigurationSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceClientTypes.EventDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceClientTypes.EventType]()
            for enum0 in matchingEventTypesContainer {
                if let enum0 = enum0 {
                    matchingEventTypesDecoded0?.append(enum0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that defines an event destination.
    public struct EventDestination: Swift.Equatable {
        /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
        public var cloudWatchLogsDestination: PinpointSMSVoiceClientTypes.CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public var enabled: Swift.Bool?
        /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSMSVoiceClientTypes.KinesisFirehoseDestination?
        /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
        public var matchingEventTypes: [PinpointSMSVoiceClientTypes.EventType]?
        /// A name that identifies the event destination configuration.
        public var name: Swift.String?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public var snsDestination: PinpointSMSVoiceClientTypes.SnsDestination?

        public init(
            cloudWatchLogsDestination: PinpointSMSVoiceClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            kinesisFirehoseDestination: PinpointSMSVoiceClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSMSVoiceClientTypes.EventType]? = nil,
            name: Swift.String? = nil,
            snsDestination: PinpointSMSVoiceClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.name = name
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSMSVoiceClientTypes.EventDestinationDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceClientTypes.EventType]()
            for enum0 in matchingEventTypesContainer {
                if let enum0 = enum0 {
                    matchingEventTypesDecoded0?.append(enum0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that defines a single event destination.
    public struct EventDestinationDefinition: Swift.Equatable {
        /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
        public var cloudWatchLogsDestination: PinpointSMSVoiceClientTypes.CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public var enabled: Swift.Bool?
        /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSMSVoiceClientTypes.KinesisFirehoseDestination?
        /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
        public var matchingEventTypes: [PinpointSMSVoiceClientTypes.EventType]?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public var snsDestination: PinpointSMSVoiceClientTypes.SnsDestination?

        public init(
            cloudWatchLogsDestination: PinpointSMSVoiceClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            kinesisFirehoseDestination: PinpointSMSVoiceClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSMSVoiceClientTypes.EventType]? = nil,
            snsDestination: PinpointSMSVoiceClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSMSVoiceClientTypes {
    /// The types of events that are sent to the event destination.
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case answered
        case busy
        case completedCall
        case failed
        case initiatedCall
        case noAnswer
        case ringing
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .answered,
                .busy,
                .completedCall,
                .failed,
                .initiatedCall,
                .noAnswer,
                .ringing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .busy: return "BUSY"
            case .completedCall: return "COMPLETED_CALL"
            case .failed: return "FAILED"
            case .initiatedCall: return "INITIATED_CALL"
            case .noAnswer: return "NO_ANSWER"
            case .ringing: return "RINGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigurationSetEventDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations"
    }
}

public struct GetConfigurationSetEventDestinationsInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Swift.Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigurationSetEventDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// An object that contains information about an event destination.
public struct GetConfigurationSetEventDestinationsOutput: Swift.Equatable {
    /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
    public var eventDestinations: [PinpointSMSVoiceClientTypes.EventDestination]?

    public init(
        eventDestinations: [PinpointSMSVoiceClientTypes.EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputBody: Swift.Equatable {
    let eventDestinations: [PinpointSMSVoiceClientTypes.EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSMSVoiceClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSMSVoiceClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

enum GetConfigurationSetEventDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSMSVoiceClientTypes.KinesisFirehoseDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = self.deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
    public struct KinesisFirehoseDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an IAM role that can write data to an Amazon Kinesis Data Firehose stream.
        public var deliveryStreamArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose destination that you want to use in the event destination.
        public var iamRoleArn: Swift.String?

        public init(
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are too many instances of the specified resource type.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListConfigurationSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/configuration-sets"
    }
}

public struct ListConfigurationSetsInput: Swift.Equatable {
    /// A token returned from a previous call to the API that indicates the position in the list of results.
    public var nextToken: Swift.String?
    /// Used to specify the number of items that should be returned in the response.
    public var pageSize: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Swift.Equatable {
}

extension ListConfigurationSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// An object that contains information about the configuration sets for your account in the current region.
public struct ListConfigurationSetsOutput: Swift.Equatable {
    /// An object that contains a list of configuration sets for your account in the current region.
    public var configurationSets: [Swift.String]?
    /// A token returned from a previous call to ListConfigurationSets to indicate the position in the list of configuration sets.
    public var nextToken: Swift.String?

    public init(
        configurationSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputBody: Swift.Equatable {
    let configurationSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListConfigurationSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[Swift.String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [Swift.String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource you attempted to access doesn't exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSMSVoiceClientTypes.PlainTextMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that defines a message that contains unformatted text.
    public struct PlainTextMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var languageCode: Swift.String?
        /// The plain (not SSML-formatted) text to deliver to the recipient.
        public var text: Swift.String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public var voiceId: Swift.String?

        public init(
            languageCode: Swift.String? = nil,
            text: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }
    }

}

extension PinpointSMSVoiceClientTypes.SSMLMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that defines a message that contains SSML-formatted text.
    public struct SSMLMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var languageCode: Swift.String?
        /// The SSML-formatted text to deliver to the recipient.
        public var text: Swift.String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public var voiceId: Swift.String?

        public init(
            languageCode: Swift.String? = nil,
            text: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }
    }

}

extension SendVoiceMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callerId = self.callerId {
            try encodeContainer.encode(callerId, forKey: .callerId)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let originationPhoneNumber = self.originationPhoneNumber {
            try encodeContainer.encode(originationPhoneNumber, forKey: .originationPhoneNumber)
        }
    }
}

extension SendVoiceMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/voice/message"
    }
}

/// SendVoiceMessageRequest
public struct SendVoiceMessageInput: Swift.Equatable {
    /// The phone number that appears on recipients' devices when they receive the message.
    public var callerId: Swift.String?
    /// The name of the configuration set that you want to use to send the message.
    public var configurationSetName: Swift.String?
    /// An object that contains a voice message and information about the recipient that you want to send it to.
    public var content: PinpointSMSVoiceClientTypes.VoiceMessageContent?
    /// The phone number that you want to send the voice message to.
    public var destinationPhoneNumber: Swift.String?
    /// The phone number that Amazon Pinpoint should use to send the voice message. This isn't necessarily the phone number that appears on recipients' devices when they receive the message, because you can specify a CallerId parameter in the request.
    public var originationPhoneNumber: Swift.String?

    public init(
        callerId: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        content: PinpointSMSVoiceClientTypes.VoiceMessageContent? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        originationPhoneNumber: Swift.String? = nil
    )
    {
        self.callerId = callerId
        self.configurationSetName = configurationSetName
        self.content = content
        self.destinationPhoneNumber = destinationPhoneNumber
        self.originationPhoneNumber = originationPhoneNumber
    }
}

struct SendVoiceMessageInputBody: Swift.Equatable {
    let callerId: Swift.String?
    let configurationSetName: Swift.String?
    let content: PinpointSMSVoiceClientTypes.VoiceMessageContent?
    let destinationPhoneNumber: Swift.String?
    let originationPhoneNumber: Swift.String?
}

extension SendVoiceMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerId)
        callerId = callerIdDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.VoiceMessageContent.self, forKey: .content)
        content = contentDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationPhoneNumber)
        originationPhoneNumber = originationPhoneNumberDecoded
    }
}

extension SendVoiceMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendVoiceMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// An object that that contains the Message ID of a Voice message that was sent successfully.
public struct SendVoiceMessageOutput: Swift.Equatable {
    /// A unique identifier for the voice message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendVoiceMessageOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendVoiceMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendVoiceMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceClientTypes.SnsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public struct SnsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've issued too many requests to the resource. Wait a few minutes, and then try again.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConfigurationSetEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = self.eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

extension UpdateConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        guard let eventDestinationName = eventDestinationName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations/\(eventDestinationName.urlPercentEncoding())"
    }
}

/// UpdateConfigurationSetEventDestinationRequest
public struct UpdateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An object that defines a single event destination.
    public var eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition?
    /// EventDestinationName
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    let eventDestination: PinpointSMSVoiceClientTypes.EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty object that indicates that the event destination was updated successfully.
public struct UpdateConfigurationSetEventDestinationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceClientTypes.VoiceMessageContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callInstructionsMessage = "CallInstructionsMessage"
        case plainTextMessage = "PlainTextMessage"
        case ssmlMessage = "SSMLMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callInstructionsMessage = self.callInstructionsMessage {
            try encodeContainer.encode(callInstructionsMessage, forKey: .callInstructionsMessage)
        }
        if let plainTextMessage = self.plainTextMessage {
            try encodeContainer.encode(plainTextMessage, forKey: .plainTextMessage)
        }
        if let ssmlMessage = self.ssmlMessage {
            try encodeContainer.encode(ssmlMessage, forKey: .ssmlMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callInstructionsMessageDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.CallInstructionsMessageType.self, forKey: .callInstructionsMessage)
        callInstructionsMessage = callInstructionsMessageDecoded
        let plainTextMessageDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.PlainTextMessageType.self, forKey: .plainTextMessage)
        plainTextMessage = plainTextMessageDecoded
        let ssmlMessageDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceClientTypes.SSMLMessageType.self, forKey: .ssmlMessage)
        ssmlMessage = ssmlMessageDecoded
    }
}

extension PinpointSMSVoiceClientTypes {
    /// An object that contains a voice message and information about the recipient that you want to send it to.
    public struct VoiceMessageContent: Swift.Equatable {
        /// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
        public var callInstructionsMessage: PinpointSMSVoiceClientTypes.CallInstructionsMessageType?
        /// An object that defines a message that contains unformatted text.
        public var plainTextMessage: PinpointSMSVoiceClientTypes.PlainTextMessageType?
        /// An object that defines a message that contains SSML-formatted text.
        public var ssmlMessage: PinpointSMSVoiceClientTypes.SSMLMessageType?

        public init(
            callInstructionsMessage: PinpointSMSVoiceClientTypes.CallInstructionsMessageType? = nil,
            plainTextMessage: PinpointSMSVoiceClientTypes.PlainTextMessageType? = nil,
            ssmlMessage: PinpointSMSVoiceClientTypes.SSMLMessageType? = nil
        )
        {
            self.callInstructionsMessage = callInstructionsMessage
            self.plainTextMessage = plainTextMessage
            self.ssmlMessage = ssmlMessage
        }
    }

}
