//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient access permissions to perform this operation. This exception occurs when your IAM user or role lacks the required permissions to access the Amazon Keyspaces resource or perform the requested action. Check your IAM policies and ensure they grant the necessary permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// You don't have sufficient permissions to perform this action.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The Amazon Keyspaces service encountered an unexpected error while processing the request. This internal server error is not related to your request parameters. Retry your request after a brief delay. If the issue persists, contact Amazon Web Services Support with details of your request to help identify and resolve the problem.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The service encountered an internal error. Try your request again.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested resource doesn't exist or could not be found. This exception occurs when you attempt to access a keyspace, table, stream, or other Amazon Keyspaces resource that doesn't exist or that has been deleted. Verify that the resource identifier is correct and that the resource exists in your account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The requested resource wasn't found. Verify that the resource exists and try again.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request rate is too high and exceeds the service's throughput limits. This exception occurs when you send too many requests in a short period of time. Implement exponential backoff in your retry strategy to handle this exception. Reducing your request frequency or distributing requests more evenly can help avoid throughput exceptions.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The request was denied due to request throttling. Reduce the frequency of requests and try again.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension KeyspacesStreamsClientTypes {

    public enum ValidationExceptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case expirediterator
        case expirednexttoken
        case invalidformat
        case trimmeddataaccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionType] {
            return [
                .expirediterator,
                .expirednexttoken,
                .invalidformat,
                .trimmeddataaccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .expirediterator: return "ExpiredIterator"
            case .expirednexttoken: return "ExpiredNextToken"
            case .invalidformat: return "InvalidFormat"
            case .trimmeddataaccess: return "TrimmedDataAccess"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request validation failed because one or more input parameters failed validation. This exception occurs when there are syntax errors in the request, field constraints are violated, or required parameters are missing. To help you fix the issue, the exception message provides details about which parameter failed and why.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// An error occurred validating your request. See the error message for details.
        public internal(set) var errorCode: KeyspacesStreamsClientTypes.ValidationExceptionType? = nil
        /// The input fails to satisfy the constraints specified by the service. Check the error details and modify your request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: KeyspacesStreamsClientTypes.ValidationExceptionType? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct GetRecordsInput: Swift.Sendable {
    /// The maximum number of records to return in a single GetRecords request. Default value is 1000. You can specify a limit between 1 and 10000, but the actual number returned might be less than the specified maximum if the size of the data for the returned records exceeds the internal size limit.
    public var maxResults: Swift.Int?
    /// The unique identifier of the shard iterator. A shard iterator specifies the position in the shard from which you want to start reading data records sequentially. You obtain this value by calling the GetShardIterator operation. Each shard iterator is valid for 5 minutes after creation.
    /// This member is required.
    public var shardIterator: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        shardIterator: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.shardIterator = shardIterator
    }
}

extension KeyspacesStreamsClientTypes {

    /// Contains metadata information associated with Amazon Keyspaces cells and rows.
    public struct KeyspacesMetadata: Swift.Sendable {
        /// The time at which the associated data will expire, based on the time-to-live (TTL) setting.
        public var expirationTime: Swift.String?
        /// The timestamp at which the associated data was written to the database.
        public var writeTime: Swift.String?

        public init(
            expirationTime: Swift.String? = nil,
            writeTime: Swift.String? = nil
        ) {
            self.expirationTime = expirationTime
            self.writeTime = writeTime
        }
    }
}

extension KeyspacesStreamsClientTypes {

    public enum OriginType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case replication
        case ttl
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginType] {
            return [
                .replication,
                .ttl,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .replication: return "REPLICATION"
            case .ttl: return "TTL"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesStreamsClientTypes {

    public enum ShardIteratorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterSequenceNumber
        case atSequenceNumber
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [ShardIteratorType] {
            return [
                .afterSequenceNumber,
                .atSequenceNumber,
                .latest,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
            case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetShardIteratorInput: Swift.Sendable {
    /// The sequence number of the data record in the shard from which to start reading. Required if ShardIteratorType is AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. This parameter is ignored for other iterator types.
    public var sequenceNumber: Swift.String?
    /// The identifier of the shard within the stream. The shard ID uniquely identifies a subset of the stream's data records that you want to access.
    /// This member is required.
    public var shardId: Swift.String?
    /// Determines how the shard iterator is positioned. Must be one of the following:
    ///
    /// * TRIM_HORIZON - Start reading at the last untrimmed record in the shard, which is the oldest data record in the shard.
    ///
    /// * AT_SEQUENCE_NUMBER - Start reading exactly from the specified sequence number.
    ///
    /// * AFTER_SEQUENCE_NUMBER - Start reading right after the specified sequence number.
    ///
    /// * LATEST - Start reading just after the most recent record in the shard, so that you always read the most recent data.
    /// This member is required.
    public var shardIteratorType: KeyspacesStreamsClientTypes.ShardIteratorType?
    /// The Amazon Resource Name (ARN) of the stream for which to get the shard iterator. The ARN uniquely identifies the stream within Amazon Keyspaces.
    /// This member is required.
    public var streamArn: Swift.String?

    public init(
        sequenceNumber: Swift.String? = nil,
        shardId: Swift.String? = nil,
        shardIteratorType: KeyspacesStreamsClientTypes.ShardIteratorType? = nil,
        streamArn: Swift.String? = nil
    ) {
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
        self.shardIteratorType = shardIteratorType
        self.streamArn = streamArn
    }
}

public struct GetShardIteratorOutput: Swift.Sendable {
    /// The unique identifier for the shard iterator. This value is used in the GetRecords operation to retrieve data records from the specified shard. Each shard iterator expires 5 minutes after it is returned to the requester.
    public var shardIterator: Swift.String?

    public init(
        shardIterator: Swift.String? = nil
    ) {
        self.shardIterator = shardIterator
    }
}

extension KeyspacesStreamsClientTypes {

    public enum ShardFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case childShards
        case sdkUnknown(Swift.String)

        public static var allCases: [ShardFilterType] {
            return [
                .childShards
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .childShards: return "CHILD_SHARDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesStreamsClientTypes {

    /// A filter used to limit the shards returned by a GetStream operation.
    public struct ShardFilter: Swift.Sendable {
        /// The identifier of a specific shard used to filter results based on the specified filter type.
        public var shardId: Swift.String?
        /// The type of shard filter to use, which determines how the shardId parameter is interpreted.
        public var type: KeyspacesStreamsClientTypes.ShardFilterType?

        public init(
            shardId: Swift.String? = nil,
            type: KeyspacesStreamsClientTypes.ShardFilterType? = nil
        ) {
            self.shardId = shardId
            self.type = type
        }
    }
}

public struct GetStreamInput: Swift.Sendable {
    /// The maximum number of shard objects to return in a single GetStream request. Default value is 100. The minimum value is 1 and the maximum value is 1000.
    public var maxResults: Swift.Int?
    /// An optional pagination token provided by a previous GetStream operation. If this parameter is specified, the response includes only records beyond the token, up to the value specified by maxResults.
    public var nextToken: Swift.String?
    /// Optional filter criteria to apply when retrieving shards. You can filter shards based on their state or other attributes to narrow down the results returned by the GetStream operation.
    public var shardFilter: KeyspacesStreamsClientTypes.ShardFilter?
    /// The Amazon Resource Name (ARN) of the stream for which detailed information is requested. This uniquely identifies the specific stream you want to get information about.
    /// This member is required.
    public var streamArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        shardFilter: KeyspacesStreamsClientTypes.ShardFilter? = nil,
        streamArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shardFilter = shardFilter
        self.streamArn = streamArn
    }
}

extension KeyspacesStreamsClientTypes {

    /// Defines a range of sequence numbers within a change data capture stream's shard for Amazon Keyspaces.
    public struct SequenceNumberRange: Swift.Sendable {
        /// The ending sequence number of the range, which may be null for open-ended ranges.
        public var endingSequenceNumber: Swift.String?
        /// The starting sequence number of the range.
        public var startingSequenceNumber: Swift.String?

        public init(
            endingSequenceNumber: Swift.String? = nil,
            startingSequenceNumber: Swift.String? = nil
        ) {
            self.endingSequenceNumber = endingSequenceNumber
            self.startingSequenceNumber = startingSequenceNumber
        }
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a uniquely identified group of change records within a change data capture stream for Amazon Keyspaces.
    public struct Shard: Swift.Sendable {
        /// The identifiers of parent shards that this shard evolved from, if this shard was created through resharding.
        public var parentShardIds: [Swift.String]?
        /// The range of sequence numbers contained within this shard.
        public var sequenceNumberRange: KeyspacesStreamsClientTypes.SequenceNumberRange?
        /// A unique identifier for this shard within the stream.
        public var shardId: Swift.String?

        public init(
            parentShardIds: [Swift.String]? = nil,
            sequenceNumberRange: KeyspacesStreamsClientTypes.SequenceNumberRange? = nil,
            shardId: Swift.String? = nil
        ) {
            self.parentShardIds = parentShardIds
            self.sequenceNumberRange = sequenceNumberRange
            self.shardId = shardId
        }
    }
}

extension KeyspacesStreamsClientTypes {

    public enum StreamStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesStreamsClientTypes {

    public enum StreamViewType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case keysOnly
        case newAndOldImages
        case newImage
        case oldImage
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamViewType] {
            return [
                .keysOnly,
                .newAndOldImages,
                .newImage,
                .oldImage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .keysOnly: return "KEYS_ONLY"
            case .newAndOldImages: return "NEW_AND_OLD_IMAGES"
            case .newImage: return "NEW_IMAGE"
            case .oldImage: return "OLD_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetStreamOutput: Swift.Sendable {
    /// The date and time when the request to create this stream was issued. The value is represented in ISO 8601 format.
    /// This member is required.
    public var creationRequestDateTime: Foundation.Date?
    /// The name of the keyspace containing the table associated with this stream. The keyspace name is part of the table's hierarchical identifier in Amazon Keyspaces.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// A pagination token that can be used in a subsequent GetStream request. This token is returned if the response contains more shards than can be returned in a single response.
    public var nextToken: Swift.String?
    /// An array of shard objects associated with this stream. Each shard contains a subset of the stream's data records and has its own unique identifier. The collection of shards represents the complete stream data.
    public var shards: [KeyspacesStreamsClientTypes.Shard]?
    /// The Amazon Resource Name (ARN) that uniquely identifies the stream within Amazon Keyspaces. This ARN can be used in other API operations to reference this specific stream.
    /// This member is required.
    public var streamArn: Swift.String?
    /// A timestamp that serves as a unique identifier for this stream, used for debugging and monitoring purposes. The stream label represents the point in time when the stream was created.
    /// This member is required.
    public var streamLabel: Swift.String?
    /// The current status of the stream. Values can be ENABLING, ENABLED, DISABLING, or DISABLED. Operations on the stream depend on its current status.
    /// This member is required.
    public var streamStatus: KeyspacesStreamsClientTypes.StreamStatus?
    /// The format of the data records in this stream. Currently, this can be one of the following options:
    ///
    /// * NEW_AND_OLD_IMAGES - both versions of the row, before and after the change. This is the default.
    ///
    /// * NEW_IMAGE - the version of the row after the change.
    ///
    /// * OLD_IMAGE - the version of the row before the change.
    ///
    /// * KEYS_ONLY - the partition and clustering keys of the row that was changed.
    /// This member is required.
    public var streamViewType: KeyspacesStreamsClientTypes.StreamViewType?
    /// The name of the table associated with this stream. The stream captures changes to rows in this Amazon Keyspaces table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        creationRequestDateTime: Foundation.Date? = nil,
        keyspaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        shards: [KeyspacesStreamsClientTypes.Shard]? = nil,
        streamArn: Swift.String? = nil,
        streamLabel: Swift.String? = nil,
        streamStatus: KeyspacesStreamsClientTypes.StreamStatus? = nil,
        streamViewType: KeyspacesStreamsClientTypes.StreamViewType? = nil,
        tableName: Swift.String? = nil
    ) {
        self.creationRequestDateTime = creationRequestDateTime
        self.keyspaceName = keyspaceName
        self.nextToken = nextToken
        self.shards = shards
        self.streamArn = streamArn
        self.streamLabel = streamLabel
        self.streamStatus = streamStatus
        self.streamViewType = streamViewType
        self.tableName = tableName
    }
}

public struct ListStreamsInput: Swift.Sendable {
    /// The name of the keyspace for which to list streams. If specified, only streams associated with tables in this keyspace are returned. If omitted, streams from all keyspaces are included in the results.
    public var keyspaceName: Swift.String?
    /// The maximum number of streams to return in a single ListStreams request. Default value is 100. The minimum value is 1 and the maximum value is 1000.
    public var maxResults: Swift.Int?
    /// An optional pagination token provided by a previous ListStreams operation. If this parameter is specified, the response includes only records beyond the token, up to the value specified by maxResults.
    public var nextToken: Swift.String?
    /// The name of the table for which to list streams. Must be used together with keyspaceName. If specified, only streams associated with this specific table are returned.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    ) {
        self.keyspaceName = keyspaceName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a change data capture stream for an Amazon Keyspaces table, which enables tracking and processing of data changes.
    public struct Stream: Swift.Sendable {
        /// The name of the keyspace containing the table associated with this stream.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies this stream.
        /// This member is required.
        public var streamArn: Swift.String?
        /// A unique identifier for this stream that can be used in stream operations.
        /// This member is required.
        public var streamLabel: Swift.String?
        /// The name of the table associated with this stream.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            keyspaceName: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamLabel: Swift.String? = nil,
            tableName: Swift.String? = nil
        ) {
            self.keyspaceName = keyspaceName
            self.streamArn = streamArn
            self.streamLabel = streamLabel
            self.tableName = tableName
        }
    }
}

public struct ListStreamsOutput: Swift.Sendable {
    /// A pagination token that can be used in a subsequent ListStreams request. This token is returned if the response contains more streams than can be returned in a single response based on the MaxResults parameter.
    public var nextToken: Swift.String?
    /// An array of stream objects, each containing summary information about a stream including its ARN, status, and associated table information. This list includes all streams that match the request criteria.
    public var streams: [KeyspacesStreamsClientTypes.Stream]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [KeyspacesStreamsClientTypes.Stream]? = nil
    ) {
        self.nextToken = nextToken
        self.streams = streams
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents the value of a cell in an Amazon Keyspaces table, supporting various data types with type-specific fields.
    public indirect enum KeyspacesCellValue: Swift.Sendable {
        /// A value of ASCII text type, containing US-ASCII characters.
        case asciit(Swift.String)
        /// A 64-bit signed integer value.
        case bigintt(Swift.String)
        /// A binary large object (BLOB) value stored as a Base64-encoded string.
        case blobt(Foundation.Data)
        /// A Boolean value, either true or false.
        case boolt(Swift.Bool)
        /// A distributed counter value that can be incremented and decremented.
        case countert(Swift.String)
        /// A date value without a time component, represented as days since epoch (January 1, 1970).
        case datet(Swift.String)
        /// A variable-precision decimal number value.
        case decimalt(Swift.String)
        /// A 64-bit double-precision floating point value.
        case doublet(Swift.String)
        /// A 32-bit single-precision floating point value.
        case floatt(Swift.String)
        /// An IP address value, either IPv4 or IPv6 format.
        case inett(Swift.String)
        /// A 32-bit signed integer value.
        case intt(Swift.String)
        /// An ordered collection of elements that can contain duplicate values.
        case listt([KeyspacesStreamsClientTypes.KeyspacesCell])
        /// A collection of key-value pairs where each key is unique.
        case mapt([KeyspacesStreamsClientTypes.KeyspacesCellMapDefinition])
        /// An unordered collection of unique elements.
        case sett([KeyspacesStreamsClientTypes.KeyspacesCell])
        /// A 16-bit signed integer value.
        case smallintt(Swift.String)
        /// A UTF-8 encoded string value.
        case textt(Swift.String)
        /// A time value without a date component, with nanosecond precision.
        case timet(Swift.String)
        /// A timestamp value representing date and time with millisecond precision.
        case timestampt(Swift.String)
        /// A universally unique identifier (UUID) that includes a timestamp component, ensuring both uniqueness and time ordering.
        case timeuuidt(Swift.String)
        /// An 8-bit signed integer value.
        case tinyintt(Swift.String)
        /// A fixed-length ordered list of elements, where each element can be of a different data type.
        case tuplet([KeyspacesStreamsClientTypes.KeyspacesCell])
        /// A universally unique identifier (UUID) value.
        case uuidt(Swift.String)
        /// A UTF-8 encoded string value, functionally equivalent to text type.
        case varchart(Swift.String)
        /// A variable precision integer value with arbitrary length.
        case varintt(Swift.String)
        /// A user-defined type (UDT) value consisting of named fields, each with its own data type.
        case udtt([Swift.String: KeyspacesStreamsClientTypes.KeyspacesCell])
        case sdkUnknown(Swift.String)
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a cell in an Amazon Keyspaces table, containing both the value and metadata about the cell.
    public struct KeyspacesCell: Swift.Sendable {
        /// Metadata associated with this cell, such as time-to-live (TTL) expiration time and write timestamp.
        public var metadata: KeyspacesStreamsClientTypes.KeyspacesMetadata?
        /// The value stored in this cell, which can be of various data types supported by Amazon Keyspaces.
        public var value: KeyspacesStreamsClientTypes.KeyspacesCellValue?

        public init(
            metadata: KeyspacesStreamsClientTypes.KeyspacesMetadata? = nil,
            value: KeyspacesStreamsClientTypes.KeyspacesCellValue? = nil
        ) {
            self.metadata = metadata
            self.value = value
        }
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a key-value pair within a map data type in Amazon Keyspaces, including the associated metadata.
    public struct KeyspacesCellMapDefinition: Swift.Sendable {
        /// The key of this map entry in the Amazon Keyspaces cell.
        public var key: KeyspacesStreamsClientTypes.KeyspacesCellValue?
        /// Metadata for this specific key-value pair within the map, such as timestamps and TTL information.
        public var metadata: KeyspacesStreamsClientTypes.KeyspacesMetadata?
        /// The value associated with the key in this map entry.
        public var value: KeyspacesStreamsClientTypes.KeyspacesCellValue?

        public init(
            key: KeyspacesStreamsClientTypes.KeyspacesCellValue? = nil,
            metadata: KeyspacesStreamsClientTypes.KeyspacesMetadata? = nil,
            value: KeyspacesStreamsClientTypes.KeyspacesCellValue? = nil
        ) {
            self.key = key
            self.metadata = metadata
            self.value = value
        }
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a row in an Amazon Keyspaces table, containing regular column values, static column values, and row-level metadata.
    public struct KeyspacesRow: Swift.Sendable {
        /// Metadata that applies to the entire row, such as timestamps and TTL information.
        public var rowMetadata: KeyspacesStreamsClientTypes.KeyspacesMetadata?
        /// A map of static column cells shared by all rows with the same partition key, where keys are column names and values are the corresponding cells.
        public var staticCells: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCell]?
        /// A map of regular (non-static) column cells in the row, where keys are column names and values are the corresponding cells.
        public var valueCells: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCell]?

        public init(
            rowMetadata: KeyspacesStreamsClientTypes.KeyspacesMetadata? = nil,
            staticCells: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCell]? = nil,
            valueCells: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCell]? = nil
        ) {
            self.rowMetadata = rowMetadata
            self.staticCells = staticCells
            self.valueCells = valueCells
        }
    }
}

extension KeyspacesStreamsClientTypes {

    /// Represents a change data capture record for a row in an Amazon Keyspaces table, containing both the new and old states of the row.
    public struct Record: Swift.Sendable {
        /// The clustering key columns and their values for the affected row, which determine the order of rows within a partition.
        public var clusteringKeys: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCellValue]?
        /// The timestamp indicating when this change data capture record was created.
        public var createdAt: Foundation.Date?
        /// The version of the record format, used to track the evolution of the record structure over time.
        public var eventVersion: Swift.String?
        /// The state of the row after the change operation that generated this record.
        public var newImage: KeyspacesStreamsClientTypes.KeyspacesRow?
        /// The state of the row before the change operation that generated this record.
        public var oldImage: KeyspacesStreamsClientTypes.KeyspacesRow?
        /// The origin or source of this change data capture record.
        public var origin: KeyspacesStreamsClientTypes.OriginType?
        /// The partition key columns and their values for the affected row.
        public var partitionKeys: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCellValue]?
        /// A unique identifier assigned to this record within the shard, used for ordering and tracking purposes.
        public var sequenceNumber: Swift.String?

        public init(
            clusteringKeys: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCellValue]? = nil,
            createdAt: Foundation.Date? = nil,
            eventVersion: Swift.String? = nil,
            newImage: KeyspacesStreamsClientTypes.KeyspacesRow? = nil,
            oldImage: KeyspacesStreamsClientTypes.KeyspacesRow? = nil,
            origin: KeyspacesStreamsClientTypes.OriginType? = nil,
            partitionKeys: [Swift.String: KeyspacesStreamsClientTypes.KeyspacesCellValue]? = nil,
            sequenceNumber: Swift.String? = nil
        ) {
            self.clusteringKeys = clusteringKeys
            self.createdAt = createdAt
            self.eventVersion = eventVersion
            self.newImage = newImage
            self.oldImage = oldImage
            self.origin = origin
            self.partitionKeys = partitionKeys
            self.sequenceNumber = sequenceNumber
        }
    }
}

public struct GetRecordsOutput: Swift.Sendable {
    /// An array of change data records retrieved from the specified shard. Each record represents a single data modification (insert, update, or delete) to a row in the Amazon Keyspaces table. Records include the primary key columns and information about what data was modified.
    public var changeRecords: [KeyspacesStreamsClientTypes.Record]?
    /// The next position in the shard from which to start sequentially reading data records. If null, the shard has been closed and the requested iterator doesn't return any more data.
    public var nextShardIterator: Swift.String?

    public init(
        changeRecords: [KeyspacesStreamsClientTypes.Record]? = nil,
        nextShardIterator: Swift.String? = nil
    ) {
        self.changeRecords = changeRecords
        self.nextShardIterator = nextShardIterator
    }
}

extension GetRecordsInput {

    static func urlPathProvider(_ value: GetRecordsInput) -> Swift.String? {
        return "/"
    }
}

extension GetShardIteratorInput {

    static func urlPathProvider(_ value: GetShardIteratorInput) -> Swift.String? {
        return "/"
    }
}

extension GetStreamInput {

    static func urlPathProvider(_ value: GetStreamInput) -> Swift.String? {
        return "/"
    }
}

extension ListStreamsInput {

    static func urlPathProvider(_ value: ListStreamsInput) -> Swift.String? {
        return "/"
    }
}

extension GetRecordsInput {

    static func write(value: GetRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["shardIterator"].write(value.shardIterator)
    }
}

extension GetShardIteratorInput {

    static func write(value: GetShardIteratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sequenceNumber"].write(value.sequenceNumber)
        try writer["shardId"].write(value.shardId)
        try writer["shardIteratorType"].write(value.shardIteratorType)
        try writer["streamArn"].write(value.streamArn)
    }
}

extension GetStreamInput {

    static func write(value: GetStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["shardFilter"].write(value.shardFilter, with: KeyspacesStreamsClientTypes.ShardFilter.write(value:to:))
        try writer["streamArn"].write(value.streamArn)
    }
}

extension ListStreamsInput {

    static func write(value: ListStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["tableName"].write(value.tableName)
    }
}

extension GetRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecordsOutput()
        value.changeRecords = try reader["changeRecords"].readListIfPresent(memberReadingClosure: KeyspacesStreamsClientTypes.Record.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextShardIterator = try reader["nextShardIterator"].readIfPresent()
        return value
    }
}

extension GetShardIteratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetShardIteratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetShardIteratorOutput()
        value.shardIterator = try reader["shardIterator"].readIfPresent()
        return value
    }
}

extension GetStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamOutput()
        value.creationRequestDateTime = try reader["creationRequestDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.shards = try reader["shards"].readListIfPresent(memberReadingClosure: KeyspacesStreamsClientTypes.Shard.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.streamArn = try reader["streamArn"].readIfPresent() ?? ""
        value.streamLabel = try reader["streamLabel"].readIfPresent() ?? ""
        value.streamStatus = try reader["streamStatus"].readIfPresent() ?? .sdkUnknown("")
        value.streamViewType = try reader["streamViewType"].readIfPresent() ?? .sdkUnknown("")
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        return value
    }
}

extension ListStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streams = try reader["streams"].readListIfPresent(memberReadingClosure: KeyspacesStreamsClientTypes.Stream.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum GetRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetShardIteratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KeyspacesStreamsClientTypes.Record {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.Record {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.Record()
        value.eventVersion = try reader["eventVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.origin = try reader["origin"].readIfPresent()
        value.partitionKeys = try reader["partitionKeys"].readMapIfPresent(valueReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCellValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.clusteringKeys = try reader["clusteringKeys"].readMapIfPresent(valueReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCellValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.newImage = try reader["newImage"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesRow.read(from:))
        value.oldImage = try reader["oldImage"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesRow.read(from:))
        value.sequenceNumber = try reader["sequenceNumber"].readIfPresent()
        return value
    }
}

extension KeyspacesStreamsClientTypes.KeyspacesRow {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.KeyspacesRow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.KeyspacesRow()
        value.valueCells = try reader["valueCells"].readMapIfPresent(valueReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.staticCells = try reader["staticCells"].readMapIfPresent(valueReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.rowMetadata = try reader["rowMetadata"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesMetadata.read(from:))
        return value
    }
}

extension KeyspacesStreamsClientTypes.KeyspacesMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.KeyspacesMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.KeyspacesMetadata()
        value.expirationTime = try reader["expirationTime"].readIfPresent()
        value.writeTime = try reader["writeTime"].readIfPresent()
        return value
    }
}

extension KeyspacesStreamsClientTypes.KeyspacesCell {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.KeyspacesCell {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.KeyspacesCell()
        value.value = try reader["value"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesCellValue.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesMetadata.read(from:))
        return value
    }
}

extension KeyspacesStreamsClientTypes.KeyspacesCellValue {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.KeyspacesCellValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "asciiT":
                return .asciit(try reader["asciiT"].read())
            case "bigintT":
                return .bigintt(try reader["bigintT"].read())
            case "blobT":
                return .blobt(try reader["blobT"].read())
            case "boolT":
                return .boolt(try reader["boolT"].read())
            case "counterT":
                return .countert(try reader["counterT"].read())
            case "dateT":
                return .datet(try reader["dateT"].read())
            case "decimalT":
                return .decimalt(try reader["decimalT"].read())
            case "doubleT":
                return .doublet(try reader["doubleT"].read())
            case "floatT":
                return .floatt(try reader["floatT"].read())
            case "inetT":
                return .inett(try reader["inetT"].read())
            case "intT":
                return .intt(try reader["intT"].read())
            case "listT":
                return .listt(try reader["listT"].readList(memberReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "mapT":
                return .mapt(try reader["mapT"].readList(memberReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCellMapDefinition.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "setT":
                return .sett(try reader["setT"].readList(memberReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "smallintT":
                return .smallintt(try reader["smallintT"].read())
            case "textT":
                return .textt(try reader["textT"].read())
            case "timeT":
                return .timet(try reader["timeT"].read())
            case "timestampT":
                return .timestampt(try reader["timestampT"].read())
            case "timeuuidT":
                return .timeuuidt(try reader["timeuuidT"].read())
            case "tinyintT":
                return .tinyintt(try reader["tinyintT"].read())
            case "tupleT":
                return .tuplet(try reader["tupleT"].readList(memberReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "uuidT":
                return .uuidt(try reader["uuidT"].read())
            case "varcharT":
                return .varchart(try reader["varcharT"].read())
            case "varintT":
                return .varintt(try reader["varintT"].read())
            case "udtT":
                return .udtt(try reader["udtT"].readMap(valueReadingClosure: KeyspacesStreamsClientTypes.KeyspacesCell.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension KeyspacesStreamsClientTypes.KeyspacesCellMapDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.KeyspacesCellMapDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.KeyspacesCellMapDefinition()
        value.key = try reader["key"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesCellValue.read(from:))
        value.value = try reader["value"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesCellValue.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: KeyspacesStreamsClientTypes.KeyspacesMetadata.read(from:))
        return value
    }
}

extension KeyspacesStreamsClientTypes.Shard {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.Shard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.Shard()
        value.shardId = try reader["shardId"].readIfPresent()
        value.sequenceNumberRange = try reader["sequenceNumberRange"].readIfPresent(with: KeyspacesStreamsClientTypes.SequenceNumberRange.read(from:))
        value.parentShardIds = try reader["parentShardIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KeyspacesStreamsClientTypes.SequenceNumberRange {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.SequenceNumberRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.SequenceNumberRange()
        value.startingSequenceNumber = try reader["startingSequenceNumber"].readIfPresent()
        value.endingSequenceNumber = try reader["endingSequenceNumber"].readIfPresent()
        return value
    }
}

extension KeyspacesStreamsClientTypes.Stream {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesStreamsClientTypes.Stream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesStreamsClientTypes.Stream()
        value.streamArn = try reader["streamArn"].readIfPresent() ?? ""
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.streamLabel = try reader["streamLabel"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesStreamsClientTypes.ShardFilter {

    static func write(value: KeyspacesStreamsClientTypes.ShardFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["shardId"].write(value.shardId)
        try writer["type"].write(value.type)
    }
}

public enum KeyspacesStreamsClientTypes {}
