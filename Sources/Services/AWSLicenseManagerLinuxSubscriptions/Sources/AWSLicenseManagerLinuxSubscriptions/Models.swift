// Code generated by smithy-swift-codegen. DO NOT EDIT!

import class SmithyHTTPAPI.HttpResponse
import class SmithyJSON.Reader
import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
import enum SmithyReadWrite.ReadingClosures
import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Contains operator
        case contains
        /// Equal operator
        case equal
        /// Not equal operator
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .contains,
                .equal,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// A filter object that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct Filter {
        /// The type of name to filter by.
        public var name: Swift.String?
        /// An operator for filtering results.
        public var `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator?
        /// One or more values for the name to filter by.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetServiceSettingsInput {

    public init() { }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum LinuxSubscriptionsDiscovery: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Disabled LinuxSubscriptionsDiscovery
        case disabled
        /// Enabled LinuxSubscriptionsDiscovery
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LinuxSubscriptionsDiscovery] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum OrganizationIntegration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Disabled OrganizationIntegration
        case disabled
        /// Enabled OrganizationIntegration
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationIntegration] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Lists the settings defined for discovering Linux subscriptions.
    public struct LinuxSubscriptionsDiscoverySettings {
        /// Details if you have enabled resource discovery across your accounts in Organizations.
        /// This member is required.
        public var organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration?
        /// The Regions in which to discover data for Linux subscriptions.
        /// This member is required.
        public var sourceRegions: [Swift.String]?

        public init(
            organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration? = nil,
            sourceRegions: [Swift.String]? = nil
        )
        {
            self.organizationIntegration = organizationIntegration
            self.sourceRegions = sourceRegions
        }
    }

}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Completed status
        case completed
        /// Failed status
        case failed
        /// InProgress status
        case inprogress
        /// Successful status
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetServiceSettingsOutput {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// Lists the settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String: Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String: Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Details discovered information about a running instance using Linux subscriptions.
    public struct Instance {
        /// The account ID which owns the instance.
        public var accountID: Swift.String?
        /// The AMI ID used to launch the instance.
        public var amiId: Swift.String?
        /// The instance ID of the resource.
        public var instanceID: Swift.String?
        /// The instance type of the resource.
        public var instanceType: Swift.String?
        /// The time in which the last discovery updated the instance details.
        public var lastUpdatedTime: Swift.String?
        /// The product code for the instance. For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide .
        public var productCode: [Swift.String]?
        /// The Region the instance is running in.
        public var region: Swift.String?
        /// The status of the instance.
        public var status: Swift.String?
        /// The name of the subscription being used by the instance.
        public var subscriptionName: Swift.String?
        /// The usage operation of the instance. For more information, see For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide.
        public var usageOperation: Swift.String?

        public init(
            accountID: Swift.String? = nil,
            amiId: Swift.String? = nil,
            instanceID: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            productCode: [Swift.String]? = nil,
            region: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            usageOperation: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.amiId = amiId
            self.instanceID = instanceID
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.productCode = productCode
            self.region = region
            self.status = status
            self.subscriptionName = subscriptionName
            self.usageOperation = usageOperation
        }
    }

}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionInstancesInput {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of AmiID with an optional operator to see subscriptions that match, partially match, or don't match a certain Amazon Machine Image (AMI) ID. The valid names for this filter are:
    ///
    /// * AmiID
    ///
    /// * InstanceID
    ///
    /// * AccountID
    ///
    /// * Status
    ///
    /// * Region
    ///
    /// * UsageOperation
    ///
    /// * ProductCode
    ///
    /// * InstanceType
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLinuxSubscriptionInstancesOutput {
    /// An array that contains instance objects.
    public var instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionsInput {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of Subscription with an optional operator to see subscriptions that match, partially match, or don't match a certain subscription's name. The valid names for this filter are:
    ///
    /// * Subscription
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// An object which details a discovered Linux subscription.
    public struct Subscription {
        /// The total amount of running instances using this subscription.
        public var instanceCount: Swift.Int?
        /// The name of the subscription.
        public var name: Swift.String?
        /// The type of subscription. The type can be subscription-included with Amazon EC2, Bring Your Own Subscription model (BYOS), or from the Amazon Web Services Marketplace. Certain subscriptions may use licensing from the Amazon Web Services Marketplace as well as OS licensing from Amazon EC2 or BYOS.
        public var type: Swift.String?

        public init(
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

public struct ListLinuxSubscriptionsOutput {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// An array that contains subscription objects.
    public var subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

public struct UpdateServiceSettingsInput {
    /// Describes if updates are allowed to the service settings for Linux subscriptions. If you allow updates, you can aggregate Linux subscription data in more than one home Region.
    public var allowUpdate: Swift.Bool?
    /// Describes if the discovery of Linux subscriptions is enabled.
    /// This member is required.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    /// This member is required.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?

    public init(
        allowUpdate: Swift.Bool? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil
    )
    {
        self.allowUpdate = allowUpdate
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
    }
}

public struct UpdateServiceSettingsOutput {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String: Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String: Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension GetServiceSettingsInput {

    static func urlPathProvider(_ value: GetServiceSettingsInput) -> Swift.String? {
        return "/subscription/GetServiceSettings"
    }
}

extension ListLinuxSubscriptionInstancesInput {

    static func urlPathProvider(_ value: ListLinuxSubscriptionInstancesInput) -> Swift.String? {
        return "/subscription/ListLinuxSubscriptionInstances"
    }
}

extension ListLinuxSubscriptionsInput {

    static func urlPathProvider(_ value: ListLinuxSubscriptionsInput) -> Swift.String? {
        return "/subscription/ListLinuxSubscriptions"
    }
}

extension UpdateServiceSettingsInput {

    static func urlPathProvider(_ value: UpdateServiceSettingsInput) -> Swift.String? {
        return "/subscription/UpdateServiceSettings"
    }
}

extension ListLinuxSubscriptionInstancesInput {

    static func write(value: ListLinuxSubscriptionInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLinuxSubscriptionsInput {

    static func write(value: ListLinuxSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension UpdateServiceSettingsInput {

    static func write(value: UpdateServiceSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowUpdate"].write(value.allowUpdate)
        try writer["LinuxSubscriptionsDiscovery"].write(value.linuxSubscriptionsDiscovery)
        try writer["LinuxSubscriptionsDiscoverySettings"].write(value.linuxSubscriptionsDiscoverySettings, with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.write(value:to:))
    }
}

extension GetServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> GetServiceSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceSettingsOutput()
        value.homeRegions = try reader["HomeRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linuxSubscriptionsDiscovery = try reader["LinuxSubscriptionsDiscovery"].readIfPresent()
        value.linuxSubscriptionsDiscoverySettings = try reader["LinuxSubscriptionsDiscoverySettings"].readIfPresent(with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListLinuxSubscriptionInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListLinuxSubscriptionInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinuxSubscriptionInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLinuxSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListLinuxSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinuxSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateServiceSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceSettingsOutput()
        value.homeRegions = try reader["HomeRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linuxSubscriptionsDiscovery = try reader["LinuxSubscriptionsDiscovery"].readIfPresent()
        value.linuxSubscriptionsDiscoverySettings = try reader["LinuxSubscriptionsDiscoverySettings"].readIfPresent(with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

enum GetServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinuxSubscriptionInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinuxSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings {

    static func write(value: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationIntegration"].write(value.organizationIntegration)
        try writer["SourceRegions"].writeList(value.sourceRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings()
        value.sourceRegions = try reader["SourceRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationIntegration = try reader["OrganizationIntegration"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.Instance()
        value.amiId = try reader["AmiId"].readIfPresent()
        value.instanceID = try reader["InstanceID"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.accountID = try reader["AccountID"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.usageOperation = try reader["UsageOperation"].readIfPresent()
        value.productCode = try reader["ProductCode"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readIfPresent()
        value.subscriptionName = try reader["SubscriptionName"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Subscription {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.Subscription()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Filter {

    static func write(value: LicenseManagerLinuxSubscriptionsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum LicenseManagerLinuxSubscriptionsClientTypes {}
