//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unable to find the requested Amazon Web Services resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterSubscriptionProviderInput {
    /// The Amazon Resource Name (ARN) of the subscription provider resource to deregister.
    /// This member is required.
    public var subscriptionProviderArn: Swift.String?

    public init(
        subscriptionProviderArn: Swift.String? = nil
    )
    {
        self.subscriptionProviderArn = subscriptionProviderArn
    }
}

public struct DeregisterSubscriptionProviderOutput {

    public init() { }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Contains operator
        case contains
        /// Equal operator
        case equal
        /// Not equal operator
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .contains,
                .equal,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// A filter object that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct Filter {
        /// The type of name to filter by.
        public var name: Swift.String?
        /// An operator for filtering results.
        public var `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator?
        /// One or more values for the name to filter by.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

public struct GetRegisteredSubscriptionProviderInput {
    /// The Amazon Resource Name (ARN) of the BYOL registration resource to get details for.
    /// This member is required.
    public var subscriptionProviderArn: Swift.String?

    public init(
        subscriptionProviderArn: Swift.String? = nil
    )
    {
        self.subscriptionProviderArn = subscriptionProviderArn
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum SubscriptionProviderSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// RedHat subscription provider namespace
        case redhat
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProviderSource] {
            return [
                .redhat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .redhat: return "RedHat"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum SubscriptionProviderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ACTIVE status
        case active
        /// INVALID status
        case invalid
        /// PENDING status
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProviderStatus] {
            return [
                .active,
                .invalid,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invalid: return "INVALID"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetRegisteredSubscriptionProviderOutput {
    /// The timestamp from the last time License Manager retrieved subscription details from your registered third-party Linux subscription provider.
    public var lastSuccessfulDataRetrievalTime: Swift.String?
    /// The Amazon Resource Name (ARN) of the third-party access secret stored in Secrets Manager for the BYOL registration resource specified in the request.
    public var secretArn: Swift.String?
    /// The Amazon Resource Name (ARN) for the BYOL registration resource specified in the request.
    public var subscriptionProviderArn: Swift.String?
    /// The subscription provider for the BYOL registration resource specified in the request.
    public var subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource?
    /// The status of the Linux subscription provider access token from the last successful subscription data request.
    public var subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus?
    /// The detailed message from your subscription provider token status.
    public var subscriptionProviderStatusMessage: Swift.String?

    public init(
        lastSuccessfulDataRetrievalTime: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        subscriptionProviderArn: Swift.String? = nil,
        subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource? = nil,
        subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus? = nil,
        subscriptionProviderStatusMessage: Swift.String? = nil
    )
    {
        self.lastSuccessfulDataRetrievalTime = lastSuccessfulDataRetrievalTime
        self.secretArn = secretArn
        self.subscriptionProviderArn = subscriptionProviderArn
        self.subscriptionProviderSource = subscriptionProviderSource
        self.subscriptionProviderStatus = subscriptionProviderStatus
        self.subscriptionProviderStatusMessage = subscriptionProviderStatusMessage
    }
}

public struct GetServiceSettingsInput {

    public init() { }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum LinuxSubscriptionsDiscovery: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Disabled LinuxSubscriptionsDiscovery
        case disabled
        /// Enabled LinuxSubscriptionsDiscovery
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LinuxSubscriptionsDiscovery] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum OrganizationIntegration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Disabled OrganizationIntegration
        case disabled
        /// Enabled OrganizationIntegration
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationIntegration] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Lists the settings defined for discovering Linux subscriptions.
    public struct LinuxSubscriptionsDiscoverySettings {
        /// Details if you have enabled resource discovery across your accounts in Organizations.
        /// This member is required.
        public var organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration?
        /// The Regions in which to discover data for Linux subscriptions.
        /// This member is required.
        public var sourceRegions: [Swift.String]?

        public init(
            organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration? = nil,
            sourceRegions: [Swift.String]? = nil
        )
        {
            self.organizationIntegration = organizationIntegration
            self.sourceRegions = sourceRegions
        }
    }

}

extension LicenseManagerLinuxSubscriptionsClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Completed status
        case completed
        /// Failed status
        case failed
        /// InProgress status
        case inprogress
        /// Successful status
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetServiceSettingsOutput {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// Lists the settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String: Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String: Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Details discovered information about a running instance using Linux subscriptions.
    public struct Instance {
        /// The account ID which owns the instance.
        public var accountID: Swift.String?
        /// The AMI ID used to launch the instance.
        public var amiId: Swift.String?
        /// Indicates that you have two different license subscriptions for the same software on your instance.
        public var dualSubscription: Swift.String?
        /// The instance ID of the resource.
        public var instanceID: Swift.String?
        /// The instance type of the resource.
        public var instanceType: Swift.String?
        /// The time in which the last discovery updated the instance details.
        public var lastUpdatedTime: Swift.String?
        /// The operating system software version that runs on your instance.
        public var osVersion: Swift.String?
        /// The product code for the instance. For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide .
        public var productCode: [Swift.String]?
        /// The Region the instance is running in.
        public var region: Swift.String?
        /// Indicates that your instance uses a BYOL license subscription from a third-party Linux subscription provider that you've registered with License Manager.
        public var registeredWithSubscriptionProvider: Swift.String?
        /// The status of the instance.
        public var status: Swift.String?
        /// The name of the license subscription that the instance uses.
        public var subscriptionName: Swift.String?
        /// The timestamp when you registered the third-party Linux subscription provider for the subscription that the instance uses.
        public var subscriptionProviderCreateTime: Swift.String?
        /// The timestamp from the last time that the instance synced with the registered third-party Linux subscription provider.
        public var subscriptionProviderUpdateTime: Swift.String?
        /// The usage operation of the instance. For more information, see For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide.
        public var usageOperation: Swift.String?

        public init(
            accountID: Swift.String? = nil,
            amiId: Swift.String? = nil,
            dualSubscription: Swift.String? = nil,
            instanceID: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            productCode: [Swift.String]? = nil,
            region: Swift.String? = nil,
            registeredWithSubscriptionProvider: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            subscriptionProviderCreateTime: Swift.String? = nil,
            subscriptionProviderUpdateTime: Swift.String? = nil,
            usageOperation: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.amiId = amiId
            self.dualSubscription = dualSubscription
            self.instanceID = instanceID
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.osVersion = osVersion
            self.productCode = productCode
            self.region = region
            self.registeredWithSubscriptionProvider = registeredWithSubscriptionProvider
            self.status = status
            self.subscriptionName = subscriptionName
            self.subscriptionProviderCreateTime = subscriptionProviderCreateTime
            self.subscriptionProviderUpdateTime = subscriptionProviderUpdateTime
            self.usageOperation = usageOperation
        }
    }

}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionInstancesInput {
    /// An array of structures that you can use to filter the results by your specified criteria. For example, you can specify Region in the Name, with the contains operator to list all subscriptions that match a partial string in the Value, such as us-west. For each filter, you can specify one of the following values for the Name key to streamline results:
    ///
    /// * AccountID
    ///
    /// * AmiID
    ///
    /// * DualSubscription
    ///
    /// * InstanceID
    ///
    /// * InstanceType
    ///
    /// * ProductCode
    ///
    /// * Region
    ///
    /// * Status
    ///
    /// * UsageOperation
    ///
    ///
    /// For each filter, you can use one of the following Operator values to define the behavior of the filter:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLinuxSubscriptionInstancesOutput {
    /// An array that contains instance objects.
    public var instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionsInput {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of Subscription with an optional operator to see subscriptions that match, partially match, or don't match a certain subscription's name. The valid names for this filter are:
    ///
    /// * Subscription
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// An object which details a discovered Linux subscription.
    public struct Subscription {
        /// The total amount of running instances using this subscription.
        public var instanceCount: Swift.Int?
        /// The name of the subscription.
        public var name: Swift.String?
        /// The type of subscription. The type can be subscription-included with Amazon EC2, Bring Your Own Subscription model (BYOS), or from the Amazon Web Services Marketplace. Certain subscriptions may use licensing from the Amazon Web Services Marketplace as well as OS licensing from Amazon EC2 or BYOS.
        public var type: Swift.String?

        public init(
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

public struct ListLinuxSubscriptionsOutput {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// An array that contains subscription objects.
    public var subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

public struct ListRegisteredSubscriptionProvidersInput {
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// To filter your results, specify which subscription providers to return in the list.
    public var subscriptionProviderSources: [LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subscriptionProviderSources: [LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionProviderSources = subscriptionProviderSources
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// A third-party provider for operating system (OS) platform software and license subscriptions, such as Red Hat. When you register a third-party Linux subscription provider, License Manager can get subscription data from the registered provider.
    public struct RegisteredSubscriptionProvider {
        /// The timestamp from the last time that License Manager accessed third-party subscription data for your account from your registered Linux subscription provider.
        public var lastSuccessfulDataRetrievalTime: Swift.String?
        /// The Amazon Resource Name (ARN) of the Secrets Manager secret that stores your registered Linux subscription provider access token. For RHEL account subscriptions, this is the offline token.
        public var secretArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Linux subscription provider resource that you registered.
        public var subscriptionProviderArn: Swift.String?
        /// A supported third-party Linux subscription provider. License Manager currently supports Red Hat subscriptions.
        public var subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource?
        /// Indicates the status of your registered Linux subscription provider access token from the last time License Manager retrieved subscription data. For RHEL account subscriptions, this is the status of the offline token.
        public var subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus?
        /// A detailed message that's associated with your BYOL subscription provider token status.
        public var subscriptionProviderStatusMessage: Swift.String?

        public init(
            lastSuccessfulDataRetrievalTime: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            subscriptionProviderArn: Swift.String? = nil,
            subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource? = nil,
            subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus? = nil,
            subscriptionProviderStatusMessage: Swift.String? = nil
        )
        {
            self.lastSuccessfulDataRetrievalTime = lastSuccessfulDataRetrievalTime
            self.secretArn = secretArn
            self.subscriptionProviderArn = subscriptionProviderArn
            self.subscriptionProviderSource = subscriptionProviderSource
            self.subscriptionProviderStatus = subscriptionProviderStatus
            self.subscriptionProviderStatusMessage = subscriptionProviderStatusMessage
        }
    }

}

public struct ListRegisteredSubscriptionProvidersOutput {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The list of BYOL registration resources that fit the criteria you specified in the request.
    public var registeredSubscriptionProviders: [LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider]?

    public init(
        nextToken: Swift.String? = nil,
        registeredSubscriptionProviders: [LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider]? = nil
    )
    {
        self.nextToken = nextToken
        self.registeredSubscriptionProviders = registeredSubscriptionProviders
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which to list metadata tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The metadata tags for the requested resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct RegisterSubscriptionProviderInput {
    /// The Amazon Resource Name (ARN) of the secret where you've stored your subscription provider's access token. For RHEL subscriptions managed through the Red Hat Subscription Manager (RHSM), the secret contains your Red Hat Offline token.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The supported Linux subscription provider to register.
    /// This member is required.
    public var subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource?
    /// The metadata tags to assign to your registered Linux subscription provider resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        secretArn: Swift.String? = nil,
        subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.secretArn = secretArn
        self.subscriptionProviderSource = subscriptionProviderSource
        self.tags = tags
    }
}

extension RegisterSubscriptionProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterSubscriptionProviderInput(secretArn: \(Swift.String(describing: secretArn)), subscriptionProviderSource: \(Swift.String(describing: subscriptionProviderSource)), tags: \"CONTENT_REDACTED\")"}
}

public struct RegisterSubscriptionProviderOutput {
    /// The Amazon Resource Name (ARN) of the Linux subscription provider resource that you registered.
    public var subscriptionProviderArn: Swift.String?
    /// The Linux subscription provider that you registered.
    public var subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource?
    /// Indicates the status of the registration action for the Linux subscription provider that you requested.
    public var subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus?

    public init(
        subscriptionProviderArn: Swift.String? = nil,
        subscriptionProviderSource: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource? = nil,
        subscriptionProviderStatus: LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderStatus? = nil
    )
    {
        self.subscriptionProviderArn = subscriptionProviderArn
        self.subscriptionProviderSource = subscriptionProviderSource
        self.subscriptionProviderStatus = subscriptionProviderStatus
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the Amazon Web Services resource to which to add the specified metadata tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The metadata tags to assign to the Amazon Web Services resource. Tags are formatted as key value pairs.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the Amazon Web Services resource to remove the metadata tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of metadata tag keys to remove from the requested resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateServiceSettingsInput {
    /// Describes if updates are allowed to the service settings for Linux subscriptions. If you allow updates, you can aggregate Linux subscription data in more than one home Region.
    public var allowUpdate: Swift.Bool?
    /// Describes if the discovery of Linux subscriptions is enabled.
    /// This member is required.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    /// This member is required.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?

    public init(
        allowUpdate: Swift.Bool? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil
    )
    {
        self.allowUpdate = allowUpdate
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
    }
}

public struct UpdateServiceSettingsOutput {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String: Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String: Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension DeregisterSubscriptionProviderInput {

    static func urlPathProvider(_ value: DeregisterSubscriptionProviderInput) -> Swift.String? {
        return "/subscription/DeregisterSubscriptionProvider"
    }
}

extension GetRegisteredSubscriptionProviderInput {

    static func urlPathProvider(_ value: GetRegisteredSubscriptionProviderInput) -> Swift.String? {
        return "/subscription/GetRegisteredSubscriptionProvider"
    }
}

extension GetServiceSettingsInput {

    static func urlPathProvider(_ value: GetServiceSettingsInput) -> Swift.String? {
        return "/subscription/GetServiceSettings"
    }
}

extension ListLinuxSubscriptionInstancesInput {

    static func urlPathProvider(_ value: ListLinuxSubscriptionInstancesInput) -> Swift.String? {
        return "/subscription/ListLinuxSubscriptionInstances"
    }
}

extension ListLinuxSubscriptionsInput {

    static func urlPathProvider(_ value: ListLinuxSubscriptionsInput) -> Swift.String? {
        return "/subscription/ListLinuxSubscriptions"
    }
}

extension ListRegisteredSubscriptionProvidersInput {

    static func urlPathProvider(_ value: ListRegisteredSubscriptionProvidersInput) -> Swift.String? {
        return "/subscription/ListRegisteredSubscriptionProviders"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterSubscriptionProviderInput {

    static func urlPathProvider(_ value: RegisterSubscriptionProviderInput) -> Swift.String? {
        return "/subscription/RegisterSubscriptionProvider"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateServiceSettingsInput {

    static func urlPathProvider(_ value: UpdateServiceSettingsInput) -> Swift.String? {
        return "/subscription/UpdateServiceSettings"
    }
}

extension DeregisterSubscriptionProviderInput {

    static func write(value: DeregisterSubscriptionProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionProviderArn"].write(value.subscriptionProviderArn)
    }
}

extension GetRegisteredSubscriptionProviderInput {

    static func write(value: GetRegisteredSubscriptionProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionProviderArn"].write(value.subscriptionProviderArn)
    }
}

extension ListLinuxSubscriptionInstancesInput {

    static func write(value: ListLinuxSubscriptionInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLinuxSubscriptionsInput {

    static func write(value: ListLinuxSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListRegisteredSubscriptionProvidersInput {

    static func write(value: ListRegisteredSubscriptionProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubscriptionProviderSources"].writeList(value.subscriptionProviderSources, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LicenseManagerLinuxSubscriptionsClientTypes.SubscriptionProviderSource>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RegisterSubscriptionProviderInput {

    static func write(value: RegisterSubscriptionProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecretArn"].write(value.secretArn)
        try writer["SubscriptionProviderSource"].write(value.subscriptionProviderSource)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateServiceSettingsInput {

    static func write(value: UpdateServiceSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowUpdate"].write(value.allowUpdate)
        try writer["LinuxSubscriptionsDiscovery"].write(value.linuxSubscriptionsDiscovery)
        try writer["LinuxSubscriptionsDiscoverySettings"].write(value.linuxSubscriptionsDiscoverySettings, with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.write(value:to:))
    }
}

extension DeregisterSubscriptionProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterSubscriptionProviderOutput {
        return DeregisterSubscriptionProviderOutput()
    }
}

extension GetRegisteredSubscriptionProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRegisteredSubscriptionProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRegisteredSubscriptionProviderOutput()
        value.lastSuccessfulDataRetrievalTime = try reader["LastSuccessfulDataRetrievalTime"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.subscriptionProviderArn = try reader["SubscriptionProviderArn"].readIfPresent()
        value.subscriptionProviderSource = try reader["SubscriptionProviderSource"].readIfPresent()
        value.subscriptionProviderStatus = try reader["SubscriptionProviderStatus"].readIfPresent()
        value.subscriptionProviderStatusMessage = try reader["SubscriptionProviderStatusMessage"].readIfPresent()
        return value
    }
}

extension GetServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceSettingsOutput()
        value.homeRegions = try reader["HomeRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linuxSubscriptionsDiscovery = try reader["LinuxSubscriptionsDiscovery"].readIfPresent()
        value.linuxSubscriptionsDiscoverySettings = try reader["LinuxSubscriptionsDiscoverySettings"].readIfPresent(with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListLinuxSubscriptionInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLinuxSubscriptionInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinuxSubscriptionInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLinuxSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLinuxSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinuxSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: LicenseManagerLinuxSubscriptionsClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRegisteredSubscriptionProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegisteredSubscriptionProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegisteredSubscriptionProvidersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registeredSubscriptionProviders = try reader["RegisteredSubscriptionProviders"].readListIfPresent(memberReadingClosure: LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RegisterSubscriptionProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterSubscriptionProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterSubscriptionProviderOutput()
        value.subscriptionProviderArn = try reader["SubscriptionProviderArn"].readIfPresent()
        value.subscriptionProviderSource = try reader["SubscriptionProviderSource"].readIfPresent()
        value.subscriptionProviderStatus = try reader["SubscriptionProviderStatus"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceSettingsOutput()
        value.homeRegions = try reader["HomeRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linuxSubscriptionsDiscovery = try reader["LinuxSubscriptionsDiscovery"].readIfPresent()
        value.linuxSubscriptionsDiscoverySettings = try reader["LinuxSubscriptionsDiscoverySettings"].readIfPresent(with: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

enum DeregisterSubscriptionProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRegisteredSubscriptionProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinuxSubscriptionInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinuxSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegisteredSubscriptionProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterSubscriptionProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings {

    static func write(value: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationIntegration"].write(value.organizationIntegration)
        try writer["SourceRegions"].writeList(value.sourceRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings()
        value.sourceRegions = try reader["SourceRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.organizationIntegration = try reader["OrganizationIntegration"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.Instance()
        value.amiId = try reader["AmiId"].readIfPresent()
        value.instanceID = try reader["InstanceID"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.accountID = try reader["AccountID"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.usageOperation = try reader["UsageOperation"].readIfPresent()
        value.productCode = try reader["ProductCode"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readIfPresent()
        value.subscriptionName = try reader["SubscriptionName"].readIfPresent()
        value.osVersion = try reader["OsVersion"].readIfPresent()
        value.subscriptionProviderCreateTime = try reader["SubscriptionProviderCreateTime"].readIfPresent()
        value.subscriptionProviderUpdateTime = try reader["SubscriptionProviderUpdateTime"].readIfPresent()
        value.dualSubscription = try reader["DualSubscription"].readIfPresent()
        value.registeredWithSubscriptionProvider = try reader["RegisteredWithSubscriptionProvider"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Subscription {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.Subscription()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerLinuxSubscriptionsClientTypes.RegisteredSubscriptionProvider()
        value.subscriptionProviderArn = try reader["SubscriptionProviderArn"].readIfPresent()
        value.subscriptionProviderSource = try reader["SubscriptionProviderSource"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.subscriptionProviderStatus = try reader["SubscriptionProviderStatus"].readIfPresent()
        value.subscriptionProviderStatusMessage = try reader["SubscriptionProviderStatusMessage"].readIfPresent()
        value.lastSuccessfulDataRetrievalTime = try reader["LastSuccessfulDataRetrievalTime"].readIfPresent()
        return value
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Filter {

    static func write(value: LicenseManagerLinuxSubscriptionsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum LicenseManagerLinuxSubscriptionsClientTypes {}
