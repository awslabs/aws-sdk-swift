// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LicenseManagerLinuxSubscriptionsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// A filter object that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct Filter: Swift.Equatable {
        /// The type of name to filter by.
        public var name: Swift.String?
        /// An operator for filtering results.
        public var `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator?
        /// One or more values for the name to filter by.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension GetServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/GetServiceSettings"
    }
}

public struct GetServiceSettingsInput: Swift.Equatable {

    public init () { }
}

struct GetServiceSettingsInputBody: Swift.Equatable {
}

extension GetServiceSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.homeRegions = output.homeRegions
            self.linuxSubscriptionsDiscovery = output.linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = output.linuxSubscriptionsDiscoverySettings
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.homeRegions = nil
            self.linuxSubscriptionsDiscovery = nil
            self.linuxSubscriptionsDiscoverySettings = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetServiceSettingsOutputResponse: Swift.Equatable {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// Lists the settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String:Swift.String]?

    public init (
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String:Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetServiceSettingsOutputResponseBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    let statusMessage: [Swift.String:Swift.String]?
    let homeRegions: [Swift.String]?
}

extension GetServiceSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegions = "HomeRegions"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .statusMessage)
        var statusMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let statusMessageContainer = statusMessageContainer {
            statusMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in statusMessageContainer {
                if let string0 = string0 {
                    statusMessageDecoded0?[key0] = string0
                }
            }
        }
        statusMessage = statusMessageDecoded0
        let homeRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .homeRegions)
        var homeRegionsDecoded0:[Swift.String]? = nil
        if let homeRegionsContainer = homeRegionsContainer {
            homeRegionsDecoded0 = [Swift.String]()
            for string0 in homeRegionsContainer {
                if let string0 = string0 {
                    homeRegionsDecoded0?.append(string0)
                }
            }
        }
        homeRegions = homeRegionsDecoded0
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID = "AccountID"
        case amiId = "AmiId"
        case instanceID = "InstanceID"
        case instanceType = "InstanceType"
        case lastUpdatedTime = "LastUpdatedTime"
        case productCode = "ProductCode"
        case region = "Region"
        case status = "Status"
        case subscriptionName = "SubscriptionName"
        case usageOperation = "UsageOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let instanceID = self.instanceID {
            try encodeContainer.encode(instanceID, forKey: .instanceID)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let productCode = productCode {
            var productCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCode)
            for string0 in productCode {
                try productCodeContainer.encode(string0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let usageOperation = self.usageOperation {
            try encodeContainer.encode(usageOperation, forKey: .usageOperation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let instanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceID)
        instanceID = instanceIDDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
        let productCodeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .productCode)
        var productCodeDecoded0:[Swift.String]? = nil
        if let productCodeContainer = productCodeContainer {
            productCodeDecoded0 = [Swift.String]()
            for string0 in productCodeContainer {
                if let string0 = string0 {
                    productCodeDecoded0?.append(string0)
                }
            }
        }
        productCode = productCodeDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Details discovered information about a running instance using Linux subscriptions.
    public struct Instance: Swift.Equatable {
        /// The account ID which owns the instance.
        public var accountID: Swift.String?
        /// The AMI ID used to launch the instance.
        public var amiId: Swift.String?
        /// The instance ID of the resource.
        public var instanceID: Swift.String?
        /// The instance type of the resource.
        public var instanceType: Swift.String?
        /// The time in which the last discovery updated the instance details.
        public var lastUpdatedTime: Swift.String?
        /// The product code for the instance. For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide .
        public var productCode: [Swift.String]?
        /// The Region the instance is running in.
        public var region: Swift.String?
        /// The status of the instance.
        public var status: Swift.String?
        /// The name of the subscription being used by the instance.
        public var subscriptionName: Swift.String?
        /// The usage operation of the instance. For more information, see For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide.
        public var usageOperation: Swift.String?

        public init (
            accountID: Swift.String? = nil,
            amiId: Swift.String? = nil,
            instanceID: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            productCode: [Swift.String]? = nil,
            region: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            usageOperation: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.amiId = amiId
            self.instanceID = instanceID
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.productCode = productCode
            self.region = region
            self.status = status
            self.subscriptionName = subscriptionName
            self.usageOperation = usageOperation
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum LinuxSubscriptionsDiscovery: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Disabled LinuxSubscriptionsDiscovery
        case disabled
        /// Enabled LinuxSubscriptionsDiscovery
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LinuxSubscriptionsDiscovery] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinuxSubscriptionsDiscovery(rawValue: rawValue) ?? LinuxSubscriptionsDiscovery.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationIntegration = "OrganizationIntegration"
        case sourceRegions = "SourceRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationIntegration = self.organizationIntegration {
            try encodeContainer.encode(organizationIntegration.rawValue, forKey: .organizationIntegration)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for string0 in sourceRegions {
                try sourceRegionsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let organizationIntegrationDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration.self, forKey: .organizationIntegration)
        organizationIntegration = organizationIntegrationDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Lists the settings defined for discovering Linux subscriptions.
    public struct LinuxSubscriptionsDiscoverySettings: Swift.Equatable {
        /// Details if you have enabled resource discovery across your accounts in Organizations.
        /// This member is required.
        public var organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration?
        /// The Regions in which to discover data for Linux subscriptions.
        /// This member is required.
        public var sourceRegions: [Swift.String]?

        public init (
            organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration? = nil,
            sourceRegions: [Swift.String]? = nil
        )
        {
            self.organizationIntegration = organizationIntegration
            self.sourceRegions = sourceRegions
        }
    }

}

extension ListLinuxSubscriptionInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLinuxSubscriptionInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/ListLinuxSubscriptionInstances"
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionInstancesInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of AmiID with an optional operator to see subscriptions that match, partially match, or don't match a certain Amazon Machine Image (AMI) ID. The valid names for this filter are:
    ///
    /// * AmiID
    ///
    /// * InstanceID
    ///
    /// * AccountID
    ///
    /// * Status
    ///
    /// * Region
    ///
    /// * UsageOperation
    ///
    /// * ProductCode
    ///
    /// * InstanceType
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionInstancesInputBody: Swift.Equatable {
    let filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLinuxSubscriptionInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLinuxSubscriptionInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLinuxSubscriptionInstancesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLinuxSubscriptionInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLinuxSubscriptionInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListLinuxSubscriptionInstancesOutputResponse: Swift.Equatable {
    /// An array that contains instance objects.
    public var instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionInstancesOutputResponseBody: Swift.Equatable {
    let instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Instance?].self, forKey: .instances)
        var instancesDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Instance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLinuxSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLinuxSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/ListLinuxSubscriptions"
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of Subscription with an optional operator to see subscriptions that match, partially match, or don't match a certain subscription's name. The valid names for this filter are:
    ///
    /// * Subscription
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionsInputBody: Swift.Equatable {
    let filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLinuxSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLinuxSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLinuxSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLinuxSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLinuxSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

public struct ListLinuxSubscriptionsOutputResponse: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// An array that contains subscription objects.
    public var subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListLinuxSubscriptionsOutputResponseBody: Swift.Equatable {
    let subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Contains operator
        case contains
        /// Equal operator
        case equal
        /// Not equal operator
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .contains,
                .equal,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum OrganizationIntegration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Disabled OrganizationIntegration
        case disabled
        /// Enabled OrganizationIntegration
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationIntegration] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationIntegration(rawValue: rawValue) ?? OrganizationIntegration.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Completed status
        case completed
        /// Failed status
        case failed
        /// InProgress status
        case inprogress
        /// Successful status
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// An object which details a discovered Linux subscription.
    public struct Subscription: Swift.Equatable {
        /// The total amount of running instances using this subscription.
        public var instanceCount: Swift.Int?
        /// The name of the subscription.
        public var name: Swift.String?
        /// The type of subscription. The type can be subscription-included with Amazon EC2, Bring Your Own Subscription model (BYOS), or from the Amazon Web Services Marketplace. Certain subscriptions may use licensing from the Amazon Web Services Marketplace as well as OS licensing from Amazon EC2 or BYOS.
        public var type: Swift.String?

        public init (
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateServiceSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUpdate = "AllowUpdate"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowUpdate = self.allowUpdate {
            try encodeContainer.encode(allowUpdate, forKey: .allowUpdate)
        }
        if let linuxSubscriptionsDiscovery = self.linuxSubscriptionsDiscovery {
            try encodeContainer.encode(linuxSubscriptionsDiscovery.rawValue, forKey: .linuxSubscriptionsDiscovery)
        }
        if let linuxSubscriptionsDiscoverySettings = self.linuxSubscriptionsDiscoverySettings {
            try encodeContainer.encode(linuxSubscriptionsDiscoverySettings, forKey: .linuxSubscriptionsDiscoverySettings)
        }
    }
}

extension UpdateServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/UpdateServiceSettings"
    }
}

public struct UpdateServiceSettingsInput: Swift.Equatable {
    /// Describes if updates are allowed to the service settings for Linux subscriptions. If you allow updates, you can aggregate Linux subscription data in more than one home Region.
    public var allowUpdate: Swift.Bool?
    /// Describes if the discovery of Linux subscriptions is enabled.
    /// This member is required.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    /// This member is required.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?

    public init (
        allowUpdate: Swift.Bool? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil
    )
    {
        self.allowUpdate = allowUpdate
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
    }
}

struct UpdateServiceSettingsInputBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let allowUpdate: Swift.Bool?
}

extension UpdateServiceSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUpdate = "AllowUpdate"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let allowUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUpdate)
        allowUpdate = allowUpdateDecoded
    }
}

extension UpdateServiceSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateServiceSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.homeRegions = output.homeRegions
            self.linuxSubscriptionsDiscovery = output.linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = output.linuxSubscriptionsDiscoverySettings
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.homeRegions = nil
            self.linuxSubscriptionsDiscovery = nil
            self.linuxSubscriptionsDiscoverySettings = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct UpdateServiceSettingsOutputResponse: Swift.Equatable {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String:Swift.String]?

    public init (
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String:Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct UpdateServiceSettingsOutputResponseBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    let statusMessage: [Swift.String:Swift.String]?
    let homeRegions: [Swift.String]?
}

extension UpdateServiceSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegions = "HomeRegions"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .statusMessage)
        var statusMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let statusMessageContainer = statusMessageContainer {
            statusMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in statusMessageContainer {
                if let string0 = string0 {
                    statusMessageDecoded0?[key0] = string0
                }
            }
        }
        statusMessage = statusMessageDecoded0
        let homeRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .homeRegions)
        var homeRegionsDecoded0:[Swift.String]? = nil
        if let homeRegionsContainer = homeRegionsContainer {
            homeRegionsDecoded0 = [Swift.String]()
            for string0 in homeRegionsContainer {
                if let string0 = string0 {
                    homeRegionsDecoded0?.append(string0)
                }
            }
        }
        homeRegions = homeRegionsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
